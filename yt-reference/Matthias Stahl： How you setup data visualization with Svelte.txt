 Hello everybody! My name is Matthias and I work as a data visualization designer for my agency HICS here in Germany. Do you want to know how you could use Swellt to defend democracy? Yeah? Well, then let me show this to you. First of all, this will not be a talk about democracy or really how to defend it. Therefore, you need to go to the visualization I show you in a second. But this will be a talk about how to produce great, nice visualizations with Svelte. How do you use all the nice features that Svelte comes with to produce cool visualizations. I want to show you this in a way I never did before. I want to show you the visualization I did recently first. And then we want to dive together into the code base of this visualization. And I show you why I love Svelte. So let's quickly go to my screen. And what you see here is I opened interference2020.org. This is a webpage I recently designed for the Digital Forensic Research Lab in Washington. This is a think tank in Washington, D.C., which analyzes foreign interference attacks in the U.S. elections. And not only that, it's not an interference tracker, it's a foreign interference attribution tracker actually. I show you what that means. So when we go here a little bit further down, we see the full visualization and I just started hovering over these nice red balloons and what you see here is US intelligence, Russia interfering in support of Trump. So this is like a claim that someone has made that Russia has interfered in the US elections process by supporting Trump in some way. Never mind, we won't talk about politics now. But what you can see here is that this is not only the claim, but it is also said who made this claim. So that's like the source, which is in that case intelligence officials. So it was an organization within the US saying that this interference is going on. And this is the actual aim of this tool. Not only show what possible interference actions are taking place no the goal of this tool is really to show who made claims who made allegations That is the important thing because these interference attempts from foreign countries they are politicized themselves on their own right now, and that is a true problem. So we tried to visualize that. The DFR lab in Washington, they collected all these cases, and my task was to put all these cases on a timeline and to also connect these cases with their country of origin. And this is why I just stitched together a timeline here on top, so you can see here the timeline from 2019 up to today and to the elections. And the map here on the bottom. So all of these cases here are for interference attributions. And where they cross with their source link, the timeline, that is actually the date when this attribution was made public. So there are a lot of elements on this page and I'd love to take you now on a tour through the code base. Let me just say one last thing about the content of this visualization, because that's the whole thing, foreign interference in the elections in any country is a very sensitive topic of course. So you always can say, well is this really a true claim? Who has made this claim? Do I believe that? And therefore the forks from the DFR lab have developed the so-called attribution score and this is visually encoded by the reddish color of the balloons. So the more red these balloons get, the more confidence they have in this attribution actually. And additionally this score is broken up in four individual scores, but credibility, objectivity, evidence and transparency. And if you want to know how these scores were calculated, well it's like true-false answer to these questions. Well it's not really questions but just true-false assessments if a sentence is true or not for this particular case. So that was one main goal when designing this visualization, to put a lot of transparency regarding the methods, how they came up with these cases. And of course there on the page further at the bottom also a very detailed method section if you are more interested in that But now let go into the code base And I told you before that I love Svelte And the thing is that I love Svelte because mainly because of three different things. And I want to show you these three different things right now. So let's switch to my code editor. And what you can see here is a standard Svelte project. So I collapsed all the folders right now to give you first a guided tour through how I made up the folder, the directory structure of this project. Because that's the first thing I really love about Svelte, that's the modularization. So in every Svelte project you have the source folder where all the files are in that needs to be compiled by our Svelte compiler. and let me just close down those and you know that every Svelte app starts with this app.svelte so that this is basically the root component and maybe that's actually a little bit too large let's make it like that very good so what you can see here is that I have just a div where I tried where I want to put my app in so I have a cookie banner you know I live in the European Union and And there you need to be very careful about cookies. So we have that implemented here. And feel free to copy that from my code base. Really nice thing to make this with Svelte. And I have my actual visualization as a component here. And here these sketches is just to show alternative content to users coming from a mobile phone or to users having the Internet Explorer in use. Still, you shouldn't do that. But well, so the visualization and from there it all starts and then all the different components that I have are sampled together. So let's go to the components folder. And for example, you see a component balloon. I guess you can imagine what that is. There's actually these red circles that we have. But there's also a lot of more components like, for example, the legend that I have. I have this shiny circle. I haven't said something about that yet, maybe later. And the parent visualization component. So that's the really cool thing about Svelte. Not only for visualizations basically but for any project which is a little bit larger it very good that you can split off your code into different modules into Svelte components in that sense. And that's not only good to have or to keep an overview, it's also very good to keep the whole thing reproducible so that you can, for example, go to your next project and use one or two or more of these components also in the next project. So that's really the first thing I love about SWIRT. That is the modularization. And just to show you a quick example. So this is the visualization again. And these red circles, these are the so-called balloons, because obviously during an election year in the US, you have a lot of balloons around in the cities and everywhere. everywhere. So that's why we chose that analogy here. So let's just look a little bit deeper into how such a balloon is actually made. So let's go to the balloon component. And first of all, this component is quite small. I don't know what you have expected, but this as only 68 lines of code and this is including JavaScript, HTML and CSS. So first of all we pull in some nice functions. Let's quickly switch to the props that we import and this is first of all an object which is called time points. So the balloon gets a time point and within this time point object we have all the coordinates where in the x-y space space this balloon has to be positioned. There is also the radius for this balloon and there is more things like the color and additional information. And then there is a second prop which is called selected. This is just a true false boolean that the balloon knows if it got selected by the user or not. Then we create an event dispatcher. That's an important thing later on because we want to hover over the circles, we also want to click on the balloons and there something should happen, therefore we need this event dispatcher. But let's first go to the HTML code and for some of you this might be familiar. Here this g element, this is a typical group element from an

 an SVG context. So the whole visualization is built using scalable vector graphics, SVG, and SVG is nothing else than special HTML elements to do graphics. For example, you have a circle element, you also have rectangle elements and lines and paths and whatnot. This is a nice way to just draw graphical objects to the browser. Usually when you have a group of such graphical objects like this balloon, you put them all in a group. It gets a class balloon, that's for sure. Then we have this class selected, which is a really nice shorthand to just put the class selected to this group when selected itself as a variable. is true. So I can switch styles with that obviously when the balloon got selected. And then we do some positioning. So this transform attribute here takes a translate statement where I say okay translate time point x time point f y which is fixed y position. So this is actually properties of this time point object that then just get assigned to the translate statement so that the browser knows where to actually position the balloon. Then we get two event handler sets. So we have one mouse over and we have one click event listener. So that means that when someone is hovering or clicking on my balloon, I can catch that and handle over that to the handle mouse over or the handle mouse click function and do something with that. Not important for now. I want to focus more on the next two lines, which is these in fade out fade statements. So these directives in out fade is a transition directive, which means that when the DOM element, so this group here gets mounted to the DOM, then run this in transition, which is a fade transition here. And when it is unmounted out, then run again the fade transition here, but with two different options that I set here. So I can set duration and delay for these animations and they are apparently different when we move these elements in or out Now you maybe wonder what do we move in or out here I haven't seen a thing like that so let me go back to the visualization. Because what I haven't showed do now is that we have here a set of filters and with these filters we can for example remove some of the balloons. For example if I only want the high confident cases I can use the slider here and filter to the high confident cases and then you see that all the balloons which don't fulfill these filter criteria are getting kicked out and these source links like the stems of flowers or something disappear to their origin countries. And the same thing happens when I reset the filter, then I will get those again and they are faded in and faded out these balloons. And this is exactly what happens here. What is just here in the code base set by this fade transition, which is inbuilt in Svelte. So you just have to use it, you just specify your parameters here and then everything works. And this is exactly the second thing I really love about Svelte and this is transitions. So this is just one example where you could use a built-in transition. So let me just show you the end of this component. Of course we need then a circle, So this is the first circle which just gets filled by the actual color. This color is also pulled out from the time point object and yeah and this builds the red circle and to have a little bit of a spherical effect on top I put another circle which is right on top of this first circle which has a radial white gradient that, let me show you, that gives you this nice effect here that the circles have a little bit more grip basically. And that's it. Some styling on top of it. Modularization again This is scoped styling So this circle CSS accessor only affects the circles within this component nothing else And that is really cool So you have the JavaScript functionality the HTML or SVG elements plus your style in the same file in a component. And now you could use this balloon in whatever project you like. Well, I think, I don't know in which projects you want to have such a balloon, but well, if you want, you can just copy it and go ahead. I talk now a little bit about these fade transitions here. They are really nice, but that's not the only transitions that you can have in Svelte. There is also other transitions and you might have noticed that, for example, here these source links, the blue lines which connect the actual case through the timeline to the source country. country. This is basically an SVG path and you can calculate how that path looks like. Therefore, I really recommend D3 basically. But this is also animated. So let me click on Iran for example and then you'll see that only the Iranian allegations, the allegations against the array are shown here. And you've seen that when I reversed it, that this is nicely animated by this pencil draw animation. And let me go with you to this component where these source links are specified. And that's here, source link, add the source link. Again let me just show you the HTML code. Here's again a group and within that group I have a path and this is an SVG path and with the D attribute I can say to the browser hey you need to draw a path with that geometry and therefore use a function that I developed for that project which is drawing these nice lines. But more importantly for us now is we have again these in and out directives but not with the fade function now with the draw function and this is exactly the animation or better to say the transition we need to draw these paths. And I of course can specify some options like duration, delay and also easing if that is needed And now it might seem a little bit of a black box to you what this draw actually does or what it is I can tell you that I import draw here from Svelte transition So let go to Svelte source code where draw is defined. So this is basically here. Yeah, here starting that function. So it's just a function. Draw is just a function taking the actual node where it was put on as the first parameter. This node needs to have a getTotalLength method and that is what paths usually have because that is just to determine how long this whole path is and then I can specify more options like delay, speed, duration or easing. And then actually there is just the length of this path computed. That is just some logic to get the right duration. So this is not even needed for the correct function of the whole transition. The only thing we need for a running transition is what we return. This object that we return it has delay, duration, easing but it has also this CSS property here and this is very interesting for us right now because here we specify a line of CSS basically. So maybe you know stroke-dash array that's an option to exactly draw these different path segments and when I move these path segments it looks like that the path is actually drawn and I need to specify like two lengths and here I take total length of the path times t and u. So t and u are variables that move from 0 to 1 and the other way around for the other variable during the transition. So with that I can easily animate it. Now the question is why is that CSS Now, usually you think, well, you need to code that in JavaScript to just move that on, right? But no, here Svelte is a compiler and that is our advantage because we are not analyzing this line of code during runtime, but during compile time. And the compiler creates some keyframe animations, some CSS keyframe animations for you that imitates this stroke dash array functionality with the moving length that we have

 specified here so that will produce actual CSS for you. Well you would say well nice to have it CSS but well it's also possible in JavaScript. Yeah that's true but CSS is not running on your JavaScript thread so it won't block your JavaScript thread and this is very important for performance. So I really recommend you to exploit that feature to write your own transitions using CSS the CSS property here because this is really really cool. Second thing I really love about Svelte and this is the reason why actually not because it's so easy to use all these transitions but it's really cool to make that in the CSS space and this is so easy that there is no no barrier before using it you can just try it out and go ahead. That's the second thing I really love about Svelte And now we come to the third and last thing I want to show you why I love Swell, especially for data visualization. And for that I want to go to my visualization once again. And I showed you before that I have this slider here on top where I can filter the cases by attribution score. So how high the confidence in these allegations was. If I simplify a little bit and this slider here is also itself a component that I use. So this is basically also reusable. That's no problem. And here I have a functionality that I can slide these two little handles. So let me show you how I implement that. There is someone writing mails because I forgot to close my mail program. or else let's go to the actual code base. And of course this component we are looking for is the slider. And the slider looks like that. So let me show you which properties it takes So we get a label we get a min a max value a current value and some other styling stuff and that basically it And then I have within that slider I have these two slider handles. So you see here like the left slider handle and here the right slider handle. and this is exactly what is the interesting part of this component because that's the moving components and now I need to query this slider handle where it is when it was slided is that an English word I don't know when it was pulled and pushed and so on and for that I use this use directive here, use slidable. And similarly to the transitions, slidable is again a function. So I will show you that function. This is called in Swelt an action. So I have actions here and there is indeed slidable action. Let's move to the top and you can see here it's a simple function taking just the node where it was created. So when these handles are getting mounted to the DOM, this function runs and here in the node variable is the actual div this slider handle. And then there are some function definitions and here something happens. So to this node there is an event listener added a mouse down event listener and that's exactly what we need. So when we have a mouse down event on that slider handle then we should pay attention to it because then there is a sliding event happening. So let's look at what is going on in handle mouse down. That handle mouse down here there is a specified the axle that is the current position basically of that slider handle and then I immediately throw an event or dispatch an event which is called slide start which tells me to the parent to my slider component hey here is now something going on we start sliding everything ready Well good And then in the same function I also specify two new event listeners One mouse move so that I can now listen to the actual movement of the handle and one mouse up because when the mouse button goes up the sliding is done. So let's see what happens in mouse up. That's maybe now interesting for us because then we want to tell our parent, hey, we have moved this to a new position. And this new position is basically specified through X and left. And this is then dispatched in an event called slide end. And with that, the parent knows what's going on. Right? So when we go to the slider, I actually listen to these events on slide. That's the slide event when the mouse is being moved. And on slide end, that's actually the event which is fired when the sliding is done. So when the user has released the mouse button. And then I have this handle slide end function where the whole logic of calculating new positions and so on is going on. And yeah, so this might look a little bit cumbersome to you, but I tell you that actions are very powerful. Of course, you could have written all this event handler stuff also here in your parent component or anywhere else. But the thing again is reusability. I think I said reproducibility in the beginning, but that's also true. So I mean reusability because you can now take this slidable actions, go to your next project where you have something sliding and put just with this use directive, the slidable function, on top of your DOM element that needs to be slided. And then just listen to the slide, slide start, slide end event as you need it. And bam, you have a slidable element with that. So that is really easy. And I really like this reusability here because when you do a lot of projects, you will see that sliders come very often across your way So that is quite nice But you can of course also do actions for tooltips for example or what not So every time you want to do something with a specific DOM element, register some event handlers or something like that, the use directive is your friend. And this is the third point why I really love Swelld for my programming, especially for my data visualization project because we have actions. Yeah, and with many more Svelte features we basically have this visualization done. And you can go, as I said, to interference2020.org to just check it out on your own. Then you can see why are there such big bubbles and what is this ring around it. So go to the website, have a look what it means, and get a feeling about foreign interference in the US elections. And also, I really want you to encourage to go to my GitHub repository, where I store all the code for this visualization. It's completely open source, fork it, play around with it. It's really nice to check out wealth features in running projects, in running code base. So I really encourage you to do that. With that, if you have any questions or ideas or comments on all that, just give me a ping via Twitter or via LinkedIn or via my email or via my homepage. I always be very open and I would be very happy to hear something from you about this visualization, about how I use Swell. I'm also curious which questions you might have. And so I wish you a very nice remaining Swell Summit day. And very lastly but very important, thanks a lot to all the organizers behind Swell Summit. It's really a ton of work with that and it was it is really great. Thank you very much.