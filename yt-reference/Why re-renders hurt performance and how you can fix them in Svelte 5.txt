 If you're working on web applications today, you've probably heard that re-renders are bad for performance. But why is that? A re-render happens when the framework you're using needs to update the underlying document object model that makes up all websites. Whether you use Svelte, React, Solid or Quick, this step is always required to change what the user sees. However, if you unnecessarily re-render elements when it's not needed, that can make your site seriously slow for visitors. The reason re-renders are bad is because they require you to update the actual HTML elements that make up the web page and that has many performance implications. For example, styles need to be recalculated if the element moves or expands and the browser also need to repaint the affected area. This process is called the browser rendering pipeline and each step can be computationally expensive, especially on lower end devices or when you're updating many elements at once. And there's been a lot of discussion about this problem lately. I especially want to to give a shout out to Aidan Bai who's created a tool called React Scan that can show rerenders in a React application. He's used this to show large companies like GitHub and Twitter suffer from poor performance due to rerenders. Here's where it gets interesting for us Svelte developers. Svelte's architecture gives us a huge advantage here over React. The way Svelte handles reactivity through its compiler and fine-grade reactivity systems makes it much harder to accidentally trigger those unnecessary rerenders. In Svelte 4 we had this very intentional reactivity system where you create direct connections between your state and DOM updates using variables and reactive statements. This is fundamentally different from React's approach. In React you're rerunning the code in all the components by default. And with Svelte 5's new signals runtimes things have gotten even more granular and performant for Svelte because now Svelte keeps track of exactly which DOM node consumes which state using signals. But Svelte is not completely immune to performance issues because it still has to render those pesky DOM elements. Even in Svelte you can write code that isn't optimal or accidentally trigger updates when it's not needed. So the question is, how do we spot these issues when they happen? So a couple of weeks ago I saw this tool called RenderScan by GitHub user NullvoxPopuli. His tool makes it possible to see re-renders in any framework because it uses a standard mutation observer under the hood. So what I decided to do was to port this library into a Svelte package and in this video I show you my library called Svelte render scan and we see how to install it into your Svelte or SvelteKit project and how to use it to check for re So I got the website for this library up on screen right now. I'll attach a link to it in this video description. So here on this website we can also see a little demo of what it does and how it works. So let's click the demo button and see what happens. All right, so let me zoom in a little bit there. So what you could see there was that when you press this button a few boxes are added to the page under here and you can see as the boxes are being added you can see that they get these little re-render boxes around them. This one says attribute change that's because we disabled this button while the animation is running and this one says children added which is because we're adding these boxes in to show us a demo and this page also has this nice highlight color demo. I'll zoom out a little bit so you get the full view of that. So what this does is it will change the color of the entire page. So let me just change this to like a green, for example, and you can see that there's a lot of different elements on the page here that are affected when we change the color, and you can clearly see which elements are affected as we change the color. And here you can also see how cool Svelte 5 is, because this demo page is built in Svelte 5, course and I didn't do anything special to make it work but only the DOM nodes that are related to the check boxes here to the boxes only they are updated by Svelte in the actual DOM. Now let's see how we can include this application in our existing SvelteKit app and kind of see how it works in a more real project. So for this demo I decided to bring out a site from a previous video I did about the streaming in SvelteKit because this site has a bunch of updating elements that kind of come in after the page finishes loading and so that's I think a really good way to demonstrate like how you will actually see this on a live site. I have the project running here, I'm going to just briefly cancel out of that so I can install Svelte Render Scan. So I'm gonna do npm install, Svelte Render Scan, and this is gonna take just a second and then if we go to the site it will tell us how to use it and it very very simple So you do import render scan from Svelte render scan and I going to do it here in this layout here And then all you need to do is render the element And since I did this in the root layout for the site it's going to be active for all the different subroutes. You don't have to worry about where you loaded it. So now let's see what happens. I'm going to start the dev server again. Load the site up. And we see right away that things are kind of popping into place here. The real thing that changed aside from this is this little eye icon over here on the bottom right. So if I disable it, you see that everything disappears. And if I bring it back, you see that this live stock price widget, this fake live price stock widget updates. And you can see here text updated. And that's because in this project, we're pulling it every second to get like a random number just to show how that works. So let's reload again and kind of see how it looks. So here we see like as things are streaming in, the DOM needs to be updated. Of course, with the new content, you have this quote here, the main text. You have even here like whether the fake site is open or closed. And you can see that when something changed, you have this little box around it that shows you something has changed. You can't always avoid this. You do need to have things, you know, obviously re-render when you change content and stuff. And of course, if we navigate somewhere, you know, of course the page needs to change for that. And so you can't completely avoid it. But the point of this package is to make you aware. Maybe you accidentally left in something that keeps rendering and doesn't have to. Or maybe there's something you can optimize around that. I also mentioned that by default, things just kind of work in Svelte thanks to fine-grained reactivity. But I wanted to show an example of where you can actually mess up a little bit and have things re-render that don't need to. So for that I have prepared this page called loop examples where you have this like fictional list of contacts Because this problem you can run into is related to loops in Svelte So what I have here so far is I have this document that has a few like Contacts in it and I can add a new contact to the top of the list and for now I'm just printing the object So let's see how that Page actually looks here I have the contacts here and I have this function called add contact that will add a contact to the top of the list And then I have an ID which is a unique ID for each contact I have the name and the email So let go ahead and print this list of contacts So I gonna first do it as a normal each loop. So each loop and then I'm gonna do each contact as contacts. The AI helps me here and everything is looking pretty good. So there we go. I am showing the contact's name and email. All right. Now let's have a look here how that will look in the South Router scan. So I'm adding a new contact. Did you notice something weird there? For some reason, it says that the text of these other contacts changed. So you see, it didn't only add this new contact that actually also updated these things here. Why is that? Well, it has to do with keyed and unkeyed loops. So if you were thinking about that, you were completely right. The reason these other unrelated elements are updating is because Svelte really doesn't know like what, which element in an array relates to which actual item in an each loop. So in order for it to know that this is contact five, this is contact four, we need to key the loop by giving it a unique ID for each item in the loop. This is very simple and I'm going to just make a second loop here and I'm gonna call it keyed each loop and all I need to do here is to add the unique contact ID to the second loop. Alright now let's now we have the normal each loop and the keyed each loop. Let me try it again. There we go. So instead of seeing all of the different unrelated items being updated on the right here, we just see the one children changed. So that means it's just adding this without modifying any of the other elements. So this is a performance improvement over this left version that updates a bunch of unrelated elements. And we can see here it also updates more and more of them as we add more items. So this is just gonna keep getting worse and worse. All right, that's it for the video. Press the like button and subscribe if you liked it and let me know what you find if you try Svelte Render Scan in your existing applications. Thanks so much for watching.