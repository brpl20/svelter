 Hey friends, today I want to talk to you about the future of Svelte. Today we're going to be looking at two proposals that are going to change Svelte forever. In the first asynchronous Svelte proposal, now the await keyword is going to be part of the language itself. So now you can use it inside of the script tag, derived expressions, and in your markup by installing the async branch if you want. And this ties into the next part, which are remote functions and basically remote functions are swell kits answer to component level data loading and this is one of the most exciting features in my opinion and don't worry svelte isn't reinventing itself or anything like that so you don't have to rewrite your entire svelte app all right but before we get started here's a message from our sponsor this video is sponsored by mainmatter mainmatter is an engineering consultancy that helps teams adopt and succeed with Svelte and SvelteKit through training and other offerings. If you're looking to learn Svelte or level up your Svelte and web development knowledge, there's no better time to start learning Svelte now. Mainmatter is offering four remote Svelte workshops for every skill level from July 21st to July 24th. Each workshop is taught by my good friend Paolo Ricciutti, a Svelte expert and maintainer, so you're not just going to learn how to use Svelte proficiently, but understand how it works and leverage your knowledge across other frameworks. If you want to get up to speed with Svelte 5, this workshop is for you. The Svelte 5 and Runes workshop dives into the new reactivity model using runes and snippets. You'll get hands-on experience migrating from old patterns to Svelte 5's simpler, more powerful approach. You're also going to learn the fundamentals of JavaScript signals and how they might eventually establish a cross-framework reactivity primitive. If you want to learn how to test with confidence, the Testing Svelte and SvelteKit Applications workshop is for you. This workshop shows you what to test, how to test it, and how to keep your tests fast and reliable. And if you want to learn how to build secure, functional, and maintainable offflows in Svelte and SvelteKit, then authentication for Svelte and SvelteKit workshop is for you. You're going to learn everything from the basics of authentication and how to authorize users in your app to show different UI based on their login status. And in the last workshop, you're going to learn how to use Svelte in non-Svelte projects. So you might love Svelte, but how do convince others to migrate an entire react codebase to svelte the svelte without svelte workshop is going to teach you how to use svelte in a non-svelte project by using web components for a smoother incremental migration you're going to learn the basics of web components and how to use svelte for a better authoring experience for web components and how to bundle them and speaking of bundlers you're going to learn how wheat can help with web components and how to create your own wheat plugins to transform your code and use that knowledge to build an integration between swelt and react each workshop is run completely online and remote the price of an individual workshop is a great deal at 175 euros plus tax there's only 30 spots per workshop to ensure the highest quality so grab your spot before they're sold you can find additional information for each workshop linked in description or by visiting mainmatter.com sweltweek thank you to mainmatter for sponsoring the video to understand where svelte is going we have to understand the present So let's look at an example how we do data loading currently in Svelte. I'm going to create these two functions, getPokemon and getPokemonDetails. They are going to serve as a sort of a database. So in the first example, we're just going to fetch a list of Pokemon, and then we're going to get some Pokemon details, which return the name and the image of the Pokemon. And then we can export them to use them inside of our component. So now we can import them from the API, and then we can declare two variables pokemon list and details and because this is a side effect we have to use an effect inside of our component but we can also use on mount if you want so we can await the pokemon list and the details data now we can invoke this function inside of an effect and this is something i see a lot of people do wrong which is passing an async callback to on mount or effect you shouldn't do that because for example your cleanup function that you define inside of them isn't going to run because that's not what Svelte expects. So you can pass an async function, use .10, or use an immediately invoked function expression. So now inside of the component we can loop over the Pokemon list and we can show the Pokemon details If we want to update the currently selected Pokemon we can just update details So now we can see our example works as expected. But as you can see it really isn't ideal, there aren't any loading states and if we have to do something like that ourselves our app complexity is going to quickly explode. Because now we have to take care of success states error states and etc and swelth also thinks that this is tedious and this is why they introduce the await block so instead of using on mount or effect we can declare pokemon list and details and pass the promise to them and now we can use the await block in swelth now we can await the pokemon and show a loading state and when it's done we can loop over the pokemon and do the same thing as before and now we can also catch and handle errors gracefully and the same is true for details so now in this example when i click on charizard is going to show a loading state but even this isn't enough and you can reach for a powerful asynchronous state management library like tan stack query so here is how it looks like we can just import create query from tan stack query and now we can create this pokemon list query which repass the query key and the query function and we can also create a details query which is going to rerun when we update the pokemon url this is also going to be cleverly cached and there's a lot of things that tan stack query does so you can do mutations infinite queries and etc so now we can easily change the ui based on the status of the query so we can check if the query is in the pending state error state or the success state and we can change the url to update the pokemon and of course we can do the same thing for details so let's look at this example so here i'm selecting bulbasaur but now we can also select something like charmander you're going to see we have a loading state and if you go to charizard you're going to also have a loading state but notice this now this is going to be cached and this is going to be instant as you can see 10 stack query is super powerful and what if you want to server-side render that data well this is where swellkit comes in for this reason swellkit has a load function which can asynchronously load data on the server or on the client depending if you define plus page.ts or plus page.server.ts if you want to server-side render that data and now we can pass this as a prop to plus page.swelt which is just a regular swelt component here we have plus page.server ts and plus page.swelt so we can import the api from lib slash server slash api and server is a special folder convention in cell kit which means that this code can only be imported inside of a server module now we have a load function which accepts the event and this is going to return the data prop inside of our component so we can fetch the pokemon list and loop over it and not only that but we can also stream data that isn't that important like the pokemon details so as you can see we're not awaiting this on purpose so we can use the await block in page.svelte and we can await the pokemon details and we can also use form actions to mutate state on the server so here we have a default action where we're destructuring the request itself so we can get the form data and now we can update the url on the server and this is also going to rerun the load function and refresh the data from the server but there's one critique that people have with this approach and that is that these updates aren't granular enough what do i mean by that well for example let's say that we just want to update the pokemon list now we have to to rerun this entire load function so we can't really invalidate these two things separately so for example if you want a banana you're going to get a gorilla that's holding the banana and we can see that more in this example so here i have example slash pokemon where red is the data loaded for the pokemon list component and we have an id in blue which is the pokemon details component so here we have a nested layout in svelte kit so now we have to somehow load data and pass it to this component for that of course we have to use a load function in svelte kit and this works great but another downside is that the load function is tied to the route itself so what if instead of page level data loading we had component level data loading it would look something like this and this is the problem that remote functions are trying to solve but before we talk about remote functions we have to improve the user experience when it comes to asynchronously loading data in svelte so this is where asynchronous svelte comes in So the main idea behind these changes is that Svelte has more built-in primitives, so this makes SvelteKit a thinner layer. So let's see how asynchronous Svelte improves the framework. We've already seen the groundwork laid out in the past for this when we talked about error boundaries in one of my previous videos. So let's see how this looks like. So first we need to define a Svelte boundary at the root of your component. This happens to be a SvelteKit app, but this works the same in any regular Svelte application. So first we're going to define a Svelte boundary, and then we can also pass the failed snippet, and this isn't anything new if you watch the error boundaries video, so we can just get the error and reset if part of our app crashes. But this is the new part, which is this pending snippet, so this works similarly to React Suspense. If any part of our app is in a loading state, we can just default to this loading fallback, and then we can just pass the children. And this is the coolest part. Now in our component, we can actually await directly in the script tag. So we can await the Pokemon list and the Pokemon details. So now we can show the Pokemon list and the Pokemon details without using on mount, effect, or the await block. And if you want, you can just pass a promise instead and you can await the result in the template. As you can see, we can use await directly in the template. And this is really cool. And you can create another boundary for a different part of your app, like the Pok√©mon details. But in the future, you might not even have to define the svelte boundary. And you don't have to create a separate boundary to have a loading state, for example. Currently there is this effect.pending rune which you can use to show a loading state, So in this example, we can just say effect.pending and show the loading state, else we can actually await the Pokemon details in this data variable using add const, and then we can display it. And this is the best part, we can just await the Pokemon list and the Pokemon details inside of a component prop. How beautiful is that, friends? So if we change the Pokemon, we can see that everything works the same as before. So this brings us to remote functions. And remote functions are SwellKit's answer to things like RPC, server functions, and so on. So we can declare remote functions in a .remote.ts file and we can import them anywhere and use them like regular functions. So you might be familiar with something like trpc, and basically that is what SwellKit is going to have baked in. But from the information that I gathered, it seems that the Swell theme was particularly influenced by this library named Telefunk, which is similar to TRPC but has a much nicer API. Basically, this is how RPC works. So for example, on the client, we can invoke this getPokemon function with an ID, and what's going to happen under the hood is going to just do a good old fetch request. So in this example, we're using TRPC and it's just going to URL and code these parameters. And then it's going to return some JSON from the server, which is also typed. And if you invoke the same function on the server, it's just going to run like a regular function. So here we have a pokemon file which can be placed anywhere or you can collocate it where you have your component Now that we have the Pokemon data on the server we need to somehow access it on the client For this, we can use the first remote function named query. Now we can define a get Pokemon query that just returns Pokemon from the server. And now we can get the Pokemon data inside of our component. Of course, we also want the Pokemon details, so let's create a pokemon details query the pokemon details query accepts a pokemon url argument and for this reason we need to pass a validation schema or we can pass the string unchecked and this is to encourage you to validate your data in this example we're using zot but you can use anything like valibot and etc so now we can show and update the pokemon details and let's say for example that we want to add a feature to like a pokemon so this is going to showcase how we can do mutations on the server so for this we're going to use a new remote function called command commands are great if you want to mutate some state on the server without having to use a form and etc where it doesn't make sense so we can just find the pokemon index and then we're going to add a favorite property to it and then we can use this get pokemon dot refresh query and this serves two purposes for example you're going to mostly use this with forms so you can do a single flight mutation where you can return the form data and update the pokemon query but in this case by saying get pokemon dot refresh inside of this command we're saying that only this get pokemon query should rerun because by default it's going to invalidate all of the queries now you can import the like pokemon query and use it inside of a button but of course the recommended way to mutate data on the server is using forms And forms are great for many reasons because we can use them for progressive enhancement. So here is how that looks like. Instead of using command, here we're using the form remote function. So we can get the Pokemon name from the form, find the index, and then add it as a favorite. And now we can just spread the methods from the like Pokemon query on the form itself, and this is going to give you progressive enhancement for free. And that basically means that if JavaScript fails on the page for whatever reason, it's still going to work and if javascript is available on the page then we can progressively enhance the form and this is great because it avoids a complete page reload but let's say that your queries take some time even 300 milliseconds can be perceived like a lot we can actually customize how we progressively enhance the form by using the dot enhance method so in this example we want to do an optimistic ui update when a user likes a pokemon so when we spread like Pokemon, we can use .enhance and we can destructure data and submit from it. And now we can get the name of the Pokemon and then we can say await submit .updates and now we can use the get Pokemon query and say . with override which is going to give us the data. In this case, we're just going to instantly update the Pokemon data on the client. In this example, I set an artificial delay of 2 seconds when you like a Pokemon. So let's see how awesome optimistic UI updates are. I'm going to open the network tab and I'm going to see when I like the Pokemon, it's going to happen instantly for the user. As you can see, it still took time to resolve on the server, but as far as the user is concerned, it happened instantly. And that is how easy and awesome Optimistic UI updates are with remote functions. There's a lot more you can do with remote functions such as pre-rendering. And this is really powerful because you can use pre-render functions on pages that are otherwise dynamic, allowing for partial pre-rendering of your data. And you're probably wondering how do I do authentication and etc. with remote functions. And for that, SwellKit exposes a function called getRequestEvent. So you can get access to the request event directly in your remote functions. There's even more cool things that weren't part of proposal like streaming real-time data from the server using server sent events and web sockets and that's it i'm going to post an example repo with all of the links i mentioned in the description if you like what you've seen don't forget to like and subscribe and i'll catch you in the next one peace