 Music NICKALA Oh hey, I was just crushing some rings. Alright, let's talk about Svelte 5. A lot of you have been following development very closely. Some of you have even YOLO'd it into production already, which God bless you. But some of you have probably been like, you know what, I'll deal with that when the time comes. Well, the time is coming. We're not there just yet, more on that soon, but there is light at the end of the tunnel. And so to get everyone on the same page, I'm gonna quickly run through some of the biggest changes. The first thing I wanna draw your attention to is the output of the compiler. In Svelte 4, if you have a Hello World component, it generates all this code. And as you start adding state and logic and behavior, it starts to grow at a fairly rapid clip. And the generated code is pretty hard to follow. It's not a problem exactly, but it hints at the complexity of the Svelte 4 design and it leads people to ask, does it scale? Now the same component in Svelte 5 is much less code. And it's much simpler, and it stays that way as we start to add more stuff to our components. This isn't just a cosmetic change, it reflects the fact that Svelte 5 is just much more tightly engineered in every respect. Here's a nice example of that. Components are just function calls. We're calling this counter function directly. There's no create component counter or anything like that. By getting rid of that indirection, we make the output really easy for tooling and JavaScript engines to optimize the hell out of. The only huge benefit of this overhaul is that the codebase is much more approachable for contributors than it was before, and it's going to be a lot easier to add new features. So your Svelte apps are going to be smaller, they're going to be more robust, they're going to be faster. Does it scale? Yeah, it scales. Now that's all good news for your users, which is the most important thing, but Svelte 5 is also good news for you, the developer, because there's a boatload of new stuff, and we're going to talk about it. The most obvious change is runes. Just like in Ragnarok, runes are magical symbols. In Svelte, the magic is reactivity. You declare a piece of reactive state with the state rune, and every change to that state causes an update. This works for objects and arrays too, so I can add an item to a list with array.push, and if I modify a single property, only the things that depend on that specific property will get updated I can create derived state with the derived rune and I can use the effect rune to run imperative code like updating a canvas element Now a side note the effect rune isn something you should be using often It's really more of an escape hatch than anything, so if you find yourself reaching for it often, think about whether there's a more declarative approach that would fit better. The really cool thing about runes is that they're not just for components. You can use runes in .svelte.js and .svelte.ts files, so whereas in the past you might have wanted to refactor some code into a utility module, but then realized that you were going to have to rewrite everything to use stores, that's no longer true. If you've used stores to do anything complex in the past, you're really going to appreciate how much simpler your code gets with runes. Essentially, Svelte is no longer just a component framework. It's a language for describing reactivity that dovetails seamlessly with JavaScript and TypeScript. There are many improvements beyond runes as well. Slots were always a bit confusing and messy in Svelte for Weird syntax, lots of restrictions on how you use them, no type safety, don't even get me started on the let directive. In Svelte 5 we have snippets and render tags. You can use these within components to define reusable chunks of markup, and you can pass them between components as props. Another big change is around events. In Svelte 4 you add a click event listener to a DOM element with on colon click, but in Svelte 5 we get rid of the colon. They're just like any other attribute. This makes things much simpler when dealing with component events. Instead of doing the whole create event dispatcher thing, we can just use props. As well as being a lot easier to use, it's a lot easier to type. Speaking of which, Svelte 5 supports TypeScript natively. TypeScript was supported in Svelte 4 via a preprocessor. If you add lang equals ts to your script tag and configure your bundler appropriately, then you can use TypeScript syntax, but not inside your template, which is particularly annoying for things like inline event handlers. In Svelte 5, it just works. TypeScript goes into the compiler, JavaScript comes out. You do still need to opt in via lang equals TS. We have reactive versions of the built-in map, set, date, and URL classes. If I edit path name here, href updates, and vice versa. It's really easy to build your own reactive classes because you can use the state and derive runes to define class fields. This is a really great approach to domain modeling. If you're one of these people who think classes are bad, it's probably because you are listening to some washed up thought leader. As long as you avoid inheritance and keep things self-contained, classes are really cool, and Svelte embraces them wholeheartedly. We're just a classy framework. Style tags also got an upgrade. You can now use CSS nesting syntax inside your components, still taking advantage of Svelte's style scoping and unused CSS removal. It's also much easier to create global styles. If I want to target some elements inside an HTML tag, I don't need to repeat this stuff over and over again. I can just put it all inside a global block. So there's a lot of new stuff. And I know what you're asking, when can I use it? Well, I won't bury the lead any further. Svelte 5 is now in the release candidate. Actually, you know what? I will bury the lead a little further. This announcement feels a little flat. Need a little something extra. There's only one man who can bear with me a second. Hey, Peru. Hey, Rich. How's it going? Good man It been too long So listen I need your help I doing the Svelte 5 release candidate announcement and it needs a little something extra I need some of that Peru magic Do you think you could hook me up Yeah dude no problem Send it over I see All right, I'm sending it over now. You got it? Okay, I got it. Let me see. and this should do the trick awesome here goes so without further ado spelt 5 is now in the release candidate phase hey thanks man this looks great yeah you really came through no worries man glad i could help and a big congratulations to the team for making it to the rc exciting times ahead. Wait, how are you doing this? Well that was weird. So what does this mean? It means that in terms of API design and feature set, as far as we know, Svelte 5 is done. I say as far as we know because we can't be certain until it ships, but if you start building with Svelte 5 today, we don't expect breaking changes between now and the stable release. It also means that all of the big, obvious how could they let this happen, bugs are fixed, and the stuff that's left is mostly edge cases and polish. It does not mean it's ready for production. I know that when I say that, a lot of you go, la la la la la, we can't hear you. But if you do take it to production, and things break, there are no refunds. So how do you get started? Well, if you want to try it out in a new project, you can run npm create Svelte at latest, and it will give you the option to try Svelte 5 in a new SvelteKit project. If you have an existing project, you can npm install Svelte at next and you should be good to go. If you're using the TypeScript preprocessor, feel free to remove that. If all goes well, things should continue to work. Once you've done that, you can start migrating your components to use the new features. And that, migration, is what I want to spend the rest of my time talking about. We've gone to some honestly quite absurd lands to make sure that code written for Svelte 4 will work the same way in Svelte 5, with a tiny handful of minor exceptions. And we're working on a tool for automated migrations that you can experiment with today. It's right here in the playground. But it's not going to be enough because this is ultimately a collective action problem with some tricky dynamics. We've seen this with other frameworks and even entire languages. The incentives not to upgrade can be stronger than the incentives to upgrade. And so we find there's a tension between application developers and library developers. A really good example of this is ESM versus CommonJS. As most of you probably know, CommonJS was the de facto standard for writing modular JavaScript for many years, and it's still the most common format on NPM. But now we have a real standard, ESM, and it has some important advantages over CommonJS. So much so that authors of new libraries overwhelmingly prefer it. But here's the rub. If your project is ESM, you can use ESM dependencies or CommonJS dependencies. But if your project is CommonJS, you can only use ESM in certain scenarios. It's got a little bit better in Node 22, but there are some caveats. The essential dynamics remain. What this means is that if you're building a library and you distribute it as ESM, a lot of people won be able to use it So as a library author you incentivized to use the old format instead of the new better one Some people will distribute both ESM and CommonJS in the same package but that involves extra work For application authors, the easiest thing to do is nothing, just keep using CommonJS. After all, switching involves extra work. So the incentives are in conflict. Both sides quite reasonably want to avoid doing extra work and the result is that the rollout of ESM has been incredibly painful for the ecosystem. Unless you're using SvelteKit of course, because we saw this coming years ago and SvelteKit projects have been ESM first since day one. Unfortunately, the same dynamics that I've just described also apply to Svelte 4 and 5. If you're building an app with Svelte 5, you can use dependencies built for 4 or 5, but if you're building an app with Svelte 4, you can't use dependencies that need Svelte 5. So once again, library authors are disincentivized to adopt the new stuff, And that could be a real problem because eventually, in Svelte 6 or 7, we will need to drop support for some of that old stuff. So how do we solve this collective action problem? Well, the answer is by taking collective action. We need to pull together as a community. Ask not what your framework can do for you, ask what you can do for your framework. For application developers, your task is pretty simple. We need you to update to Svelte 5 as soon as you can once we reach a stable 5.0. If you want to start experimenting with the release candidate on a branch today, that's even better as you'll help us uncover any last bugs and design flaws. You don't even need to update your components. That can happen gradually over time. All you really need to do is update your package.json. If you're currently on Svelte 3, I do recommend updating to Svelte 4 first by following this migration guide. That's something that you can do today without waiting for Svelte 5 to come out. For library authors, the first thing I recommend doing is updating your peer dependency on Svelte. If you currently depend on three to four, make that three to five. You can do that in a patch release without any other changes and people who have updated to Svelte 5 will be able to use your package without getting a bunch of peer dependency warnings in their terminal. Once you've done that, it's time to create a Svelte 5 version of your library. This is a breaking change of course, so it needs to be a semantic versioning major release. If you plan on continuing to support the old version, then you should create a branch at this point so that you can continue working on that branch and cutting releases from it without interfering with the new version. Make sure that in the new version, your package.json specifies a peer dependency on version five and not on older versions. You could release it just like that, but if you're gonna do a major release, then now is the time to make any breaking API changes. For example, getting rid of slots and replacing them with snippets and replacing any component events created with createEventDispatcher with callback props. Once you've done that, you can release your package to NPM, pour yourself a drink, sit back and relax, knowing that you've done your bit. Aside from app developers and library developers, there's a third group that's essential to making this migration a success, and that's the educators. If you're someone who creates content about Svelte, then people are gonna be looking to you to understand how to make best use of the new features. We can do this. It's a challenging moment for any project, but this is our framework, and if we all pitch in, I'm confident it's gonna be a huge success. I'll see you all soon. Peru, stop it.