 Hey friends, what's up? Today I want to talk to you about effects in Swell. So previously we learned that Swell 5 has this new reactivity system called Runes or Signals Under the Hood so we can say for example, LetCount, $State and we can just pass in the value. Let's create a simple button, we're going to say count and then on click, let's increment the count. And that's it, boom, easy peasy, lemon squeezy, now we have a reactive count. And we also learned about other things that we can have the right value, so for example we can say let double and then we can just say derive and we can pass in our expression here right and of course we have dot by if you want to do something more complicated like pass a more complicated expression inside of here but there's actually another spooky thing here called effect oh my gosh is this react friends oh my god have we been bamboozled and no the answer is no because svelte doesn't work anything like react for example in react when you update a value it tree renders the entire component. This is not how Svelte works. This is going to just update the value that it has to because it uses signals under the hood, right? So even if we say, for example, console.log count, now we're going to see here is going to log each time this updates. And as you can see, there is no spooky dependency array. There is some foot guns that you have to be aware of, but you're really going to have to use effects. And that is, in my opinion, quite interesting because effects are a core building block of signals. Without effects, signals are useless because a signal is really just a fancy object with subscribers on it. But let me actually show you what I mean by this. So I can just keep this as it is, but let me actually show you. So when you use this value count in your template, Svelte under the hood creates an effect for this and it just uses some DOM helpers to update the value. And let's actually see that this is true. So we can go to sources, routes, and then let me just open our page.svelte. And you're going to see so we have this value count boom swell turns this into a signal under the hood and we can see if we scroll down this is turned into an effect so it uses this dom helper set text it passes the text and it gets the freshest value from the signal that's basically it but i actually want to go into more detail to explain what actually are side effects right because actually look at some docs for even react solid and etc and they kind of like assume that you just know what side effects are this academia is trying to hold you down, these gatekeepers, right? Okay, so let's... I'm so sorry. Okay, so let's actually first explain what are side effects I like to thank this video sponsor you the viewer You can support the channel through Patreon or a YouTube channel membership Members get early access to videos help shape the content and a special Discord role You can find all of the links in the description. Thank you for your support. Alright, so what are actually side effects? And let me just quickly yeet this, boom, gone. So let's just create a script tag here. And this is everything those functional bros have been raving about for years, even though it's not really important. Who cares, to be honest? but we can say for example let's create a pure function so we're going to pass in a b and of course we're going to return a plus b and why is this a pure function because the expected result is always the same right you pass a plus b and it's going to return that so let's actually make this impure or introduce a side effect right so for example we can say let result and then inside of here we're going to assign to a global variable god forbid we can say plus b and then we can instead return result. And this is basically a side effect because we're modifying something outside of this function. And in fact, console.log is a side effect. So you can say, yo, here, this is a side effect. Using fetch inside is a side effect. Manipulating the DOM is a side effect, right? So whatever you're doing here is a side effect, right? But you might be asking yourself, so what is a function here, right? We have this like swell component, right? So how is this a side effect? How does effect fit into this equation, right? And let me actually show you something. So what is this at the end of the day our swell component well you actually might be surprised but not really because your component is just a regular function and this is why we have side effects here this is why we need effect sometimes not all the time you're actually going to rarely have to use it but yeah that's basically what side effects are it's really nothing intimidating right so boom so let's actually see this in action so for example here we logged count but let me see if i actually log here so you can say component and we can say for example here component mounted like this boom so let me just refresh for good measure now we're going to see component boom this runs first this runs second when the component mounts and effects aren't only used for side effects they also replace life cycle functions so you might remember something like this from swell4 and etc you had on mount you had before update and you had after update and there was also on destroy right So you could return a cleanup function from onMount or you could use onDestroy for these lifecycle methods, right? But you don't have to use any of this anymore because effect replaces all that So as we can see when we use effect boom mounted mounted that basically it So this replaces on mount And then we can actually return a cleanup function when this component unmounts so you can do whatever you want inside of here. And another caveat is that this also reruns whenever this effect runs. So when you're updating some value, you can do some additional cleanup, right? So it's not only going to run when the component is destroyed. And we're actually going to talk in a second about something really important when it comes to effects and that is about timing and the micro test queue so you actually understand how and when to use effects so you don't get into trouble right and for example if we want before updates so we want to run something before the dome updates because this is something really important for example let me just go over effect it actually tells you right here the timing of the execution is after the dome has been updated and we're going to actually see how this can get you into trouble if you try to use effect to derive values which you shouldn't but for example if you want to update a value right before the DOM gets updated and we're going to look at another example later you can use another thing you can use effect 3 so you can do this and you can just say before DOM update and we can say after DOM update and this is how all of these lifecycle functions get replaced by something simpler right and let me just console log so we can just say component and let me just refresh the page and now we can see we get logged first component and now we get before DOM update and then we get after DOM update logged okay but let me actually show you how to avoid foot guns when using effects so I'm going to remove this and I'm going to leave this single effect right so you have this count value right here and we're thinking okay I want to create some history of this and let me just say state and I'm going to turn this into an array and you're like okay I just learned about effects how beautiful is this friends and you're going to say history push you're going to push in the counter like okay this looks great to me right wrong. Now when you save this you're going to run into an infinite loop but the Swell compiler is actually smart enough to detect this and prevent you from doing it. And this is why you should avoid effects in general because effects aren't meant for updating and synchronizing your state, right? Because look how easy this is. You already have this function here, count++. Instead of doing something convoluted like that you can just do it here. You can just say history push count. Let me actually save this. Let me output the history here. I'm going to save this, refresh, and we're going to see, now we get the history, right? How easy peasy lemon squeezy is this? But let me actually remove this and let me show you what you can do if you have to use effects for whatever reason right I not going to judge maybe you have to do it for something who can foresee those things right so we can actually import something named on track from swelph so you can import untrack and inside of here untrack just accepts a callback we can take this and then we can say untrack and we can just pass in the callback here and this is going to make these values not reactive so it's going to untrack them as the name said so let me just show you nothing is going on so like okay what is the the point of this well you can just put the value that you want to react will be tracked inside of here like count boom that's it so we're going to see this is going to work this might be unclear to someone like what are you doing here so do something like this if count then we're going to untrack this and update the value right and you can see this works as expected all right but let's actually talk about why timing is so important with effects and i'm going to remove all of this since you don't need this and let's say for example that you go here and you say double for example. And let's create state. And now we're going to use effect to update this value. So we can reassign double to be count as two. Let's also update it inside of the template. Let's save. And you're going to see everything works great, right? So you're wondering, okay, so what is the problem with using an effects? And it's the timing, right? So if you look at effect, the timing of the execution is after the DOM has been updated. So let me show you how this can get you into trouble. So for example, we can create this function increment. Let's do the same thing, count plus plus and we're going to replace it here increment and now we're going to say here console log we're going to say count double but do you notice the problem here because these effects run less right we're going to increment the value but we're going to log the stale value of double and this is why timing is so important let me save and let's see what happens so we're going to go through eight and we can already see in the output that our values are out of sync and this is why you should avoid using effects for this. But we're going to look at another example where the timing might not be that important, but in general, the reason why I always say to avoid effects, because it's a slippery slope, you can be like, okay, this looks fine to me, and then you can get easily into trouble if you continue using effects. So as you see, it's really important to understand when these effects run. And when do they run? They actually run on something called the microtest queue. And there's literally a code in the Swell source code which invokes this function. Cue microtask and it cues something to do later, right? Let me actually show you how this works. So you can actually look at this animation here. So this is your event loop in JavaScript, right? You have some tasks. This gets on the call stack, right?

 actually when it gets popped off then we can run the microtest queue and this is mostly user code so this is your promises queue microtest and etc and then you have another thing called the microtest queue and these are mostly browser apis like set timeout set interval and etc and let's actually see how this works so when test gets popped off of the stack then we can only run the microtest queue not before right so when it's empty we're going to run the microtest queue and when the microtest queue is done then we can run the microtest queue and this is basically what gets repeated and this is what basically the javascript event loop is this is really something important to understand not just in swell but in general in javascript and other frameworks based on it right they all do this so remember always just use derived for deriving value you don't have to do any of these convoluted things so we can just say count as two we can remove this we can have increment and now we're going to see when we log the values they're going to be synchronized how beautiful is this friends all right so speaking of the arriving values let me show you the alternatives you can use instead of using effect so here i have this derived example let me just type in derived open it and that's basically it so here's my example and whatever you type in the input here is going to be capitalized that's basically it it works beautifully but let me actually show you how this works so here we have some reactive state feels right nothing special here we create this input component and then we can just bind the value that we have inside we can bind it to fields.name. And let me actually show you how the input component looks like. We make this value bindable, and then inside of here, where we bind this value, we just want to capitalize it. And here, the timing is not really that important, right? You can actually get away with using effect here. I actually wouldn't be mad. So you can just inside of this effect say value equals to value.uppercase. And why do we have to do this? Well, the reason we can't use the write for this right now is because the drives are read only. But if you're watching this video in the future, this might have changed or Svelte might have introduced another rune to make it easy to link values right but let me actually show you the easy thing you can do instead of using effect just use an event listener there is nothing wrong with that so for example we can create a function uppercase we can pass in the event and then we can just reassign value to be target value to uppercase that's it let me just remove this effect so now we don't need to bind this value we can just say value and then we can use an event listener and then we can just say uppercase let's save this and now we going to see whatever we pass in is going to be capitalized and you can see when we restart the component when it mounts is going to be lowercase but you can just check something here based on a prop or you can just capitalize the value here. So you can say value, value to uppercase, right? So you can see easy peasy, lemon squeezy like that. And alternatively, what we also did in a previous video, you can use a writable derived if you really want to have a bindable value. so for example we can just create uppercase here and then we can say get value so we can return value to uppercase and then we can also set the value we can pass in the newest value and then we can reassign value v to uppercase like this and let me remove this function and now again we can bind this we can say bind value to uppercase that's it now we no longer need this and of course we can bind to a constant let me just and we have to say uppercase dot value since you're using an object and obviously it works as expected and this is what you can do so you can use a writable derived or you can just use a regular event listener right there's nothing wrong with that and of course you can turn this into some utility function maybe you can use a library like rune that has some helpful utility functions for dealing with signals and etc but yeah if you're watching this in the future it might be simple as just saying uppercase and then saying derived so you can say value to uppercase but the problem right now with derives is their read only right so for example if we do something like this we're going to get an error cannot bind to derive state but yeah make sure to check the documentation all right but let's look at another example to understand how the callback function provided to effect works so i'm going to go to this timer example and inside of our component i just have this timer and milliseconds piece of state and then below where i have these buttons i'm going to slow down or speed up the timer and that's basically it so Let me just uncomment this effect to understand how it works. So I'm just here assigning an interval. I'm saying setInterval. Then we're just going to increment the timer. And these two are now a dependency of this effect. And we can also see that we return a clear interval function, right? But let me actually just comment this out and see how this works. So if I save this, you're going to see our timer works as expected. Well, let me try to speed it up. You're going to see, okay, it works fine. Well, let me just try to undo it. And we're just only going to make this works. and it becomes more erratic because these intervals are stacking on top of each other. Alright, so we can actually clean this up, but what's important to know here is this callback that we return doesn just run when the component is destroyed or unmounted this reruns each time effect reruns so we can actually say console high for example and let me just refresh everything so now we have this timer everything looks great and we're going to see when we speed it up we're going to get high twice right so let's actually undo what we did and let's actually put it back to normal speed and we're going to see things work as expected because we're supplying this clear interval timer but yeah that's basically it just keep in mind this reruns each time effect reruns and not only when you unmount the component all right so let's actually look how effect tracks dependencies so i'm going to open this depth example and we're going to see something interesting so for example we learned previously that whatever we put inside of this effect is going to make the effect rerun so we have this count dependency for example but in this case this isn't going to work because we passed in an object here and the only time this is going to run is when we specifically update a field or property on the object so for example let me just save this and you're going to see it logs once and then not anymore right so we can actually see that this is true if we go back here and let me just specify something like this and we can actually reassign count we can say something like value 10 whatever not important you can see this is now going to rerun each time, right? But this is actually not what we intended. So let me actually revert this. And let's actually look at this other example. So we can see when we're specific about what we want to log, this is actually going to log count dot value when it changes, right? So let me actually refresh this. Let me say 1, 2, 3, 4. You're going to see this works as expected. And we can see also something interesting in the case of double. So double is going to work because under the code this is actually just a function, right? So this is going to create a new object each time. And this is why it gets reassigned, right? So we're going to see that this actually works compared to count, right? So let me just say console.log double and I can save this so I can say one, two, three, four. And you're going to see this works as expected. But all right, what is actually the reason for using this here? You might be using something like this to log a value when it updates, but actually don't use effects for that. We actually have this super powerful rune that you can use called inspect. And you can do a lot with this. you can check the documentation out, but the simplest thing is when you pass in a reactive value, it's going to use console.log by default, and you can also pass in an optional callback quick, and you can do whatever you want, like slap a debugger on it, see the stack trace and etc But basically this is as simple as it gets This actually doesn care how you update this value For example let me refresh and now I can say 1 2 3 4 And boom you can see it works as expected So if you want to observe any changes regardless how deep they are, just use the inspect rune. Alright, let me show you another example where you don't need to use an effect. So I'm just going to go to this counter example right here and let me just open the code. I'm going to say counter. And as you can see, I just have this simple function create counter. I'm going to create this counter. As you can see, we can pass in whatever, 10, and boom, everything works. Easy peasy, lemon squeezy, like that. But you don't actually need this. Let me actually show you the counter code. This is the actually interesting part. So as you can see here, we have this special file, counter.svelte.ts. Because in Sveltefy, we have universal reactivity. You don't have to use stores anymore because runes or signals work the same regardless if you're using a Svelte component or just a regular JavaScript or TypeScript file. As you can see here, I'm just creating this function create counter here you're passing an initial value i'm creating a reactive piece of state value right and because the reactivity can't magically cross a function boundary you can just return this value right and let it be reactive we can actually just use a simple function or we can actually make the developer experience a lot better by using a getter and a setter and that's basically how this works you can see here we have a reactive count but all right let me actually get to the meat of it so this is something really important to understand so for example let's say you just learned about effects, you're thinking, oh my god, this is so great, I'm going to use effects here to write this to the local storage so I can cache this count, right? And let me actually show you something, this works as expected, right? So I'm just going to uncomment this out so we can have this initial effect so when this mounts or when we invoke this function, here we're going to get this count value from local storage, right? And we're just going to reassign it and then we have this sole effect here that's just going to update this count value. Alright, so let's say this and going to see everything works fine so let me just log for example local storage you're going to see here we have this count already let's increment the count let's also log local storage again you're going to see everything works fine if i reverse it that's perfectly fine what is actually the problem with this well one thing that you have to understand about effects they only work when initialized in the component life cycle and what does this actually mean well you can get into some surprising problems when you try to use this outside of the component lifecycle. So for example, if you create count here, we can say create counter like that. Boom. Now you get an error. So it says a swelterr, effect orphan, effect can only be used inside

 an effect and i'm actually going to explain to you in a bit why that is but the solution to this you're already starting to notice that you're starting to complicate things here for no reason so basically effects need to have a parent root effect so how you can solve this problem is using effect dot root and you can just move this inside of here so now this effect has a parent truth now when we refresh this you're going to see everything works fine and we can check the local storage we're going to see we have count eight and instead of doing this what you can actually just do you're already writing to this value right here right so why not just do it there so for example we can just use this code so when we read this value right we can just do something like this and when we update the value we can also do something like this right there is actually no reason for using fx save this and when we refresh you're going to see everything works the same and instead of value here we're just going to pass v which is the freshest value so now if If I refresh, let me increment. You're going to see we go to 10 and we can log local storage. And again, as I told you, avoid using effects. Use effect only if you have to. And let me briefly explain why that is. And not because you have to understand this, right? I just think it's really interesting. So for example, let's go back to our counter here. And we're just doing this so we can output a stack trace. So we can say console trace, boom, easy peasy, lemon skizzy. Let me refresh this page. and the only interesting thing here is this mount function so for example when we call this mount here we can actually go inside the code and you're going to see the root of our app is actually wrapped in this root effect and this is done for cleanup and some other reasons i really don't know 100 to be sure but this is basically why it complains with you when you're using an effect outside of the component initialization phase because it has to have this parent effect root But yeah that basically it Let me show you another interesting example here So there another esoteric effect root called tracking Let me just open that. I'm just going to open this example. Let me show you. So basically, I just have the store. It's almost the same as the previous example. I'm going to create a banana, create a store fruit, and just going to set the value. And as you can see, if I look at local storage, here we have our fruit here, our count from before. It's really not important. but let's actually look at the code for the store again it's almost the same as before we're reading the value from local storage here we're using an effect inside but again we're going to run into the same problem so for example if i say const a i can say store let's assign it a key a and if we say a.value then we're going to run into trouble right and an alternative to effect root that you can use to check if you're running this inside of an effect or a template you can use this esoteric effect.tracking rune. Again, this is very advanced. You don't need to know about this. As you can see here, it knows in what context you are. So if you try to log it inside at the top level of the components, you're going to say false. And if it's inside of effect in your template, because again, as you've seen at the start, your template is basically an effect, it's going to say, okay, I'm running in this context. So here in this example, we can solve this another way. We can say effect tracking, and let's actually say effect tracking, then we can use this otherwise we're going to bail out of this so let me actually refresh everything in order to see we're not going to run into a problem anymore let's say local storage and now you won't run into an error again but again this is all convoluted i'm just showing you the problems you can run into if you try to use effect when you don't have to again so you can just write to local storage from here and you don't have to do any of this nonsense right move it where you set the value and then you can check for the value and that going to be basically it Alright so let go through a practical example together Here we going to convert this chat example from the Svelte 4 tutorial to Svelte 5 So if I go to this chat here this isn AI this is just Eliza So for example we can just say hi and then ask it what is the meaning of life. And you can see here we have to scroll unfortunately. Okay, it tried, but yeah. So as you can see here, I can uncomment this line. So they're using before update to measure everything and they're using after update to update the scroll position. So now if I save everything, let me just say hi, you're going to see the scroll position is going to update. Right? So let's actually see how we can convert this to 12.5. Alright, so let's actually turn this into state. I don't think we're going to need auto scroll because we're going to use a single effect. Let's turn this into state. And now we can just comment this out and remove this because we can't use this with runes. So let's actually see what else do we have to do. This is optional of course, but a great thing about 12.5, now you no longer need to spread the array to add something new. you can just say comments push comment we can do the same thing here comment push typing and the only thing i'm going to change here so this is comparing two objects which aren't going to be the same because we're using runes and i wouldn't even do this example i would rather do something like this so comment value so this is just filtering these dots that's basically all that this is doing all right let me save that and another thing is that event handlers are now just regular props, which is really beautiful. Okay, so now if I save this, let me refresh everything, and we're going to see at least this is going to work, right? So now actually, let's add an effect. Alright, so first I'm going to add an effect, and I'm going to use pre, because we're going to measure the DOM before the update, and then after it updates, we're going to update the scroll position. So let's check if div doesn't exist, we're going to return it, let's take these two values, let see what is this So this is going to calculate the scrollable distance and then we can assign this to a variable And now we can say if auto right Now we going to update the scroll position Cool. Let's do this. And I'm going to also delete this because we don't need this anymore. Cool. That's it. But you're going to see this isn't going to work for two reasons. Well, first, this effect isn't going to rerun because we don't have a dependency inside of it. So we can say, for example, just something like, not messages, comments length, right? But actually, let's just put this inside of an if. And I'm going to move all of this inside. Cool. But as you're going to see, if we say hi, this is still not going to work. Because if you remember, they used after update to update the scroll position. So how can we do that? Do we use another effect inside of here? And the answer is no. We can actually use something from Svelte called tick. We can say then, and then we can pass a callback here. but actually tig just uses q microtask under the hood so let's actually play the same game these effects are playing so we can just say q microtask let's pass in a callback so now let's see if everything works we can for example say hi ah and you're going to say how are you doing and okay that's it great conversation really riveting right but you can see now everything works as expected all right and let's see why it isn't getting rid of those dots so we can actually go here and here's another pro tip if you just want the normal value from this proxy state you can just say state snapshot and we can pass in the comments so it's easier to read right so we can just open this and let me just pass in something like hi so here is my mistake i said dot value instead of dot text all right cool so now actually i can remove this let's just say dot text and let's try again awesome that works all right so that's basically it if you like what you seen, don't forget to like and subscribe. Thank you for watching and I'll catch you in the next one. Peace!