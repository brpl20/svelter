 Hello everyone, I'm Kirill and today I will introduce you to Svelte actions. We'll look at how to use them and why they make development with Svelte better. Ok, let's begin. So what are Svelte actions? Svelte actions are essentially functions that are executed when an element is mounted. That's all there is to a Svelte action, but there is so much more we can do with it. So if you are familiar with React hooks, React hooks and actions are quite familiar in that both allow you to share non-visual logic. To see what that means, let's jump straight to some examples. So here is an example of a chat with Elizabot, which you may have seen in official Svelte tutorial. And when we launch it, the input, where we are supposed to input our message, is automatically focused. In this example, I'm doing this with a Svelte action. to do this i input the autofocus function and then i use the use keyword and use it so if we look inside we see this really uh our element is focused on mount and that's all it does and that's a legitimate svelte action. Of course, we might want to do much more, and we can. Here's another example where we not only autofocus the element on mount, but we also refocus it when our user navigates to some other tab and then goes back to the tab with chat. It automatically refocuses the input field. And to do this we just register something like visibility change Event on document and then we remove it when the element is destroyed Another thing we can do is provide Functionality like auto scroll so If we input something and send it a couple of times you can see that our chat window is not automatically scrolled. This is the job that we have to do and one way to do it is with this felt action. So for example we can use this action which takes the node and then on each update which basically means after every message we send it recalculates the scroll height compares it to the client height of the window and then it updates the scroll position again to use this action we just import it in our component file and then we just use it like this now we can send messages and the chat window is automatically scrolled and the great thing is that you can apply the same logic the same auto logic to a lot of other chat windows which you might have in your web application That what makes SvelteActions cool So we could do something similar by creating components say a component named autofocusable or a component named autoscrollable. But in reality, what makes this approach different from SvelteActions is that you can use it only with one element type, say only buttons or only inputs, only divs or only articles, and that's why using a component in this case is definitely not a good idea. Moreover, this approach has another big disadvantage. For example, what if we wanted to reuse some other independent functionality? Maybe I want my input to also be automatically validated on every update. well, where should I put this validation logic? Does it fit inside into the autofocusable component? I don't think so. And so to summarize, Svelte Actions allow us to share non-visual logic across many types of DOM elements. That's what makes them different from using components. another example I want to show you is salt actions that allow you to extend DOM attributes so to see what that means let us look at this little example so here we have an input which has type range and inputs they have type range can also have a step so for example if the step is one then the value is increased by one if the step is two then the values is increased by two and so forth and and for example i might want to use dynamic step the The problem is that if you just use the step attribute on the input, it is fixed. But what if I want to use step 2 when the value is below 6, and then use step 4 when the value is below 12, and then increase step even more? That requires some custom logic. And one way to do it, again, is with this felt action. So here, in this example, I'm using the step action, which allows us to define steps and values below which the step is applied. So for example, in this case, I am dynamically updating the padding of an element using the current value from the input. so it increases by one when it is below six but then it goes eight ten twelve sixteen twenty twenty four thirty two forty and so on and the logic for this is really simple it just goes through the configuration and then returns the step that matches the current configuration and this is great because you can use this logic with a custom configuration on many inputs in your application so i discovered it when i needed to dynamically update tailwind css class names as you may know tailwind has classes like p4 for padding or p8 but it doesn't have it doesn't have classes like p7 or p9 so if we used an input with just a fixed step of one at some point we would have a value p7 or p9 and there is no such class so our CSS would basically break and that's what I make what that's what I think makes actions really cool so to summarize what we've seen so far we see basically three main advantages of Svelte actions the first one is they allow us to reuse non-visual logic as we've seen in examples like autofocus a second they allow us to extend existing logic which is for example logic the native logic of dom elements so take the step attribute and third they also allow for better library authoring experience uh it is there so self actions are good fit for libraries because many libraries need to do some work both on mount and after every update and using callbacks making a user import callbacks like after update only to call some library function feels wrong these are implementation details that must be hidden ideally you should be able to just import the library and then use it with the use keyword Okay, so let's look at some other examples which we can use Svelte actions. So here I have an example which dynamically updates CSS with a Svelte action. As you may know, Svelte does not allow us to dynamically update CSS based on state, at least not yet. that's what some libraries CSS and JS libraries allow you to do but here we can do this just with Svelte so here we have some text and two inputs one allows us to increase the size of text and another one allows us to change the color of text and to do this we input the CSS action and we use it on our container we pass to it the color variable which has a default color of black and also inside the style tag we define the CSS custom property with the same name say color and then we just use it using the bar keyword so what happens is that on every state update our action sets the value of the custom property based on the current state so So let go inside the action and see how it works It is actually pretty simple it just goes through the keys of the object that will pass to it and it uses to set the property using the current value and that's it that's all it does but you can literally update we can literally update any CSS value you like you just need to name it and pass it to the action and then just find some way to dynamically update it so another great example of Svelte action is another great thing you can do this Svelte actions is animations currently Svelte allows you to use some built-in animations like fade in fade out fly in fly out transitions and also something like a flip when you when the element changes its don't position when you shuffle a list so I created my own example of a flip animation so here we have a list and when I press shuffle it reshuffles the elements but all of this is done with a custom svelte action so I will not dive deep inside of it I will not dive dive deep into this but this is what it might look like here we utilize functions like before update and after update and take an on mount that you can import from Svelte and what it does is basically before each update it caches the current coordinates of an element using uh the get bounding client rect function and after after every update it compares the current coordinates with the cast coordinates it calculates the difference and then it uses something like uh web animation api to actually before the animation using the calculated diff and this is what we see now to use the action we just import it in our component and then we simply use it on any element that we'd like to flip we can additionally and optionally pass options like duration and whether and even whether the animation should be done with sprint physics this is not this is something you cannot do currently with the built-in svelte flip animation function but you can do it with this one so for example if i check this checkbox use sprint the elements are shuffled using sprint physics now it looks kind of buggy because there is no logic that updates the position cache when the window is resized that is something that must be done if this is a library and that's it Thank you for watching, I hope you have a lot of fun with Svelte actions.