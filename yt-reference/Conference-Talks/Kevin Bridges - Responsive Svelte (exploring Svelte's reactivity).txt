 Thank you. Hello, my name is Kevin, and this session is all about exploring Svelte's reactivity. So this is going to be a bit of a deep dive, but we're not going to go too deep into the internals of Svelte, because we're going to be doing this from an observer perspective by visualizing Svelte's reactivity firsthand right within our application. So there's a bit of mystery behind some of these concepts, and we'll delve into some of the lesser known detail that you may not have considered. I should mention that this is not a Svelte tutorial. You don't need to be an expert, but we are not going to be spending any time on Svelte basics. So the hope is that we will come away with more insight and be better informed on how to use this awesome product. I think there's something for everyone in this session, whether you're new to Svelte or an experienced Svelte user. So let's take a quick look at the resource links that are listed. You might have noticed that they're there here highlighted in yellow on the lower left of the screen. I've also placed this on the demo screen in the upper right in case you missed it. It's basically a bit.ly link. So it's bit.ly slash r dash svelte for reactive svelte. This is a link into my webpage. If you click on the button or scroll down, you'll go into the presentation syllabus. And there's also a list of the resources that we'll use throughout the presentation. The first one is there's a copy of the slides you can follow along if you so desire. The most important link is the second highlighted link, the demo link. This is a REPL that we're going to be using throughout our presentation. I've listed an article here. I've written an article by the same name. And in some cases, it goes into a little more detail on what the presentation does. So you're welcome to look at that if you're on leisure. And there also a second REPL entitled Reactive Triggers And we be using that midstream within the presentation just briefly And lastly there is a link to Rich Harris Rethinking Reactivity presentation So let's go ahead and get started. I'm going to jump right into some code. This is a REIT user component, and basically is a component that is going to display the characteristics of the currently logged in user. The first thing you need to know is that the user import here is actually a SvelteStore, which is a user object that has the characteristics of the user, which is the name and the phone number. And then we'll actually reference those characteristics within our HTML markup. You can see that we're referencing the user name and the user phone number. And we're also distinguishing some CSS styling based on whether or not this phone number is long distance. If it begins with a one dash, we're going to color code it with a long distance CSS, which happens to be pink. So let's take a look at this in our REPL. So if you go back to the resources link, just click on the demo link and that brings up the REPL itself. So I'm going to maximize this to try to get as much real estate that we can. Now I'm not going to go into a lot of detail because we're going to focus on this GREET user component pretty exclusively. But if you do look at the REPL just briefly, the bottom of the app, the primary thing that it's doing is it's actually combining an edit user component and a greet user component. So you can see that the edit user is here on the upper part and the greet user is the component that we just reviewed very quickly. Normally you would not show these two components together but in this case it merely correlates the reactive state between the two. So we can actually run this if we change characteristics of our user. I'll change it to Ginny O. Let's add an extension to her phone number. And if I apply change you'll see that that's immediately reflected in the greet user component as you would expect. And then also if we change the phone number to have a one dash in it, it'll be considered a long distance number and so applying that will apply the CSS styling change that we saw earlier. So as a trivia point, the phone number and the name that are used in the demo are actually very famous. It actually may have been before your time so I would suggest that you google it and see what you can find. So what could be simpler? We're We're going to be using different variations of this component throughout our presentation. So as a sidebar, I'll be using the term snippet quite frequently in this presentation. A snippet is any JavaScript expression that Svelte reactively manages and invokes when its dependent state changes So there are two forms There a code snippet that is found in the script tag and that demarked with the dollar sign label and Svelte refers to this as reactive statements And there also an HTML snippet that's found in the HTML markup delineated with curly braces, and Svelte refers to this as interpolation. So code snippets are typically lightweight in that they result in changes to JavaScript state variables, while HTML snippets are typically more heavyweight because they result in changes to the HTML DOM. But ultimately, snippets provide the dynamics within our HTML markup, i.e. its reactivity. So I'm using these terms to have a concise distinction between these two use cases, code snippets and HTML snippets. So I'm a brand new Svelte user, and like many of you, I think Svelte is so cool. It all began in 1969 when man first set foot on the moon. Well, I guess that's not exactly true. This is actually my tribute to Rich Harris's presentation entitled Rethinking Reactivity. If you haven't seen it, it's a must watch. And you'll see the correlation to the moon landing in the first 30 seconds of the presentation. Well, needless to say, I began my career six years later and 20 plus years before there was a usable internet. and so I'm probably the old guy in the room but I remember when Netscape was introduced with this new JavaScript language in the mid-90s I was all in and subsequently I worked on a number of projects that promoted reactivity within our application without any frameworks i.e pure JavaScript and believe me that requires a lot of code and some good architecture to ensure that code is maintainable. So I actually skipped right over the jQuery phenomenon which is an amazing library in its on write, right into these new declarative component-based frameworks. So coming from my background, I never cease to be amazed at how much you can do with so little code. So Svelte is merely, I think, taking the next progression or going to the next level in that it provides all the benefits of these declarative component approaches without the bloated in-memory runtime framework. So why is Svelte so cool? Well, primarily, I think it is its unique approach to reactivity. Other declarative frameworks are focused around component re-renders, and your app must trigger reactivity, for example, the set state function in React. In Svelte even though it is component reactivity is somewhat independent of the component Reactivity is triggered rather magically at any time In other words reactivity is simply baked right into the application. I think this is accomplished by what the Svelte compiler is doing for us. It actually does the following things. It isolates the JavaScript snippets that provide our dynamics, and it determines their dependencies of each one of those snippets. It monitors those dependencies for staleness, and it re-executes these snippets whenever the dependency is stale. Ultimately, this has the effect of updating our DOM fragments. That is the Svelte compiler in a nutshell. So being the curious fellow that I am, I want to see Svelte's reactivity firsthand. We might be saying, of course, you can see the reactive results of your production app through the state that it's visualizing, but that's not what I'm talking about. I want to definitively determine when Svelte triggers the execution of my snippets. In other words, I want to see Svelte's reactivity in action. In doing so, I can become more grounded in Svelte philosophy, and it can give me a bit more insight on Svelte heuristics, such as dependency monitoring and reactive triggers and DOM updates, and overall give me a better appreciation for all this reactivity that's occurring automatically all around me. And we may just discover some detail that we hadn't considered. Well, at first glance, this seems like a difficult task because Svelte is in control of this, not us. So how can we accomplish this? Well, it turns out we can use a common developer trick to logically or a console.log prefix to each of our snippets. So here's our original HTML markup with the production expressions in these HTML snippets. And then the second section shows what it looks like if we add the diagnostic logging probes. So console.log actually returns nothing. So because that's undefined, the logically or expression is going to unconditionally execute the production expression. And so the end result is we have the same result with the addition of the logs added to our console log. So as an example, if the phone number changes, you're going to find phone section fired in the logs, and that's based on this console.log within that expression. So let's add diagnostic logs to our greet user component. So you can see here that I've set up a series of probes, which are just functions, just to kind of make it a little more concise in the actual logical R expression. And then down here, we're actually monitoring them. So I'm putting the probes in logically orienting them.

 appropriately. It's important to use a unique text within the logs so you can correlate which text is associated to which probe. So let's look at the demo REPL of this version of GREET user. So the REPL actually allows you to select different versions of the GREET user. You can do that right here. So I'm going to select the version with reflexive diagnostic logs. And so I'm going to bring up the console log so you can see it. And so now if we make changes, to our user, we're going to see that actually fired down here in the log. So you can see the name section was fired and the phone section was fired. So that's pretty cool. And we can also change the long distance characteristic and you can see the appropriate firing that occurred. So that's pretty cool. For the first time we can now definitively determine when Svelte has executed our HTML snippets. Well, logs are great, but depending on how many probes we have, it may be tedious to correlate them to our snippets. It'd be nice if there was a way that we could actually see Svelte's reactivity right in our application. So here is a simple utility called Reflective Counter. It's actually a reflective store that maintains a count of every time a snippet is executed. In its rudimentary form, it is a basically a simple counter. However, its API is tailored to be used as a reflective monitor. So you can see here that we're actually creating a writable store and it has a single value, which is a counter. And what it's returning is a custom store and it has the monitor function, which is actually updating the internal counter every time it's executed. So the usage of this is both in monitoring, and so it's very similar to our diagnostic logging probes, where you have a logical OR expression, but we're using the monitor method in this. And then in addition, we're going to actually report the counts in our code or within our HTML. So you can see here that I'm actually displaying the count of that particular probe. And I've actually put this in a mark HTML element to actually highlight the fact that it's not production rendering. It's a diagnostic. So let's add advanced diagnostics to our GREET user component. So here you can see that we are doing a setup and it very similar to our logging probes except we using the reflective counters for the probes And then we also doing the monitoring very similar to the logging probes as well with the logical R But in addition, we're also reporting the results of these using the mark HTML element with the value of the number of times that particular probe has been executed. So let's look at this in our REPL. So to see this, you want to actually select the with advanced on-screen diagnostics probe. And so there you can see that we actually have in addition the yellow highlights that's showing the reflexive count. So if I update the name and update the phone extension, let's say, then we'll actually on the fly see the counts update. So let's change this to a long distance phone number and apply the change and see the reflection right on our page. So this is great. Our component's reactivity is now visible directly on our page. So I don't know if you have noticed it or not, but there's actually some unexpected results from these probes. And that is that HTML snippets are re-executed even when their state did not change. Ouch! So you can see this by... let's go back to our REPL. You can see this by just changing one value. I'm just going to change the name and apply change and see that all of the snippets re-executed. In fact, you can even just click on apply change by itself and all the snippets are re-executed. Now as a sidebar, I realize that I can optimize the user store to prevent this last scenario, but for the purposes of this discussion, it better highlights the points that we are driving at. So this is really an unexpected hit. What is going on? The answer has to do with Svelte's dependency monitoring. As it turns out, there's a big difference in how Svelte monitors objects versus primitives. Objects trigger reactivity per the entire object, not the individual content. In other words, the stainless granularity is the object itself. And this is what we were seeing in our demo. On the other hand, primitives trigger reactivity only when the value changes based on identity semantics. So I have a second REPL that demonstrates this. Let's look at it now. So back on your resources link if you click on the link that says reactive triggers it bring up that REPL And I going to go ahead and maximize it as well So this is a pretty simple REPL It basically has two state variables. One is a primitive called prim, and one is an object called my object that contains a couple of primitives within the object itself. So the REPL, if you look at it, is implemented in such a way that the button label is actually the expression that is executed. So it's pretty obvious what you're doing by clicking the button. And so I'm displaying both the primitive and the two object properties up at the top. And it is also orchestrated with the reactive counters that you can tell what's happening there. So as an example, if I click on the primitive plus plus, I'm actually adding a value to the primitive, you can see that its reflexive count was increased, as well as decrease also bumps up the count as well. If I change the value to a hard-coded 1945, you can see that it initially updated the count. But if I do it again, it's not going to consider it stale because the primitive value has not changed. Now that in contrast to how objects are handled, if I just basically update the foo property of the object, then you'll notice that both the foo property and the bar property are reflexed because again, Svelte is considering the entire object as being the dependent granularity. So, again, you can see that I'm updating the bar reference, even though the only thing that changed was foo. And here's an example of changing the entire object to a different reference has the same effect. Changing the foo property to a hard-coded 1945 still updates both reflexive counters, because, again, Svelte is considered that object as being changed. And even assigning the object to itself has that same effect. So, this is a very interesting tidbit. While it's probably what you would expect, to my knowledge, this is not mentioned in the Svelte docs. So back to our re-render analysis, the elephant in the room is the question, is Svelte producing redundant and unnecessary re-renders of our DOM fragments? Remember, DOM updates are expensive. Is this really true, or is there more going on under the covers? Well, a spoiler alert, Svelte does in fact optimize this, and we're going to discuss this a bit later. But for now, I'm going to take you through the same progression that I took when I came to this conclusion. So it turns out there are app-specific techniques by which we can tweak the reactivity. So how can we impact this? After all Svelte is the one who is in control of executing our HTML snippets How can we alter this So the basic thrust of what we about to do is to move reflexivity from HTML snippets to code snippets Remember that code snippets have less overhead because we're merely changing the JavaScript state variables. We can take that in combination with what we learned about staleness monitoring and do something with that. The first one is applying a finer-grained dependency management. Remember our discussion of dependency management and that primitive types also include identity semantics? What if we normalized our reference state into primitive types? So here is our greet user component that is dereferencing the user objects within the HTML snippets. And here is the after we have normalized it into primitive types. So you can see that we've moved into the code snippet a reactive statement that basically is denormalizing the user into primitive types, name and phone number. And then we're referencing those primitive types directly in our HTML snippet. So let's look at this in our REPL. And in this particular version, we need to select the one with primitive normalization. So now if we change just one of the values, Jenny, the name itself, you can see that only the name reflects. And if we changed the phone number, only the phone number will reflect. And if we apply change without any changes, then no reflection is occurring. You may also notice that the CSS snippet also executes whenever the phone number changes, even though the long distance distinction hasn't changed. So that's going to be the topic for our next discussion. So the second thing that we can do is normalize conditional logic into primitive types. So here is our code that contains conditional logic in our HTML snippets. And here is the after version where we have normalized this resolving the CSS class name within a primitive string. So we've moved up here to a primitive classes string that's actually referenced within our HTML snippet. So let's look at this in our REPL. So this is the last version of our greet user that is entitled with variations in code. So now, if we change our phone number without changing the long distance classification,

 only the actual phone number snippet has been updated. But if we change our classification to be from long distance to local call, then both the CSS class as well as the phone number itself snippets have changed. So now we find the execution of our HTML snippets to only fire when the DOM needs the change. Okay, let's come back to our earlier million-dollar question, and that is, is Svelte producing redundant and unnecessary re-renders of our DOM fragments? It occurred to me that just because Svelte decided to re-execute my HTML snippet doesn't necessarily mean that it resulted in a DOM update. Could it be that Svelte further optimizes this process by ensuring the result of an HTML snippet actually changed? If you think about it, this makes a lot of sense for Svelte to do, and there are two reasons which we have already seen. The first one is that Svelte's overly broad dependency granularity, and this is the difference between objects and primitives that we discussed previously. The second one is that HTML snippets can return the same result even when the dependencies legitimately change, and we saw this in our long-distance CSS styling of the phone numbers. So how can we verify this? Well, one way to do it is through a very simple debugging session. So let's go over to our REPL and I'm going to base this one off of the second version of our GREET user component and that's the one that begins with GU2. And so I'm actually going to put a debugging probe directly in one of our diagnostic probes. So I'm going to make this a full function where I can have multiple lines and I'm simply going to put a debugger probe right in my code. So we want to be executing that second version. So let's bring up the debugger. Now the theory is when I break in this point, I'm just gonna actually click on the apply change button. And so now we're in the debugger probe that I set. And so we're in our HTML snippet. And the theory is that if I step up one level, I should be in the Svelte realm because Svelte is the one that's actually executing my HTML snippet. So let do that I gonna step up one level and sure enough here we are we are in some pretty cryptic looking code We just executed line 492 or I mean sorry 942 And so that a pretty ugly looking statement It a big conditional logic statement And if it true it going to set it going to invoke a utility function called set data Now, my theory is that set data is what's actually updating the DOM fragment. So to prove that, I want to set a breakpoint right on that set data. And so I'm going to do that. And now I'm just going to continue to run. So at this point, if I apply change without changing anything, it's in my debugger probe here. If I continue on, it doesn't stop anywhere else. But if I actually change the name and apply change, here's my debugging probe, and if I continue, sure enough, it has actually stopped. It's getting ready to execute this setData function. And so the theory is if I step over this function, it should be actually updating the Gini to GiniO. So let's try that. I'm going to step over that statement. And sure enough, that setData is actually doing the DOM update because the GiniO was updated. So that's pretty cool. We've now definitively determined that DOM updates occur only when the content has actually changed. So in looking at this code, you can see that it actually has some app-specific comments in it. You can see there a reference to the dollar sign user. It's looking at probe one in a comment here. So it occurred to me that this could be the Svelte compiled code, you know, that tab that you're always afraid to click on. So let's look at that a little further. So if I go into this JS output tab and look around a bit, just widen it out, scroll down a little bit, pretty cryptic looking variable names. Look, there is the actual code that we were in with that cryptic conditional statement and the set data. So I'm not going to go into a detailed analysis of this code within the presentation. I actually do that in the article if you want to read that section. But suffice to say that we've actually proven that Svelte is very efficient in what it's doing, is DOM updates occur only when the content has actually changed. So knowing what we know now, is it really necessary for an app to apply the optimizations that we went through earlier Well to be honest most likely those techniques will not significantly impact your app performance In some cases we just moving an optimization that Svelte was already doing into the application realm However, there are cases where our newfound knowledge can be useful. Consider this. What if the discrepancy count between reflection and re-render were large, where we were needlessly re-executing an HTML snippet many times with the same output? Or what if the overhead of executing this HTML snippet were extremely high? And what if the same HTML snippet were needed in multiple places in our HTML? Well, the bottom line is we have a better understanding of the finder characteristics of Svelte's reactivity. So knowing these details can give you an advantage when you hit those edge cases. So here is an extra credit exercise. In its current form, the reflective counter is providing us a reflexive count, the HTML snippet execution count. Can you think of a way to enhance this to provide both reflexive counts and re-render counts, that is, of the DOM updates? Well, here's a really big hint. Our invocation is going to change from a prefixed logical or expression to a function that actually is past the production expression as a parameter. So if you think about it, the monitor now has access to the actual production expression. And so it can actually execute that expression and compare it to the previous cache value that was returned from that expression. And then it can actually maintain two counters, one for the reflexive count and one for the re-render count. I won't go through the complete solution. I'll leave that up to you. But there is actually a hidden Easter egg within our REPL that reveals the solution. So let's take a quick peek at that. In the upper section of our original REPL, you'll find an Aleutianse link, which is PIG Latin for solution, and as an aside also makes our REPL bilingual. Well, sort of. So if you click on that particular link, it'll bring up another REPL that is the extra credit solution, and there you can actually find the enhanced reflexive counter utility. But if we just look at it from a usage perspective, we can go through all the same characteristics Let go with the advanced on diagnostics And you can see that the diagnostics here have for every probe it has two counters a reflexive counter and a re counter So if we in this state if we just do our apply changes you can see that the reflexive counter is being bumped up but the re counter is not And so if we go into the other solutions that we walk through, the primitive normalization, applying the change there, the reflexive or the re-render doesn't update. If we actually change our value, let's say the extension on the phone number and apply change, you can see that the phone number expression both reflexed and updated the DOM, whereas the class only reflexed, it did not update the DOM for the new classification. If we change the phone number to be a long distance, let's go ahead and reset these counters here and do the apply change, you can see that both the classification and the phone number itself updated both in the reflexive and the re-render. So that's pretty cool. So what have we learned? Well, we've learned that we can visualize Svelte's reactivity right in our app, either through diagnostic logs or the reflective counter, which is a new utility that you have for your utility belt. And we've learned that there's a big distinction between primitives and objects when it comes to dependency management. We've also learned that Svelte's reflexivity is very efficient in that its DOM updates occur only when the content has actually changed. And that we have learned that your app can fine-tune reactivity as needed. Okay, then. Before we wrap it up, I'd like to give a big shout-out to Rich Harris and all the core contributors for making Svelte such an awesome product. You've truly changed the landscape of web development, and we all appreciate your time and effort. As an aside, you guys should really consider recruiting Big Bird on your team. I have it on good authority that he would be a most excellent contributor to the Svelte code base. To find out why, you'll need to read the corresponding article that spawned this whole presentation. It's bit.ly slash responsive Svelte. How do you like that shameless plug. Well, that's about all I have. I hope you enjoyed this little journey and learned something as well. If you have questions or comments, I can be reached at the following email, and my Twitter account is also open for direct messages. So thanks for watching, and enjoy the rest of the upcoming sessions.