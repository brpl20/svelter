 Yep, seems good. Okay, I guess everyone can see my screen as well. Yep. Yeah, so hi everyone. Nice to meet you guys. Yeah, so I'm dialing in from Singapore, so it's a bit late as you can see from the window outside. So, pardon me if I may look a bit tired right now. So anyways, it's been a pleasure to be speaking in this meetup. So today I'll be talking about looking into the Svelte compiler. So yeah, so this is me, Li Hao. So Tan is my family name and Li Hao is my given name. So you can call me Li Hao or Tan, I think it's okay. But this is my Twitter handle at Li Hao Tan. You can follow me on Twitter. I share things about like Svelte and React and CSS like anything front-end related right so a bit about myself I'm a front-end engineer at Shopee Singapore so Shopee is a it's an e-commerce based in Southeast Asia but a bit of myself I actually grew up in a small town in Penang Malaysia. So, and another thing about myself is that I'm one of the maintainers of Svelte. So today we'll be covering about Svelte compiler, but as Ilaesh has shared with you guys early on on how Svelte works, right? Like how do you use Svelte? And probably what I'm going to do here which like quickly do another recap. So usually it starts with like having a button, having an element on the screen. So Svelte component starts with a file that ends with a .Svelte extension and the code itself looks like HTML, right? So here you have a HTML element and you can have a script tag where you can include like JavaScript. So here I declare a variable called count i can use the variable inside the template via like a curly brackets and i put so you can have a count over here and now you can see zero on the screen i can add event listeners like this so now when i click on it i can increment the count so i can install it so i can add a style tag and put styles inside what's cool about this is that whatever styles inside here is being scoped within this component itself so it'll be just a button that is written within this file this component file that is styled as read and font size of 2 em yeah and one thing that is very different from other frameworks that you don't see that often is that we have this thing called a reactive declaration which means that when you say double equals to count times two with a dollar colon sign over here it means that the value of double is always two times of count so when i increment the count you can see that the value of double is always two times of it the next thing is so sorry so now we've seen how we can write a svelte component let's think of take a bit like think a bit like how would you implement this in vanilla JavaScript right so how would you implement this in just JavaScript without any framework right so one thing you could do is let's start with like the variables and let's so to create a button we okay so we have text nodes first right so to create a text we use document a quick text node so this is one of the browser DOM API to do it right and then we can append it to the to the DOM to the browser DOM and to create a button we do the same thing document create elements set the text content so So for event listeners, you use API like add event listeners and then you add on the browser. Next what we do is that to have that interaction where when you click and that increments the value, right? What you do is that you update the value of the variable, but at the same time you call this function called updates where you try to update the value of the text. So here we also have to count the evaluates the value of double every time, right? So because it's always two times of counts. And lastly, for styles, you can create a style element and then you append it to the document. Right? That's how you get the styles. And then okay, last but not the least, in order for the styles to be scoped, if you just use button you'll be all the buttons for it to scope probably add some class with some hash and then we also have it declared over here so so now your styles this style will only apply to this button instead of any other button right so this the recurring later on i will be showing a few examples of how svelte how you write svelte component but one thing i want you guys to think about is that for all the examples that you're going to see later on, think about how you're going to write it in vanilla JavaScript. How are you going to implement them So one example of what you can do is felt is that you can have some logic blocks right one of it is if so based on condition you show element or not right another thing is await so you can pass in a promise and then whether the promise is pending resolved or rejected you can show different kind of elements and another thing is each where you can look through an array and then repeat your elements for for each item right here we can in svelte you can do data binding so there's a bind attribute a bind directives so data binding next what you can do is you can have transitions so you can have in animations and like different transitions in and out Lastly, you can have components in Svelte. So in Svelte we use tempers and slots that are more aligned to the browser custom elements API. So now we are going to cover about Svelte's compiler. So when I show you just now like how you write a spelt component, right? And also to show you that how you write JavaScript without a frimbo, that's actually because, sorry, I think I should go back a bit. Is that if you take a look at here, when you look at a code that is being generated, it's pretty much just similar I would say okay like you can see here there's some sort of similarities between like the code that you just written in vanilla versus the code that's been generated out from Svelte. So Svelte is a compiler that compiles your code into JavaScript code and it tries to generate as optimized as possible and yeah so that is what we're going to take a look at how this process is going to be okay so how does so before we start about talking in specific for Svelte compiler let's take a look at how a normal compiler works so in a compiler usually when you write code it will tries to scan through the code character by character and then break it down into things called tokens. So one token is like one segment of code. With tokens, you will arrange it in a tree-like data structure. So this is what we call AST, abstract syntax tree. So this is a tree structure. So the compiler will then analyze this tree structure using like say deficits or graph, like those tree traversal algorithm to analyze it and process it and transform it say for example we transform from the left to the right and then from the from the final transform ast which tries to generate a code out of it so this will be the final generator code so this whole process is like a typical how a general compiler will work right you start from passing the code into ast and then you analyze it you optimize the asd you transform the asd and finally you generate a code out of the asd and this is what svelte compiler does as well so this is roughly the process so the first part is that we parse the code so we read the code we read the code from the svelte component file and then we parse it and then we create a component so so the code that i showed here is uh it's like loosely copied up from the svelte source code but in this step what happens is that we're going to track references and dependencies which i'll cover it later on and then over here the next step is we start to generate code so there's two different kind of targets that you can compile for svelte One is like you generate for SSR and one is for the client side. Right. So here after you generate, then we output it into like a file where you can consume by a build tool or you can just write it out to a file system. So let's talk about the first step, parsing Svelte's code. So here is a Svelte source code that we are going to take a look throughout this, throughout the rest of the example, the Let's tap through for compiler. So the first thing is that Svelte implements its own parser. So the Svelte syntax is like HTML syntax. So Svelte will parse the HTML syntax and also logic blocks. And when it encounters a script tag, it will use acon to parse it. So JavaScript is fairly complex. Acon is right for the job. So Svelte is not going to parse JavaScript but it uses Acorn to do it. So it also when it encounters curly brackets within the template, it will also use Acorn to parse them as well. Whenever it can't encounter a style tag, then it uses a library called CSS3 to parse it. So once it's been parsed, now you get all the tokens and then we form it like an abstract syntax tree. is a Svelte abstract syntax tree. So if you're interested on knowing how it looks like, you can actually visit like ast explorer There you can play around with like the Svelte AST So next step what we going to do is doing static analysis so here the same code again so it in the ast form but for each easier visualization we just stick it with like a the source code so the first thing what uh spell will do is that it will traverse a script tag right so when you encounter a variable we're going to record it down and then so we have count we have values and then the next variable is double so double here is a declarative variable right you declare double without a let so what does here is that you will mark that this variable you need to be injected because we need to add like the declaration of it next thing we encounter counts again here we mark counts as reference so it's been so we know that we are we are using counts right now and also we know that from here double is dependent on count because you use count to evaluate double so there's a dependency arrow drawn over there next let's move on we have data now data is within the scope of that curly brackets over here so it's not like a top level variable so you can't use this data variable in the template so we just ignore it now we have i ignore as well double so now we we are referencing double so we mark it as reference uh math it's a global so we ignore it and then lastly we are assigning data to values so we mark that values is mutated and because we use double in like computing for the value of values we draw a dependency like arrow for for the relationship so now we are done with the script tag the svelte will start to travel through the templates right so we encounter the input tag and then we see a bind directive so over here we see bind we are binding the value of count right so we are saying that count is being referenced in the templates and it is still being mutated and then we follow on we move to the ish block here we see that values so in in each of the logic blocks we have create a new scope because here the ish block is declaring a variable called value and value can be only reduced within the ish block right so to represent that we draw another box represent that scope right so here in each blocks what we have is that the each block is has a dependency of value right it depends on the value of the values and then it creates a new variable called value and at the same time we mark the values as reference and let's move into the inside of the content of each block we encounter like the div element tag and then the class and then here we are referencing the value of value so we mark it as reference and color is again so mark it again and then we are done so once we are done with the script tag done with the template now we go back to the script tag again so this time it's mainly for optimization right so we've we've known that all the variables that is being used being referenced we know that what are being all the variables right so now we can do optimization for example we can mark whether a certain decoration reactive decoration syntax for example like this one probably we can know whether it does it need to always being evaluated or it's being static by knowing that whether counts is will be updated right and then that is based on whether it will be muted or not so next thing after we've done all the optimization check next thing we do is that we will traverse through the style so we're going to go through each and every one of the selectors and then we are going to for each of the selectors that matches elements within the template I'm going to add a spell hash class to it so this This is for us to say scope the CSS within the component. So we are done with this past static analysis. So let's move on to the next step where we try to generate output code from what we have analyzed. So in the rendering step, we have two different targets. One is for the DOM and one is for SSR. So let's first look at the DOM first. So here is the code again. So a typical DOM output looks like this. We have three parts. The first part is fragment which returns an object which is like a recipe. So each of this method is how we create, mount, update and destroy elements for this component. Then next we have instance over here. We'll talk about it later. And then lastly, we have app, the class, the component class, right? So to string all this together, you see like there's the init function that takes in instance script fragment. And that's how all these three parts being string together. So now we want to generate code to generate the template, right? So we traverse through a template one by one and add code to insert them. So the first element we see is the input tag So in this create method we create a where statement to create this input element and then in the mounts method we create like a we add a statement to insert it to target right and when we want to unmount we have to remember to remove it right next thing we look at is the binding so to bind a value of an input we need to add event listeners right to listen where the value change and then we update the variable so over here we add like a new variable called input handler so here is that first thing is that firstly when we insert the dom we first set the value as the value of counts right and then we listen to input change on the input and so it returns a remove eventlessness function so we need to remove it when we are amounting the component next is that whenever the value of the count has changed we need to update the value of inputs right so this will be added in the update method next we move on to the each logic block so we add another function that looks similar to create fragment so this function will will be focusing on creating elements within one each item right so you have safety so and also we have another function called get each context so this will text in the variables and in return so this will add one more value variable value to into the scope right so yeah based on the variables that we need to add one more variable value right so I'm gonna skip through the steps on how to add like so basically it will go through one by one elements attributes and then insert the code for each of the methods and after that let's look at the instance function right so what happens is that for most of the code we were going to copy it verbatim inside the instance function but for reactive declaration they will be copied and paste into this function called self dollar dollar update right and then for each of the statements we are going to based on what is being dependent so for example the first one is double is depending on count. So we're going to check whether count has changed before we update it. So how does it know? Again, if we pull out the dependency from this variable list and then we know that what variables depending on each. Right. So of course we have to add the input handler that we just injected previously. And then lastly, we need to return. So instance will return a list of variables that have been used inside a template. So how does it no again we look through variables that is being referenced in the template so finally to make the whole thing whole reactivity works is that for all of the assignment statements we're going to add like the invalid state met function call right after them so we're going to add it here here and here right so this is for the dom and now let's take a look at the how we generate code for ssr so here is our code again for ssr it's much simpler it generates a code something that looks like this so a general idea is that it will be a function that returns a string right so when we traverse so over here we just we can copy all the code from the script tag into the function to set up the variables next uh for now we traverse the template so we have inputs and then for binding because in server side you don't need two-way binding right you just need a value so here we add the value and then this will be like a template literal and then expression of count and then let's move on to each so each will be like a function that will like a map function so it takes in the values the array and then it takes in a function that is like the item and then here again we're going to fast forward where we generate the strings to generate this div template right so this will be just for the ssr output so the last step would be output all this as part of JS and CSS right so it will return so the Svelte API will returns an object that has JS and CSS and both of them will have the output code as well as a soft map so that you can refer it back so usually you don't really need to care about this if you're using webpack for example then this will be consumed by your Svelte loader and if you're using rollup this will be consumed by a rollout plugin right so your bundler will consume this and then will pass it to the bundler so in summary a svelte compiler comprises of this four set passing the svelte code doing static analysis and then the rendering step generating a code one for whether you depending on whether you are generating for DOM or SSR and output them as JS and CSS. And that's all from me. So once again, I'm at Leehao Tan on Twitter. So if you have any questions, definitely you can feel free to ask me now. But of course, if you want to chat more about this, you can always look out for me from Twitter. Yeah.