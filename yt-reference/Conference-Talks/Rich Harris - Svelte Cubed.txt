 We'll be right back. Hey, Rich here. I want to talk to you today about an aspect of SvelteKit that has kind of flown under the radar so far. We haven't really talked about it a lot, and it's probably not what you think of when you think about SvelteKit, but it's a feature I really like that I think kind of sets it apart from its competitors, at least for now. I hope they steal it. So a quick recap for those of you who aren't yet up to speed. Svelte is the component framework. SvelteKit is the app framework that builds on top of Svelte and gives you routing, data loading, server-side rendering, static site generation, beautiful developer experience provided by Veet, and so on. Lots of you are already using Kit to build your apps because there is apparently no amount of this is not yet 1.0 messaging that will dissuade you lot. And that's fine. We're all adults and your feedback has been hugely beneficial. So keep doing your thing. But here's the thing. It's not just an app framework. It's also a framework for building libraries. And in the next few minutes, I'm going to show you how that works and what it means. So imagine you're building a page of a SvelteKit app. Chances are you'll have some mix of code that's specific to that page, code that's been imported from a third-party library, and code that sort of sits between those two, the sort of thing that you might shove in a generic utils.js file or something like that. Every app I've ever worked on has some concept of an internal library. In SvelteKit, there is a place to put the stuff that belongs to that third category, the source slash lib folder. It's really a convention more than anything. It's not a magic folder, though SvelteKit does provide you with an alias so that you can import files from here without doing the whole dot dot slash dance. Really, the idea is that you don't have to waste brain cycles figuring out where to put common utilities and components. And if you move from one SvelteKit project to another, it'll follow roughly similar organizational principles. Now imagine you're building a library for Svelte. It could be a component library or a new action function or something like that. You're going to need to try out your library in a sandbox app while you're building it, then you're probably going to want to build a demo site or some interactive documentation. Historically a typical workflow for this is that you start building the library over here and npm link it into your sandbox app over here or maybe you fancy and you have a mono repo or something like that and then you do the same thing when it comes to building out demos and documentation The problem is that NPM link is the leading cause of baldness among open source maintainers There just something about it that makes you want to tear your hair out, like having to relink link packages every time you install a new dependency. There are solutions to the problems called by linking. Take a drink every time someone shouts, PMPM, but it's never going to be the ideal workflow. And then you have to think about build steps. If your library uses TypeScript, or if you're one of the holdouts still using SAS in your Svelte components, then you have to account for that, and it all adds friction. But wait, if every app needs an internal library, and every library needs a demo app, then why would we have two separate workflows? Why don't we use a unified approach and let you build the two things in tandem, and then give you the choice between deploying your app and releasing your library? The punchline, of course, is that this is exactly what SvelteKit does. It's not an app framework, it's a toolkit for building apps and libraries. Demo time. Let's create a new component library called Svelte Maths. I refuse to yield to the American math. It's short for mathematics. It makes no sense that you would abbreviate it that way. We're using the BareBone Skeleton app with TypeScript and Prettier Pre-Configured. Our first component is going to be an adder component that takes two props, A and B, and adds them for you. We'll create an add function that takes A number, B number, because this is TypeScript, and use it inside our markup. Back in our root root, again I refuse to yield to route even though root root is a lot easier to understand than root root, we can import the component from lib, add it to the page, give it some props, and confirm that 2 plus 2 is indeed 4. That's cool, but if this code was going to be visible anywhere, for example inside a demo, then it would be nice if we were importing from Svelte Maths instead of lib. We need to jump through some hoops to make that work, but it's pretty straightforward, so I'll do it here. First we update svelteconfig.js so that Vite knows about the alias. We need to resolve an absolute path, so I'm importing the path module. Then we need to update our tsconfig.json so that VS code doesn't freak out about a missing dependency. We'll need to restart the dev server in order for this to take effect. Now we can update that lib to Svelte Maths. When we create a new multiply component, we can import it straight from Svelte Maths, multiply 6 by 7, and the answer is 42. So we could now do npm run build to create an optimized production version of our app, but we could also do npm run package which will create a distributable version of our library. Let's take a look at the contents of the newly created package directory. We have our two component files that say that they've been pre-processed, which in this case means TypeScript has been converted to JavaScript We also have these declaration files so that if someone else imports components from Svelte Maths they get type checking and autocompletion Inside package is copied over the relevant parts of the root package and it's added the exports field so that library users can import from Svelte Maths slash adder.svelte and Svelte Maths slash multiplier.svelte. Maybe that's not what we want though, maybe it would make more sense to use named imports rather than deep imports. Let's go back to the library and create an index file that re-exports our two components. Now we, and anybody else, can import them in a single declaration. If we want to disable the deep imports, we can update the package.exports section of our SvelteConfig.js. And now when we do npm run package, the exports map no longer lists the components. Of course, our demo app might still need an internal library alongside the one destined for publication, and we want to exclude those files from the package. We can do that by updating the package.files section of our Svelte config.js. So now we have both a production ready app and an NPM ready package, and we could easily add a script to build and release both simultaneously. I've grown to really love this workflow, and I think you will too. All right, all of that was really just an excuse to show off a library I've been building with SvelteKit. It's something I started working on over the summer at the New York Times for our Olympics coverage. News organizations aren't allowed to show footage from the Olympic games because the broadcast rights are jealously guarded. So if you want to announce the results, you either have to describe them in text, or you have to find a way to show them. And so my friends and I built an app, using SvelteKit of course, that would ingest results data from the Olympics API and convert it to Twitter videos and embeddable widgets. We chose to use 3JS because for my money it's the best 3D library out there. But when you're building something under extreme time pressure, it's really useful to have a declarative component-based approach to keep a lid on the complexity and give us extra features like hot module reloading. In other words, in the same way we use Svelte to keep our DOM code manageable, we wanted something to keep our 3 code easy to work with. Today, I'm open sourcing the result of that work. It's a component library called Svelte Cubed, and you can use it right now. There is a caveat. It is not feature complete. The documentation has gaps. Some things will definitely change. But I know you people well enough to know that that won't stop you. So let's look at a couple of examples. I'm hoping to add more to this page soon, but I'm only one person. if you know your way around 3.js and have some fun ideas then please help come and fill this page up. There's the obligatory hello world. We can edit values in the control panel which is provided by another SvelteKit library called SvelteKnowby so you can play with the material properties. If you curious about what the source code for this page looks like hit the link in the bottom right Another example try Solaris Some of you might have read the Three Body Problem trilogy I only read the first two books so no spoilers And it begins with this classic physics problem about the unpredictable motion of three bodies relative to each other. I implemented it in JavaScript and the behavior is indeed very chaotic. What I like about this example is that almost all the code is JavaScript. The three component stuff is very compact. On the documentation page you'll find a short tutorial for building a 3D scene from scratch. Let's build it now. We'll begin by creating a new SvelteGit project, npm init, Svelte at next, and setting it up in the normal way. I'm going to copy over the starter code from the tutorial. The first thing you'll notice if you've used 3js in the past is how little code there is. This is the equivalent boilerplate if you were to write the same thing without SvelteCubed. So far it's not that exciting. Let's make it look a little bit nicer by enabling anti-aliasing and giving the scene a background color. Now let's add some camera controls so that we can interact with the cube. At the moment the cube has the default material called mesh normal material which is very handy for debugging normals which are vectors that tell WebGL which way a face is facing but probably isn't what you want in your app so we'll add a material of our own using the color of the Svelte logo. Now that we're using mesh standard material which is physically based we need to add some lights so that we can see it. We'll add both an ambient light and a directional light coming from the left, hence the minus two along the x-axis. Let's add some controls. We'll add variables for width, height, and depth, and apply them to the cube mesh using the scale property. Now we can add some inputs and change the values. Right now SvelteCubed is only telling 3 to re-render the scene when something has changed, the dimensions, the camera angle, or whatever. Some frameworks will automatically re-render 60 times a second regardless, but Salt Cubed has more respect for your users' batteries. That said, sometimes we do want to update things on request animation frame, and for that we have the on-frame lifecycle hook. Looking good so far, but we can polish it up a little bit further. We can make the cube cast a shadow, then add a horizontal plane for it to cast a shadow onto. We'll use the Primiter component to add this grid helper to the scene. We need to enable shadows both on the canvas and on the light source. I'm going to customize the shadow map slightly so that it looks less blurry. Lastly, I'm going to add a fog property to the canvas so that the plane fades out gracefully. And there it is. That's all I've got for now. There's lots to do still, docs to write, features to add, and if declarative WebGL is the sort of thing that you get excited over, then come on over to GitHub and we'll build it together. Thank you.