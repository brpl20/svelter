 Thank you. Hi, I'm Ivan and today I'm gonna talk about every developer's favorite topic. Yes, you guessed right, internationalization. I'm a software developer and maintainer of a lightweight internationalization library called Typesafe i18n that can prevent mistakes on compile time. There is no official i18n support in SvelteKit yet, but I will show you how you can add this functionality by yourself in under 10 minutes. Let's get started. I have prepared a skeleton project from the script provided by the SvelteKit homepage. First we need to set up the localization library. We can do that by running npx typesafe i18n and pass the setup auto option. This command will install typesafe i18n, create a config file and add a new script inside package.json. If we now run this script, the generator gets launched and will watch for changes in our translation files. We now can see some new files appear inside an i18n directory. These folders contain our language information. We will add our first translation to our base language file. In this case our default language is English, so we will add our greeting message there. If we now hit save, the generator detects the changes and will update our i18n types file. And if we now go to our German translations, we will see Typescript yellowed us, because we haven't added the translation here. Let's fix that. Let's create a layout.swelt file and initialize the provided i18n sweltstores by calling init i18n inside the load function. We now can import the translation function into our index page. Open localhost 3000 in the browser and we will see the English message appear. Let's say we want to pass a variable to our translations. In this case we want to pass the year. We replace it with a zero surrounded by curly brackets. When we hit save and go to the German translations we will see an error because also here we need to specify the place where the variable should be inserted Also in our template we get an error until we pass the variable to the translation call Now we decide that we only allow numbers here To do that we just add the number type to the English string and we will get an error because we try to pass a string. Maybe improve the example a bit and make it more clear what we expect and rename the parameter to year. Hit save and TypeScript tells us where we need to update our code. Update our translations and pass in an object that contains a year. Now you should have seen the benefits of using a fully type-safe internationalization library. It prevents you from common mistakes and has a lot of advantages over solutions that use simple JSON files. If you don't take anything away from this talk, then just remember this. Anything that can go wrong, will go wrong. I have had some bad experiences with existing i18n solutions. And one day I had enough and decided to create my own library that prevents our team from common mistakes. I can't promise that your translations will contain the correct wording, But I can promise that you will catch all mistakes from a technical perspective. You don't have to wait until your users stumble across errors on the production system. Let's continue with our SvelteKit project. We still have some things to do in order to deliver a great user experience. Currently if we visit our page we always get greeted by the English message. We should auto-detect the user's preferences and deliver the right language version. Luckily we can do that with SwellKit quite easily by reading the headers of the request. Let's create a hooks.ds file and add the getSession function. Typesafe i18n provides a language detection feature we can use. We just need to add these two lines and return the detected locale. Inside our layout page we now can access the session and pass the locale to the init i18n function. That's it. Let's reload the page and we still see the English version. Let's head to the settings and set German as our preferred language. And if we now refresh the page we will see the German text appear. Of course we also want our users to be able to choose the language manually. I now have added a few styles to the website and I also have prepared a local switcher component. It renders a list of all available locales and adds a click handler that will change the language. We can add Italian as our third language The language switcher will detect this and update the list automatically Before we switch local we shortly open the DevTools network tab When we now switch to English, we see that a new network request appears. If we click on the entry, we will see our English translation file. TypeSafe i18n makes sure that only the local that is currently visible gets loaded. If we don't click on the italian entry, this translation file gets never transferred to the user. We still aren't done yet. We are looking at the english version and if we refresh the page we will see the german version again. We also want to persist the local information between page reloads. To do that we will use a dynamic route called lang. We need to move the index.swelt file to our new folder and create a new empty index.swelt at the root. We want to redirect users to the subpage once they visit the root page. We can do that by adding a few lines to our layout.swit file. If we now refresh the page, we get redirected to the German language lag. But it is not perfect yet. We also want to change the URL if we switch language. Let's head back to the local switcher component and call push state to add a new history entry and to update the URL. Now we can switch language and see that the URL changes too. But what happens if we click on the back button? We will see an inconsistent state. The browser's URL says that we are on the English page, but we clearly see the Italian message. Like the name push state already suggests, we can also push some state by defining our local as an object on the first argument. Then we also need to listen to so-called popstate events that occur whenever a user navigates backhand 4. Svelte makes it easy to listen to that event by using the svelte window element. We then need to write our handle function that calls setLocal whenever we receive a local state. When we now go to the English homepage and hit reload we see another issue. If we click on view page source we see that the server sends us the German version and the client then immediately switches to the English version. To fix that we need to update our layout.swelt file. Let's create a new variable for the language parameter and cast it. is a type that contains all local names from our project We replace it here and instead of passing the preferred user locale we now can use the lang slug from the URL If we now reload the page we see that server rendering works too and we see the text no longer jumps around when we refresh the page. We add two small improvements. First we want our users to be redirected to the English page if they try to use a wrong language slug. When we try to access the French flag we get redirected to the English page. And second we delete the locale from the session because it will no longer match the language you will see on screen and we can read the information from the Svelte store if we need it somewhere in our codebase. Just one last thing. If we again view the page source of our German homepage we see that the html lang attribute does not match. Unfortunately SvelteKit currently does not allow to set this in an elegant way, so we need to be creative. Open the hooks file and add this handle function. We read the language lag from the URL via area destructuring and make a simple string replacement on the response body. With that little hack we now have a fully working internationalized version of a SEO friendly SvelteKit page. You can access this code example on GitHub. It also contains some examples how to handle plural rules and date formatting which are also key parts of a great internationalized web project. Typesafe i18n not only works with TypeScript. You can also use it in your JavaScript projects too using JS doc commands. I have prepared the same example in a JavaScript version. You can find that example linked here. And also check out the GitHub page of Typesafe i18n and leave a star if you liked what you saw here. The tags of your translations will probably come from people who don't know how to use Git. You can also integrate any translation service. Just take a look at the importer and exporter section of the readme to learn how to integrate them. The library also works with other frameworks like React, Angular or you could use it in your Node.js APIs. Other frameworks can be added with a few lines of code. I hope I can also finish the Vue.js integration by the time this talk goes live. This library is the typesavers and probably one of the lightweights solutions out there. It only adds around 1KB to your bundle size. But it doesn't mean we should stop here. If you know something about abstract syntax trees and want to contribute to the project, please reach out to me on GitHub discussions and help me reduce the output size to less than 500 bytes. Thanks for listening. Goodbye, tsch√ºss and arrivederci!