 Hi, I'm Tom and I'm going to talk about convex svelte. So this is a new convex client for Svelte. You can install it today, npm install, convex-svelte. And what is Svelte? Well, oh, you know that. What is convex? Well, it is a way to extend reactivity from your reactive DAG tree, whatever, of Svelte atoms all the way back to the server and even all the way to the database. I'll say that again. This is a way to extend reactivity from the div or the span or whatever back through the other derived things in Svelte. But then often that's server state. What if that server state were also to update reactively? And what if that server state were always in sync with the database? So here I've got a simple Svelte app. I've got a layout that sets up Convex here and then a page. and when I use a query, I'm gonna get a reactive view of some data in this query object. We can check if it's loading. This is all kind of Svelte query style. And then in here, I get to act on this data. What would normally be the end of our reactive graph, our reactive tree, our reactive dag, we get a server function. And we pop over there, take a look at it. Looks like it is a query which just asks the database for everything in the tasks table. Buy groceries, integrate convex, go to the park. If I look at my convex view of that data that happens to be backing this view, I can update something. And we see this check mark appear here. And now let's change that query. Instead, we could say, well, these are the tasks, but I actually wanna augment that data somehow. Maybe I wanna join it with another table here. All I'm gonna do is return tasks. Let's map over them task. Let's add another property here. We'll say everything that's in the tasks straight from the database, but then also let's add that the assigner was Tom. So this is just hitting home that this is arbitrary JavaScript here. And somehow, talk about later, talk later about how, somehow we get a reactive view of this function. So now back in the page, we could be using the task.assigner. And now that's popping up here. Assigned by. Cool. Now this is code that runs on the convex server. It's not running in the client. And that's a hint about how we're gonna do this magical reactivity. Let's look at a little more complicated app. We've still got a single table here that we're displaying a view of, but now we've got some UI, the chat interface, I can send new messages I quite like VS Code now And you can see some state flowing through here I've got some states. We've got the full version of use query where we need a reactive svelte object that gives us the new value of what the words we want to mute are. So I can say, you know, I'm just tired of hearing about Vim. Filter those out. Gosh, actually it's Emacs that I've got enough of. Also, I just don't like the letter Z, not a fan. And our server function's a little more complicated too. Let's take a look at this. List now grabs the messages, does an in-memory filter where we remove the ones that have somewhere in them one of our mute words and then return the messages reversed so that we have a nice chat interface where new messages show up on top. This is the built-in demo app in the convex Svelte repo. So you can check it out, run the initialization commands and give it a shot. People have been using convex with Svelte for a while. So this library isn't necessary. You can see the syntax for normal JavaScript. Svelte can work with JavaScript. And it's not bad. It's just missing that use query hook that lets you say, I want a reactive view of this query on the server. Don't think about subscribing, unsubscribing, anything like that. This Convex client is written for Svelte 5. And that's not just because I was trying to be cool. I actually like Svelte 5 more. And I tried to do this about six months ago for Svelte 4, and I had some trouble. So I want to look at why it was easier this time around. One answer is it was prioritized this time. It wasn't just a side project I was just playing with. We decided it was time. You'll need to support the Svelte community. Another is I asked for more help. Gosh, the Svelte community has been terrific. Just in Discord, let's see, calling out three people that helped a lot. I've got Stalky, who sent a lot of nice, you know, playgrounds while I was trying to learn the primitives, how the runes worked. Stanislav was helpful. I got Ben to give me some thoughts on the library. But another thing is I really think, I truly believe that Svelte 5 is actually easier to learn. Or at least it was for me. That could be because I'm coming from React, and so I'm not used to some of the compile time things, and that's a little more explicit. It could be that there's just the one kind of reactivity. So when I was trying to build it before, I thought, hmm, do I need a store of stores? But then I'd also be looking at where I was using this and seeing the more compile time reactivity. and I had some confusion regarding these two. Thinking about the different kinds of reactivity between Svelte 4 and 5 also makes me think about how convex's reactivity differs from Svelte's. So I want to talk about reactivity and convex. I first will claim that everything that's reactive, all reactivity is about running your code, every request animation frame, at least conceptually, right? If I could just write simple code that made my UI a pure function of state and just did that on every frame, and then I guess cheat a little bit because there's different kinds of state that I need to persist in the DOM. But basically I'm just building my UI every request animation frame. And the different kinds of reactivity are about how we optimize that How do we get around the fact that we don actually want to run this 60 times a second 120 times a second Different than game programming right Where you might say yeah absolutely Just have a one linear path. Go ahead and try to run that code 60 times a second. We would like to run less code sometimes. We'd like, if there's no interaction with the page, we'd like there to not be a lot of CPU getting eaten up. So when we look at the convex code, we don't see signals. These functions run from top to bottom, and they're, at least TypeScript tells us, they're just pure data. And TypeScript's right. This is just exactly what it says. This is just an array of message objects. And filtered messages is the same thing. So we don't have that. There aren't these signals in there to do this more carefully. So you think, well, is this convex just a polling thing? Is it just going to run this code once a second, 10 times a second, whatever, on request animation frame, right? And again, that's a reasonable mental model, but that's not what's happening with convex. Another reactive system I've worked with is observable. And there we compile an expression out so that some of the variables come from other cells. So maybe that kind of compilation is what's happening here. But that's not what's happening here either. Instead, it's all done at runtime. In convex, we run a function, see which rows were read from the database, and then track that. So no compile time at all, just run the code and see what happens. So looking at this code here, when we read this whole messages table, we are saying there is a dependency for this query function on that entire messages table. So this is more dynamic. There's no need to declare dependencies. But what about if statements, right? What if the first time you run a function, it accesses these database rows, but then another time you run it, it accesses some other ones. Well, if it didn't access them, then it's not part of the read set. But because the convex runtime is deterministic, we know the next time we run it, that same if branch is gonna be taken. Determinism takes some work. We've got a mockout math.random. We have to schedule the promises carefully. So this is happening in a custom, in a V8 runtime that's not node. And as compared to something you could compile, say SQL, which lends itself really well to compilation, we can look at it and say, oh, I see that we're reading these things. This is more work, but the expressiveness of JavaScript is really worth it. Writing business logic in SQL is difficult. You get some of the same benefits that we have in Convex of code that runs inside the database, code that has access to the database code that run transactionally, but it's, yeah, trying to write imperative-ish SQL, SQL that accomplishes business logic is tricky. Okay, but what about database rows that didn't exist before? So I run a function, it reads these six rows, and then I add a seventh row. That one wasn't in the set of rows we were tracking. Well, the way that we track rows is actually ranges, ranges of tables, maybe a whole table, maybe hopefully a region of that table, or a range on an index. So this is an interesting, different take on reactivity that produces something similar to signals where the level of the signal is the query. Each of these queries will be re-fired when necessary, and you can have dependencies in your front-end app on each of these queries. You could have many queries. Each one will re only when the result to that function has changed There are some other benefits of this model that are interesting Part of extending reactivity all the way from a div back to the database is that we also get to extend the database consistency all the way up to the divs. So say you have code where this region of UI depends on database query, This region of UI depends on a different database query. If those were requested at different times, then those might not quite match. But hopefully whatever you're using to fetch your server-side data, maybe it fires mostly together. Maybe they're just a few milliseconds off, so it's fine. It's just a visual anomaly. But maybe you have data that depends. So it's one piece of UI that depends on multiple database queries. It can be tricky that each of those database queries might be, each of those results might be from a different logical timestamp. So you need to be careful never to join across them on the client side, never to assume that just because you have a list of messages with user IDs, you'll be able to look at an array of users and find the right user in there. But because we have this reactivity that goes all the way back, We can take the database transaction and say, now we are at a new logical timestamp and provide a consistent client view. Consistent client views simplify writing front-end code because it makes writing a front-end less of a distributed system. We can say, I asked for this data from the server, and I know I'm looking at this data and this data and this data all at this consistent logical timestamp. I think of reactivity as intimately related to caching now, right? In that if I don't have something that's reactive and it's my job to maintain a cache, say like in Svelte query, the cache of the server side state, it can be, you know, it's a tricky imperative problem to say, all right, now's the time to invalidate that cache. Oh, I know that it's, I've changed this thing, right? I have made a mutation and I expect that that will change something. So we need to go refresh it. And this logic applies to edge compute too. If you have a read replica somewhere or you have something dumber, which is like just memcache sitting somewhere and you need to manually invalidate or something in between. The convex approach is nice because we have a completely consistent cache and we can push that cache down to clients. That's sort of what we're doing with these use query hooks. But we can also populate some other kind of cache with that. So it's powerful in general with reactivity to not be thinking about manually invalidating caches. Instead, to have enough information to do incremental computation, enough information to say, yeah, this is the current value because this is the current value of all the other atoms in the chain of reactivity. So writing this client has been really fun. but learning Svelte has been even more fun. I've, as I said, appreciated the Svelte 5 approach. It's meshed more with my brain. So if there's any kind of hesitancy for folks, understandable that the change is frustrating, but from a newcomer, from my perspective, and again, mine sullied by React a bit, it really was easier to learn with runes. So thank you. Love to hear what you think of Convex, what you think of this library. Love hell with this library and look forward to see what you make.