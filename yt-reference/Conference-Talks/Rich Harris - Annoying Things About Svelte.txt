 Thank you. all right Svelte Loader it's me Rich with a talk on annoying things about Svelte this is going to to be a two-part talk the first part is things the Svelte core team has done that annoy you lot and this is inspired by a post on the Svelte subreddit last week called what frustrates you in using Svelte and I thought I would just go down as much of this list as time allows and look at some of these points and respond to them maybe in some cases explain why we made certain decisions maybe in other cases who knows figure out some to-do list items the second part is going to be, just in the interest of balance and fairness, things that you lot do that annoy the Svelte core team. But we'll get to that. All right, so without further ado, what frustrates you in using Svelte? That I become sad at work when I have to use Vue instead of Svelte. I'm sorry, there's not a lot that we can do about that. Not much, honestly. I wish SvelteKit had better error messages when something went wrong. Next had really great debugging compared to SvelteKit. Yeah, this is true. We have decent error messages in some cases, but not all. I would say that this is kind of a natural phenomenon in software development. Like an error occurs when something has gone wrong, and the reality is you just cannot anticipate all the ways that something is going to go wrong. Once people start hitting certain cases, you might find that you can provide a more informative error message than just throwing whatever error occurred. But in order for that to happen, people need to find it. And so a framework like Next which has this ginormous user base and has been going for many years its users have found all of those situations and have raised issues about them And so I think this is one of those things that just kind of naturally gets better over time. So we definitely want better error messages in everything that we do. If you hit a situation where you have a cryptic error and you think that the framework could be doing something better, then raise an issue because the chances are we'll agree with you. All right. The VS Code extension, code completion and formatting often don't do what I expect them to. Sometimes they completely mess up import statements and I haven't figured out why it works sometimes and sometimes not. So I think the VS Code extension is a marvel. Full disclosure, I don't totally understand how it works. It's maintained by smarter people than me. I just use it. and most of the time I find it works great. Occasionally it'll do something that's not 100% perfect, but on the whole it works pretty well. But if you do find that you run into cases where stuff isn't working well, then you can raise an issue. All of this stuff is maintained on the language tools repo to Svelte.js, language tools. This is where to go. Okay, the only things missing from Svelte for me are error boundaries and each over iterables. yeah so error boundaries um what's meant by that is if an error occurs during rendering it should be possible to recover from that and at the moment that's not the case in svelte you need to you basically need to make sure that errors don't occur during rendering this is something that we're definitely thinking about for svelte for i don't want to make any strong guarantees but it's something that i want and it's something that lots of other people want so you know watch this space. Each over iterables. This is something that's come up from time to time. And if you're not familiar with this jargon, then it's probably easier if I just show you with a little demo. So say you had a map. Map equals new map. Then map set A1, map set B2, and so on. It would It would be cool if you could do each map as entry, and then do something inside here but you can That not possible because the each block expects you to have an array object And maps aren They iterables So you have to do this sort of thing instead. You have to convert it to an array first. And in there, I think, it's something like entry there for the key, and then entry one for the value. or you could use destructuring like that and then reference key and value like so. Why don't I make this a little bit bigger so that you can actually see it. So yeah, it would have been really nice if we could get rid of that. There's a reason that it's like this. The reason that we made that decision back in the day was when we were designing all this, iterables weren't really a thing outside the context of transpilers like Babel. In order to iterate over this object, you would need to use a for-of loop, and Babel turns that into some monstrosity with some pretty bad performance characteristics, or at least it definitely did at some point. That's not really the case anymore. Now iterables are well-supported everywhere, and this is something that I think we could do and possibly something that we should do. Next up, the push for edge serverless first. I had a working prototype with Sapper, which is SvelteKit's predecessor, which only ran on Node, and an important express middleware, which is a hard requirement. The switch to SvelteKit happened and screwed me completely over. Well, I'm sorry about that. That's definitely not what we want. It is possible to run SvelteKit as a Node app. we're still figuring out the best way to accommodate things like express middlewares that do frankly some quite naughty things with the request object before passing it to your middleware. We want to be able to expose those things. So if something adds like rec.session or rec.auth or whatever it is then we want to be able to surface that. But we want to do so in a way that is sensible and isn't going to be a design foot gun further down the line. So bear with us. We will have a solution to that. The whole edge serverless first thing, though, that's not just us. The entire industry is moving towards this model. And that because it has some very concrete advantages to the old way of maintaining your own node servers Right now I think there are probably more apps running on node servers but the growth charts when you look at serverless and edge are just extraordinary. And it's important to skate to where the puck's going to be. We want to be able to accommodate users who don't want to have to worry about maintaining their own servers. And serverless and edge have some very desirable characteristics. characteristics and we think that this is the right choice. We think this is the way that people are going to be building apps for the foreseeable future. I know it's in tactic sugar but I'd like a switch block. It feels primitive to chain if else's. Yeah okay let's think about this. So, let's go back to our REPL. Let's say we've got let thing equals whatever. Make it a prop. And you might have if thing is foo. So how would we do this with switch syntax? Well, we'd begin with switch thing, obviously. And for the remainder of this, we're going to have these errors down here because this is invalid syntax, but this is just for an exploration, so we'll ignore it for now. We need to get the cases in here, and maybe these are blocks, like case foo. but that's going to feel quite laborious after a while, because we've got one for each of these. That's quite a lot of markup. So I don't think that's going to work. but maybe we could take a leaf out of the else tag here and turn that into a case foo and then maybe case bar and then maybe case baz and then

 Default? It feels a little bit weird that every other time we have a block that has these continuation blocks like else or then and catch in the context of a wait block, they're all flush left. They're all at the same level. So maybe if we just get rid of that indentation, this part looks a little bit weird. Maybe we put the default up here like that. So everything until the first case is the default, and then we start the case. I kind of don't hate it, honestly. we've also got the situation where there is no no else there's no default fallback in which case we wouldn't have that and then maybe we do the same thing that we do with await blocks when there's no pending state when you only want to have you wait for the promise to resolve and then you show something so we would do like that hmm Yeah, maybe we should do this. I don't know. Sound off in the comments. Tell us what you think. SvelteKit configuration needs to be simplified a lot. Should be a list of options in the CLI setup tool. Do you want a static pre-rendered client or a full client server with endpoints? A simple SPA option would be nice too because some people still need to write them. I get where this is coming from. I do. Particularly if you're just getting started, it's nice to not have to understand what the configuration is doing before building your site. But I think this is one of those things that's seductive but ultimately would be a mistake. And here's why. Very often you don't know what you need to build until you're actually building it. And what I find with CLIs that give me a list of predetermined options is that I don't understand the difference between them. Like I know how to create a completely static site or I know how to create a fully server-side rendered thing. I know how to do the Node version or the Cloudflare version or the Vassell version because these are options that are in my CLI But then what if I change my mind What if I need to change something afterwards Then my job of figuring out how to do that is much harder because I don't understand the differences between these different starting points. And so, for example, you're building something that you think is going to be a fully static site, but then it turns out that you need something dynamic. It might not even be dynamic server rendering. It might just be that you need to add an endpoint to do some proxying or something like that. If you've started with the static site preset and you don't have the configuration options that SvelteKit has and instead you need to go back and recreate it as a partially dynamic site or whatever it is, then you've lost. We think it's better to have some configuration that exposes all of these controls in a way that is consistent and documented and that you can change to meet the evolving needs of your application. I do agree that we could probably make the onboarding a little bit simpler. We could have more examples than just the demo app or the skeleton app. And that's something that we'll probably get to for 1.0. But in general, I think even if the configuration does take some learning, it's a better approach than having presets that are then hard to work with when you discover that your needs have changed. love Svelte but missing all the ecosystem of React for sure yeah we can't fix that overnight unfortunately the Svelte docs don't have a search bar yeah so at the moment the Svelte documentation is one single giant page and if you want to find something then you just have to press command F and search for it that way, the Svelte kit docs on the other hand do have a search bar and it's split into multiple pages. So instead of using command F you use command K and you get much better search. And I think what we'll probably do is we'll backport this search function to the Svelte docs. Because I agree it's much easier that way. Alright what a comment about syntax. Everyone loves to talk about syntax. I forget the syntax every time even I'm not sure right now. In Django template it's much more simple for X and y and then end for like I personally recoil at things like end for and end if it's not quite as bad as bash where you have if and then you you end an if block by writing phi which just boggles my mind every time But it still a bit weird I think having a closing slash kind of makes sense in the context of a language that extends HTML because that's how you close an element. It just kind of flows naturally. But look, everyone has different opinions about syntax and none of them are correct because it's all basically subjective. But what I will say is that syntax in Svelte has... Let me just pull up the issue. So this has been bike-shedded more than just about anything else in the framework. This is a very old issue. Between Svelte 1 and Svelte 2 is when we started having this conversation. And it goes on forever. Like every possible combination and permutation has been considered at some point, and this is what we landed on. And so the chances are, if you have a different idea for syntax, we've already considered it, and there was some reason that we couldn't or decided not to do it. Currently nothing in Svelte itself, only SvelteKit, as the docs are not so good. Yep, guilty. The reason for that is we haven't done any kind of interactive tutorial for SvelteKit yet. is going to be a big undertaking, and it's something that we're definitely going to do before we get to 1.0. You're just going to have to bear with us for that. The lack of a comprehensive UI library, again, there are a bunch of UI libraries out there, but ecosystem stuff just takes time. The single biggest frustration for me as it's felt is not a standalone compiler. I'm forced to use some garbage bundler. so in version 1 of Svelte we actually had a Svelte CLI which did compile Svelte components into JavaScript modules and we got rid of it for a good reason which is that what that compiler essentially had to do was it would inline all of the internal library helpers that your component was using so that your Svelte file could be used as a standalone JavaScript module without dependencies and it doesn't really scale very well. We found that people were doing that almost out of laziness and it was resulting in bad end user outcomes So you should be using a bundler If you building anything you should probably be using a bundler because that is the way to deliver the best outcome to your users But you can use Svelte as a standalone compiler. In fact, on the main Svelte docs, we have a compiler API that you can play with yourself. It's just that normally this stuff is abstracted away because you're using a bundler that has a Svelte plug-in and it just happens automatically behind the scenes, but you can do it yourself if you want. Nothing is stopping you from doing that. All right, this is a big one. It's a Svelte kit thing, but I really dislike how heavily server-side rendering is pushed. Search engines do actually run JS, so CSR isn't a big deal for SEO. We'll come back to that. And the slower first page speeds do negatively impact Google's search rankings. Okay, there's a lot going on here. We do heavily push SSR, and that's for three reasons. SEO is one, but the other two are performance and resilience. So on the SEO front, yes, Google does run JavaScript. Google is not the only search engine bot out there, but it is the big one. And it does run JavaScript, which means that if you have content that is injected after the page has been loaded, then it can get indexed. But, and while I don't have any inside knowledge of how search engines work here, what I've gathered over the years is that this process is less reliable and it will happen less frequently, which makes sense because it uses a lot more resources to open a page in a headless browser and execute JavaScript than it does to just scan the HTML and index it. So the advice that we've been given over the years is that you should do server-side rendering because your content will be indexed more reliably, more efficiently. And in fact, there's a page I have up here which I will drag in so I can highlight some stuff for you. This is from a page by Google on understanding JavaScript SEO basics. And there's a couple of interesting snippets here. Once Googlebot's resources allow, a headless Chromium renders the page and executes the JavaScript. Okay, so once again, it's about resources and whether or not we have the bandwidth. to do so. Keep in mind that server-side or pre-rendering is still a great idea because it makes your website faster for users and crawlers, and not all bots can run JavaScript. So putting aside the not all bots can run JavaScript thing,

 What he's saying is that SSR is good for performance, not bad, as the commenter suggests. And this is something that people pretty much universally find. SSR is good for performance, and that's for a couple of reasons. First of all, it's good for perceived performance, because seeing a blank page and then seeing content flash in makes you think that things are slower than seeing some content immediately when the page loads. But it's better for actual performance, too. If you think about here's a browser and here's a server, if you're getting a blank page with some hml and css and javascript taking that back to the browser running the javascript and then fetching some data from the server then you've got to do these two sets of round trips but if instead you go to the server and the server gets data from itself or from somewhere else in the same data center that's basically instantaneous and so you can send that back to the client fully formed and so you can get content in one round trip instead of two That's a simplification, of course, but the general principle is that server-side rendering will make your site faster. And that is one of the reasons that we push SSR so hard in SvelteKit. Finally, resilience is really important too. JavaScript fails all the time for reasons that are completely outside your control as an application developer. People with spotty connections or people on weird Wi-Fi networks with bad configuration. people on browsers that don't support the JavaScript you're running people looking at your content on something like the Internet Archive years after it was initially created all of these are perfectly valid use cases and in all of those cases those sites will only work if you have server-side rendering so for the combination of those three factors we think that SSR is the correct default and that you should only opt into SPA mode when you have a really, really good reason to alright I've gone way over my time budget so I'm going to stop there even though we didn't get through everything thank you to everyone who contributed to this thread it's really useful just in general feedback like this is super helpful for maintainers so please keep it coming I'm going to go get some lunch and then I'll see you for part 2 let's enjoy an intermission you'll find our snack bar chock full of good things to eat and drink tasty tempting hot dogs thirst soft drinks fresh crunchy popcorn a complete assortment of delicious candy and a full line of cigarettes All right, part two, time to turn the tables. So there's really only one thing that I want to talk about, and it's a bugbear that I share with basically all open-source maintainers, and it's around reproductions. sometimes people open issues on open source projects and they're asked to provide a reproduction and they either don't or they create a bad reproduction. So what I want to talk about in this section is why repros are important and how to create a good one. Now when you open an issue on SvelteKit you're presented with this issue template and one of the sections here is the reproduction section and I'm going to read it out of the baton. A link to a repository or a fork of Node.news slash SvelteKit that reproduces the issue. Reproductions must be short, self-contained and correct and must not contain files or codes that aren't relevant to the issue. Please do not just paste a link to your project. Explaining how to reproduce is generally not enough. It pushes the burden of creating a reproduction project onto a small set of volunteer maintainers and isn't scalable. If no reproduction is provided, the issue will be closed. Now, frankly, we're not all that militant about closing issues without reproductions, but we probably should be because it would increase our development velocity. The worst offenders are people who open issues and choose not to provide a repro, often saying something like, this is simple enough that I don't think I need to provide one. This is kind of like going to someone's house and being asked to take off your shoes and deciding to keep your shoes on. You know, you might be thinking, my shoes are cleaner than your carpet, but it doesn't matter. You've been asked to take your shoes off, and you'd be a sociopath not to. And that's kind of what it's like when you disregard the instructions in the issue template. It's a little bit rude. The thing is, it's in your interest to create good reproductions. And that's for a couple of reasons. Firstly, any moderately popular open source project will get a lot of issues. a few days ago SvelteKit had somewhere around 400 I've been aggressively triaging over the last few days and it closer to 300 now but it still a lot of issues and each one requires a lot of time and effort to deal with and we grateful for these issues we glad that you chosen to open an issue but at a minimum it going to take a few minutes to look at the issue understand what's going on, develop the context, and either close it, which means writing a message explaining why it can be closed, or writing a pull request with tests and everything else that goes with it in order to close it the hard way. Either way, it's going to take time. Let's say it takes 10 minutes on average to close an issue. If you have 400 issues, that's 66 hours of non-stop work. There's only 40 hours in a work week, so that's a week and a half of doing literally nothing else. But the reality is that 10 minutes is way too optimistic. The average issue, I would guess, takes somewhere between 45 minutes to an hour to close. If it's an hour and you have 400 of them, then that's multiple weeks of doing nothing but closing issues. And in that time, more issues are going to come along. It's very true that issues with reproductions get closed faster than issues without reproductions because they're easier to fix. And so if every issue has a good reproduction, the time that it'll take us to close them all and release felt kit 1.0 is going to be reduced. So between us, if we can all create good reproductions, that's going to help everyone but it's also beneficial for you as an individual because as maintainers we prioritize issues with good reproductions it's partly a question of gratitude if you've put the effort in to make the issue really easy for us to fix then we want to repay you we want to thank you by prioritizing your issue but it's also just because I know that an issue with a good reproduction probably isn't going to be a giant rabbit hole and I want to use my time profitably. So I'm more likely to pick an issue from the tracker that has a good repro. So for all of those reasons, please do provide a reproduction. And then there's the issues that do have a reproduction, but the reproduction is overly complex, or it includes things that aren't relevant to the repro, or it doesn't have instructions. And that's almost as bad. So in the next few minutes, what I'm going to do is talk you through what a really good reproduction would look like. So let's say you found an issue relating to how URL parameters are encoded in a SvelteKit app, specifically that they're different between server and browser. And you want to create a reproduction that shows this. The first thing we're going to do is create a project with a distinctive name. I not just going to call it SvelteKit bug because then when I clone your repro locally and put it with all my other repros maybe there going to be a naming conflict or it just going to be harder to juggle with all of the other things that I'm working on at the moment. So good project names is a really good first step. I'm going to call this SvelteKit URL params encoding issue or something like that. CD into that directory, and then I'm going to create a new repo using npm init svelte. I'm not just going to take my existing project and add a branch to it that shows the problem. I'm going to start from a fresh project because that's the best way to not include all of the extraneous stuff that isn't going to help the reproduction. I'm going to create it in here. Create a skeleton project. I'm just going to pick all of the defaults here. I'm going to install dependencies with npm. I know some of you like to use Yarn. I like to use pmpm. But a good baseline is to use the same package manager as the ecosystem at large. And in JavaScript, that means using npm. By doing so, it means that you're going to check in a lock file which will enable any maintainer to recreate the state of the reproduction at the time with the versions that you were using when you encountered the bug. If you use Yarn and you check in a yarn.lock file, then you're forcing maintainers to also use Yarn. And a lot of maintainers don't use Yarn. We use npm. I personally use pnpm, so I'm happy with a pnpm lock file. But a package-lock.json is the gold standard here. Let's open this project. I'm going to start my dev server. Open that up. And then I'm going to create a route that demonstrates the issue. Call it test slash params dot svelte. And we'll give it an accompanying endpoint, params dot js. And we'll write some code that shows that the params from the server match the params from the browser when we have a simple parameter like foo. If we then add some links that show the bug, then we can immediately see the problem. And then the last step is to do the same thing.

 to put this repository on GitHub and link to it from your issue along with some instructions on how to see the bug. And that's all it is. That's all that's involved in creating a simple reproduction. Now, I cheated a little bit. This reproduction is one that I stole from an issue that is currently open on the Svelte Kit repo. It was submitted by Blueby, and it is an absolutely perfect example of how to do a repro. So Blueby, you're awesome. everyone else be more like Blueby okay here endeth the rant thank you for everyone who does submit issues with reproductions it truly is appreciated and thank you everyone for watching this talk I'll see you around