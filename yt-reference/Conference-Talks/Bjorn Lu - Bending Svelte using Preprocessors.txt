 Thank you. Psst, hey, what if I tell you there's more behind Svelte? What if you can change it, change the way it works? What if you can do something crazy, like writing Svelte templates like Vue? Or can do something more practical like importing images directly, or maybe something experimental like using variables in style tags, or what if we just want to optimize for better performance. Welcome to Seveld Summit, my talk for today is Bending Seveld. So when it comes to mastering this skill, you'll mostly be dealing with Seveld preprocessors. could be easy at first, sometimes it will get complex. Sometimes you wonder if it's the right way to do things because sometimes there's many ways to do a serviled preprocessor and there's no right or wrong. But for this talk, I have some goals that I'd like to share. So over here I have three goals. One is to create a preprocessor from scratch. The second is to understand ASTs or abstract syntax or more specifically in this talk we think into the surveilled AST and lastly for number three we will look into source map support so that we can improve the developer experience when they want to debug their surveilled code so with that said let's get started what better way to learn than building our project the project we'll be building today is a special source code component so over here we have a list of roots and around here we have a big button a few source button and if you click on it you will see a list of the roots but in the source code so from here i'd like you to think how would you build something like this and in the end we could compare and see our implementation because there's always many ways to build the same thing so welcome to the project over here is some files that I restarted off when building preprocessors. So there's not much at the moment but if we look at the source folder there's this index.js file which exports a preprocessor function. Currently it does nothing it's an empty preprocessor. It also imports the magic string package but we'll go over that later on. And besides this file is the source code.servelp component So right here there is a simple source prop and also the check state. So whenever the check is true, we will show the source. And of course, we have a slot to render what's inside in this component. So let's go to the test folder here. So the main test folder is very simple. It accepts an input.servial file right here. and then it runs pre-process on that input file with our custom pre-process function that we import from the source and finally it outputs in the output.servalp component. So currently we have the input file which is empty and we don't have the output.servalp component yet but when we run the test it will create so that we can compare the outputs and work from there on and also over here we have the playground folder which is a simple vid app so we could test our preprocessor in and lastly we have the package.json we could take a look which has the type module specifier so we could use imports directly there's some exports and also most importantly dependencies which is the magic string dependency and the serve up dependency So before we write any code, we want to plan out what we want to do and the steps to achieve that. And my favorite website to test this is with asdexplorer.net. So as you can see, the left side is the normal code and on the right side is the syntax tree. So we can go to the Surveld syntax tree under here on JavaScript, we go to HTML and over here we choose Surveld and there we have it is the Surveld AST. So what's pretty handy about this is whenever you click on something, it will focus on this specific node in tree or if you hover something around here, it will highlight on the left side. This makes the development a lot quicker when we prototype a preprocessor. So to start planning out, we can first remove this piece of code. And let's start with a component, the source code component. So here I have a code that I have pre-written. Ideally we would want to import the component called source code and then we use the component something like this for now it doesn have to actually work just that it has to be a valid syntax and then what if we add some logic so here is a list of fruits and then we want to render it inside the source code component so here is the list of fruits that we render inside the source code component. But the idea here is that we want to move this piece of code to somewhere that this source code component can detect. So going back to the source code component that we have, we have this new source prop. So ideally you want to move this piece of code into a prop. So we could do this manually when write our code but ideally we want to have this automatically injected into here and we'll do that via a pre-processor so what we want to do is move this in and have a final output to something like this so if i copy this and then i paste it here it should look something like this although not really formatted well and as you can see there's a few things we have to do like escaping these braces so let's undo this at the moment it's a bit hard to read and maybe replace this with a placeholder so what we want to do is to find out on the AST cell things we want to know how we can use this information here to manipulate this output on the left side. So if we click on source code here, we should see that it highlights this inline component node. And over here, it highlights the entire thing. So our goal is to find out how do we extract this specific part, which is a child of the source code component. So over here we have a very well named frog children And when we over over the three elements here We can see on the left side it is also highlighted So this is ideally the note that we want to capture So we can click on this one and see the start and type the text inside it This one has more children inside and we don't have to dig too deep into it but what's important here is the start and end property so for this specific child we have the start 160 so it should be somewhere here and then if you look at the last child close this one here the last child you can see that it ends on 239 which is somewhere here even though it's not highlighted. So with this to start and end we could easily get out this specific part of the text that we want to extract. And then once we know the start and end we could slice it using javascript and then we paste it back into here with the preprocessor. So for this source part, let's remove this and let's now plan how do we want to add that prop. So if this will be the code that the end user writes, we want to add a new prop here. And what I'll usually do is to find out the index in this specific part where I click so that we can add a new prop there. and going back to the AST on the right side here you should find out the source code and then the attributes which is the source attribute that we would want so at this point there's often a common question as whether we should mutate these attributes directly and then we print out this AST so one of the issues with that is that sometimes you're doing too much when there isn't the need to. For example, when you print out, sometimes there's an extras in column or sometimes this single quote becomes a double quote. And another problem is that the only surveil ASC printer we have right now is the Pretia plugin surveil. And that makes things a lot complicated and a bit more overhead in general. So that's why going back here, I'll usually do simple string insert and just call it that as it's the faster way. But the problem here is that we don't actually know where the index here is. As if we look at this node, we can see that there's the start over somewhere here and there's the end over somewhere here. but we don't have the index of this place where we insert the prop. And the way we do it is a little bit hacky, but in general, in preprocessor, we'll be doing a lot of this sort of hackiness. Yeah, so if we check the name of the source code, we can see that it is 10 letters long and then if we have the start over here and we count 1 10 11 So somewhere here after this dot plus 11 index we reach this point and from this alone we could inject the props and and yeah we done so this is the ast planning done now we're back in our project so we can go to source index file and we can start writing our preprocessor. So as you've noticed earlier we have this magic string dependency. You could take a look at the repo for that which is on github here which is coincidentally by Rich Harris as well. It is well magical. It helps you do a very fast string manipulation and also most importantly having source maps. So you can just do generate map and then you now have the source map. So there's many more to it, there's a lot of great documentation, I'll recommend you to take a look. But I'll now jump into the code part where I'll explain as we go. So when we manipulate the servile AST, usually we don't need to interact the script or the style phase, we only need to do with the markup phase. And let's do this in with the parameters, let's get the content and the file name that will use later. And now let's start by initializing magic string. So I'll initialize because s equal to new magic string. And we pass in the content here. And usually I use s because it's more easy to read as we will be using it in many places and let's do a quick return of the code which is as the magic string dot do string and get the actual string and also the map which is pretty handy you can get all right sorry a map and do s dot generate map and then passing some options we do high res this will export a more high resolution source map and also not to forget the file name so it will link back to the original server file that we modified and yeah marriage string is basically done and you can get into the parsing phase so for the For the parsing phase, we will usually use the serval compiler, which can import from the serval slash compiler and then there's the handy parse function. So the parse function here would essentially parse up the string and then it will output the AST. So we can do a constant AST is equal to parse the content. now we have the ast and what this ast is is actually the same as the one we see over here it has the html css instance and module properties so it's say ast dot something you'll get it from here and after we do the parsing we also need to walk the ast so walking is sort of a fancy way of saying traversing the tree, like going through node by node to find out the info of each of them. And so the compiler also exports a very handy function walk. And now we could do a walk on the ST like so. And it also accepts an object here. And with the enter function which also accepts the node. so whenever it walks the node or in a tree we would call this function and then we could start doing whatever we want and at this point we could also do a small optimization we could st.html part because we don't need to walk the javascript part or the CSS part we only need the markup so this would squeeze up a little bit of performance when we do the manipulation here So if you go back to the ASC, our first step is to extract this part out using the first child and the last child of the inline component which is named source code and we can do that by doing a simple check on the node. So if node.type is equal to an inline component and also if the name is source code. And now we know that we're dealing with the component that we see in the AST here. And we could then access the children and get the information that we want. So over here we could get the content start. So this is the node.children and get the 0, the first one, and get the start. And then we also get the content end, which is the node.children. We get the last index. So to start and end, we can now slice the string out. So when we slice we usually use the magicStringS variable instead of the content And that has a lot of reasons Because firstly, when we start manipulating strings multiple times, for example, if we have multiple Stroscope component, we would be doing, we would add new strings or be removing strings many times and this would affect the offset. So magic string will now help us to calculate everything in memory so that when we mean this index, it will actually slice that specific index in the original file. This saves us some extra time calculating offsets here and there, which is quite handy. So let's move this content start here and also the end, the content end here. And we're done. We have the string over here. so we name it con to not conflict with the content variable here and we have the string now the second step will be to inject it into the prop so we go back to the sd explorer you want to inject it over here so our goal is to find the start of the source code component and then we navigate through 11 indexes to start injecting our prop. So go back here, get the node.start and then we pass 11. Well, we don't want something magical, we could do something like this. dot length so that we know what we're doing and let's give this a variable inject start and now we could inject it using metric again as dot well it's not an inject problem but if you look over here there is one handy function called append left so what this does is that we take a look at the IntelliSense it injects something at an index with a content on the left side. So a brief explanation of left and also the other variant which is called append right. append left it means that if we injecting multiple strings at the same index we want it to be append on the left side of the string but not on the right side. So it always takes the higher precedence if we have we so happen to have a prop that is also named source but in this case it wouldn't matter if you use it right either ways but it's a personal preference that i have so we put this inject start here we now have something to inject into and the content would be the the source prop. So of course we need a space in the front so that we don't stick to the component name and that's equals braces and then we use templates as well so we escape name plus backslashers. And also lastly we put an extra space in case there's some attributes that we don't know of and here is where we put our cont content in and we're basically nearly there right now so if you know this uh if you think about it what if we have backticks in our string so we also need to escape that as well so if you do a quick replace so that capture any backticks and replace it with this double backslash and backtick. It should essentially insert these backslashes so that the string is valid and we don't have some things suddenly escaping. And yep we're basically done. We can now verify if we go to the test folder in NexoJS which will run our preprocessor and we can open our terminal here we can now run our node test slash index dot js and that there's no error and there's now this new output component and let's check yeah we have the things copy over and we're basically done so this would be the source code and we can now actually verify in real server app so we can head over the playground folder here which is a vApp open an integrated terminal at the playground directory and if we run that so we can now visit this website if we copy this over go to a browser and then we check this we have the list and the moment of truth yeah if you source it will show the source over here down there yay so we are now done with the preprocessor it now works as we verified now we shed more light on how to to create Reprocessors with SourceMap support and the Server NST in general. If you'd like to see the file repo, I have the link over here which is in the Seveld View Source repo. If you have any questions, feel free to leave in the comments or in the repo github discussion, I'll check on that as well. So yeah, it's time to turn those what-ifs into reality. And thank you for having me and happy Seveld Summit.