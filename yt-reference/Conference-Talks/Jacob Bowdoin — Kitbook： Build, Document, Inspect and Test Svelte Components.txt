 Music Hey Svelte community, I'm Jacob. And I'm living in Taiwan studying Mandarin. and here I am with my Chinese teacher. I work on various language-related web apps, and to make my work easier, I build a tool called Kitbook that makes it simple to build, document, and test user interfaces in SvelteKit, and I'd like to share it with you. Let me start with a view I have that demonstrates why a visual mocking tool is needed. Living Dictionaries is a platform for small language communities to build their own dictionary for the first time. The dictionary entry page has many different possible states as both editors and viewers come to the same place. We need a way to be able to easily mock state and test interactions on views that have a large variety of possible states. We have four levels of user access, visitor, contributor, editor, and admin. The main word or phrase could be written in multiple writing systems. There are often multiple glossing languages, sometimes with their own special keyboards. There's a number of possible additional fields beyond entries and glosses I won't dig into. And as well, an entry could have multiple senses. We support 14 different user interface languages, two of which are right to left. Users can add multiple different types of media, or even a geopoint. And then you have differences between desktop, mobile, client-rendered, server-rendered. You get the point. You also have components and views that you want to be able to build, edit, and test in an easy fashion without having to change user accounts, change languages, make database edits, or find just the right page. You need a tool to build components in isolation where it's easy to mock state. This includes pages and layout components, as they're just Svelte components with a special data prop, as you well know. Kitbook's goal is to make it as easy as possible to build Svelte components in the context of a Svelte kit project. So far, you've seen a bit more complex examples of a view. Let's scale things back and look at the basic functionality of Kitbook. At the core is the variant, a named object exported from a sibling variants.ts file with the needed props for mounting a component in its own iframe. You can go further and define specific viewports, set context, platform, and language settings, for example. But the basic variant is just an export with the needed props Variants cover most use cases Sometimes though you need some slot snippet content or you'd like to create a composition of components working in tandem like this document picture component you'll see used by Kitbooks viewer later. This leads me to Kitbooks second core feature the composition which is a Svelte file using the .composition extension and an optional config property exported from the context module block. Now, the last of the basic features is that you can add a sibling markdown file to document while you build components, or you can just have documentation on its own, either way. Variants and compositions will follow the documentation when the files have the same names, except for when you specifically include compositions in the middle of the markdown using the foam extension for VS Code. As a side note, for those who happen to be building a library with SvelteKit, like Kitbook itself, or my SveltePieces library, the Foam extension makes it effortless to WikiLink between pages and ensure these WikiLinks never get broken. These links auto-populate, work in VS Code, GitHub, and of course in Kitbook. You can also alias them. Now, since I work on multilingual tools, i18n support as a first class citizen. Just add your languages to the global Kitbook config along with a function that tells Kitbook how to adjust the URL such that each language can be placed into the URL. As you view variants and compositions, they are server-side rendered and then client-rendered. The change happens pretty fast, so you can set it to stay in the server rendered state if needed for inspection via toggle. Or perhaps you're doing something like rendering HTML from a Svelte component for an Open Graph Image Generator, or you're wanting to compose an email using Svelte and getting the HTML from that. In these cases, you always want it SSR only because the component.render function only works on the server. You can do that by setting CSR to false and things will still live reload. Not HMR, but live reload. Or the opposite situation. You may have components that work in the browser only, and so you can set SSR to false to avoid getting a server error Kitbook supports virtually free visual regression testing via GitHub Actions running Playwright automatically on all your variants. Composition supports still to come. And then storing those snapshotted images in a Google Cloud Storage Bucket solution. It's nice in a small project, but in a large project with a large number of languages, it's a little bit slow for Playwright to take all the screenshots, even with test charting. So in the future, I'd like to use ViteTest-enabled HTML comparison and not pixel comparison to check for differences between the main and your most recent push to a PR branch. And then, only visually render components via the kitbook when I'm reviewing as a human. That'll be much faster, and I'll switch to that method. But of course, the current screenshot method would still work in the future if that's what you really want, but I don't think it's quite as compelling. My visual checking needs are mostly not browser change related, but rather they're for team communication and bug checking to make sure changes that we ourselves made didn't change HTML that we don't want changed, just made the changes we do want changed, as well to quickly review what teammates are doing. Currently, the action will add a PR comment with changed images, but in the future, this will be adjusted just to be a few stats about what changes happened, and then a link to the page in the kitbook that will display all the changed instances between the main branch and your current feature branch in one page, that way you can easily review them. I don't use it much, but you should also know that this pipeline enables custom playwright component testing via the meta.tests property of a variant. And I'm sure people are interested in the future VTest and Svelte testing library could operate the same way to get some interaction testing automatically accomplished on the variants, too. So those are Kitbook's basic features. My favorite is how simple and powerful the variants are. The sky's the limit with what you can do with them. For example, in my language learning app, I can emulate delayed data from the database. This is especially useful for developing edge cases or situations that change really fast. Or even if you want to mock out an AI chat interface. That's super easy with variants. Now I have to tell you about my other favorite part of Kitbook It that it tightly integrated into and designed for SvelteKit apps After adding the Kitbook Vee plugin and starting your dev server you notice a new route slash Kitbook was added to your routes folder We can open that in the browser to go straight to your app Kitbook From here, we can search for a component, add a variant, add some documentation, or add a composition. There are a lot of features to make it easy to jump from Kitbook to your editor, and also from your editor or your app into Kitbook. It's part of your main app, kind of like Nuxtub tools, so that it's easy to move from working directly in the app to working in the kitbook. You'll also notice I forked the amazing Svelte inspector into a kitbook viewer. Left click works the same with complete node modules avoidance, but right click will open a document picture window with the current component state. I can change state in the page context and watch it update, or I can take that and make a new variant from that state. Functions passed in as props are turned into simple console logs, as most likely they have dependencies that would not get copied into your variant.ts file. But the original function code is still there in a comment to help you create a mock function quickly. I can toggle between these variants in the viewer, but I actually want to dig in a little deeper, So let's jump into this component's KitBook page in another tab. Add some documentation and yet another variant. I can double check how it looks in different contexts and call it good. The addition of KitBook to your main app means there's no need to duplicate setup of i18n, CSS, or mock various SvelteKit imports. It all works because it's just another route in your app. In doing this, it's important to still retain the ability to make sure to keep components back-end agnostic. All data and possible database operations should be passed in via page layout load functions. If you follow this principle, then I have notes in the docs about how to structure your app to ensure components are decoupled from the backend. So yeah, read the docs all the way through if you want to use Kitbook. You need to know about the various useful features, but I also want you to read the roadmap so you can be aware of the rough edges. Though the core functionality is stable, it's not the prettiest yet, as well as a lot of the convenience features like quickly creating files may have bugs. As you use it, consider cloning the repo next to your project folder and installing a kitbook like this so you can make improvements and contribute them back to the project. I'd love your help, and the roadmap can give you ideas of PRs that would be very welcome. Follow the repo releases to hear about new features, fixes, and general tips. That's all for now. Give it a try and let me know what you think.