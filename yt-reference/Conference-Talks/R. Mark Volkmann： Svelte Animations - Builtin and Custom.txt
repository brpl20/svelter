 Hi, I'm Mark Volkman, author of the Manning book Svelte and Sapper in Action, and today I want to teach you everything you need to know about implementing animations in Svelte. You can find all of my slides at the URL that you see on the screen, along with all of my other contact information. The topics we're going to cover today include why to use animations, how to use them, what kinds are supported, details on easing functions that control the rate of change throughout an animation, then the main packages provided by Svelte to implement animations, Svelte animation, Svelte motion, Svelte transition. We'll get into all the details of those. Then we'll talk about how to implement custom transitions, and finally events that are dispatched when animations go through different parts of their life cycle. So the reason you'd want to add animations to a Svelte application? Well, one is to make your apps more enticing to users. Another is to make certain things that a user is doing more intuitive. By showing things moving around on the screen, you might, for example, show that an option has moved from one category to another category. The way that you implement animations, well, everything's built in in Svelte. With other web frameworks, you might have to pull in other libraries, but in Svelte, there's a transition directive and a couple of others. And you just add that to HTML elements and specify the kind of transition you want, and it just works. And in Svelte, these animations are CSS-based instead of JavaScript-based, and that means that they don't block the main thread, and that's a lot better for performance. There are two main kinds of animations that you might use. One is an animation that takes place when an element is added to the DOM or removed from the DOM, And so you can specify some effect that's going to happen over some number of milliseconds. And an example of this would be an element that fades into the screen when it is added to the DOM. And when it's removed from the DOM, it could slide off of the browser window. And that's much more visually appealing than just quickly seeing a component appear or seeing it abruptly be removed from the screen. The second kind of animation to consider is just a value changing. So, for example, maybe the value of a bar and a bar chart changes. And so rather than have the bar jump from a height of say 10 up to a height of maybe 90 you could instead say that you want that change to occur over some number of milliseconds and then the bar just grows or shrinks gradually instead of jumping abruptly. So the first thing you need to know about animations is that these don't necessarily take place in a linear fashion. Instead, you can specify an easing function, and all of the transitions have a default easing function that you can either keep or override if you'd like to. And so a good place to learn about these easing functions is to use this tool called the Ease Visualizer. And so I'm going to click this link and show you what that is like right now. So here we see the online Ease Visualizer where I can experiment with different kinds of easings. Right now I have the sign easing function selected. And then I can control whether this is an ease in, an ease out, or an ease in and an out. And that's just controlling whether the curve is affecting only the beginning of the animation or only the end or both ends of it. And then I can specify a duration so I can bump this up if I'd like. And then I click play and I can watch that orange circle move along the path to get an idea of how the speed of the animation is going to change as it moves throughout its duration. And I can pick from all of these different options. Many of them are just slight variations where it's still a basic kind of a curve. The more extreme easings are the ones that you see down at the bottom, back, elastic, and bounce. And these all kind of have a forward and backward motion to them. So for example if I pick bounce that's a pretty extreme curve. When you use that you'll see items move corresponding to the curve that you see here. So here's a review of all of those easing functions that we saw in the drop down menu inside the ease visualizer. So the most basic is to do a linear easing which is a smooth animation at a constant rate. Then there are the ones that are some type of a curve all listed in the middle there where expo is the most extreme of them. And then there are the three that I mentioned that have forward and backward movement to them. So back changes directions once. It's the least bouncy. Elastic changes directions five times and bounce seven times So the actual names of these easing functions end in the word in out or the words in out So for example if you want a bounce easing function you have to pick bounce in bounce out or bounce in out So the in affects the beginning of a transition, out affects the end of a transition, and in, out affects both ends of a transition. The Svelte Animate package currently provides only one function. It's called flip, and that's an acronym for first last invert play. So it's not flipping anything. Instead, what it's doing is it's determining what the new position of an element is going to be and then changing its X and Y values from an old position to a new position. So you could use this to animate changes to positions of items in a list. And we'll see an example of that right here. So I'm gonna go to this REPL and what you're going to see is that I have an add button and every time I click it, it adds a new button that has a number. And when I add new ones, they'll be added before the existing ones. And I'm doing that because I want to force the buttons I've already added to have to move to make space for the new one because that's when I'm going to see an animation. But I also have a horizontal checkbox that you can click to change whether those numbered buttons are either to the right of the add button or below it. And when you change that, you're going to see all of the buttons animate to move between being vertical and horizontal. So here is that REPL. I have no numbered buttons right now, and so I'll click Add. And notice if I click it quickly, you'll see the one button move to make room for the two and so on. And then if I click a button like the three here, it's going to delete that, and then the two and the one will move up to close the space. So let me add a few more, and then I'm going to switch to horizontal and watch as they transition to their new location to the right of the Add button, and then click it again and they move back to vertical. And interestingly, if I click the horizontal checkbox while it's in the middle of a transition, it will reverse itself. All right, so that's incredibly easy to add. I don't have enough time to walk through all of the code, but you can open up this REPL yourself and you can see here that there's not a lot of code required to implement that. So here are the options that you can specify with the flip animation. First of all, you need to use the animate directive to specify it. And if you look at the very last line on this slide you see animate colon flip And then I pass it an object that contains the options I want to specify And there are defaults for all of these and so you don need to specify options but the delay option says how long should I wait before the animation begins, and then duration, how long should it take to move from the beginning to the end of the animation. And interestingly, this can either be a number of milliseconds or a function that is past the distance that the move needs to take place over. And then that function is supposed to return the duration. And so that means that the duration can depend on the distance. And in fact, the default duration does exactly that. It takes the distance it's going to move, computes its square root, and multiplies by 120. The easing function defaults to the cubic out curve, but you can change that to any of the easing functions that are specified in the svelte slash easing package. And you can also implement custom easing functions. The Svelte motion package provides the spring and tween functions, and these are writable stores. So maybe if you've dug into Svelte a bit already, you're familiar with the concept of stores. So these hold a value that can be updated by calling the set or the update methods. So the set method is just past the new value, and then anything that is subscribed to that store will be notified about the change. The update method, instead of being given a value, is given a function, and that function will be past the current value. Its job is then to return a new value based on that current value. So typically, you use spring and tween to interpolate between two numbers, but you also can interpolate between objects that hold data in the same shape where the primitive parts of those objects are numbers. And so in that case, you are interpolating between a whole set of numbers. So here's an interesting example of applying the spring and tweened animations. I'm going to use this to render a pie chart. And when I change the value, what I want to happen is for the pie wedge not to just jump to the new value, but to gradually move from the current value to the new one. And so here is the REPL for my pie chart. And so I'm going to come up here to my number input for the percent, and I'm going to type in 80. So I have this set up so that all the way around the circle is 100, 100%. So if I type in 80, you see that it didn't just go down.

 jumped to 80 percent. It gradually filled it in. And now since I'm still in the number input, I could use the arrow keys and change this. In fact, I can hold down the key and let that move continuously. OK. And then I can come over to my code and I see that right now I'm using tweened, but I'm going to comment out that line and instead use the spring animation. And so that change takes effect immediately in my REPL. And now if I go to 80%, you see there's kind of a spring action going on. Okay, let me do that again. I'll change to 90, change it back to 10. So interesting spring effect. If you want details on how this was implemented, it is an SVG-based pie chart. And notice that zero starts at the three o'clock position if this were a clock face, just the way that you remember from geometry class. One difference between spring and tweened is that spring supports some additional parameters like stiffness, damping, and precision, and it does not use the duration parameter. The interpolate function is an option that you can specify for either the spring or the tweened functions, and it supports interpolating between values that are not just numbers or dates or arrays of them. So you can have a custom way of computing an interpolation between a starting and an ending value. All you need to do is return a number between zero and one that represents moving between those starting and ending values. So in this example, what I want to do is interpolate between hex colors that are in the form rrggbb, standard red, green, blue syntax. So here we see a REPL for exercising this. And if you look through the code, you'll see how it pulls apart an RGB representation into its component pieces of the color and then computes moving between them. And so if I click next, right now I'm on red and I want to transition from there to green. And it's moving between colors that are in between red and green. And if I click again, it's going to transition between colors that are between green and blue and now between blue and red. So that's an interesting example where I'm not interpolating between numbers but instead some other kind of data type and I writing the code to tell it how to do that The Svelte transition package provides the most animation options in Svelte Here we get the blur draw fade fly scale slide and crossfade functions and so we'll walk through what each of these do. They can all be specified using either the in, out, or transition directives. In is for when an element is added to the DOM, out for when it's removed, and transition is for both cases. Just like with the animate directive, in, out, and transition can be applied to an HTML element and you can't apply them to a custom component. So let's walk through what each of these do at a high level and then we'll see an example of them. Fade is for changing the opacity of an element between zero and its current opacity, which is typically one. It goes from zero to the current opacity when an element is added to the DOM and from the current opacity to zero when it's removed from the DOM. And you can specify the delay and duration options with this. The blur transition animates some amount of blur in pixels. It accepts the delay and duration options just like fade, but also accepts easing opacity and amount options. So easing is an easing function. Opacity is the starting opacity value, which defaults to zero, but you can change that. And then amount is the size of the blur and pixels and that defaults to five. The slide transition is like a window shade. It animates hiding and showing an element by gradually changing its height. When you're hiding an element, after the height reaches zero, it's removed from the DOM. At that point, elements that are below it in the DOM flow move up to occupy whatever space was left unoccupied. And this accepts the delay, duration, and easing options. The scale transition animates the size and the opacity of an element, and it accepts many of the options we've already seen. A new one here is start, which specifies the smallest scale to use before an element is removed. Usually you want this to be zero, but you could, for example, say that when the scale gets down to 20% you'd like to remove it. The fly transition animates the x and y location of an element. It accepts many of the same options we've seen already. New ones here are the x and y coordinates that can be set to negative values if what you want to do is slide the element off the left or top side of the page By default it also animates the opacity to zero to hide it but you can change that by specifying the opacity option So if you'd like to move an element without changing its opacity during that movement, you just set opacity to one. So that's a quick description of most of the transition options. And now we'll take a look at a REPL that demonstrates these, and it will demonstrate all of them except for draw, which we'll get to next. And as you're looking at this in action, it helps to focus your attention on just one at a time so that you can really see what it's doing. And so here, if I just look at the line that says this is fade, there you clearly see that it faded out slowly. And now if you look at some of the others, you see blur is getting blurrier and blurrier until it disappears. slide the size of it is changing until there's zero height left then scale is changing its size until it disappears fly is moving off the left side of the screen but also its opacity is changing towards zero and then the line right below it is doing the same thing but it keeps its opacity at one and then finally the bottom one is entering from the left side and exiting to the right So here you see it exit to the right and when it comes back in it's entering from the left. So those are some simple examples of how to use all of those and you can check out this REPL code if you need to implement these in your own applications. One more from this package to look at is the draw transition and this animates the stroke of an SVG element. It takes many of the options we've seen before. A new one here is the speed which says how fast should it be drawing the SVG stroke. So let's look at an example here where I want to draw the outline of a house and I have a toggle button which at first is going to erase the house and then when I click it again it will redraw that. Notice how it's just tracing along the shape of that SVG. So looking over at the code you see that there's a string of commands here and we don't have time to get into the details of SVG, but suffice it to say that I'm moving to XY coordinates and I'm drawing vertical and horizontal lines and sometimes diagonal lines. And so if you look at the comments above, you be able to understand what happening there Canceling a transition means that an element is going to return to its previous state So maybe it was already in the DOM and you were removing it but now it coming back to the DOM or vice versa. Or it could be that you're moving an element and it's moving to its new location, but you've canceled it in the beginning, so it goes back to where it started from. But only transitions specified with the transition directive can be canceled. If you use in and out, you can't do that. And this makes sense because if you use the in and out directives, that means that you're able to specify a different transition for each one. For example, the in might be using a blur transition and the out might be using a fly transition. So it would be odd if you were in the middle of blurring the element in and you cancel it and then it would immediately do a fly transition. So that's the reason why you can only cancel transitions specified with the transition directive so that we know it's using the same for both in and out. The fade and flip transitions can be combined in interesting ways. And so in this example, what I want to do is be able to click a button and cause it to fade the button and then make it reappear in the other list. I've got a left list and a right list. I'm also using the flip transition because, for example, if I click the orange button, I want the yellow and green buttons to move up to occupy the space that was vacated. And so here's the REPL for this example. And so let's start with what I just mentioned. I'm going to click orange and you'll see it fade out and then fade in to the list on the right. And yellow and green will move up. and I can do that with buttons on either side and it'll move to the other list. So that's nice but we really can do better if we use the crossfade transition. This creates two transitions that act as a pair, a send and a receive transition and they coordinate with each other. This is also referred to as a deferred transition. So in this example when I click a button in the list on the left what will happen is that item is going to be sent out of the left list and it will be received into the write list. And so that send transition is going to defer to see if that element is being received in another location. And when it sees that it is, it will animate the transition of that element from its current location to the new one. And that's a much better effect than just fading it out from one list and fading it into another. I'm also still using the flip.

 animation. So again, if I want to move the orange button, I want green and purple to move up to fill up that space. So here's a REPL for this demo. And when I click orange, notice how it slides over to the other list. It's kind of fast. We could slow this down a bit, but you can see that it's a much nicer animation. You can actually see the buttons move to their new location. Svelte also supports implementing custom transitions. And it's fairly easy to do this, but there are some basic rules that you have to obey. And so the first thing you need to do is you need to write a function that takes two arguments. It will be past the DOM node that is being transitioned and an options object. We've seen many examples of options already, like delay, duration, and easing. You can also specify options that are specific to your transition. And that function has to return an object whose properties include the transition options being used and a CSS method that you're going to implement. That CSS method needs to return the appropriate CSS string that is going to cause your animation to take effect. So that will be passed a number between zero and one that is determined by the easing function that's in use. And so it's telling you how far along you should within that transition and then you returning the CSS that corresponds to that So Svelte takes care of honoring the delay and duration options for you You just have to handle any other options that you care to support The transition options that you return from your custom function can be given default values that are used when the caller of your transition doesn't supply them. So here are some examples of CSS properties that you might want to animate over time. opacity, size, font size, the position of the element, rotation, and color. And so let's look at an example of doing this. Here what I want to do is implement a custom transition that will take that text, take me for a spin, and I want it to spin it. So it's going to rotate it two times, and also while it's spinning, it's going to change its scale so that it appears that it's going down a drain. And then when I click the toggle button again, it will spin back in, coming from a zero size back to its original size and spinning in the opposite direction. I also have the springy checkbox that, when checked, will cause it to use a different easing function to give me an interesting effect. So now I'll click the toggle button and watch how it appears to spin down a drain. And when I click it again, it comes back. But if I click the springy checkbox and then do it, notice that it begins by spinning in the opposite direction and then goes in the normal direction and comes back in the same way with some spring to it So looking at the code here you can see that there's not a lot that I had to write to implement this. So here is the custom function that I wrote simply called spin and you see that I'm past the node that I'm going to operate on and options and And I'm expecting that I might get an easing option. And then times is the number of times that it should spin. So all I need to do is return an object that contains all of those options. So just using the spread operator to put all of those into the object I'm returning. And then I have to implement a CSS method that's going to be past a time value that's between 0 and 1. And I'm using that to call whatever easing function was specified to get the eased value, which is a number between 0 and 1. Then I can compute the degrees through which I want this to spin. It's 360 multiplied by the number of times it should spin. Now I can construct the CSS string I need to make this happen. So I want to do a transform. I want to scale it according to the eased value between 0 and 1. And then I want to rotate it also based on the eased value by some number of degrees. Svelte provides events that are dispatched at certain points in a transition When an in transition begins an intro start event is dispatched and then when that in transition ends we get an intro end event Similarly for out transitions there an outro start and an outro end. Just like with other events in Svelte, you listen for them by specifying an on directive that registers a function that is called when those events are dispatched. For example, if we want to execute a function after a transition for an element being removed from the DOM completes, we can use on colon outro end equals and then the function to be invoked. And those functions can do many different things like affecting that component or other components. And one thing it might do is to move focus into a particular input element after an animation ends. As we've seen, Svelte has great support for CSS-based rather than JavaScript-based animation, and that's important because it doesn't block the main thread and it's very efficient. We've seen that easing functions can control the rate of change in an animation, and many of them are provided, plus you can write your own if you'd like to. Animation is supported by four main packages, Svelte slash easing, animate, motion, and transition, and we've seen how you can easily implement custom animations. For more, check out my books, Felt and Sapper in Action, at the URL at the bottom of the screen. Thank you so much for watching.