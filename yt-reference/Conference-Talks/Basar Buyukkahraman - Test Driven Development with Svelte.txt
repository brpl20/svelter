 Thank you. In this session, I will be showing how to apply test-driven development in a CWELT application, having external API interactions with it. Hello, my name is Bashar Büyükkarma. I've been teaching web technologies by applying test-driven development. And thank you for joining this session. We are going to create a simple component. It will be loading random users from this public API, random user me, whenever we click the button. And in each request, this API returns random user back. The project is based on Swell template. It has additional dependencies for the test environment, like we have the Jest, the Swell testing library, and the Mox service worker. Test configurations are also set in the project as well. You can check the description for the repository. And right here in the browser, the application is running. And right behind me, we have the test console. Let's move it to the front. Now it's time to see TDD in action. I will be doing the implementation in this app Svelte. And for testing this component, adding a new file here, app.spec.js. The test runner is deducting the files having the extension of .test.js or .spec.js and then runs them. With test-driven development, we start coding by adding the test case for the requirement. And let's do that. Let's import the render and screen functionalities from testing library. And then let's import our component. Now let's add our test. It has load random user button So in this page we will have a button which is having this text load random user First we are going to render our component This function this render is rendering the app to document body In this document we are going to query the button and we get that button by using this query function coming from the screen. Screen is containing the query functionalities and we are using this query by role here. We are using accessibility roles in our test and the component we are looking for is having the role of button and also it has the load random user text on it. And finally we can do the assertion. We are expecting this button to be in the document. Now let's save this one and the test is automatically running and here we can see the test is failing because we don't have the button on the component. Now let's implement this. Now just clearing the app and let's add just simple button to this component and saving it. Now we have the button and the test is passing. Consider this one as a warm-up. Let's add a more interesting test. So going back to our test. Now let's add functionality to this button. Let's add our next test. It displays title first and last name of user. This one has async await in it. This username will be visible after async API request is completed. Again, we are going to render F, then we will get the button. This time we are going to click this one and it will make an HTTP request to random user me. But in test environment, we don't want a real HTTP request to be gone to actual server, because this would make the test environment fragile. We cannot control the external dependencies, so we cannot have predictable tests. tests may end up with false negative results. For solution, we can use mocking and we can mock the HTTP client. Let's use Axios in the application. So in the test, first let's import the Axios. We are going to use the get functionality of the Axios. So we are going to replace the existing axios get function. And we are assigning a mock function to it As a result this is going to be resolving this value This is not the whole random user API response It is just a part just needed for this case This result value is exactly what Axios get is returning. It is having this data wrapping the actual API response. Now we mock the Axios. Let's click the button. For that we are going to use fire event functionality of the testing library. And right here we are going to click the button by using the fire event. After clicking the button we are going to look for full username. This is going to be visible after async API call is completed. To await this text to appear, we are going to call await screen find by text. And the text we are looking for is just the merged version of the title first and the last. And we expect this user full name to be in the document. Now let's Save this one. So this is failing. Let's fix it. We will use Axios in this component. And we will have this local state for the user object. And let's have this function loadRandomUser for loading the user from backend. We get the user from randomUserMe. Let's call this function onClick for our button. And if we have the user, let's display full username. Let's save this one. The test is passing. Now let's test this on browser. Here clicking the load random user. And here we are seeing this username. And if we click this one more time, we are receiving another user. So we completed the implementation. But instead of Axios, we could have used Fetch. It is part of the browser functionality. So we don't need additional dependency in our project to make HTTP call to back-end servers. Let's do that. Let's comment out this part. And let's do the same thing with Fetch. So we are using fetch here then we get the body from fetch response like this Then we take the user from the body result array And let save this one Now our test is failing. But let's try this one in browser. Just clicking this load random user. And here it is working. We are receiving new user whenever click this load random user. So this fetch is properly working. But our test is failing because our test is dependent on to the Axios. Now we are not using Axios. Therefore, we need to refactor our test to make it work with the current implementation. Now let's fix this one. Instead of using Axios, let's go with a better solution. Let's use mock service worker. First, let's remove this import and let's get setup server and rest from the mock service worker dependency. And in the test, before rendering the app, let's create server. There will be rest get handler and this will be handling the request for this random user me. This is going to be intercepting the request and the actual request won't be delivered to the backend. This one is going to be returning the response. And let's start this server in listening mode. Now we don't need this mock part. We don't need anything about the HTTP client in our test. Now let's say this one. And here we can see the test is passing. Just like we have tested on browser, it is working. So now our test is not dependent onto the HTTP client we are using. Currently the test is passing and we are using fetch. Now let's go back to Axios. So just commenting out the fetch part and uncommenting the Axios usage here. Let's say this. And this one is also passing. We completed this tiny project by applying test-driven development. As you practice it more, it becomes second nature in your coding routine. And in test codes, if you stay away as much as possible with the implementation details, then you will be able to implement the requirements however you want. That's all from me. Thanks for watching.