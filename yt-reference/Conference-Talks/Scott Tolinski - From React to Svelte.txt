 Thank you. Hey, what's up? This is Scott with Level Up Tutorials. And for my Svelte Summit talk here, we're going to be exploring our transition from React to Svelte on leveluptutorials.com. I'm going to be giving you some pitfalls, some things that I've learned, and some general thoughts on the transition. So let's get started. This talk is called From React to Svelte, how we rewrote our front end and found developer bliss in Svelte. And I don't say that lightly because we really did. I really feel strongly about the positive effects that this rewrite will have on our code base going forward. So now before we get into that, who am I? My name is Scott Talinsky. You can learn more about me at scotttalinsky.com. Honey Pot did a really, really awesome documentary about the career that I've had so far teaching people online. I am the co-host of the Syntax Podcast with Wes Boss, a podcast where we do twice weekly episodes talking about all kinds of important web development topics that's highly focused on education and teaching people web development in a fun and positive way. Now, I'm also the creator of Level Up Tutorials, which is a tutorial website where we have a new tutorial every single month. And by tutorial, I mean a new tutorial series where they're often 20 to 30 videos long every single month on the latest and greatest. OK, so leveluptutorials.com seen here is a site that I've been working on for a very long time. This is my sort of main career project that I've been creating since 2012, really. So we even have a Discord and all sorts of stuff on here where we create new tutorials, like I mentioned, every single month. Now Level Up Tutorials was created in 2012 as a YouTube channel specifically and nothing else In 2015 we rewrote the site to have greater control And at that point we rewrote it in Meteor which is a node platform for real data And it was really nice, actually. It was a great movement from Drupal to Node because I finally felt like I had control. And I wrote our own e-commerce solution for that. I wrote the subscription service and the video streaming platform. We eventually moved off of MiniMongo into GraphQL and had our API being done in GraphQL. Then we moved our API off of Meteor entirely and went full on GraphQL with Fastify and TypeScript. Fastify is amazing. In fact, the GraphQL library we're using for Fastify is called Mercurius, and that's what serves up our GraphQL API right now. It's incredible. A huge, huge fan of that project. Now, we eventually moved our UI off of Meteor as well, and we moved it to Vite and React. However, when we moved to Vite and React, it was already on React, but when we moved to Vite, we lost server-side rendering. We had quite a bit of trouble getting code splitting, working with React Lazy and SSR together. We just had a really tough time. We also used GraphQL code generator heavily, and we still do. I'm a big, big fan of GraphQL code gen. It's an amazing project. So once we moved our UI to React and Vite and our API to Fastify, we were officially off of Meteor, which opened up a ton of doors in terms of freedom for the platform. And that was great, right? But we eventually got to this point where we were thinking about React and how it fits into our site. the user interface of the site, all of the components in the site had not seen a full on rewrite since 2015. And that can be a very long time in web dev world, but it's an especially long time when you've had some major shifts in an ecosystem. For instance, with React, we initially started with React create component. Then we moved our components to class based components and then to function components with hooks. That's a ton of churn and that was a lot of work to do that and it felt like just to stay current we were kind of doing not full rewrites but these refactors into whatever the newer version of React wanted you to do And was you know varying greatly in syntax just a lot of change right So that was a whole lot of chain And we really saw no benefit from going from create component to class components to function components with hooks. The only benefit there was that we were staying current and able to use whatever new packages were coming out without having to worry about a deprecated older version of React or an older technique. The site itself did not get any faster from going with create component to class components or function components, although the users probably would never have even known. So that's a lot of churn. And you know what happens when you have a code base that churns so much is things can get a little iffy over time. They can start to get a little smelly, right? So the UI could have used a full rewrite or just a full rethinking from scratch, regardless if the CSS or any of the visual aspects were changing, we were getting to the point where the code had undergone so many changes over time that just felt it felt a little funky, right? Just always was feeling like something had to change in the code base, just to stay at baseline to stay up to date, which, you know, you don't want to feel like you're behind, you know, there's some psychology there, where you're feeling like a little overwhelmed that you're behind all these versions. So did we need to rewrite the site over and over again in these different things and potentially churn it a little bit? No, probably not. So the UI, it really could have needed a full rewrite regardless of what we are going to pick. And that opened us up to the possibility of even suggesting or thinking about moving off of React. Now, I have worked in React for a very long time and nothing against React, but I started to really feel burdened by React in ways where I felt the platform was over-engineered for what we were doing. We're displaying video. We have a list of things. These are things that a PHP-based website, a WordPress website, or even the Drupal based website probably did better than our React website. So it wasn't necessarily a matter of figuring out what we wanted. It was a matter of taking a look at all of them in pros and cons, whether it be Next.js for React, because let's face it, if you want code splitting and server side rendering it going to be Next right And then Vue there a ton of Vue platforms and then SvelteKit Now don get me wrong I love Vue I think Vue is fantastic But Svelte and SvelteKit just felt far enough in the direction of simplicity that it felt like a worthwhile swap of a full-end front-end framework. So we knew that every component needed to be evaluated, and we knew that we wanted code splitting in SSR, and rolling our own platform was not super successful in the past because of the React ecosystem just not essentially being friendly for that. Like if you're trying to do it all yourself, yeah, you can do it. But let me tell you, having to deal with suspense, SSR, and code splitting is not worth the time if you're not using something like Next.js, right? It was a tremendous PIA, not a PWA, but a PIA. So what if we rewrote it in SvelteKit? Ooh, JK, unless. What if we rewrote this thing in SvelteKit? That was a big question because I had already created a SvelteKit tutorial course, and I was admittedly a little tipsy on the wonders of Svelte. I was thinking, this platform feels so good to work in. Wouldn't it be great if I could work in this platform every day? No, I couldn't. I couldn't possibly do that. I could not possibly rewrite the entire front end of the site in Svelte. It's entirely different language. Why would I want to do that? It was the type of things that when I told my coworkers about it, they would say, yeah, I don't know if that's a great idea. So I did what I do, and I took 24 hours to just kind of hack away on a SvelteKit version of Level Up Tutorials just as a proof of concept to say, hey, if we wanted to do this, if we wanted to make this thing happen. How far could I get in, you know, a day? And it's not a real day. I have a family life to take care of. So it was an eight hour day, right? So 24 hours, it was an eight hour day. And I just started hacking together some stuff. And next thing you know, I had a working homepage with CSS. I had authentication working and I had SSR with code splitting. So I left that 24-hour period with hope that not only could we do this, but I don't know if it would be that hard. So when I started thinking about it practically, you take a look at something and you get so much done in that short amount of time, you say, I can do this. But then when you look at all of the details, it's going to be much more exciting.

 than a weekend project, right? And in fact, this took us three months, which admittedly isn't that bad. How about instead of me just telling you we're gonna do this, how about you just spend some time in the Svelte version of the site and just try to write a couple of components with it? And of course, the reviews of the platform were glowing. Everyone was saying, wow, this is a ton better to work in than what we were currently dealing with. So that's why we made that decision. And like I said, three months later, we had nearly a full rewrite. Now, the entire UI is done with the exception of the admin sections of the UI, which is currently being served as the old React app because the admin section has a video uploader. It has reports. It has chart. It has all sorts of stuff that, to be honest, would have taken a long time. And now I'm slowly getting that portion of it done with the the idea that I can actually takes some time because we have a functioning React version of the admin that doesn't need to be updated or changed. We have this thing that exists. Let me just go ahead and see what we actually need in our admin tools. What can we make better about it? And take a look at truly building it from the ground up. So, challenges. What kind of challenges do you have in rewriting your entire UI? Seems like challenges should be a lot bigger than three things, but to be honest, these were the main challenges for us because Felkit took care of a lot of the challenges that we were having with the other project, whether it is SSR, code splitting, suspense, those types of things. We didn't have to worry about them anymore. But the challenges were really, all right, we have to rewrite hundreds of components. And a level of tutorial is not a small code base. I mean, this is a legit large code base. You have admin tools. You have the whole user experience. You have the video experience. You have courses, blog posts, you have user accounts, you have subscription information, billing, the whole checkout flow. And this is a big, big site. Also, applications and application data and state. React famously has no real direction there. So you kind of just, you pick what you like, and you kind of use it a little bit. Maybe you do some context, Maybe you use Apollo for GraphQL. Maybe what you do is use a whole host of different libraries to try to wrangle state in React. So it definitely needed a tremendous re because the state in Svelte is an entirely different animal than it is in React And by different animal I mean that state in React is a porcupine and state in Svelte is a cute soft little cuddly bunny I mean, that's how it feels to me, at least, especially after working in both of them. Also, testing. What are we going to do for testing? Testing is a big challenge, typically, especially if you were using something that was very specific to React testing. Now we have to rewrite all those tests. Whoa, no thanks. So I'll talk a little bit about some of these challenges. So challenges, solutions. We have solutions. With solutions, let's say we needed to rewrite hundreds of components. That means you kind of need to get good at rewriting components. So I figured I would show you just very briefly how we did that. So here's a very simple component. This is the author courses. I'm going to make a new file here. We're going to select the language. It's going to be Svelte. I'm not even going to bother saving this file. I just want the auto-completion and the code pretty earring. So here's how I did it. Here's how we rewrote all of our components. This is the simplest, most basic component that exists. So we just copy this. We paste it into the Svelte file. you can see it's broken. Then we get removing on the extraneous garbage. Like, okay, we don't need an export. Obviously we're exporting this. We don't need to import React from React because obviously the React components, okay. A function. Well, we don't need a function because this is going to be, oh, you get out of here, because this is going to be a single file component. Okay, well, we don't need the return. There's no function. We save this. Well, we don't want to save this, but we have this. And this right here is the difference between React and Svelte. And granted, this is a div with an H3 that says coming soon. This is not exactly anything crazy. This is like the lamest component in the history of components, okay? I don't even think we, well, clearly it says coming soon. We're clearly not using this component. But I wanted to illustrate the difference here. We have a component that is a div with an H3 in it. And look at what it looks like in react and look at what it looks like in felt 11 lines, three lines that should tell you right then in there that this is how this is going to look because I don't think there was one single component that we updated on our site that didn shrink about by this much whether it is 50 50 smaller or whatever they are typically losing quite a bit of heft from these components, right? Let's take a look at another one. I'm going to do another Svelte, and this is going to be a much more simple component or a much more complex component, and this is the hero component. Now I'm going to copy this and I'm going to paste it in because that's how we do it. Now this right here is a bit different of a component. You can tell it has some styled components in here. It has a function. It has several imports. So when you're taking a look at a big component like this, what are some of the things you do first? Well, for me, what I do is I I once again start to just rip everything out, right? And especially the imports, the function stuff, the boilerplate. Let's get rid of it, okay? And likewise, we'll do so at the bottom with the export. And granted, this is JSX, so this is not going to be super friendly to Svelte, but here it is. Not to mention there's tons of components that are going to be missing here. And we have our styled components. So styled components, right? Um, what we did to convert our style components is rather simple. Actually, we can say, all right, instead of const hero layout, that's overriding a layout. What we can say is let's just take this whole entire line and turn it into a style tag with a lang of SCSS and get rid of that back tick and wrap off the style tag. Okay. Now, these things, remember we were overriding the layout class, so I can use layout, which is effectively going to allow us to override the layout class here the same way because of how Svelte handles scoping. And we'll just wrap these ones in here like this, okay? Now, you'll see some interesting things, like we were using a button here. We can just say, now, let's convert all of our styled components into just classes, right? And that was actually, honestly, pretty easy. we were just copying and pasting straight out of style components and then pasting it into our SCSS. So like a button now becomes dot BTN. And so we can just replace both of these with dot BTN. We already wrote the CSS You can see that clears up quite a bit here and that will do it for our CSS Pretty easy conversion Um I not quite sure what this is angry about Oh I can find NodeSAS That because this file isn in the repo I don want to save this in the repo. Next, let's take a look at this HTML. We have some interesting things. I know we were using a button component, but this is really a link that looks like a button. So one thing I'm going to do is I use heavily usage of find and replace. We're going to find and replace button with an anchor tag. Okay. We're going to find and replace, um, two is equal to, to href is equal to, there we go. So now they have anchor tags. Now, one thing we'll want to do is add a class equal to btn. Okay. And likewise, a class of btn can like this. Now, we'll also want to find any instance of React specific language. Things like class name can actually finally be just class. Thank you. Thank you so much because I love this change. This is, I honestly have never understood, I mean, I get technical reasons behind needing this to be class name, but no thanks. I don't like it. Never going to like it. Now, I remember what I said about the hero layout was a styled component that just extended layout. Since we have scoped CSS in here, we can use the parent layout class and use the scoped styles from that parent layout class. So we can say this is now a div with a class of layout. now motion div this stuff is going to need some work i'll talk about that so we don't need motion div right we don't need that and for style i'm not quite sure why i initially put these in lines but we can just remove those entirely come down here paste this in and then convert this to text aligned now this is kind of a pain in the butt there's probably easier ways to do this but you know what? Once you do it a few hundred times, it doesn't feel that difficult. It's just kind of a grunt work, so to say. Okay. But that's it. Take that inline style out. Cool. We'll also want to remove, uh, anytime we see as, cause as means nothing in here. Okay. Starting to get a little bit more spelty here. Now, what are the, what are the things we have to do next? Items. Yeah. Items is just a div.

 Items is just a div. There's nothing really interesting about that div. I think there's now a class called items. It's for having things side by side. There's two items here. They're side by side. It's a div. I believe what this does is just makes the flex box look nice. Okay, so last thing we need to do is the animation component of this all, where we want to do a new script tag. Actually, I use TypeScript. So I have a STS, which is just script with a lang TS. And then we can import fly from Svelte forward slash transition. It's not going to be able to find this because this is not in a module. And we have an initial and an animate in here. But we can change initial animate. we can now say fly colon, or sorry, we can say in colon fly. Thank you, VS Code, for letting me know. I was about to do something very wrong there. And we're going to say the opacity starts at zero, and the Y ends at zero. And then we'll change this out fly to be opacity. I'm sorry, opacity should be one for n, and then y should be negative 40. And that way we can get rid of initial and animate. Bingo, bango. That's it. And notice how what we had to do for this was we didn't need a library for scoped CSS. No more scoped CSS libraries. Thank you. We didn't need a library or at least to install a library for animations or transitions thanks to Svelte. And we got to remove a ton of extraneous garbage. So if we look at the total end results, the savings on this one weren't as big. In fact, mostly because the CSS section is larger. That's one of the big ones here. But look, look at this. Look at this top, top area. The top area is significantly smaller, three lines compared to five. It's not a huge deal, but the bigger your components get with the more imports they get, the more that this becomes a big deal. the actual div, the actual HTML starts at line number five instead of line number nine. And you can see that we done with the entire HTML of this thing by line 22 where this one isn done with the HTML or the templating section to line 29 Then we have parentheses and a bracket and an export This stuff is unnecessary in this case, right? We have a single file component. It's not doing anything for us. It's making things maybe a little bit more explicit, but hey, at the end of the day, you can see that while the savings weren't as great, 43 to 38, still feels good, right? And many times what we're seeing is a very real reduction in the amount of code that we have. And the code that we're removing is all code that I would deem to be exceedingly unnecessary, right? All the function stuff here. Okay, so let's keep it moving. Application state, stores for global state, vars for local state, that's what we ended up going on. We're using stores anytime we have something we need to be global. Let's say that we wanted to trigger a loading state. In fact, I have this neat little tool that lets us toggle states. So this is a global state. We can toggle the loading state for many there. Just loading is equal to true. Same with the checkout is checkout open. Although this one needs some other things before it will actually open. Maybe the login window is a good one. There we go. You want the login window? There it is. even though we're already logged in, it's still global state, right? Is search overlay visible? There we go. Cool. That's the benefit of this stuff is hello, React. You can see that it works really super well just by typing in here. Okay. So global state, and we didn't have to make those choices, right? That was just kind of seemed like the way to do it with Svelte, right? GraphQL data initially came in via Apollo, but we started to feel like Apollo being our largest dependency. We weren't really using the cache to its fullest potential. We were like, well, why why don't we just do fetch calls? Why aren't we just using straight up fetch call GraphQL to get our data back and display it? I don't know why I, you know, wanted to use a big, big library to do that. So we started off with fetch calls and that fetch call ended up becoming a plugin called G Query, which I'll talk about in another talk. And G Query is really just an exceedingly simple fetch command that stores things into a Svelte store and does it all via code gen. So that's where we ended up for state. Code gen for the win. Code gen saved our bacon so much here because we didn have to rewrite any of the functions that hit our API All we needed to do was run CodeGen with our new plugin It spat out the functions for us And let's see if we can see a, um, actually let's look for, um, this is a good one here. It shot out a function here, like a get active playlist. And then we can do things like a wait, promise all get active playlists, get playlist tutorials, and have those fetch for us in the load function. And then just have those available as stores on the front end where we could do things like make derived stores or use those as stores themselves. So that was pretty neat, right? CodeGen really saved our bacon. And actually the best part of all of that is this stuff is typed, right? Active tutorials is typed because of GQuery and CodeGen. So yes, amazing. Testing. Guess what? We didn't have to rewrite a single test. Why? Because we use Cypress and we use data test IDs. So our tests stayed the exact same, meaning that what we could do is leave all of our UI tests as they were, and then we could run them and very quickly see which aspects of the site were neglected or forgotten. If we were using React specific testing libraries, that would not have worked. That would have been a huge bummer and we would have had to rewrite a ton of our code. And that's one of the reasons why I think I'll stay away from, like if people ask me, you know, what specific testing library should I use? I'm going to stay away from all of them and I'm going to use a testing library that runs in the browser where the users are using it. That way we didn't have to rewrite any of our tests. This right here, huge, huge, huge hack for us. This saved us so much time. Okay. Lessons learned here. What kind of lessons did we learn? Well, conversion to Svelte from React, very doable. It was way easier than I was expecting. When I first dreamt up this idea, I thought there's no possible way it was going to be doable. I thought it was going to be just a giant bad idea, and it ended up turning out to be a great idea, maybe one of the best ideas. Now, Svelte is a dream to work in. It's a whole other lesson learned is that I really like working in Svelte, and there hasn't been too many times where I'm like, man, I really wish I was working on the old version of the site, which, granted, was still in TypeScript and latest in greatest React, Svelte's just that much of a good experience. ECMAScript modules, they can be a big pain. In fact, I've had pain with ECMAScript modules. And in fact the same type of pain many people will have moving to an SSR platform if they are using SSR Because if you done a lot of server side rendering in the past there a lot of gotchas here ESM not always been fun not always been super awful either Working with the DOM directly in Svelte totally rules. It's awesome. One of my favorite aspects of this is that I no longer have to look for the Svelte way to do things. And I'm more or less looking at what browser APIs exist. I can access the node directly. I can even write a Svelte action that accesses to the node directory directly if I want to. It's awesome. I love working with the DOM. It really truly feels like you're not working on an abstracted platform over the DOM. You're working with the DOM with an abstracted platform. So it's like you get the best of both worlds there, right? Cross-platform libraries are my new best friends. Rewriting a site is tough stuff. So we used a Vime JS or Veeam. I don't know how you say it. For video, it's a web components-based video library that has been working great. The only problem is trying to get it to play nice with SSR, and really that wasn't that. Next is that it was a good opportunity to prune hefty libraries and focus on shipping less code. And we are shipping way less dependencies and way less code. it's hard to express just how easy SvelteKit made it for us to do that. But if you take a look at so many of the things that we would have had to bring into React to get it to do what it wants to do, your routing library, an animations library, a state library, a scoped CSS library, and the scoped CSS library needs a Babel plug-in, like, no thank you on any of that stuff. We got to remove all of it, use the Svelte platform, and not have to ship any of that extra code. What a dream. It's so good. SvelteKit makes perf easy. It makes performance super easy because things like code splitting and SSR are baked into the platform. You don't have to do a whole ton to get them working. You don't have to do anything, really, to get code splitting working. And that's the dream right there. That's the future. So perf, the site was instantly faster. when we deployed the new version of it. Even in a client-side-only version of it, people were reporting that the site seemed just very noticeably faster. So that was awesome. TypeScript rules. We have all of our, since everything in the site is typed, whether it is from the GraphQL cogen to our components,

 TypeScript has just been a dream to do a refactor of this size with. I would feel very uncomfortable doing a refactor of this size without TypeScript. Not that I will ever do one of those again. Svelte encourages not over-engineering things. I kind of touched on this already, but Svelte kind of has a very simple way of doing things. And usually, 99% of the time when I was refactoring components and I ran into a situation where something felt difficult, it was only because I was still in my React brain of things needing to be complicated, where just the simple act of being able to send data upwards when you need it, that simple act can be really, really nice. It's not about removing the boilerplate and the extraneous stuff. It's that Svelte kind of encourages most things to be fairly simple, whether that is working with the DOM or that That is the APIs in general. And because of that, you're much less likely to over engineer simple components and simple things and everything will just work again. Not needing a library to do everything really helps as well One less thing you got to worry about staying up to date with that for sure This last one is when you make less tech choices you can focus on what really matters And that building smooth fast excellent user experiences things that look and feel nice rather than, you know, which state library am I going to do to display this text? Okay, so that's it. That's what I have from React to Svelte. You can check out the site at leveluputorials.com. If you sign up today only upon watching this, you can use the coupon code SUMMIT and get 50% off. And there's a new course every single month. The course right now is on Astro. Like I mentioned, next month, the course is going to be on accessibility with Amy Kaepernick. And it's going to be very, very cool. We have some amazingly talented content creators like Colby Fayok and Brian Douglas and Ryan Align, Scott and James Quick. All these people have made amazing courses for Level Up Tutorial. So if you want to check those out more, sign up today, use the coupon code summit, you'll get 50% off the yearly subscription. And if you're watching this in the future and you still want that deal, we'll be doing the same deal for Black Friday. So new courses every single month. Again, thank you so much. Again, this is Scott with Level Up Tutorials. I'll see you in the next one.