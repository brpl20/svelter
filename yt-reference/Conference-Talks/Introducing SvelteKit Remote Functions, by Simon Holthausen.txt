 Hi, I'm Simon. I work on the Svelte team and today I want to show you a new feature in SvelteKit that's going to change the way we interact with data and it's called remote functions. I'm going to show you roughly, rough overview, what are they, the motivation for them, and a little example that shows how they look in practice. on a very high level remote functions are a new concept in SvelteKit that allow you to declare functions inside a .remote.ts file import them inside SvelteComponents and then call them like regular functions so on the server they work exactly like regular functions and on the client they become wrappers around fetch so it looks like you're calling a function but actually you're doing a fetch call, which goes to the backend. There the function is actually invoked. The promise resolves, the result is sent back, and then shown in your browser. So if you're familiar with RPC or server functions, this is basically our take on the concept while addressing some of the drawbacks we've encountered with other implementations of this idea. So first up, like, what's actually wrong with loaders? Why are we changing this? So just a quick recap, SvelteCats data loading today is based on the concept of loaders. So you could declare a load function inside a plus page or plus layout file, fetch the required data in there for the whole page, retrieve the result via the data prop in the sibling plus page plus layout dot Svelte file, and that's it. This allows for a very structured approach to data loading, and it works well for sites where basically everything is needed at once, or when you mutate something, everything is mutated at once, basically. But when that isn't so clear-cut or you need more granular dynamic requirements, then some drop-backs have become apparent over the years. And those are implicit coupling because you have your loaders in one place and your Svelte components in the other, and it doesn't look like they're connected, but they are implicitly. Also, collocation suffers because data loading happens in one file, and the usage of that data could happen in the other file. And if it like right next to it in the plus page that fine That okay But maybe you use that data deep down in a page and then collocation isn really given anymore Also maybe you need that data in the corner of your page only under certain conditions, but you still need to put it in the loader and load it there always because you cannot really connect the two things. Also, deleting and refactoring code becomes harder since you need to keep in mind both where the stuff is loaded and where it's used. Also, if you are sharing data, you maybe need to move it up a level. So if you have it in a plus layout TS, only because you're showing the list of blog posts also in the side navigation. And so you're basically moving data up and down the loader tree to find the place where it's best shared and that leads to more complexity and you need to organize this more on the technical side and not as you would want to organize it when you could just freely put it where you want to. Also it's not granular enough because refetching data that happens on a loader level so you can at most tell SvelteKit to reload a specific loader and not the other loaders but you cannot get more granular than that. Also, if you're using forms, form actions, then you kind of get a nice DX, but it's not totally type safe. But if you don't use form actions, then you're basically on your own. You have to use regular fetch with plusserver.ts files, and that's completely untyped. Lastly, we have asynchronous Svelte. So this is a new feature in Svelte itself that you now can use await at the top level of the script tag or inside your template. And that in itself is already incredibly valuable, but the way SvelteKit's data loading is architectured right now, you cannot really take advantage of that inside SvelteKit right now. So a solution that should fix these drawbacks and take advantage of Svelte's capabilities, that looks like it should be secured and intuitive, which means we don't want to have accidental closures which means accidental security leaks so the boundary should be clear still it should be intuitive we want to increase collocation so moving the data loading closer where to where it used we want to make loading and mutation more type safe regardless of whether or not you use forms And we want to put control of granularity in your hands. And remote functions are basically the outcome of this. They tick all the boxes. They're secure, intuitive, for both humans and LLMs. So, like, if you, I did this before. I gave basically a very condensed version of remote functions to an LLM, and it just got it right because it's just functions. It's more granular, it's type safe, and so on. So, that's it for the whole overview, and now let's have a look at a little demo. So, this is the website we're going to build. It's basically a simple blog post. We have an overview of articles here. We can read the article, see the content here, and have a few comments. And we can also like the post. And to do that, we need to log in, which you can do either here or here. So, if we log in, we go to this login mask. We can then sign in, come back. We now see that we are logged in by a welcome message and the logout button. We can now toggle the reaction or leave a comment. and so this is what we're going to build is the end result and this is where we're going to start so the whole UI and so on we're not going to build that today we're just going to focus on integrating remote functions with this and for this we're gonna go into our blog posts list first so should zoom in a bit so this is where we start we have our announcements we have our list of posts and for now it's It just an empty array and we want to show the blog post list So what we going to do is we currently create a log remote TS file and then we going to add a, okay. We're going to snooze this for a bit. Going to get posts, query, and then we have our DB, which we can get stp from lib server database. And there we can get our posts from. So we just get all posts in here. And this is our first remote function. So we've created it in a .remote.ts file. You can also put it in a .remote.js file. And we just export a function from here, creating it via the query function. So, this is the first of several remote functions we're going to see today. And by doing this, we're basically exporting an asynchronous function on the server. It will just be basically calling this directly. And on the client, as I said before, it's going to be a fetch wrapper. And what this means is we can now just use that inside this each block. And because we are also making use of the new experimental feature that we can use await in the template and at the top level we can just write await get posts as post and that way we now see the list of posts. So when we go now into one post, it's all empty right now So, this is the next thing we're going to do. We're going to create a export const get post. And for this, we need an ID. And we want to make sure that we encourage you to validate your input because this is actually â€“ so, let's go back to this for a second. And if I go back to the blog, you actually see that we do like a post. We actually do a get request.

 to what I would say is like a hidden endpoint. So we're doing it to underscore apps slash remote and then hash of a file name and then the method name. And so remote functions basically create hidden public endpoints. And that means theoretically anyone could call them. If it's a post, we make sure that it's not possible to do like cross-domain requests. but forget you cannot put this restriction in and so you basically have to make sure that you guard against malicious get requests here. And so for that reason we encourage you to validate your input and so in this case we have no input so we can just put a function in here. If you have one input we can either use unchecked and then we can type it ourselves so like slug string and then we do return post isync with DB get post by slug and then we just do like if not post then error for for post not found and return this so this is the unchecked variant how we can do it and so you have to type the input yourself and if you do that you better know what you're doing like for example maybe you want to hand roll your input validation in that case it's fine to use unchecked but you use unchecked without checking what this input actually is because TypeScript is going to tell you it's a string but maybe it's something else if a malicious user calls it in some other way. And so the probably better way in most cases is to use a import string from valuebot. A validation library such as valuebot or zod. Basically anything that is a standard schema compliant library is fine here And so by doing it like this we saying okay this is guaranteed to be a string because it going to be validated before we pass the input to this function And so if it wrong it just going to be a 400 request So, and this is all we need to do to create a getPost function. And now we can, again, use that inside this details page. And we want to use the title, the author, the date, the content. The way we can do that is to say like post equals await dollar derived. And we're just saying get post of page params slug. Put it in the wrong place. So like this. so this basically creates an async derived which will have the fully resolved post ready whenever it's updating and on the first call it's blocking for that reason and so we can use that to say okay this is the title and this is the author this is the date and for the content we're going to use at HTML and that's it. All we have to do to get the block content going. So we have that. Now we also want to see the comments. For this we're going to create a comments.remote.ts file. And we are going to export get comments from here. And this is another query. And this is, again, a string input. This time we get the post ID and return just the, I guess we can leave that out, get comments by post ID. Let's make it like this again, start sdb, and just pass the post ID And once we have those comments in place we can now use it in here and we can do like comments And this is another way we could use that. So, we're saying just like get comments and this time we're going to use the post ID. Don't worry about this for now. They've got the warning. It's just like to showcase that you can use it like this as well. So, this now creates a resource, and then we can await it later on down here and say, like, await comments as comment. And that way, we now get the comments as well. So, this is cool. Now, you maybe want to do some comment, leave some comments ourselves or have some reactions. and for this we need to create the login flow. So let's do that next. We're going to create a path.remote.ts file. This time I'm putting it inside lib because I'm going to use this on the login page, but also I'm using it on layout because it's always visible in the top right. And so this time I'm putting it into lib. So the .remote.ts files, they can be anywhere in your source folder. They don't have to be in your routes folder or something like this. And so first, let's do the login. And so far, we only have seen queries. Login now is like a mutation. And we're going to use the form remote function for this. so they for now look like this so you have your data, this is always form data we have a pending discussion proposal so that you could get more structured data but for now form always receives one function with a form data object and from this we're going to get the username username as string and the same for password and redirect to. So we redirect to the login page with a search parameter which is passed to this form so that we can redirect back to the correct page and if it not there we going to redirect to the to the root and now we do like some basic checks like if username or password are missing then we just return an error username and password German came through for a second here. And then we're going to get the user from our DB, from our auth, sorry, libso.auth. And we're saying like auth get user validates credentials. That's what I want. username, password. And if this doesn't give us back a user, then we have an error here, invalid username or password. And if everything is fine, then we're going to create a session token for the user. And we're going to put that into the cookies. And for this, we're going to use getRequestEvent, getRequestEvent, which basically gives you most of the things you already know from the load functions, like cookies, the params, although the params is empty, like fetch, locals. Those are probably the things you are most interested in. And in this case, we want to set the session to the cookies. So, we're saying cookies set session, just going to name it session, put the token in here for the root path so it's available everywhere. And then in the end, we're going to use the redirect function from self-care, then redirect wherever we were told to go to. Okay, and this is our whole login logic. And now to use it, we're going to the login page and we have this login form here.

 already prepared and all we need to do is to spread the login function onto the form and that's it. So what this does is it sets method equals post, it sets the right action attribute so that whenever it's clicked we go to the correct remote function and it's also adding an on submit event, which means whenever JavaScript is enabled, it won't do a full page reload. Instead, it will keep it on the page. So you get automatically enhanced login pages. So we're going to save that. And now if I put in my correct ones, I can now, well, log in. Although right now we don't see that we are actually logged in yet because like there's no way to see that that's next. Also, we did like, if this is wrong, then we are not showing anything right now. So, if the user, for example, the credentials were wrong, we're returning this error here. And right now we're not showing this in any place. So what we're doing here is to say like if login.result.error, then we're going to show a div with class error message. And then we're just going to put the whole error message in here. And that's how you can basically react to a form result. And that way it just appears in the... Don't go away, Chrome. Was warning me that this credential was reused in other places, which, well, I guess. and so when I now enter wrong credentials it's going to show up here as the error message and so now okay we have this now and we also need to show the like when we are logged in we also want to see that we are actually logged in. So we need some way to show that. And for this, we're going to create a user.remote. And so we're doing at spot against current user or just get user. It's another query. And I don't think we need async here. And for this, again, we get the cookies from the request event. And then we're just returning get user from session from server.auth. And we're passing it the cookies. And basically, it just extracts our session token from it, checks, okay, is this valid? is this user and then extracts the correct user from this. And this one we can now use inside our layout to adjust this logic. So right now we're always showing login, but when we are logged in, then we want to show a logout button. And again, we could use something like await, get user. But we also want to show the user name here. And so we would have to do something like this maybe. So we probably would want to have this as a derived at the top like this derived, no, not double, wait, get user. but what we also can do and this is the like another way we can use the queries instead of doing it like derived weight we can also make this use the resource directly because it has a current property on it and we can say like if user current is there then we're saying like welcome user current display name and else we show the login button. Although in this case not having current doesn necessarily mean that the user is logged out It could also mean that the request hasn finished loading yet And for this, we can use the ready state. So, else if user ready. So, if the first value is available, but current isn't set, that means, okay, we are actually, we need to show the login. And this way, we show neither as long as the first time the query is running, is going. And this dot current will update whenever get user is updated. So, if we later log out, this will switch back from this to this. So, this is another way we can use it. And that means the handling of remote functions is very flexible here. you can use query with await, which basically means it's blocking on the first render and will coordinate updates on subsequent renders together with other await expressions. But if you don't want that, if you want it non-blockingly, then you can use the dot current notation and use that to interact with the asynchronous data. So, yeah, both ways. It's very flexible. Choose what fits best for your use case. Okay, and so now if we save that, we should be able to see, yeah. So, now we see welcome shell and the logout button, although the logout button isn't doing anything yet because we didn't create the logout experience yet. And for this, we're just going to do another little form. So, const logout equals form. We get the data, get our cookies from the request event. And we just delete the session cookie from the whole thing and now we have to spread it onto the logout form and that all I need to do to have the logout working So if I go here bam it gone If I now log in again, showing up again here. Cool. So, this was the login logout and the get user with the current. Now that we are logged in, we can finally add a comment. Although we have to adjust this as well in here. So inside the post, like right now, it's just like defaults, then show the login. So we need to use the get current. The current user here as well. So we're saying like, and we use that in a few places. So again, we're using like get user. I'm going to use the derived notation in this case, which is funsies. So if user then show this, else show that. and now we should be able to be able to add a comment. Correct. So let's do that. This is another form we are going to add and for this we're just doing like add comment, another form and now we first need to check that the user is actually logged in, that there is actually a user that is making this request. And we could get the cookies from the request event and so on, but we can also just reuse the remote function we already have. So we have our getUser function, which is a remote function, which will already have all the logic, like look in the cookie, get the correct user, and so on. And so we can just encapsulate that by reusing the function. So it's because everything is just functions, we can compose this,

 really really nicely and in case it's not a user then we can say like must be logged in to comment and if that is okay then we're gonna do the old dance again extract the correct things from our data and then we would have to do some more validation here like no post id or no content then that's a was any content required And if everything is okay, then we're going to create a comment. Add comment with the post ID, the author, which we get from the... I'm not sure if I need the display name or the ID. I guess the ID makes more sense, but... Okay, I'm not sure. We will see if it's this or that. this isn't a really like, it's a really rough mock of a backend. So, not using best practices here, I guess. Although, we just, we don't need that. So, and that way, we're just adding the comments. And now, if we are using that for the slug, I'm going to, again, spread it onto here, add comment. We also need to replace the post ID, give this the right post ID. And now we will be able to add a comment and it's going to appear here. but forms by default will refresh everything on the page so if I now add another comment and post to it we see that after the post it will re get user it will re the post and re the comments But we only need to re the comments And it's like that by default to mimic what would happen in a full page reload case. Because then the whole page reloads and everything will get re-requested. But in this case, we don't want that. We want to have this more granular. And we can do that by adding a await get comments dot refresh here. And that way we are doing two things. We are telling it to only refresh the comments. And we are creating a so-called single flight mutation. So when this response comes back, along with any, maybe I do return something here, that will be returned. But also there will be like a somewhat hidden field with the refreshed data. And it's coming in one response as part of the same response. And so that's why it's called a single flight mutation. And so this time, when I now go into the network and add another post, we're going to see that I'm just doing one single post request. No other things are refreshed here. And if we want to look into how it looks like, you can see that it has like refreshes as a property. So the result would appear here, refreshes would appear here. and the client side of the SvelteKit runtime would know what to do with that data. So this way we get single flight mutations and we only refresh what we need. Very nice. Now, for now, add comment is really fast, but like let's imagine we have a very long delay here. So, like, let's say it takes one second until everything's there. Or let make it three seconds And now if I post this like it showing up here it not coming in and now it there So it took the whole three seconds and that not like a nice experience And so what we can do here is do optimistic updates. And for this, we are using the .enhance method on the add comment form function. and we can use that to, whenever JavaScript is available, enhance the experience. And in this case, we want to make it so that the comments show up immediately. And for this, we are using submit.updates. So, submit will just do the regular submit. and with .updates we can then do optimistic updates. We can also do another thing there so we can just do get common comments post ID or I think we even have yeah we have this already and then we're saying with override and we already do have the comments and we spread the comments and then we're going to create a new one and the author is the current user which is user display name content is for this we need our data this is the form data object so data dot get content as string. And we need created add, which is going to new date. ID unknown. Host ID is host ID. And so this way we are creating an optimistic update. We're basically creating like a preliminary version of the new comment. And once the submission is done and the refreshes are about to return it knows to revert the override the optimistic update We could also use it like this without an optimistic update and that way we would initiate a single flight mutation from the client. So, in here, we're doing it on the server, but maybe you also want to initiate the single flight mutation on the client. And in that case, you wouldn't have to create the await refresh on the server. And this way, we are not only initiating the single flight mutation, but we're also saying this is an optimistic update. And if we have this now, then we can add a comment. And it's there immediately. the last feature we need to implement is likes and for this we are going to add a new type of remote function here which are commands and theoretically we can also use form functions here which means it would also work without javascript but i want to showcase commands here as well. And commands are basically a way to do fine-grained updates that are JavaScript only. First, we're going to get the real count here. So for this, we first create another remote function file. So we create likes.remote and we're saying like get likes. This is another query it gets the string the post ID and it gets the import star is to be from the database and then we get the likes count for the post ID and then we can just use that in here get likes for for this post. And if we now go back, we should see that there's one like right now. And now we want to toggle it. And that means we need to add an on-click handler

 here and then call a function. And this is going to be the toggle like function. And we're going to create a command for this. It's going to take a string as well, the post ID. And then we are going to first go to the DB and toggle the like post ID. We also need the user for this. So we again can just get this from our other remote function get user. If there's no user we error. And else we just double the like. And now we can add this to the onclick event So we saying toggle like host ID And now when we click should we see something Probably, but we don't see anything yet. And that's because commands are basically, with regards to how they behave with refreshing data by default, they are basically the inverse of forms. Forms by default refresh everything. commands are more fine-grained in nature and so by default they refresh nothing and so we need to tell it what to refresh and we can do that again here on the server to say get likes for this post id refresh this please and that way again we are doing the single flight mutation and get back the the correct results And now when I toggle this it goes from one to two or two to one as expected By the way we can also add the updates method to toggle likes or generally to commands just like with submit of form functions So you can initiate the same single flight mutation and or optimistic updates as you know from forms, as you've seen before from forms. okay last thing we're going to see is just that's more like a quick thing to know about so we go back to the beginning we have our posts here and maybe those posts at most change once per deployment and in that case it doesn't make much sense to make this a query because then Every time someone hits your page, it's going to put load on your server runtime. And instead, we can swap this out to pre-render functions. And now these functions are evaluated at build time rather than at runtime And the result is basically static assets and so there a super fast response Okay, that's all we have for now, the demo. We've seen query functions, we've seen commands, we've seen forms, and we've seen prerender. These are probably the four most common ones to be used. We have other remote functions planned, like stream. These are basically service and events for live updating data. We have batching. We have thoughts about how we want to do caching. And so there's more to come. That's it for now. I hope you're as excited about remote functions as we are. it really changes and simplifies the way we interact with data in SvelteKit apps yeah try it out give us feedback and see you soon bye