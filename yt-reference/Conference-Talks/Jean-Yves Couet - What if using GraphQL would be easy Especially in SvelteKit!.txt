 So let's start right away. My talk is about what if using GraphQL would be easy, especially in SvelteKit. Who knows about GraphQL? I don't know anything else. Okay, no, big portion. We will start from the very basic. I think everyone being a good deal. And who knows about SvelteKit? It's about the same. Not everyone, not everyone. So first of all, what is GraphQL? If you go on the doc, actually, on the main website of GraphQL, you see that there is three parts. The first part is the server part. It's where you describe the data. And then describing the data, everything is typed. So you can, from the start, have a great top-top types. So people liking TypeScript will love GraphQL. Second thing is the client request. you ask for what you want and here you will recognize that it's almost json so it's very familiar to go to the cross because it's just the key of the json not the value then the server is doing a lot of things and then returning to the client the response with a regular json if i mix it up in another way around we have the client request we go with the client the GraphQL spec and actually it's only a spec so it's the language of GraphQL. It's going to the server. The server will resolve a lot of fields. Each field will get resolved and then it's going back to the client with a JSON very figuratively. First thing is about doing a query. So when we want to to get data, we call this a query. So here we have the query called user list, and I require the ID and the name, something quite straightforward. And the result will be something like this, a list of users. You have four users. There is an interesting concept also around fragments. So instead of writing everything in the query, the ID and the name. You can split this part of it with fragment. And here I call the fragment called userInfo with the ID and the name. And then inside the query, I just put dot, dot, dot, userInfo. Developer like to reduce the amount of code, so we will reuse a lot of the fragment. And then we get the exact same result, which is kind of cool, right? So then what's the deal with Svelte in the end? And actually what's the deal with the KIT. So what we said just before, the KIT is only the front end, but KIT is a bit bigger with the routing, server side and everything. The deal I think is about data. So GraphQL is about having the data or having the semantic of the data and the KIT is about transport and everything. So let's do a bit of history. When you want to launch a website, a cool website of course, I don't know if this domain is taken by the way. You will have some data or some service hosted somewhere. And then back in the day, we were doing what we called MPA, multi-page application, PHP, C-sharp. So basically you hit the server, you do a web, the server is going to get data. It's a database or service, we don't care. So there's a code. Then it's coming back to the website and it's what we call in the in the days now, SSR, server-side rendering. We have a lot of three-letter names everywhere. Each tweet is about what is the best three-letter tweet. So this is one, SSR, you will see. So NPA was the king of SSR somehow. And then you have another way of doing websites, starting, I think, with Angular maybe, one popular framework back then. And then SBA works a bit differently. So your website grabs the source of the website. So SBA stands for single page application. And then from the website, you do network call to your database or service or whatever. So it's a network call. And this is, and then of course on the website, you need to have a pretty good caching, because if not, you will request always something to the API so it gets complicated. And this is what we call CSR, Client-Side Rendering. Okay, so we have the two models, SPA with CSR and MPA with SSR. I'm happy that they put a lot of three letters. And now we have Svelkit. Svelkit actually is taking both things, and everything is done automatically somehow. So we have, let's go back, GraphQL for semantic. And then we have the enabler, I would say. ZenKit enabling these different modes, SSR and CSR, and very powerful feature like stores and preprocessor. And today I'm happy to announce, actually today, a new release of Houdini. Houdini is a library dedicated for the client, dedicated for the client to build, to close the gap between these two things, getting data out of Raphael and circuit. So let's dig a bit into what is Poudini. Poudini, you know, it's a magician, so the idea is to disappear. So in the end, we will not see a lot of Poudini. This is the goal. So first thing in our project, we put one Raphael file, the one we saw at the very beginning, so userleaf.gql, which is exactly what we typed before. I don't know if you know, but if you configure your ID in the right way, you will have auto-completion, intelligence, and all the schema. Because the server knows everything, then you will be able to introspect. So if you do control space, you will see ID, you will see name, and you can't do any spelling mistakes. That's why I love this. And then you will hit one command, generate, and it will generate store. Each query is a store. So with this in mind, we will write our first component, so userlist.velte. And I'm very happy that I have a PowerPoint like this. I have no problem with live coding. And in this velte component you will see first that we have a prefix So the userlist have a prefix GQL underscore So like this very easy GQL underscore and you will see all your store pop in here And then here user list that fetch That we want to grab the data. Okay. So we fetch the data from the service. And then we have what I said just before, everything type. So I can display here the ID and the username. I cannot do any mistake. And when I go again on my user list, I add a new field, then generate everything again. Every type is again coming from the store and being able to display. And this was for then just before. This was for TSR. So I launched my website and I do network call. Now the cool thing today is to do first server-side rendering and then network call when we navigate through the application. To do that, you need to... Oops, I'm not going in the right direction. To do that, you have one line in the load function. The load function, something very common in cell kits, you have something like this, giving an event. Then you have this one line, and it's exactly the same line that we were doing before. A nice copy paste will do the job. Thus, you have to add inside the event, like this, you can get the fetcher, but everything is big for you. There you have nothing to worry about. And doing this, you will have surface-side rendering by default. So you do F5 on your page, the data is directly in the body of your HTML. If you go through a navigation, client-side navigation, then you will do a network holder. So you have CSR, SSR. You have also, of course, inside of it, a cache built-in. Let's see if we can have a look a bit later. And then what I showed you is that we did this in two separate files. So I have one file for GraphQL and one file for the Svelte component. It's one way to develop. But we have another way to develop is also to remove this file and to do what we call inline documents. So inside the Svelte file directly, you can see that we have this special tag GraphQL where we put our query inside. Here I put everything in there, but we can also use the Pregnant. So it's just about preferences. If you want to work one style and another style, those are available to you. And here actually we make use of preprocessor, so we wrote some logic, and in the end it's creating exactly the same code as what we saw before, with loaders and getting the SSR working and CSR working. So what's the deal? we have everything we can get data it's type it's in in inline external document we have caching then what's next and this is actually what's next and it's features what i want you to use is feature of virtual first thing pagination who had to implement the pagination i think most of the apps right have to do with this and then how do i do this it can be complicated Actually, you have two kinds of patination. I have my left side, it's what I call the page by page. So I see two items and I can navigate to page one, two, three, four. Then you have another kind of navigation called infinite score, where you do load more and then you will see four items, six items. So if I hit the next button, then it's increasing on the right side and on the left side I see the the number 3 and 2.4. Now how to code this part? I will go back on my userlist.jql. And here I just have input. So this is a regular GraphQL query. We have the limit and the offset. And depending on this, I will see limit two element, offset zero. And then when I go to the page two, I will do offset two. And that's nothing special. If I go back on the page one, everything is cached. So you don't even need a network request. Everything is automatically done. So basically, there is nothing to do. Everything works out of the way. To do the infinite code, then you have to think a bit more. And here, to make it easy, we added only one directive. So directive is called here addfaginate. So on this user connection, which is a list, I'm doing the same thing as a list, then you add this addfaginate. and by default you will get one function called load more and the load more will just load more data and will append inside the list the new element so just with this part a little directive you have your infinite call working i found it all great let's go to mutation now so we spoke a lot about queries queries about getting data mutation is is about mutating data, changing data. First thing to do is maybe update the username. So I will write a query, so or external file or inline the document as you prefer. So here I give the ID to know which ID I want to change the name, and then the name. And then on the Z component, we have to have just one function, which is update user. And we have again a new store created just for the mutation, starting by GQL underscore as you roll. And then I will have update user. And here I don't do a fetch, fetching with just the ground data. Here we do mutate. And I mutate with the two viable ID and name. Nothing fancy, but it's working. And all stores having this ID will be updated across all the application. So if you have a list with this name, one place you update the name, everything gets updated. Just with this one line of code, everything is synchronized. This is also pretty cool. It's going further. Of course. Something called optimistic UI. Maybe you heard about it. Yeah. It's complicated to do optimistic UI. And here it's, I think, not complicated at all. So we just add a bit more thing in the mutate. We add one thing called optimistic response. And here, at the start, I decide my name will be Optimistic name. Of course, I could decide better, but just for the example, we could imagine like this. And if we go a bit in this example, I put my name somewhere, GQuet. Then I trigger this, I call this update user with my new name, GYQuet. It will immediately change all the store with my new name or my new Optimistic. Then it will go to do a network call and get the right data. So the idea of optimistic update is that 80% of the time it will work well. So people will think it's instant. And on 20% on the case, maybe it's coming back with an error or something you are not allowed to do. And then it will revert back the changes. And again, this is out of the box, just adding this optimistic. So you know about it. You are an optimist person. Let's do this. If you are not optimist you can just move this out What can go wrong Next big topic how to add an element in the list how to append the list So everything is a store, so how to add something in the list. Here also, a nice trick, we have a directive called atList, and we just give the name of this list. OK? When we hit the generate button, it will create for us a fragment. So you remember the fragment of before. And the fragment will make sure what you insert will be in line with what you have in the list. So by default here, I'm requiring ID and name. And by default, the fragment will have also ID and name. If you change tomorrow to have another field, it will generate everything again. So everything will be always consistent. Then the same thing as before, I create a addUser.gql, So just a regular mutation. And here I want, as a result, a fragment, the fragment that was generated for me. So like this again, I know that everything is in sync. Then in my component, I do my mutation, adding my new user. And then that's it. The user is added to my list. So almost nothing to do, generates, and then having the right fragment name is doing the job. If you remember also at the beginning, If you configure well your IDE, everything gets autocompleted and everything. So the underscore insert, you cannot make mistakes there. So you list the list, then the automatic fragment, and then the mutate and you have KLRs. What is KLRs? No one knows? Let's see. So in GraphQL, you have five types to work with. So integer, float, string, Boolean, and ID. And that's it. You cannot do more. Of course, you can do more with something. So how can I work with a date? Because it's very common to have a date, right? So of course, you can do more. On the server side, we have this scalar capability. And then you have to define them. So I want to have this scalar of date time. And then I will manage to serialize and de-server. But this is on the server side. But on the client side with Houdini, we also de-serialize it in the right way and you can customize it. And then it's already a date. So your store is getting already the type you want. So you don't need to manually, everywhere, parse it as a date, parse it as a date. And it's valid for all the scaler you have. So like this, I'm just using a regular store. User.autocompletion is coming by default. I'm also a huge fan of TypeScript, so everything is TypeScript ready. So this was about Houdini. Please, all of you go on the Gizal repo, give a bit of hype to this project. We need it. But that's not it. Today, we announced also a release of KitKuel, a new version of KitKuel. So actually the last two months we worked with the creator of Houdini, we are now both maintainers on both sides. Houdini focuses on the client side and all what I showed you before. KitQL focuses more on the whole ecosystem of SvelteKit and GraphQL. Because here I spoke only about the client side, but you saw before SvelteKit is capable of doing back-end code. Why not putting our GraphQL server inside SvelteKit directly? Actually, it's what I do every day in my daily work today. So I work for it, and then now I open source with this KitQL. And inside KitQL, what do I have? I have a lot of packages, actually. And KitQL, essentially, is only bundling all the packages together to make sure they work well together. And through a few good conventions, or at least I think they're good. You can come and comment on the rainbow, no problem. So the first one is Yoga. Yoga is a GraphQL server that can go on a lot of different platforms and one of them is the Pitocore. So very powerful, you have to try it. Actually, you have to try it through Ptune. Then Envelope is a way to expand also your GraphQL server. So if you want to have rate limiting or some non-caching response, you can do this at this level. Logging, you can go crazy there. then you have modules also what this is a way to code in a separate concern and we go more in detail just after then we have code then of course code gen will generate types also on the server side so as i said before typescript is if you do copy with those types you miss something somehow so all this is baked in then you have scale out of course what i explained before for the server it's there you have as well graphql eslint for the normal who just before in the product you said no to eslint but me i say always yes please check my code check that everything is ready and there is a package not only my code is ready but my graphql is also following a lot of tools so it's a nice package also to look at and then there is a small bit plugin to be able to run the generate alone because i don't want to type generate all the time and i'm a lazy person so when i save my graphql file he knows that it's a graphql file and he generates in the background generates all the types and then i just have to enjoy my typing in in the whole ecosystem you have also graphql coming for free somehow uh so i don't know if you know GraphQL for the people who know more REST it's like the swagger of GraphQL so you go here on this page and then since we know the server we have all types then we can have all the documentation on the left part we have an explorer to be able to build your query with a nice UI you click boxes then you are on the right side to see all the docs all your types and everything and then in the middle you have the request so here you can type freely with at the bottom some viable and on the right side you have the response let's go back to this module development way of doing things so in a project there is a module folder which is the key tool and a module for me contains everything. For example, here I showed the user one and then the user will contain the script for the database, resolver for GraphQL, also all the UI components ready to do CSR and everything. Everything is the one package and then I just use it and I compose actually my application and I think this is the key. Composing your application with the root, you just grab the user, grab the display list of user, update user, and then you're done. And I realized that in a lot of projects, we have to do user, profile, role permission every project has a list right So my next goal would be to to share actually uh to share with the our kit modules so when when we have a user package because which is syncing up and then we can be shipped the idea that other project can just grab it and they have everything directly out of the box not only the ui component or the server component but everything banged together ready to be used we're making one By the way, I'm Jean-Yves, thank you for your attention and please follow me, let's connect. Any questions? I had one but I forgot. Too much content? Yeah. Maybe I missed something, because I was really negative. But how do you handle partial types of the curries? Maybe I missed the cost of it. I spoke about optimistic UI, and this is quite close to partial data. And it's something that we don't support fully today, but we are exploring how to make it actually we are using it but we don't expose it for the user to make use of it and we're exploring this uh in the next iteration yeah it would be an interesting thing but by the way now that you think about the partial data we handle also pre-fetch in our store this was a big complaint that's why i mentioned prefetch is also working out of the box because when you prefetch something you want to put it in the store but you don't want to display it and this is under with this one line of code you have nothing to worry about we worry about it for you okay i have one question i remember them um like for for svelte kit for the pages you You can either use the load function or you can use the get endpoint. Does the GraphQL server-side vendor also work inside of the get endpoint, like the page endpoints? Yeah, but the get endpoint actually is not useful for our way of doing things. The load function is sufficient for everything. Yeah, I mean, it is the load function actually. Yeah. Page endpoints wraps around the load function and checks it. I was wondering if it's possible to use, like for data fetching usually, you can just use the page endpoint. Yeah, but for regular fetching, yeah? But here we bake for you all the things. Okay. So meaning that I don't see where we could call these stores in a get function. Because the whole point is that we feel it has stored. And that's where I don't see, maybe there is a use case, and we spoke about it with the other guy, Alec. But we didn't find a scenario where it's useful. So today, the load function was sufficient for our use cases. But maybe tomorrow later, a proper way. Other questions? Can you go back to the load function example? It's far away. I have a question. Did you really prepare all of this today? Yes. You can leave it like this. Maybe as a feedback, you could also eliminate some of the boilerplate here inside this upper You could create a GQLUserList.load and you just export const load equals GQLUserList.load and this just drafts this const load attack. The whole thing here? Yeah. So it's the same line instead of the additional await, additional return, additional passing event. Yeah, we have to see because the idea is here, you will do your own logic, right? So when you are on the page with an ID, you will want to see the variables for this ID, and you need to write this code. I cannot imagine what you will do. For the user ID, for example, you will need to add it on line number 3. I have my line number. And then this code, I cannot code your application for you. So you will have to write this code. works or simple use kind of common that you need to expand a bit um maybe if the data is only related to the url like if you have for example a review a restaurant review site and inside of the url you have the id from the restaurant then you might be able to do that i guess yeah but it's you decide that this is the id the name of the id and then maybe you use a session, maybe you use stuff. So this is your problem. Actually, we iterate quite a lot and we would be happy to reduce even more. One question maybe you have. Maybe I can ask a question to the TypeScript. In TypeScript, you have to have a type for the ARC, for the inputs and then a type for the return. What I love in the GSDoc is that we can have one thing on top which have the type of the function and the return. Would it be possible in TypeScript to have one line with both? And it's maybe this that we need to explore more, because I'd like to move that link. I have a quick question. I'm not sure I would have been to stop here, I think normally if you do the endpoint, I think, and if you call the endpoint, right, on the server-side it won't be an HTTP call, it will be just a function call, right? Exactly. Is this the same thing? Yes, it's exactly the same thing. So in GraphQL, we don't have a lot of endpoints everywhere. We have only one, which is the GraphQL job. And this is the power of it, so I didn't spend time in there, but then you don't have to have to maintain a list of users with only ID and name, a list of users with ID name and birthday. This is the power of a query. Just query what you want. And not having an endpoint with everything. Then you have a huge payload. You can pick and choose. All right. Thank you so much. Thank you.