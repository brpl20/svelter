 Okay. Yeah, it looks like my clickbait title did work and a lot of you showed up. Thanks. So let's get started with my exceptionally talk. I'm Ivan. I'm a web developer. I have a passion for great developer experience and that's probably also the reason why I fell in love with Svelte and also TypeScript. I'm also working on open source stuff. I created TypeSafe i18n, an internationalization library that's lightweight and fully TypeSafe, and it tries to offer a great developer experience by creating type definitions for your translation calls. And I also have created the SvelteKit TypeScript showcase. It's a collection of some examples because the official Svelte documentation does not really offer anything when it comes to TypeScript and how to use them in your components. So if you don't know how to type something, you can go to that repo and you will probably find it there. I always use it. It's a pin tap on your browser, right? So what I will show you today, I will talk about error and exception handling, not so much about Svelte, so I have to disappoint you a bit. I will talk more about TypeScript and how to write less error-prone code. And all those concepts can be applied to any kind of applications, not just Svelte. It works with all frameworks. I mostly use it in my server-side code. So let's first start with the definition. What's an error? an error in my opinion is unrecoverable so the application can't function if a certain condition is not met. This can be for example if an environment variable is missing when you start the application then it does not really make sense to start the application and it should crash Or if your database migrations fail then it also doesn make sense to start the application with the new code because you will access the database with wrong models. And the expected behavior is that the application should crash and you have to to resolve the issue manually. On the other hand, we have the exception. The exception is recoverable. It just affects certain parts of your application, and mostly they are temporary or input-dependent. An example for a temporary exception is if you are calling your payment processing provider and it is down, probably a few newly registered users can't subscribe to your services, but every other user is not affected by this. And an example for an input-dependent exception would be if you upload some data, it works probably for all users, except for that other one that tries to upload a 2-gigabyte zip file. and the expected behavior is that the application should continue to work, and it just affects a small amount of people. The distinction between error and exception is sometimes a blurry line. It is not always clear, and you and your team have to decide how to deal with it, and also case by case. But most things are probably exceptions and not arrows. If we take a look at this function, we call, we get some events from our database service and in the end we will log something out here. Nothing special, but you as experienced developers will probably see that if you try to get something from the database, you probably have to handle it somehow. In this case, the exceptions are not handled and you as a developer need to know where to handle them because nobody tells us that we need to handle it here So let try it Let handle this exception We wrap it in a try catch block. We have to define a variable here. We call the same function like before and then catch it and here we return early of that function and if everything succeeds we log something to the console. What I don't like about this solution is that we added a level of indentation here. In my opinion the code is less readable. We have to declare the variable here, because, or else we won't, if we would define it here, we won't have access to it here, so we have some scoping issues. We introduced a mutable variable here, we cannot use const, we have to use let, so you could actually overwrite it somewhere down below, and we also need to define the type manually. In the other case it would be inferred by TypeScript. And it adds some boilerplate code. Just for this example we added five lines of code. So I told you a bit what I don't like about the solution to distract you a bit. What's the real issue in this implementation? it returns an array. Maybe. We should trust the function name. We don't have the exception. Yes, the exception is just... Yeah, it's just a placeholder. Try catch does not work with asynchronous function calls. You have to know that. You would probably not test you will probably not test this you think yeah wrap it in a try catch block and we handle the exception but this you have added a lot of code and you didn't catch the error great so what you need to do is to add the catch function at the end of the promise and yeah then return again and in the success case we again log something to the console Can you see the issue yeah the return statement inside the catch block in the catch function here has another behavior than the return statement in the try catch block and in this case events could be undefined for this special case we TypeScript would have told us that because we are trying to access the length attribute here. But if we don't do anything with our events variable or we do something that would be valid, then TypeScript would not have helped us here. So this is the correct solution how we should do that here. We need to check if events is defined and then we can return here. Finally. So let's summarize this a bit. We have different approaches for synchronous and asynchronous code. They also alter the structure of your code. It is not linear anymore. And you need to know what function could potentially throw. You have to look into the implementation of that function to see if it throws or what it throws. this can be also multiple levels deep because that function could call another function which calls another function and yeah, then you have a thought about this specific function but what if the implementation of that function changes will your code still be safe? you won't know and TypeScript also does not know it does not know that something can result into an exception where exactly an exception can happen and also what kind of exception can happen. So how to deal with it? Not handling it at all. Yes. You can leave it like it is and wait for it to

 make for the exception to occur on production. I heard of some good service that could help us here. Or you could write more integration tests, but they will become less maintainable or a lot of effort to maintain if you have to test those multiple levels of function nesting. Also wrapping everything into a try-catch block does not really help us here, because we saw that it doesn't work with asynchronous code. What you really should do is return exceptions instead of throwing them. You probably saw this approach already. We have a result, or we return always a result. A result can either be a success or an exception, and in our success case, our first element of that double is our data attribute, our data, and the second one is undefined, and in the exception case, we return undefined as our first element and the actual error class as the second element. so if we take a look at our get upcoming events function we see that it somehow does not like mondays and in this case it returns undefined for data and a new error that says try again tomorrow at the end we also need to use as const because we need to tell typescript that we want to treat it as a double and not as an array of undefined and error in the success case we return events at the beginning and undefined and we also need to use as const if we then call this function we can destructure it and you check for the exception and then log the result here then maybe if you do that a lot you may think why do I have to check for the exception I can check if the data is here Then let check if the data is here But can you see the issue with this code Yes. If we check it like this, a number of events could also be zero and therefore false, and we would treat it the same way as we would treat an SQL exception. we could do it here, check if number of events is undefined and handle the exception there. So from now on, we always check if our data is undefined and treat it as an exception. But can you see the issue? What if we don't have an upcoming event? Should we treat it the same way as we treat a SQL exception? Probably not. And this is how we really should handle it. We should always check for the exception and check if it's undefined. If it's not undefined, then we got an exception and in all other cases we have a successful response. So in this case, event and exception could be undefined. Don't become lazy. Always check for the exception. There's also a similar approach. It is a data exception object. Looks similar. Instead of a double, we return an object with either a data attribute or an exception attribute. In this case we don't have to use as const, we don't have to return undefined, we just write exception in the exception case or data if it was successful. And when we call this function we can destructure it like before. In this case if we want to To give the variable a meaningful name we need to write a bit more but in the end it looks quite the same If we compare those two approaches we see that in the object case returning data is a bit easier because we don have to use undefined The auto-inference of the types works a bit better, because we don't have to tell TypeScript to treat it as const. On the other hand, naming variables is easier. with the Tupler approach some things work good, some don't but in my opinion the biggest issue is that it does not enforce you to handle the exceptions and like we saw before, it is not that obvious how to handle them because when you implement it the first time you probably won't have thought about that it could be undefined and undefined and And yeah, I thought a bit about this problem, and then I implemented my own solution, and I introduced to you, exceptionally, a library that tries to solve the issue described above. And now you should also see why I came up with the title of this talk. It may not be an exceptionally talk, but it is a talk about exceptionally, so I didn't lie to you. The word consists of exception and ally, which is the short word for accessibility. And it is an exception handling approach that makes it easier to use unknown code. And it informs you about potential exceptions and therefore is more accessible because you don't have to know the implementation details of that function you are calling. And it enforces you to handle exceptions. this is the syntax the library provides exception and a success function in the exception case we wrap our data with the exception function and in the success case like this we get back a result and check for is exception here and that means that an exception occurred and I will show you a little demo So here we have a function from before If we hover over the result we see that we get an error or in the success case an array of our event data. We can unwrap the data by calling the result as a function and when we are inside the exception block we see that we are dealing with an error, and in the success case we are dealing with the array. If you comment out this code, we get an error because length is not available, is not a known property on the error. But what if the types are compatible with each other? So, for example, we have the getUpcomingEventName function that returns a string in the exception case, but also a string in the success case. So here we are accessing the length attribute and it works for both. What we can do is use a utility function and TypeScript should tell us that we forgot to handle this. Let's comment that back in. We got rid of this error here, but we get another error because message is not a known property on string. If you use regular try catch blocks, then you won't know what kind of exception you get back from a function. It is typed as unknown and you have to write some code that tries every possible solution. You won't really know what you get here. Let's call the getUpcomingEvents function and we see that it is possible undefined. Let's ignore that for now.

 If we hover over the exception result, we see that it returns an SQL exception, so we could write some code to handle it. of what I forgot to tell you before. You should not return strings as an exception. In an ideal case, exceptions are always some kind of class with a meaningful name. In this case, SQL exception or maybe also database unavailable exception. That tells you what really went that tells you what really went wrong, and you can easily do something depending on the type of exception you get back, because you probably want to implement a retry logic if the server is currently down, but that retry logic does not really make sense if you send some invalid data to the server and get a 400 arrow back. So, we do something here, we handle it, and we can also check if we have handled all exceptions with another utility function. No. Live demos, yay. Should it be returned? Return. Return. Thanks. So now we have handled everything. Let's call another function. And we get an error because we forget to handle that Let do that quickly Yeah. What I try to show you is if we... We think we have handled everything. later someone orders the implementation of that function, returns something different, and now we see that we forgot to handle it and we will catch the error, the exception. And, yeah. We can if we this looks a bit ugly because if you want to do a call multiple functions at the same time, you will need to use promise.or. You are extracting the result objects. You are checking if one of those is an exception and then do something for that. You have to write a bit of code and if you add a third function you will probably forget to check if it's an exception here if you don't pay attention. To help here a bit I added another helper function that does everything for you so if one of those function calls returns an exception then the full result is an exception and we can extract the data the same way as before. You probably will also need to call some code that does not come from your code base and that will probably not use an exceptionally way of handling exceptions. and for that you can use the try catch helper and it wraps everything for you. It works the same way for synchronous and asynchronous code. You also can become creative. In this case we have some storage service This storage service does not really know anything about exceptionally It just returns something It uses the file system to read a file Nothing can go wrong there. And yeah, you could wrap it with a proxy object and then you will get back the everything every function call as an exceptional result of course you don't want to implement this even if in this case it is uh not that much code but you won't you probably won't don't want to write the type definitions yourself i'm planning to release to add a better a utility function that works. Let's get back to our slides and I have a fun fact for you. Do you know how much decor of this library adds to your bundle size? It should remove something. Yeah. Just as much as it takes this PC to save this paragraph on disk. It's just 132 bytes minimized and gzipped. In the end, it's just a few lines of code with some TypeScript magic on top. This is the full implementation of the core. It's about 15 lines of code, and additionally four times as much TypeScript type definitions on top. So what are the alternatives? You can write your own solution. It's not that much code. You saw it. But you have to come up with some good type definitions and also have to test it. And after I've implemented the base functionality, I thought, yeah, maybe there is something already on the internet. I found those two libraries that try to solve the problem in a similar way by returning exceptions Resart and NeverFrow And I can tell you a secret about never throw It will throw If you don't pay attention, it will throw. And your code should never throw unless you really want that. And this should only be where you are on the boundaries of your application and not. So when you are communicating with other systems that probably expect that something throws, but not inside your code, because then you lose the control of what exactly can happen there. So what are the advantages of returning exceptions instead of throwing them? The code flow stays linear. You can treat asynchronous and asynchronous code the same way. You get full TypeScript support with auto-inferred types. process. You don't have to look at the implementation of a certain function and you will see if exceptions are handled or not. And this is a huge help when refactoring but also while you are writing the code. Of course there are also some disadvantages. There is a small learning curve. You have to wrap everything. This can be solved with a proxy like we shortly saw before and it only supports a code you own yourself because other libraries, other codes will probably not use that approach and you can wrap that functionality, that external functionality like we saw before. Has anyone heard of the shift left principle? The key message there is that you should resolve issues as early as possible. If we think about coding, then the earliest possible moment where you can resolve it is in your brain. If you code more, then you get some experience, you see something, and you probably write some less error-prone code, hopefully. the next moment would be while you're writing the code. So when you have, when you're writing

 IDE tells you with the help of static code analysis that something went wrong, then you will see it immediately. The next moment would be while you manually test the code. So you are clicking through the browser. It will take a few seconds and then the application crashes and you will see the issue. Next step would be in CI when your full code base gets checked. Then on the staging environment you push something, it gets deployed. Then some hours or days later someone tests it and sees the errors. And the baddest thing that can happen is that it goes into into your production system. This can happen weeks or even months after you've implemented the functionality. And it may also result into other issues, for example, data inconsistencies. And you have to resolve them on top of resolving the actual issue. And yeah, you should get it the earlier. You resolve something. It reduces costs and effort. and by returning exceptions instead of throwing them you can catch the bugs here and also here why does not everything get caught here? because your IDE will only check for errors in the files you have opened so if you don't run the static type checks locally then you won't catch those issues but thankfully CI will help us here and you have to wait 5 minutes or 10 until but it's early it's really early because if it goes to staging or production then you probably won't even know what you have written there So what does it mean if you stop throwing errors Will your code be bug safe? No. It's the same as if you start converting JavaScript code base to TypeScript. if you type everything as any then yeah TypeScript won't help you there if you still write the same code then you have the same errors the same bugs so by using TypeScript and also returning exceptions it will make you aware of potential bugs but it does not prevent them can you ignore writing tests? I would say no but you will probably need to write fewer of them especially integration tests because they can be replaced with static type checks does it replace services like Sentry? yes no would we set a 50 lines of code to replace it? You will probably still make mistakes. You could forget to return the exception instead of throwing it. You could always use the tools incorrectly, so having a reporting service as a fileback is always a great idea. Should you know the implementation details of a function you call, I would say no. You should be able to trust the implementer of that function and also TypeScript that it tells you what our possible outcomes are. If you access this QR code, you will get to the GitHub page of this library, try it out, share your feedback and don't forget to leave a star. You can also check out my GitHub page and you will see the projects that I mentioned earlier If you already have done something with internationalization you probably know that's not that easy to work with. And I'm planning to start a new project that's called Pipeline 18N. And it's just an early draft. I think it tries to solve a lot of issues that we currently have with I-18N and tooling. and right now I just shared some ideas and if you care about i18n, please check it out and share your feedback. Thank you. Please follow your questions. Or should I return to my place? Maybe a quick question. Can I use exceptionally inside my JavaScript files? Yes. I should still get the... In the end, VS Code provides the language server, and also if you just write regular JavaScript code, if a library you use has some type definitions, it will also help you there. Yeah? So you mentioned that try-catch doesn't work in Async or Wade. Yes. but I've been using that for years so this is like a I mean this is like a TypeScript thing because it definitely catches no it does not you will get an on-card promise exception but it definitely catches I've been doing that since 10 years maybe it's the way it's not I tried it maybe if you re-throw so I'm definitely not in a context of TypeScript I'm definitely throwing I'm just setting some stuff I tried it before I made this this presentation please don use the JavaScript SDK I mean you always have to wrap it in an async function Yeah Async Yes, exactly. So you use a statement afterwards. Async. So you have to do return and wait. Oh, that's probably. I was thinking the same because I was using Tricast for async for like really long years. I'm like, well. It works. I hope it works. You need to wrap the tri-catch in an async function. I mean, this, of course, will never... Really? Ah, okay. Then I got something wrong. Sorry. I mean, the tri-catch has to be in an async function, and the weight has to be in there, exactly. Good. Okay, let's try it. Okay, my bad. I probably forgot the await somehow. Yeah. I was really afraid. I was going to go hard. A good way to catch everyone's attention. No pun intended. I mean it's still really valuable to have a list of the exceptions that he's throwing and take all of them separately that is amazing this is the key point the implementation detail inside add another throw you never find it and with this you will find it I mean that is the key take yeah I've refactored a bigger application and I caught a lot of errors because a lot of bugs because of using exception. That's why you have to use sentry. Okay. Thank you. Thank you.