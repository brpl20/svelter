 So, you want to pick a router? Well, hello everyone and thank you for watching this talk. My name is Alessandro Segala. During the day I work at Microsoft on the Visual Studio Code team. Today, however, I'm here in unofficial capacity as in my spare time I've been building and maintaining a few open source projects including Svelte Spire Router, one of the most popular routers for Svelte 3. In September I also published a book called Svelte 3 Up and Running, which is a great introduction to Svelte 3 for building static web apps and deploying them. You can find me on Twitter and GitHub at atitalypaleale. So what does a router do? Well, the first and most obvious thing, a router determines what is the view that is rendered. Let's say we're building a library app that shows a collection of books. Our app needs two views, one to show the list of books and one to show the details of each book. When you click on a book on the list, you go to the books page. So why do we need a router then? Well, I mean, of course, that could be done just with a global state variable, like in this code that you see here. The problem is, besides this being a little bit ugly, this can also turn into spaghetti code really easily. But aside from the quality of the code, there are a few other issues that are not less important. In this code that you see here, the state is kept in memory, in a svelte store. This means that there's quite a few things that we are not able to do. We cannot go back using the browser's back button. We can also not open a link in a new tab because the state is kept in memory in a specific tab. We cannot refresh the page and go back to the same view as before automatically. And also we cannot share the link with someone else because they will not have our state in their browser's memory. So what routers do and should do is keep the state in the URL. That is, when you are building a multi-page app, I would say it is self-evident almost the way that the state is kept in the URL. In this case, for example, assume we had a bunch of static HTML files. Maybe they could be generated in the server, but that is irrelevant. If our app were a multi-page app, we would have an index.html file, and then we would have a set of pages, for example, in the books directory, and we will have one file per each book. In this case, the file system does the quote-unquote routing, but the state is kept in the URL, so we can hit refresh, we can use the browser's back and forward buttons, and we can also send the link to someone else or bookmark the page, and all of these things will work. So it's doing everything that we want it to do. The question then is, what about when we're building single page apps or spas? Of course, you can build multi-page apps with Svelte, and that's totally fine, but most of the apps that are written with Svelte tend to be spas, because that's what developers are building nowadays. As I'm recording this, there still is not an official router for Svelte 3. Of course, there is Zapper, which does integrate a router as well, but Zapper does much more than just that. Zapper is a full framework in fact. Aside from those who are using SAPR, when you're building a spa with Svelte, you do need a router. By the way, I know that an official router is a common request, and Rich himself said that they are looking into it, but so far we need to rely on third-party options only, and there's quite a few of them. Before we get into seeing a demo of how to implement a router, we need to understand how we can pick the right one. We spoke about how the state needs to be in the URL. Well, there's two ways of doing that. The first one is to use the HTML5 history API which was introduced many years ago with the earliest parts of the HTML5 standard It works even in Internet Explorer 10 so browser support is not really an issue here. On the other hand, however, we do have hash-based routing. The History API works by creating, I'll call them, synthetic URLs, something like foo.com slash page slash two. These URLs don't necessarily need to exist in the server. In fact, you might have a single index.html file in the server that contains all the views. In fact, that's a single page app as part. And all the fake URLs or synthetic URLs are mapped to it. This makes the URLs also SEO friendly because the URLs look normal and users normally don't have a way to tell that the route is synthetic just by looking at the URL. With hash-based routing instead, the state is kept in the fragment of the URL, which is what follows the pound or hashtag symbol. You have an index.html page which, if it's index.html, of course can be omitted, so it can just be foo.com slash pound slash page slash two. And that page, that index file or whatever HTML file, contains all the different views. So HashBase routing has been around, I would say, forever, and it relies on the fact that for the longest I can remember at least, browsers have added a new entry in the history stack when the fragment of the URL changes. So with a little bit of JavaScript magic observing the pages fragment, it's possible to implement routing for client-side apps. I don't know if this was done on purpose, like this fact that adding a different fragment changes the history stack. I don't know if they did that on purpose when they decided to implement fragments in browsers, it works and people have been doing that for a long time. Like I said with hash-based routing, the URLs look a little bit less nice. In fact, you have something like foo.com slash pound slash page slash two, which doesn't sound as nice. They're also not really good for SEO because search engines like for example Google or Bing cannot really index these pages properly. So if they're so bad, why are we still talking about them? Well, when you use the history API, you're creating synthetic URLs like we said earlier, that only exist within the client and the app that is running in the browser. For example, assume you are in the page foo.com slash page slash two, and there is no really file in the server called slash page slash two slash index.html. What happens if you hit refresh on the page? Well, unless the server supports this scenario and can redirect users to your SPAD, knows that the route is synthetic and so it has to send users back to the index.html file, you would just get a 404 error, like a page not found, because the page does not exist in the server. So hashed-based routing still has a reason to exist today, as it's the only one that works on object storage services such as AWS S3 or Azure Storage or GitHub Pages. When you use hashed-based routing, your app can also be cached better by a CDN because the CDN doesn't know about synthetic routes, so when you try to refresh the page, even if the server responded with a synthetic URL and returning the index file, the CDN doesn't know that, so it will cache another page and then users will keep requesting page and it's just a little bit more bandwidth and more resources that are used. Hash-based routing is also the best one when you want to use things like Electron. In fact, the History API doesn't really work too well in Electron. To recap my recommendation is that when you want to pick a router you should pick the History API or a router based on the History API if what you building is a public site where every page should be indexed by search engines For every other scenario, for example, software as a service app like SAS, I would argue that hash-based routing is a better approach still today. And even though hash-based routing is older, it doesn't mean that it's outdated or deprecated. In fact, thousands of apps that are being built today, in these days, use hash-based routing, including Gmail. And if it's good for Google, it's probably good for all of us, too. So let's look at a code demo on how we can implement routing using SvelteSpa router. Okay, so let's see this in practice. We have an application here, which is already the skeleton for our library application. This has a few different Svelte components already created. The app component is the main one, and then we have this list component that shows the list of every single book in the library, and we have a book component that shows the details of an individual book. In this specific case, because this is just a demo, the list of books is in a JavaScript file, and it's just a JavaScript object, but normally you would, for example, import that from a RESTful API, making an API call. But for sake of simplicity, let's just use this object. So if I launch the application now, as you can see, there is nothing in the main view. So I'm going to run npm run dev to start the dev server and open it in my code space. And you will see that right now there is nothing here. So when this loads, there will be no view. So let's start populating this. The first thing we need to do with Svelte Spy Router is we need to add a routes object with a list of every single route that we want. This is done in, for example, a routes.js file, and we're going to paste in here the list of the routes that we want to use. This one is exported a JavaScript object that says that for the main view, so when there's nothing else in the URL, we're going to show the list component that shows every single book. Then we have a route here which has a parameter, and this is slash book slash ID. So everything that starts with book and then has an ID will show the book component and will show the details of our book. At the end, we're also adding a not found route and this is using the star symbol and this is a catch-all. So if nothing else matches, then our router will show this. So it's a sort of 404 not found page. Okay, so let's actually add the router now. So in our app component, we are going to first import the router from the the SvartSpyRouter module installed from npm, and then we are going to import the routes object that we just created. This is... I apologize. And then in here, in the main view, we are adding the routes component and passing the routes object as a prop with the same name. So right now, if I go back to our dev server and refresh the page, you should see that this will start showing the list of different books. And here they are. If I click on something, it will not work yet because we have not implemented navigation, but this is already something. So, let's look at navigation. When we have hash-based routing, navigating between views is literally just as simple as making a link to something that starts with the pound or hashtag symbol. So, We're going to make this one, which is the link of each item in the list, a link to pound slash book and then we going to add the index of the item that we iterating on This comes from the books array that you saw earlier and we going to use this as the ID of the book Let save this and then let refresh and now you will see that I can click on one and I am going to the page of the book. There's nothing that appears right now because we have not actually implemented the code that takes the ID of the book from the URL and uses that to display the details. We're going to modify the book component, and we're going to get the parameter ID that, as you remember, we defined in the routes object. We're going to get that and import that so we can use that. The router passes the parameters through a prop called params, which by default doesn't have any value, so we're making it as an empty object. Then we're going to get the id that is a property inside this object. There is one caveat, which is that everything in the dictionary is a string, so we have to convert that to a number because we want an integer to use as a key for the books array, as the index of the element. So now, after saving this, if I refresh the page, you will see that I already have book one, and I can change the ID to see another book in the library. This is already working, so if I press, for example, a browser's back-end forward buttons, I can already navigate between the history stack. There's just one more thing that I wanted to show you. We have seen how to create links that go back and forth in the application and allow us to refresh the page. I can go here, refresh, and you can see that this will load the book where I was at a moment ago. But what if I wanted to navigate programmatically between the pages? One of the simplest examples is I want to create a button that brings me back, no matter where back was. So it's like pressing the back button in the browser. In order to do that, we are going to use the pop method that is exported from the router. So let's go back here and let's import pop method from the router. So this method, when invoked, will just send the user back to whichever page they were in a moment ago. And we're going to make this back button send users back when people click on here. So we're going to add a handler and make it a pop. And let's save. And now if I refresh the page and I click on back, I will go back to wherever I was before. So like I said before, if I change the page and then I click back here, then I go back to the previous page. So when you use Veldspare router, there's a lot of different options. It's a fairly basic router and it's trying to be as simple as possible, but there's quite a few options. You can find the router instructions to use that and the full documentation on github at italipaleale.com. So thank you very much for watching and I hope you enjoyed the talk and the demo. You can connect with me on twitter at italipaleale. You can also You can also find my router on GitHub at github.com.italypaleale.svelte-spa-router. In there, you can also find docs and more samples. Lastly, you can get my book Svelte 3 Up and Running on Amazon for an end-to-end guide on Svelte 3, how to build static web apps with Svelte, and how to deploy them to production, including adding automation with DevOps tools. So thank you again, and enjoy the rest of Svelte Summit.