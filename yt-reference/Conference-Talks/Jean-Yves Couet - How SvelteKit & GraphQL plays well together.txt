 Thank you. Thank you. Welcome ladies and gentlemen to the greatest show on earth, on the web, on Svelte, at least in my bedroom. I'm Jean-Yves, your French tech magician, and today at Svelte Summit, I want to show you how SvelteKit and GraphQL plays well together. But before we start, let me assure you that there is no smoke, no mirror code. Here, we don't summon rabbits from hat, but data from server. And I will tell you that this is magical. Hocus Pocus, keep your focus! But before we start, is there any alternative to GraphQL? Maybe REST? Maybe GraphQL? Maybe something... . Dig into it. First we slide and with the architecture. So most of us have some endpoints with some data or something else, whatever. And with Velt we were doing a lot of CSR going to a REST endpoint And this REST endpoint is doing hopefully some business logic to retrieve some data and displaying it on the UI With REST the good thing is we are able to have a UI representing the data or being able to play with the data without any browser interaction or Svelte interaction It's just about the data. And then when SvelteKit arrived, we were about to have this SSR, meaning that we can get the first page with the HTML already with the data. All right. What's the deal now with GraphQL? GraphQL is about the same thing. So in the end, it's replacing REST. We have this GraphQL endpoint, and then we have a GraphQL to explore the data. All the REST is very similar. We have the SvelteKit story where we can do SSR, and the Svelte story where we can do CSR. So it's really about the same thing. First thing, let's have a look at this layer of browsing data. For this, I will go to the SvelteSubmit endpoint, and I prepare the two. So the first thing is the REST swagger. If I go to the REST swagger, we can see that we have a REST with tasks and categories. And maybe if we look at tasks and we try out this task, execute, and then we get a big JSON of a lot of things. So hello endpoint, check the tire pressure, and we can see maybe a category with an ID, a strange ID here. But at the beginning, I saw that there was a category. So if I go get categories, try out, execute, and in here, I have two answer, tech and bicycle. Ah, now it makes sense to check the tire pressure on the bicycle. Okay, so now that we can see data, let's see if we can post data. So to add a category, for example. If I go here, I'm able to see that it requires a name. And let me try it out. So if I put the name on rest, for example, execute, I see that it's executed successfully. And then we have the name rest with a new ID. And if we come back now to the get part and execute, we should see three elements, tech, bicycle, and rest. Okay, so we are able to see data and to update data or mutate data. Very good. Let's have a look now at the other part. And I think we'll come with with another UI, let's make it bigger maybe, where we can see GraphQL Explorer. And with the Explorer, we're able to see what is all available on my endpoint. And we can see again categories and tasks and other things. So let's have a look at first the task, for example. And when I click here, you see that it's building my query in the middle. Task, items, title, for example, and I can execute my query. And in here, I can see only the title, which is what I requested, nothing more. This is already the big difference that we can see between REST and GraphQL. So we were able to see before as well the categories. So let's have a look at categories, item, name. And if we hit, so let's remove the task. If we hit enter here, we're able to see tech, bicycle, and rest. Good. We are able also to mix and match things. So if I come back to my query in the editor itself I don need to click on the left part In the editor itself I can do a control space and I will have auto everywhere So if I do again task open bracket item open bracket here I can see the title like we did before But now we can get maybe the category of it. So if I control space, I can see category and in the category, I can display the name. And now I can see that hello endpoint is from the tech category and all the rest is coming from the bicycle. Okay, I have a lot to do in bicycle part. Now let's have a look at how to add data that we added like we did before. So if I go back to categories, items, name, we added the rest here. Let's add now the GraphQL. So I do a new query here, and it's not called a query, actually it's called a mutation. And if I create an operation that looks like a mutation, I'm able to see here create category, and I will give some parameters. It needs an input. In the input it needs a name, and I can put GraphQL. Every mutation needs to return something, so it will return the category normally with the name, for example. Now if I execute this query, I can see GraphQL, and if I go back to my previous one, and if I run this, I can see the four options. Okay, now we can see that we can grow the data in both worlds, so in REST and GraphQL. So we're able to grow the data. Now we have SvelteKit, which will deal with component, route, and everything, and we have GraphQL, which will speak the semantic of the data. And to close the gap between the two, we have a library called Houdini. Let's first initialize our project and initialize Houdini inside of it. So I open my comment line and I create so ntm.p-skeleton-at-latest-it-graphqr. Under. We want a skeleton project, we want it in TypeScript and we check everything. CD, kit, graphqr, boom. And now we have our code editor. We've got everything and let's do an init first directly after creating the project init. Save. We will install everything. PMI. PMBet. Okay, let's check now if it's working. Okay, good. It looks like it's working. We have a welcome to SvelteKit. Perfect. Let's continue a bit to tweak this first example. So if I go to route, here I can create a plus layout.svelte. That will be a little for us to navigate through things. We can just remove here. And we can put the page 2 here to say it's home. In here we can put a slot, say we have home displayed and in the A plan you can say, welcome to kit.ql. Okay. And let do we can put the title So it kit Okay we don the title but that fine And the most important part we can add the default CSS which will tweak all our elements in a nice way in dark mode. Okay. So now that we have most of it ready, so tweak, done. Now that we have everything ready, let's add Houdini. So to do that, I will do a npx, Houdini, Houdini, init, enter. And it will ask me, hopefully, if I have a remote Kafka endpoint. Yes, in this example, I have a remote Kafka endpoint. And you remember before, it was something like this. So localhost, API, Kafka, you will. Enter. Very good. Let's do nothing here. We have a few files created. Let me check this file. So something in the Git ignore, because we generate some part. Something to help the code, the configuration of Kootini itself, some documentation about the package, the schema, so the contract between the client and the server. And we'll come back to this later. We'll update the self-config to have Kootini working with it. A few TS config tweaks so that we have better typings. And then finally, we'll do the client. So we do init, Kootini. So we do pnpmi. to install the latest of everything. OK, very good. Now, if we pnpm dev, we should see our site coming again here, live. Yes. And we can see that there is no operation found. Everything is normal. Now that we initialize everything with Houdini, let's grab our first data. And to do this, we have this special page.gql to speak only about the data. So let's go here. We know that we have in route the plus page.svelte, dealing with the svelte component, the route component. And we can create another file called plus page.gql. And in this file, I can do query and open the brackets. And here I have exactly the same experience as the GraphQL we saw before. Autocompletion through the server, through the endpoint. So if I do query categories, and in categories I have some items. In the item, I have a name. And in here, I just need to add the name of the query. So it will be categories, for example. If I save this, now Houdini is telling me, oh, there is something new coming called categories. Good, so we seem to have data. How to bring it now to the plus page itself? Exactly like what we do with the data in the usual component. So I open the script tag here with the line TS because I'm in TypeScript. And in here, usually I do something like this. So let's do a bit of space here. So I import page data from the type and export the data from page data.

 we work with Houdini, we don't import from $tile, but $Houdini. And by doing so, in here, I can see that we have data categories. And the category is a store directory. So if I go from space here and I get the category, at this level, I'm able to say already, so let me have a look here. I want to get items. And the items will be the store. So $categories.data.categories.items for nothing. And you saw with this already that everything is typed. So in the home, I can do a for each. And on each items, I want to say it's category. And in there, I will have like a P tag, for example, category dot. And in here also everything is type. So I have only the name available. And now I save it. And boom, I have my tech, bicycle, race, and off. Good. Now it's good because we are able to get the data. Let's have a look with parameter how it looks like. So you remember that in each category, we have a few tasks. So maybe we can create another route called task of category. category. And the category here will be the ID of the category. So we can do task of category and maybe a dash here. In here, I'm going to create a file called first page. . In here, I have my list of tasks. Let's see if we can already navigate to this one. So in here, instead of just displaying the name of the ID of the element here, I will put the href, sorry, like this and I will come here bring this guy in the middle here so now it's a link and in the href I will do slash tasks of dash and we do one two three here save now everything is a link if I click here I have a list of tasks and I can come back let's just for convenient reason bring a link here. So I do link to home, so it's with a home, and the href is like coming back here. Okay, so I can go home. I go tech, home, tech, home. Very good. Let's close this one. And now we need to bring here the ID of our category, right? But in the category, we get only the name. So not a big deal. Let's go back to the plus page.gql. And in here, I want to get the ID again. So if I save this now, so the category is updated, as you can see here. And now I can come back here, And instead of the ID here, I see that I have ID and name. And instead of the hard-coded ID, I can simply add here item.id. It not item of course It kate Save And now if we go here we don see because the URL is too big but we see that we have an ID here OK So it looks like it's working. Now we go to each page, and each page has a different thing. But now how to bring the data? Then we do exactly the same thing that we created this plus page.gql on one side. We'll create this plus page.gql on this other side. So plus page.gql. And in here, I will do also a query. And the query, I have my category. In my category, I want to see the task of the category, for example. And in the task of the category, I have a few items. In the item, I have the title. So here, I have to name my query as usual. So task of category, for example. And it's telling me that there is something wrong here. Yes, because a field category needs an argument called ID. So let's add the ID. And the ID will be something. And this something is coming from the URL. And fortunately, if we have this parameter here, it's already available in our plus page.jql. So if I do dollar category, This will be a variable, and it's a variable that will be sent from the top of the query here. So like this, this variable is coming here and setting it to this category. And then if I save this, I have now this new task of category coming from Houdini. And if I go to my plus page.svelte, where I have my list of tasks, same thing as before, I would do my script tag because I want to get the data. I have my little snippet, page data. Instead of coming from type, I do Houdini. And in there, in the data, I have already my task of category. task of category, I will do the same trick. Items equals to task of categories. No, not this one for sure. The dollar one dot. And we have already a lot of things here. The data, the category, the task of category, the items or nothing. Same thing as before. Here I do each items. So this will be a task. and in here, I should be able to display the task.pilot. Save. Okay, so now if I go to tech, if I go to tech, I have my LO endpoint and if I go back home to bicycle, I have a lot more things to do. Okay, and we have our two other things, the rest in GraphQL. Good. Let's have a look at the network a bit. So if I do F12 and network and in the network type, I check only for the GraphQL API. So I'm on home now. If I do F5, there is nothing about API GraphQL. Why? Because everything was SSR. If I go now to tech, I see that we have one GraphQL request coming here. And this one GraphQL request, we have the data coming back with our task title, hello endpoint. Cool. If I remove this now, and if I go back to home, nothing is happening because everything is cached If I go to the bicycle I have a second GraphQL query coming If I come back home everything is cached so no queries anymore And now if I navigate to tech or bicycle there is no query happening because everything is cached. Cool. A few days ago, someone online said that it's good to define data requirement in a component and fetch it at the route. So now it's what we are doing. We fetch at the route. But we don't have the data requirement in a component itself. Everything is in the route, which is a problem. And I totally agree with this statement that the data requirement should be in a component directly. And it's also what Alec commented, this should be Houdini's new tagline. I fully agree as well. Let me introduce you at the same time Alec, the creator of Houdini. And without him, all of this would not be possible. So thanks a lot, man. Let's speak about component and about fragments. Let me show you the code. In our library, there is nothing today. So let's create something called task.self. The task.self will be empty for now. So if I put just a P here, hello, just just to make sure that everything is wired. I'm doing it like this usually. So instead of the task title, I will just do here task. OK, do the right import, save. And if I go to bicycle, I see my file header. Now let's go back to something with data, right? So now we have to improve our task component to be able to have a fragment inside the component and make it query from the page. For this, I will go to the Houdini website. And in the Houdini website, I want to show you a few things. First thing, if I go to the API doc, I have something called fragment. And in here, I have directly the example of how to use a fragment. So a small cool feature is that we're able to see the code here in GSDoc. And over there, we can switch it to TypeScript. So let's bring all this into my component. So let's make a bit of space here. And instead of having hello, I will just maybe put this one at the bottom. Hello. And not display anything, not an image. So here, I just copied this example. But of course, we don't have this kind of code in our case. So we deal not with user. So let's have a look inside here. There is the GraphQL statement. So of course, when I just copy-paste the code, VS Code is not happy because we don't have an avatar user or anything. But let's focus first at our GraphQL statement here. We have a fragment with a name, and here our name would be more something like task component. This is the name of my component. And this will be on the type, and I can control space here, on the type task. And on the type task, what do I want to get? So if I do control space here as well, we have already also autocompletion, and I want to get the title. All right. Already good. Now, with the task component that was just created, it will create a type called task component So I can copy this and paste it everywhere here Now if I say everyone is happy okay We can see that we export something here called user because it was from the example And in our case it not user of course it task So now we have a task. And in the task, I will want to look into the title. So if I go one step before, this component is complaining because we are missing the task. So let's bring the task. And the task is equal to something where we need to assign the task component. The task component, so let me say task is coming from the task above. and in here of course if I save this it will shorten the thing and it's telling me that the fragment is missing in the route plus page of the query. So if I go back to the route here and I do dot dot dot, I can see that I have one fragment available to put here called task component. And if I save now, I have this coming here and this will be sent to my component and in my task here I have my hello that I can replace by dollar dot dot title save. And now I will my data are coming here. But the magic of this is now this component is fully autonomous. So if I want to display now here title and ID and save, everything is refreshed in the background. And I'm able now to say, whoops, $data.id, save. And my ID is here. And the cool thing is that it's available only to this component. And this is called fragment masculine. So if I go one level above here, where I was able to do this task, the title, in here, if I do dot, I don't see ID. Even if ID is fetched into the component inside here, not able to get the ID here. So I get the title because it's displayed here, so we can see it here. But if I go back to my plus page of GQL, and I comment this title, if I save this, and I go back to my component, it's telling me that the title is not available at this level. So at this level, I'm allowed only the thing coming from the page of GQL, not anything else. So every component is responsible for his data, nothing more. So I can now remove this safety, and then we have our beautiful component working. Make sense? So this was about fragment, and yes, you're totally right. It should be the new timeline of Houdini. You fetch data in your route, and you have your data requirement in your component. Like this, everything is safe to avoid. You can have nested component, nested fragment, everything. Now let's look at a few utilities. First one is about paginate. So in here, you see that that will be overloaded, because I have a lot of things to do in one of the five items. So if I go to this task here, page.jql, at this level here, we have a list of something. So when we have a list, we are able to do an at paginate. If I save this now, it's telling me that, oh, To have a field paginate, you need a limit argument. OK, let's have a look at the limit argument. And I can do a limit. Now, if I save this, I have only two items. Cool. Just with this one paginate, I have two

 Cool. And now if I go to my list of tasks, I can say under something like button, next, for example, and then on click to be able to go to the next page, right? And to do this, I will go to task of category dot load next page. Save. And now I have another button called next. And if I click on it, it's going to the next page. How nice is this? It's only one directive away. So now that we have this passionate directive, let's look at this other directive called loading. at the leaf level, so the task, I want to say that this can be loaded. So loading and loading. OK, save. When I have this loading, now I can do a switch statement at this level. I can do here, if is pending. What is pending? If I have my $.data.id is pending, for example, I will display loading. Of course, you will go with crazy CSS here. Well, not with this, but this. And then else, you want to display something. OK, to have this working, we have from the root, say, I want to opt in loading. So I have to say loading on top here and save it. And if I now go to my network, because my network is fast in my environment, and if I go slow 3G, if I click bicycle here, I navigate to my page to download the JavaScript and everything that is needed. And then I'm able to see loading, loading, loading, and then like two things are common. Good, good, but we know already that we have a limit of two. So let's say here loading, and let's specify the count will be two. And like this, we'll be having exactly the same thing. If I come back to my task in the meantime, I'm able to also put the P tag here so that the loading will be in the same place as the title and ID here. So I go back to fast network, home, F5, and now I go back to slow3G. And if I go to bicycle, now this is downloading my JavaScript part, then moving to the next page. I have my to loading, and now when my data is back, I have my check tire pressure. Everything is just adding this loading directory. You see that we have two distinct things. One thing is about Zodkit and the component itself. The other thing is about data and semantics of data. And here we say, data can load. OK, very cool. So now that we are able to load things also in a pretty granular manner, let's have a look at how to mutate data and add information. And for this, we will create a new category. So for that, I will create a new component here. So addCategory, for example, . And in this addCategory, I will have an input of type text. I will bind this value to name okay And then script yes I will have let name is nothing okay, and I will have my form. In my form, I have a button, add, yes, and then I do it on, submit, submit, on, submit, recall. OK. So now if I go back to my page and I add at the bottom here this Add Category, Save. I should have this coming here, so of course not to be able to do it. So we can say New Thing, Add, and it's removing the new thing. It's not adding here because we didn't do anything. So now let's add here the mutation. And for that, we will do let add, and we'll do equals to GraphQL, and the GraphQL coming from Houdini, and we'll open our template tag. And in our template tag, it's exactly like the GraphQL we had before. So I can start typing mutation. We do add category, for example. And in there, I'm able to write down my mutation of create category. And you remember that it needed an input. In the input, I need a name, and the name will be of $name, for example, which will be the title. And then I need to return something. So if I return category name for example, and so since it needs the dollar name here, I need to pass it as an input and it will be a time frame. If I say that, you can see that Houdini creates me the add category and the add category now is a mutation available. So if I come here and say add dot, I have this store where I can mutate thing. And in the mutate, I can do control space here and you can see that you have the viable name. So in here, if I put the name, then it will mutate with the name. Let me save this and put an R wait. So I need an R sync. All right, all this should be good. So from cell kit. And if now we refresh, we have something coming from cell kit. OK, everything good, but we need it to refresh, which is not the best experience ever. Moreover, that we have one list here coming with a name, and we have another list coming with maybe other fields. So let's have a look at how to deal with that. If I go back to my plus page.gql, Here I have my list of items with the ID and the name. And under items here, I can add list and say that this list, the name is called L underscore category for the list of category for example If I say that it updated this of course but it will update something else as well But it will update something else as well So if I go back to my add category in here I'm going to say dot dot dot, LKT, which was the list that I created just before, insert. And if I say that, it will refresh everything, of course. And now if I do, let me open this in big, for example, so I have no request here. From start kit number two, add. And now, with only one GraphQL request, we can see here, it's only one GraphQL request, which was the mutation category. We also filled the list here. So we don't need to do a F5 anymore. It's already appending into the list with just this little fragment here called with the name of the list, underscore insert. The really cool thing as well is that if I go back here to this plus page, I can improve the requirement of this thing here. And maybe say in here, I want to see also the total count of task category. And it increased the number of things I want from the fragment. And in the page here, instead of just displaying the name, I want to display also the kt.taskCategory.totalCount. If I say that, now I have the number of tasks in each category. And now I didn't change anything in my mutation. So I can do form cell kit number three, add. It will directly do the mutation, for sure, and do the query with this total count included. So you don't need to think about, oh, this list has this number of data. Now I have to return this or that. Everything is self-contained. Everything works with component. Everything works together with fragment. Fragment is one of the biggest thing on GraphQL. Of course, in here, you can have a font. Result equals this. And do it log result. And if I log this result, and if I do a, for example, add, you can see that the data category, the category is new. Why is it new? Probably because we got an error. So in here we can say, not only category, but I want to see error. And error, depending on the type name, so on error, I want to see the message. And if I now trigger again the A, enter, I'm able to see that data, create error, we had an error, name is too short. so my server doesn't accept one character. Okay, so now we can extract this for sure in a separate logic and do something around the name and the name is too short All right so one good thing is also about this one schema which is somehow the contract between the client and the server So let go back here and let pretend that in our backend someone is changing something, a field, which sometimes happens. And I don't do anything on my client code. And Houdini, which is checking the schema from time to time, tell me, oh, cannot query title from the type task. And fortunately, if I go to my div here, I can see directly that, oh, yeah, in create task input, it doesn't require now a title but a title name. And you can see that, yes, it seemed that the whole title was renamed to title name. So either you go to your backend team and say that, please do something. This is a breaking something. But you are unsure about consistency. And this is the key point. You want to have this consistency. And you want to be aware, as soon as there is something inconsistent, it's not just preying on the runtime part that the return of a fetch doesn't return title anymore, but title name. All right? You heard probably about another topic called persisted queries. What is it about? I think there is two angles to see that, or three or four. The first one is about security. One thing is that you don't want to enable anything from your endpoint, right? Because a customer can do very nasty queries, very, very deep and everything. So you want to avoid this thing. And doing so, you have to enable persisted queries. Like this, the server will be able to answer just with an ID, with a hash. And fortunately, if you go to this $Houdini, you have this persistedqueries.json. And in there, we write down the list of all the queries possible in your application. And you can see that ad category, categories. And everything is now an ID or a hash. Now you just need to give this to your server, and you need to allow this to your server only being able to execute these three things. So it's two advantages. First one is security, because you need to know the hash to be able to execute something. You cannot execute a random thing. Second thing is about the weight of what you transfer from your client to your server. Now you don't need to transfer the full query, which is quite light. But now you just need to transfer a hash, which is also a nice benefit. And then, of course, I cannot leave without speaking about the very famous GraphQL N plus one issue that everyone is talking about on Twix. But let me tell you something. It's not a GraphQL thing. Let's have a look at our example. So we take our architecture, and over there we have tasks and categories, right? With GraphQL, when we want tasks and categories, we will do something like this. So we want all the tasks, and then the items, we want the title. And then for each task, we want the category and the name. This will be sent to the server, and over there we'll have a few queries. The first one we select on the task, and then we have as many select from categories, we have the ID of the category that is here. This is what is called the N plus one problem, because yes, you can get a lot

 of SQL queries, which is not that good. So let's have a look now at the REST side of it. I put in place some Soda code here. So first we get the task and then on each task we will get the category to get the name. So first request will happen here, then we go back to the browser and then we do multiple other requests to get the category name. So here we have even a bigger problem, I would say, is that the N plus one issue is a network issue and an SQL issue, while in GraphQL it's only an SQL issue. Of course, it's not what we want. But everything about this relates me to this very famous thing. I think that we will arrive to n plus one issue very fast. So people from the REST side will tell me it's easy, just create another endpoint called task and category. And yes, it's true. On the front end, now you have only one thing, and then we will fetch this task and category, and this will result in one very nice SQL statement with a from and a join, and this is the most optimized thing. Very good. Now on the right side, on GraphQL, are we stuck with our SQL queries? Actually, no. There is already the traditional data loaders, where it will not go down to one SQL query, but to two, which is probably good enough in 99% of your cases. If you want to know more, there is a Datalodder 3.0 talk that was done by Jens from Wondergraph. Actually, it's rethinking about how to use Datalodders. Very interesting talk. And then there's another initiative called Graphas from Benji, where at this level, he's able to go to this one SQL statement with a joint. So pretty good research. And if you see, it's at the bottom right, meaning that all this happened on the server, meaning that on the front end, there is zero change. And this is the best thing out of it. When you have a struggle with performance and data and something, you look into your server and optimize things over there. But on the front end part, no change. So you require all the tasks and the categories the same way. And this, I think, is a huge benefit. Thank you very much for listening to all what I had to say. If you want to come and join the conversation, go simply on Houdini on GitHub, and we will be happy to welcome you there and teach you all the stuff about GraphQL. Thank you very much again, and have a nice end of the summit. Bye-bye. Okay, can we rest a bit? At all stops or so.