 The Svelte stores allow you to easily manage state within your application. Svelte also allows you to create your own custom stores where you can leverage Svelte's reactivity to manage data however you like. In this video, we'll show how to use custom Svelte stores to transform data to and from local storage and illustrate a couple of use cases. First, a quick review of Svelte's two-way binding. Let's create a text input and bind its value to a variable. Now, let's move the variable out of our component and convert it to a Svelte store. Note that to reference a store, the only change required is prepending the store name with a dollar sign We can now create other components that will react to the changes to this store Now let's create our own custom store, which we will use to write its value to the browser's local storage. First, let's implement Svelte's store contract in an object to make our own store. Custom stores must adhere to the store contract and supply a subscribe method and optionally a set method. Here we will use Svelte subscribe method and wrap Svelte set method. Now that we have our custom store, let's maintain its value in local storage. When the custom store is created, we'll set its value to the value in local storage, and the value of the store changes, we'll write it out to local storage. Okay so we able to store strings in local storage but what about objects LocalStorageGetItem and LocalStorageSetItem write UTF16 strings not objects so we need to adjust our custom store to handle transforming data on read and write We'll do this by supplying an array of functions to call on our data when we write it to local storage, and another array of functions to call when we read from local storage. We'll use JSONStringify to convert the object to a string for writing, and JSONPars for converting the string to an object. So we can see what's happening, let's show our object on our component and create a way for the object to change. The store will react to the changes, transform its value according to our functions, and write out to local storage. As you can see, our store is transforming our new values and writing them to local storage on each change. You may be wondering why we used arrays of transformation functions in our custom store. This is so we can chain transforms together. Consider an example of compressing objects out to local storage. First we need to transform our object into a string, then compress the string, and then write to local storage. We use the LZString library to perform compression and decompression and adjust our components so that we can see the results Note that our interface to the store hasn changed at all We get the value of the store by reference, and store a new value by assignment. Svelte handles everything else. While this reactivity is very convenient, be careful when doing too many assignments. Each assignment statement here is picked up by Svelte as modifying the store, so each of these assignments will call our set method, meaning in this function, each of our two objects calls set three times. A better way would be to make a single assignment to the store. You could also handle this in the store itself, perhaps by debouncing the set call. How you solve this is up to you. While this example uses local storage, there's no reason why you couldn't put an endpoint call in the store, so that values are persisted to the back end of your application. In this video, we showed a simple way of transforming data into and out of a custom Svelte store. For more information on custom stores, check out the Svelte docs on svelte.dev.