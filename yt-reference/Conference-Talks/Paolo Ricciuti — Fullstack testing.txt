 Welcome to my talk, Full Stack Testing. Before we begin, a quick presentation. Who am I? I am Paolo Ricciuti. I come from Campo Basso, Italy. You can find me on Twitter as Paolo Ricciuti, on GitHub as Paolo Ricciuti. And I'm a proud Svelte ambassador. I'm generally a nerd. And I work as a full-stack software engineer at Made Matter, which is super cool because I get to work with Svelte, but also teach Svelte because we do a workshop. But most importantly, because we do team augmentation, which means that we work with you on your Svelte project and we also teach you how to work with Svelte and stuff like that. So, let's begin I know that you are scared Because I just dropped on you The most fearful word In web development world Full stack testing Especially testing But bear with me And I know that you are already asking Why? Now, if you are working on a library You should definitely test your library No point But if you are working on an application I would assume that it's still pretty good To test your application So, let's play a game I will show you this, which is a diff from GitHub. And what I want you to do is tell me if this is a bug or not. Now, if you are following along on fullstack-testing.rechuti.app, you can just click here or here to actually get to the page to vote. You can actually just go to this page or scan the QR code. and if Kevin is following along, he should have put the result of the vote here because, I mean, this is actually recorded so I cannot show it to you, but I can enjoy it to you to see the bar changing. You need to press yes or no if you think that this will introduce a bug or not. And so, yeah, I will just give you a couple more seconds. So will this introduce a bug or not? And I really hope that you voted yes because yes this is actually introducing a bug If you want to react to a prop changing you actually need to use derived You cannot just use let trimmed name And I mean, this would never work with Svelte 4. So yeah, this is actually a bug. It was a pretty simple one. You can now click on next if you want to go to the next question. So let's move to the next question. This is a simple component. It's just a button with a user list. When you click user list, a user list will drop. and you added asvel transition because you want to do something cool. And now you're adding asvel transition.slide global to this. So will this introduce a bug or not? And I will give you a couple more seconds. And no, this is actually fixing a bug. Yeah, because the transition global means that even if the ul, in this case, is removed from the DOM, the transition will still play, while with a local transition, only if the li is removed from the DOM or added to the DOM, the transition will play. Yep, next question. This is an interesting component. Basically, you just drop it in your plus layout.svelte on the root, and you pass it the page that the user are in, and basically it's just an effect that send a navigator.send beacon, which is just a post request to the page, to this selection analytics that contains the data of the page. So in the beginning, it was like this. You then thought, well, maybe I want some information on the user. So you added inside the effect, a fetch call to get the user ID. You are also using a controller because you're a good internet citizen and you're adding the profile to the beacon, basically. So will this introduce a bug? and a couple more seconds and I really hope that you voted yes because yes, this will introduce a bug and the reason is because effects are synchronous by nature so you cannot use a synchronous code inside them you can actually do it but you have to be aware of the fact that only the variables that are accessed before the first await will actually be tracked as a dependency In this case, we are tracking user ID, but we are not tracking page anymore. That's a bug. Let's move to next question. And please ignore that this could have been done with Svelte window it just for the sake of presentation So there is an effect and you basically remove the window inside the effect You move the listener outside of the effect and you add that the window.eventListener to that function and then return it the window.removeEventListener. Is this a bug? I'll give you two more seconds from now and no, this is not a bug. This is actually fixing a bug. You always need to clean up your event listener, otherwise it will stay there even if the component is unmounted. So let's move to question number five, and this is one of my favorite. I can imagine the commit message for this to be like clean up code base and stuff like that. And the component is pretty simple. It's just an input and you want a minimum of 10. Like it's an input number, you want a minimum of 10. So on input, you're actually saying e.target.value as number. You're storing that in a new value. And then you're assigning to value between mat.max from new value and 10. This means that if new value is less than 10, you will assign 10 to value, basically. And again, ignore that this could have been done with mean attribute on the input. I will give you a couple more seconds for this. and I hope that you voted yes. This will introduce a bug. I know it's crazy, but basically what's happening is that if value is already 10 and you try to assign 10 to it again, effectively the value didn't change. And if the value didn't change, Svelte will not do extra work for you. Like why should replace something that is already 10? But this also means that it will never say input.value equal value. And this means that if no one does that, when you click the keyboard with the down arrow, it will just continue to go down. So, yeah, obviously never do something like this. Write a comment or use, don't say please work. But, yeah, explain why this is working. working and the reason why this is working by the way is because you are changing the value of value before re 10 so yeah let move to the last question so you are importing locale which is a store and locales which is a list of locales and get system locale And the reason why you doing that is because you also want to add a way for the user to select the system locale So when the user selects system locale, you add a button and you set locale to undefined, and then you change the current locale to handle the fact that it can be undefined. So will this introduce a bug? I will give you again three more seconds, and I hope you voted yes, this will introduce a bug. And now I hear you shouting, what are you talking about? And the reason why this is introducing a bug is because the store was using another part of the application, and the other part of the application was sure that it will always be defined, and you're introducing a bug. Now, I know that this is kind of sneaky, it's kind of tricky, but it's exactly the point that I'm trying to make. The more your application grows in size, the more it becomes difficult. Just like this wonderful screensaver from Windows 98. The more time passes, the more your application interconnects, the more it grows in size, the more difficulties to reason about. That's why you should test even your application code. So let's stretch out and let's start this journey into seeing how you can test your application in SvelteKit. But before we do that, a couple of things. One, 100% coverage is a lie. And I mean, this is true for coverage in general. Like, don't trust an application just because it's high coverage. You should not aim for a number of coverage because it's just a metric that will be gamed. So the thing that you should do is actually just test with your gut. So, and second, I will use opinionated tools here. This does not mean that you need to do, to use exactly my tools. This just means that you need to find a way to do the same thing with your tools. Pretty easy, right? Now, let's move back in time to a place where people were starting exploring, fire was discovered and like this beautiful painting were painted on the wall of the cave. And in this era, in the web development world,

 be used to build SPAs, or single page application. Now, in this era of single page application, everything was easier. Like, for testing especially, it was very easier, because the only way to access your data was through fetch. So, you could just do something like this. Like, if you are in testing mode, you just change window.fetch with a custom function that will return your mock data based on the URL and maybe on the init. But nowadays, we are in the era of meta frameworks. We are in the future. There is SvelteKit, Next, Next, Remix, SolidStart, Quick, and by the way, can you tell which one I love? And this means that this was our situation before, where our line was between the front-end and back-end data. and there was a single point where you could go to actually fetch the data. And this is changing because those are full stack frameworks and so the line has shifted. And now you want to test your front end, you want to test your back end, you want to test their integration and you want also to test your back end. And this means that the single point where you need to mock is between back end and data. now let's see what tools we're going to use because there are a bunch of tools and this is because we need to test different stuff so we will use Playwright, Esculite, Drizzle we will use MSW, Vtest and Svelte Testing Library this is because again, testing is comprised of a pyramid probably something like this where unit testing is the smallest unit that you can test you are just testing single functions and those single functions take a value in and respond with a value. And you're just testing that your expectations are met with those functions. Then there is component testing. And I know sometimes, like someone could say, it's not a component, it's actually integration testing. And I might agree, but I think in application land, what do you want to test is actually your components because that's the part that probably integrates with your code. so that what the other thing that you want to test and then there is end test this is the beefy guy This is the complex one but also it the most important in my opinion for application because this is where we are testing the user flow. This is like we are mimicking the user flow and this is where you can very much catch nasty bug. So what's the simplest way to get started on this? The simplest way is just tick those two boxes. If you tick add playwright and add vtest, your vt config will change a bit. So instead of importing define config from vt, you will import define config from vtest slash config. And you will also have this test include. And this just means that every file that ends in .test.ts or .test.js will actually be tested. Will actually be run for test. and this is an example of a unit test you're importing my function you import this helper function from vtest like eat, describe, expect and you can define your test like this so you describe what you are testing and then you start writing your test and it reads like English it works as expected obviously write better than this because I'm just lazy in this case but then inside the test you should have a three point, basically, the setup where you create all your variables and stuff like that, the act where you actually call the function and then the expectation. So when you say in this case, I want my results to be defined. Again, unit testing is pretty straightforward, pretty simple. Let's move to something more interesting. How can you test component testing inside SvelteKit? You need to install something. You need to install testing library slash svelte and testing library slash jest DOM. I know that we are using vtest, don't worry, install jest DOM. And also you need to install happy DOM. Happy DOM is a library that basically mimics the DOM, but in Node environment. You can give it a string and it will render the DOM and you have access to the DOM object model, document object model inside Node. And given that you are running a node, we also need to change a bit inside the bit config. Now the defined config is a function that takes in a parameter in this case mode and returns an object And when mode is equal to test we want to do resolve condition and we want to add this browser condition here And this is basically telling Vtest that when it's running your application, if mode is equal to test, you actually want to run your application just like if it was a browser. And this basically allows, for example, functions like onMount to actually be defined, because otherwise onNode, onMount does nothing. So that was a problem. Do it. The other interesting bit is these setup files. These setup files is very important because it's these two lines of code here. you can actually do other stuff, but those two lines are very important because this will actually make sure that every time you render a component inside your component testing, after the test finish that component will actually unmount, and this is actually adding TypeScript stuff, for example and expectors, so the fact that you can do expect greet to be in the document is actually something that comes from this library, so you definitely want to add it. And then you can test it just like a unit test with VTest. You import the same variables like describe it expect, you import render from testing library slash felt, and this will allow you to import the component and render the component. And after this, what you get back is a series of functions that you can query the document for. So in this case, I'm just checking that after we render that component, we actually have a text Svelte Summit inside it. So we are expecting that greet is in the document. One important bit, you need this. You need to specify your vtest environment to be happy DOM, otherwise there will be no DOM inside this. You can actually do it globally inside your vtconfig, but I prefer doing it inside my files. Now, this is component testing. Let's move to the big beef, right? The end-to-end testing. And if you are just using fetch on the server side, you are pretty much good to go with MSW. MSW is a wonderful library. It's called Mock Service Worker, and it allows you to mock your data on the server or on the client And it used by Microsoft by Google like a bunch of Adobe like really it the industry standard How to use it Very simple You can install it obviously PMPM install MSW at latest. And if you have these inside your packet JSON, where you're specifying where MSW needs to put the worker, the service worker that it will use to mock your data, in this case for SvelteKit, you really want to be in static because this needs to be served from your server and it's a static asset. So you really want to be there. And once you do that, if you do npxmsw init, it will create the service worker for you. And after you've done that, the only thing that you need to do is define your handlers. And so one way to do it is you can import HTTP and HTTP response for MSW And then you basically define an express-like application. Like you basically say that HTTP. You have all the verbs. So you can mock a GET request, a POST request, a ALL. That means whatever you want. And then you specify what URL this needs to mock. Because obviously different URL needs different mocking. And inside here you have the function. And the function actually receives everything you need. receive cookie parameters, which is this kind of here. Like this is a parameter, an ID. Um, and the requests, the request is actually a spec to request. Like is the, the request from browsers and node. And so you can, for example, create the URL, get the search for arms and you return an actual response, like the response from the spec. So pretty cool. And you can return whatever you want. Like this is an HTTP response helper to like return text or JSON or whatever you want, really. And after you have done that, you have defined all of your handles. You can import this handler both on the client and on the server. That's the beauty. Like you literally are using the same handlers on the client or on the server. And for the client, you want to set up the worker with those handlers and export it. for the server, you want to set up the server and export it with those things. And to use them in StartKit, what you want to do is you want to import your worker in hooks.client.es

 and if import.meta.env.mode is test, so if we are in test mode, you want to await the start of the worker so that the worker is mounted before the page is rendered. And if we are on the server, we want to only do that if the mode is test and start listening. And the best part is that given that you are doing this, if you are inside a mode that is not test, this will not be there and if this is not there this is not needed and it will be through shaken away the last thing that you need to do is update your playwright config which also comes from when you tick the playwright thing inside creates that and in this case you want to build with mode test and preview with mode test so that these actually work and this is actually unrelated to MSW but it's something that I constantly do. Pipe your standard error and standard output because you will probably need it. And then you can write your first end-to-end test. It's very similar to Vtest. You expect, you test, and then you can literally destructure a page where you can navigate. So you can do await page.goto, await expect, and then you can get basically the same thing. You can get by role, get by text, get by even a CSS locator. Very, very, very cool. You expect this to be visible and you basically can navigate away. You can click around, fill forms and stuff like that. But this is the happy part. This is if you only have fetch calls inside your application If you have a DB the things change a bit because you need to do a bit more work Now I using Drizzle as my ORM So to set up Drizzle you can just do pmpmi and lib-sql-client. This is the client for SQLite. And you can do pmpmi-drizzle-kit-d. it's a companion library for Dreadle and once you've done that this is basically what you need to do you can create a file where you export your DB handle you can create the client and in this case I'm just using a file so it will literally create a file next to my process named mydb.sql and put everything there but obviously this can come from an environment it can be Turso for example and stuff like that and then you want to create your tables like this and you can import SQLite table or text and you create this export const users and once you have these what you can do is with Drizzle you can actually run your migration so if you run pmpm DrizzleKit generate SQLite this will generate a series of SQL files that will bring your database up to date with your schema, which is super cool. And then you can use TSM, which is just a node for TypeScript file, basically, but you could use ban or you could use like node.migrate.js and it will work the same. And this is our migrate file where basically we are importing the migrator from Drizzle and then we migrate the DB. I forgot to import the DB. sorry we await migrate telling that the migration folder is And so we also export this and you will see why later And this is just the drydl config that you also need to write And there's all, everything is in there documentation. So it's pretty easy to do. But now what we can do is we can create a utils file. And this utils file, in my case, is just re-exporting all the schemas for the moment. and I'm importing the schemas inside a file that I set up. This is a fixture.ts file. I'm importing the schema, I'm importing the DB, and then I'm importing test from Playwright. And what Playwright allows you to do is you can extend your test function. And by extending your test function, you can basically tell that the test, if you remember we were destructuring page before after we do this basically you can create those functions here and then you can also destructure DB or destructure schemas and this is pretty cool because basically now every test can destructure DB and the DB is actually the thing that you pass to this use function here and the best thing about this is that those are called fixtures basically here before the a way to use you can set up your database and here you can clean up your database so in this case we are like it's not always needed the init and the clean up but it's nice to know that you can do it and so now what you can do is instead of using test from playwright test you using test from your fixtures file and you call text This is literally the same but now you can destructure DB and schemas And so before I navigate, I can, for example, insert something into the database. In this case, I'm inserting a name, a user with the name Paolo, which is me, by the way. There's only a slight problem with this is that we actually did not clean up the database. So every time this test run, the database will have a new user inside. And this might not be useful because you want your DB to start fresh for every test, right? So the way to do this, you can add this resetDB function from the utils, and this is explicit for SQLite. This is a way to basically clean up your DB without closing the connection to it in SQLite. and then we migrate away again so that the DB is back to be in the right shape and that's why we are exporting do migrate. And obviously you can do the same with Postgres or MySQL. So yeah. And so now we can get the resetDB inside our fixtures and reset the DB every time we begin a test and we can even reset the DB after we use it so that it's always, always fresh. Now, I already hear Kevin, like, pointing his finger to the clock, because it took way longer than I was needed. So the last thing that I want to do, I want to thank you for listening, and I hope that you learned something, and I hope that this made testing a bit more approachable for you. Thanks for watching.