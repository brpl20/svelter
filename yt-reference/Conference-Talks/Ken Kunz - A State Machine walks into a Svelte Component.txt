 Thank you. Hello, Svelte Summit. Welcome to A State Machine Walks Into a Svelte Component. My name is Ken Coons. I'm the founder of Zentropic, and we make software for humans. Speaking as a human, I'm a huge fan of Svelte. I began using it about six months ago and haven't looked back. I'm also admittedly somewhat obsessed with finite state machines. I tend to notice them everywhere in the world and use them frequently in my code. I love the quote, all models are wrong, but some are useful. I continue to find finite state machines to be incredibly useful. Several months ago, I was working on a new software product called Zendeavor, a tool that enables you to map assumptions on a two-dimensional grid and prioritize them by risk. And the assumption component is growing increasingly complex. It can be idle, focused, you can drag it, you can also edit it, and in some cases the assumption needs to handle the exact same inputs in different ways depending on the state that it's in. For instance, dragging across it has one effect when you're editing and a very different effect when it's just focused. Hitting the delete key has one effect when when you're editing, another when it's focused, and no effect at all if the assumption is idle. So at this point the assumption component is just screaming Finite State Machine And as I look around the JavaScript ecosystem there are some excellent finite state machine libraries available I used both of these But for use in a Svelte component they feel bulky and verbose, just not at home in Svelte. So I took a brief detour from working on Zendeavor to create Svelte FSM, the Svelte Optimized Finite State Machine Library. Let's see what's next. I'm going to do a brief overview of finite state machines, explain why Svelte FSM is a great fit for Svelte, walk through some code examples, and answer a couple questions. So what is a finite state machine? And more importantly, why should I care? Let's illustrate with this drill. The first thing I notice are its inputs. It has a switch, a trigger, a dial. The next thing I notice is it has a finite or fixed set of states that it can be in. Currently it's locked. Push the switch one way and now squeezing the trigger causes it to turn clockwise and back the other way counterclockwise and back to locked. It has inputs, it has states, and we've also just seen that it has transitions. These are rules that determine the mutations or changes in state based on its previous state and the inputs. Lastly, it can have side effects. So under the right circumstances, you get shelves on the wall. That's a finite state machine in a nutshell. As we all know, with Svelte, you write less code. Your code is clean and easy to understand, hopefully, and you get smaller, faster builds. I love how Svelte leverages inherent language features to keep things simple. Svelte FSM brings that same philosophy to finite state machines. It minimizes the overhead of using them in terms of both the code you write and your build size. The module exports a single function that adds less than a kilobyte to your build. Svelte FSM is intentionally simple It not trying to replace the tools you have in your Svelte toolbox for managing overall component and application state Why would it Instead it complements them for those use cases where you would benefit from using a finite state machine Let's look at some examples. Our first example is basically the hello world of finite state machines, a simple on off toggle switch. You don't really need a state machine for this, but it's a good way to explore the API. First, let's test it. Now let's see what it's doing. We call FSM with two arguments, the initial state and a state object with two states. Each of these states has a simple toggle transition. Looking at the template, the FSM implements the spelt store contract, so we can reference the current state with the dollar sign syntax. Finally, in our event handler, We just invoke a method that matches the toggle transition. Instead of a simple string property, an action can also be a function, which optionally returns a string transition state. This is where you could implement side effects, as well as logic to conditionally transition. Now let's look at a more practical example where you might actually use a finite state machine, form submission. Here you see a very biased survey. It's a form with a single input, And if you submit anything other than svelte, it returns an error. Our form can be in one of four states. Entering, submitting, completed, or invalid. And we see the actions and transitions here as well. So let's see that in code. Our entering state has a submit action, which transitions to submitting. A great pattern for handling asynchronous actions is to have a separate state for the entire async task. Enter is a special lifecycle action, which is called whenever you enter a state, so we use it to kick off the async operation. Our promise just invokes additional state machine actions on success or failure which transition you out of this submitting state Invalid takes you back to entering if it receives an input event And once you submitted you done Looking at the template our form submit handler just calls form submit. Our input, input handler, calls form input. The submit button is disabled unless your form is in the entering state. And again, we use the dollar sign syntax to access our state throughout. We see from this example that Svelte FSM gave our form predictable behavior that helped us to organize our thoughts and our code, all with very little boilerplate and minimal impact to our build size. So we have time for a couple questions. Does it support TypeScript? Sort of. It depends what you mean by support. On the one hand, it's just JavaScript, so it's also valid TypeScript, and it ships with a type declaration file for the exported function. But I wouldn't say it's optimized for TypeScript. Svelte FSM is dynamically dispatching event invocations to the appropriate state action, and it passes along arguments when it does so. So it might be tricky to provide the level of type checking and safety that a TypeScript developer would prefer. That said, I'm 100% open to suggestions and contributions to improve the TypeScript experience. Does it support hierarchical state machines? Not currently, and I'm not certain it should. I haven't yet seen the need for state machine hierarchy within a Svelte component. If you think you need it, you may really just need to extract a child Svelte component that encapsulates its own state. I'm not ruling it out, but it would add a lot of complexity and I have a strong bias towards simplicity, so I just need to be convinced by real-world examples. Well, that's it! Check out Svelte FSM on NPM and reach out if you have questions or feedback.