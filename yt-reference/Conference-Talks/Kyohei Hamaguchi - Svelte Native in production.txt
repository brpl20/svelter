 Ooh in theadin ke browse the standard Hi, it's the Verde community. Thanks for having me this time again. My name is Kyohei. I have been a software engineer for 14 years or so, but being in front-end field just recently, like 2 or 3 years. Today, I'm gonna talk about SubvertNative, a framework that enables you to build native mobile apps for iOS or Android. I assume most of you have heard of it, and some of you might have actually tried it. I myself have tried it recently, and that was so fun! I really loved and would like to share how smooth I could switch between SWERT and SWERT Native Codes basis in development. So this talk is gonna be for you if you're interested in trying SWERT Native in your product. Before jumping into the topic, I'll share the context that I decided to use SWERT Native. I currently working for a startup called HIDE and there building a unique platform where you can take back your personal data from the megacorps, get rewarded by participating automated analytic surveys if you'd want, while keeping your data secret to anyone, even to us. We have one challenge here. We rely on OAuth, but at the same time, we must not touch the authorization code and access tokens in the process on our server side. Otherwise we would be a middleman breaking user's privacy. To overcome this, we had to build OAuth client to be publicly audited and importantly run token requests in the confidential Kubernetes cluster that accept only publicly audited container images. As you see, this is a little involved, so I had to prove that the concept would work in advance, and it successfully with browsers. But as a matter of business, we needed to make sure this would work with mobile apps as well. Also, I didn't want to expand technology stacks too broadly for our teams. Otherwise, our small engineering team, which is three developers including me, would be overloaded by the context switches between them. If we could write web and mobile both in Svelte, how would it feel nice? That's why I decided to try Svelte Native. So what is Svelte Native? It is a framework for building native smartphone apps with Svelte components. In the context of ReactX system, you would have heard of React Native. As the name suggests, in the overview, they share most of the concept, both allows you to write user interfaces, mobile or native apps with familiar syntax and concept in web. Biggest difference here between Svirt Native and React Native is Svirt Native is also a compiler. In contrast to React Native that resolves JSLogix at runtime Subvert Native does most of the job at compile time so it allows more slick user experience So, I think two of the most interesting selling point or value of Subvert Native are developer ergonomics that comes from the Subvert syntax and concepts and the reusability of the code. I had been using React Native for quite some time, mostly for gig works. In those days, there was a quite common misconception in clients over there about how much code would actually be reusable between web and native apps. When I was new to React Native, I also naively assumed that most of them could be reused, and it was true in theory, but less in reality. So I would discuss mostly about the code reusability here, since I believe great ergonomics of SWERT syntax is well established and discussed already in this event. SWERT native supports HMRL, Tailwind, or many other things you love in web development with SWERT. Let's see how SWERT components in both contexts look similar. This is an example of the components taken from the Svirt native tutorial. Look at how it is nicely formatted just by copying and pasting it from VS Code to Keynote. It's really in the same structure with Svirt. Let's compare this to the similar example from the Svirt tutorial. You'll find they look very similar, don't you? Actually, both can have a tuple of the markup, script, and style block. They can both recognize JS or TS typescript natively. But at the end of the day, they rely on the different technology, namely DOM for one, native components for another. This makes it hard to reuse code as much as in the common misconception I mentioned here. Since if a component has DOM elements inside, it cannot be used in SvelteNative that runs outside browsers, and vice versa. Here is a simplified version of dependency graph. DOM elements or native components are in the bottom of the diagram. They cannot coexist. So more components contain them, less can be reused. To achieve maximum re-usability, let's move code we would need to move code to higher portion. The lowest hanging fruits are the pure business logics. As Svet FAQ mentions, they are likely to be the first ones to be separated. In all cases, long before native apps required for us, we had separated already those out of the components. to use them in the endpoints in KIT and to make them easier to test. We had already organized modules to be placed either under $lib or $lib clients or $lib server so that they can easily find out in which context modules should be used. So with this background, it was straightforward for us to assume the modules and the DaraLib or DaraLib client would work on the native context. And that's where pure business logic is placed. I hope junior engineers also can enjoy this talk. So I want to let me, I want to believe what business logic looks like. This is the example of the components that contains business logic taken from the tutorial as well This part I sure no one would find any meaningful interpretation in just A plus B So let's give them a little more concrete name. So then this becomes a BMI calculator. And as you would understand any technical concerns wouldn't matter to the definition of BMI. They would be calculated with this formula, weight over height squared, no matter either on clients or on server side. This is an example of business logics. Actual scope of the term highly depended on the context or culture or school of thoughts on architecture. But ideally, they are supposed to be a function or a class that doesn't affect it by other technical concerns like networking, data persistence layer, or more importantly in this talk, user interfaces too. They should be determined no matter where it gets executed in the browser's server or mobile apps or any other context. That's why they tend to be caught with pure. There's no clear distinction between UI concern, user interface concerns, and pure business logics. It's not unlikely that you implement business logics unintentionally into a subvert component. This example also shows how a business logic tends to be intervened in the UI concerns. I like referring this as a discovering business logic. You can sculpt out a business logic like this, just like you discover a sculpture in a marble. In the same analogy, you sometimes unintentionally build a marble which a sculpture or a business logic already is in. I'm sure you've done this many times ever. It's also called something like refactoring or architecting. They are all about extracting a business logic. You extract them to organize code bases well and get better sites on it. But also, it helps you reuse it in another context. This applies here in the same way. Okay, back to the topic. Once pure business logic has been separated, data fetch should come next. Since fetch is available in native script and Svirt native, it is also trivial to use helper class that use fetch written for kids in native counterparts. Actually, I love this part most in Svirt native. I hadn't worked on mobile devs these days, but when I was there, I remember people used to struggle to find or decide which is a good HTTP client to use on the native apps. I don't know what it is like recently, but having fetch built-in JS runtime feels a huge win for me. So once you have a thin data fetch layer that depends on just fetch and business logics layer, you're going to be able to reuse the data fetch layer and the APIs behind it. hopefully written as the endpoint in the kit itself. And the components. But the bottom line first, I don't think it's a good assumption that you can reuse Svert components written in Svert native. I would explain the possibility in theory first, and the reality that where it's not and why. In theory some components seem to relatively easier to migrate those which are abstract enough not using HTML element DOM element directory Take an example in the tutorial again This just imports another's words components and doesn't depend anything else itself. So if you'd inject corresponding version of nested, a component called nested for web and native respectively, they seem would work in theory. The challenge here is to reuse the components that directly contain DOM elements. It wouldn't be impossible to abstract them away. If you would inject corresponding version of a component called nested for web and native respectively, the same would work in theory. The challenge is to reuse the components that directly contain DOM elements. it wouldn't be impossible to obstruct them away to the components that share the same interface but user HTML elements or native components inside appropriately like this. But I don't recommend to do this because of too low ROI. In reality, components in Subvert Native App would be like this. It's unrealistic to make wrappers for all of them. all of these native components used in here. Especially you're interested in Svirt Native because of limited amount of the resources in the first place like us. In the end, those are the exact concerns user interface library is trying to solve. They shouldn't be abstracted away carelessly or will be too leaky obstructions. I hope they could be like mobile revs where we had to develop separately long ago but can be single-complace nowadays thanks to responsive CSS. But at least, at this moment, native components are too different from the DOMS to be unified. Fortunately, writing native components in the sub-native is fun and effective enough. It might feel like non-dry at the beginning, but you'd gain a good balance of dryness and optimization not too eagerly. So finally, we'd be able to reuse three kinds of code out of the five boxes in this diagram. 60% is about 60%. Amazing! It's a joke aside, but this is worth knowing for when you want to assess how subvert native would make native... make native development easier. Let me conclude. Svirt Native is a framework for building native apps with UI components within your Svirt. It's a thing that I would call it as a plugin of native script if it would lower the barrier for you. Svirt Native would be a good fit if you were in a small startup or do a hobby project and also if you love SWAT economics and would like to write similarly must be great fit. Combining with the web built with kit, most of our code bases are written in SWAT mindset. Less contact switch means to deliver more value quicker and better. Great! Unfortunately, we hadn't released the apps yet, but we'll do really soon. like in May or early June. If you'd like to try it out, feel free to send a private message in Discord. And I'd really love to get feedback. I would invite you to internal test. So, thanks for joining this talk. Happy native hacking with Svirt! Bye bye!