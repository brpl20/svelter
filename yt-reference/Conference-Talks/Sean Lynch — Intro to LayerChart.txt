 Music Hey everyone, my name is Sean Lynch and I'm the creator of Svelte UX and Layer Chart. Today I will be providing an introduction to LayerChart. The agenda of the talk is first starting with a brief introduction about myself and the project, including how it got started. I've prepared a little demo reel to show what is possible at the library. Then I'll break down how LayerChart works and finally deep dive into a few examples. As I said, my name is Sean Lynch. I'm a developer who lives in West Virginia in the United States. I was previously a contributor to VizX, a React visualization library. I'm currently a lead software engineer at Definitive Healthcare, working on a healthcare analytics project in the med device space. I'm fairly active on Twitter and Discord if you want to reach out and say hello. Both Svelte UX and LayerChart also have a shared Discord server if you need any help or just want to chat. Invite links are available on both projects for me. A brief history about the project. I started working on a new healthcare analytics startup in 2017, originally written in React, and we used Vizix for the visualizations. For those who may not have heard of it, Vizix is a collection of reusable low-level visualization components for React. Vizix is what got me drinking the compositional chart component Kool-Aid back in 2017 while watching Harris and Schaaf's early livestreams. I contributed a few PRs to the project, including their text component, a lot of hierarchy components, including tree map and link, and assisted with the design of XYChart and React Spring integration. During the summer of 2020, I decided to switch my primary project from React to Svelte after drinking the Svelte Kool-Aid, as I like to call it. Svelte solves so many issues we have been experiencing on a mature React project, and is especially adept at making highly interactive visualizations. LayerChart was created as a means to fill the hole left by Vizix. At the time, I also came across Michael Keller's LayerCake library, which aligned with the work we were doing with XYChart and Vizix, but even more integrated. At this point I decided to create LayerChart from what I had learned from developing and using Vizix the internal chart library we had built upon Vizix and using LayerCakes Foundation and robust examples Later inspiration also came from ObservablePlot which was created about a year after LayerChart Both LayerChart and SvelteUX are used on two robust healthcare analytics projects, as well as many others. Now let's take a look at the demo reel to get a glimpse at what is possible with the library. We'll be right back. We'll be right back. We'll be right back. LayerChart would not exist without standing on the shoulders of other open source projects. D3 provides a robust collection of utilities, ranging from scales to shapes to layouts, while this is truly an understatement to its importance. Moving up the foundation, LayerCake is responsible for setting up a chart's context, including the dimension scales as well as the rendering layers, which we'll be delving into further. Lastly at the top is LayerChart, which sets up additional context including tooltip and geographic projection and provides all the components ranging from drawing primitives data interactions geo layout and others It will be delving into many of these Practically all JavaScript visualization libraries are built upon D3 including Layer Cake popular React libraries such as Vizix, Recharts, and Nevo, and framework agnostic libraries, including Observable Plot, which was also created by D3's creator, Mike Bostic. You will even find integration within Tableau and Power BI applications. Now let's talk a little bit about the chart structure and get into why it's called layer chart. At the root is a layer cake chart. You pass the data and describe each dimension or axis. For this example, each item in our data has a date property that is used for the x-axis and value property for the y-axis. You may also define additional information when setting up your dimensions or scales. For example, we defined that the y domain should start at zero regardless of the smallest value, and null is used to have Layer Cake determine the max extent for us. Padding is also useful to provide space for an axis or legend. Lastly are the different rendering context layers. Layer Cake supports SVG, HTML, Canvas, and WebGL layers, each with their own strengths and weaknesses. These layers are stacked atop one another and any combination can be used. You may also use more than one layer of the same type, which can be useful when dealing with Canvas contexts. Each rendering context has its own strengths and weaknesses. Here is a general guide of reasons why I believe a layer excels or struggles. Since both HTML and SVG add elements to the DOM, they excel at styling and interactivity, since you can leverage CSS, including variables, and element events, such as mouse over and click. They are also generally the easiest to work with and familiar to a web developer. HTML has the advantage of layouts such as Flexbox, Grid, and the general box model, while it has limitations with graphics such as rendering a complex path. Typically, it is also the best option to use when rendering text since it is the only context which supports native word wrapping. SVG is typically the most common layer due to its robust graphic support, it's kind of in its name, has all the benefits of the DOM, and while it lacks word wrapping, it makes up for it with support to apply text along a path. While the DOM giveth, it also taketh away in the performance department. Due to the overhead of tracking each element very complex visualizations such as when there is a lot of data or have detailed paths can bring the browser to its knees especially for mobile or less powerful devices This is typically where I find it best to reach for Canvas or possibly WebGL While Canvas lacks direct interactivity, sometimes leveraging SVG in limited aspects along Canvas can provide the best of both worlds. Lastly, WebGL typically provides unmatched performance at the cost of an unapproachable API via shaders. My rule of thumb is to use SVG as much as possible, falling back to HTML when layout or text become challenging, or Canvas when additional performance is needed. Luckily, Layer Cake and Layer Chart allow you to mix layer types, and some of Layer Chart's components even detect the context it is within and use the applicable API under the hood, such as the GeoPath and GeoPoint components. This is an area I also plan to continue to explore in the library. Now I'd like to give you a tour through the documentation and kind of how best to leverage it and what's available. Along the left-hand side is the nav menu, and we have a getting started section, both if you're using Svelte UX as well as standalone. So it does work with other libraries like Skeleton or ShadC and Svelte or Daisy UI, or even other CSS libraries like Uno CSS. this. We also extract out the changelog, and then we provide a pretty large, robust collection of examples. They're grouped by kind of chart type. We have Cartesian and Polar for just kind of your general X, Y, or radial type charts. We then have hierarchy and graph, followed by force components or force examples, and then geo, which is maps and globes. And then below all that is then the components themselves that make up those examples. So these components are grouped based on their functionality. And while some of these could probably span multiples because they kind of are dual or triple purpose, they are kind of grouped into where you might find it the best. So common is, as you'd expect, the most common components that you'll reach for. And typically most, if not all of your visualizations chart being the thing that you'll always reach for, along with things like an axis, as well as like a legend. If you want to show like a color scale or, you know, kind of a breakdown of your of your scales.

 Next are primitives. And primitives are basically SVG elements that have been enhanced with motion capability. So they support both tweening and spring. And they also support the theming that's built in, kind of out of the box. So while you can still leverage a standard circle or a rect or just another common lowercase element, you typically will probably want to reach for these just because they do integrate well. And most of the examples are using these. Next up is the data-driven components. and these are context aware to the data registered to the chart and they kind of marry that data with the primitives themselves so these are what you'll reach for typically the most to go along with your chart and they leverage the primitives under the hood and you might need to kind of break glass on occasion and like override a slot which is available for many of these and use the primitives But typically the data-driven ones are very flexible in what you need to do with them or what you'd like to do with them. Next are interactions. And these include things like tooltips, dragging a canvas around, for example, like a map. Or maybe you have like a large collection of like a scatterplot that you want to like drill into. That's something you'd use with like transform. but these kind of have all to do with either hovering or clicking and dragging or some type of interactivity. There's also a new brush component coming as well that we might take a look at later. Geo, as you'd expect, is where all the geographic-based components are for building out maps and globes and whatnot, followed by layouts. Most of these are hierarchy-based layouts as well as then the four simulations. So as opposed to using the data and plotting it into like a XY coordinate system, you use these layouts based off of the structure of that data and or registered forces for force simulation. And it will put the elements accordingly based on that layout. Next up is clipping. And this is kind of you know everything to do with clipping anytime you want to various ways that you might clip something to be invisible A good example of that is clipping a geomap like a tile to the boundaries of a geographic region for example like the United States And we'll take a look at that here in a minute. And then lastly is the other section. And this is just kind of a misfit toy section, so to speak. These don't really fit well to kind of warrant a new category just yet. Some really popular ones in here are like linear gradient and pattern to add some styling to your SVG elements. And then things like motion path to animate an element along a curve or a path. Let's take a look at how best to leverage the documentation. So I'm going to scroll up here to kind of a random component. Let's see. Let's use Spline. So we have our navigation on the left. You can also jump to a component by either clicking up here or hitting Command-K and then filtering down to, say, for example, like bar or globe, if you want to see kind of like all the globe examples. So that's kind of like how to jump around. Once you're in a component or an example, at the top there's the description, there's the source. So this is the source of the component itself. If, if we're looking at, you know, a component, not an example from here, we can also click on view on GitHub and it will jump us to the GitHub page, which can be useful if you want to like, you know, reference some lines in here and copy this URL off to somebody. I'm going to close this out. Along with the source of the component itself, There's also the documentation or the page source that we're looking at. So same capability. You can scroll through and kind of see how everything's made. It's particularly useful to use this to look up in the script section. And then same thing. You can click on view on GitHub and do the same thing there. We also have on this page, which is the little table of contents on the right. You can toggle that away if you want to kind of go full screen. This will also collapse responsibly on smaller viewports. As we kind of work our way down the page, there's usage, which is kind of just like how to import it. Some each component is a little different but some will have a playground to kind of give you a lot of examples that you can kind of play with within here Typically the components themselves are fairly light on examples but they'll then point you to kind of a more fleshed out like actual example kind of towards the top of the page up here. So we're just going to scroll through here and we can, you know, play around some of these examples. We've got tweening for the spline, how to document beginning and end of the points, and even synchronizing the drawing of a line with a dot. So then we get to the section called Related, and this is helpful to both find related components. So if, for example, this component doesn't fit your needs, you might find another component that aligns better, as well as in the examples for that component. And this is usually the most useful to kind of bounce between examples and then the documentation itself of a component. And then within the documentation of a component, we show you the API that we kind of extract out, including its slots and its events. And that's really useful. So let's go ahead and jump to one of these examples like Sparkline. So if you click on this, this jumps us up to the Sparkline. And now we can kind of see a little more like fleshed out examples. For example, like if we use this spline kind of inline as like a spark line with a very small height, which basically turns into a spark line. And each of these examples, both within the components as well as the examples, you can see the code specifically for this. And that's kind of where it is useful. Sometimes you want to look up in the page source to see kind of what's in the script section kind of encompassing everything. but we just want to just kind of get a general idea of what's going on that's available here for each of those you can also view the data that's kind of being passed to the underlying chart so this information right here is the data that's being passed to our chart right here now there is some serialization involved when you pull this up and particularly when you go to copy it so for example dates will become you know stringified dates as opposed to being date instances So you kind of be a little wary of when you pull that at that. It may not be 100%, but it should get you pretty close. So we have the ability to copy the data here. You can also when you looking at the code you can copy the code example If you looking at page source you can also copy the whole page source This is sometimes a good way to get started The documentation does use local aliased imports. So one thing you'll need to do when you do copy and paste one of these is you'll need to update the kind of internal imports to just the top-level layer chart. That's actually outlined in the getting started section, if I'm not mistaken, towards the bottom. Yeah, right here. So the examples kind of tells you, you know, if you see this, it should translate into that. Let's go back to Sparkline here for a minute. And if you scroll down this example, you'll see that there's related components. So we can see the spline and tooltip and highlighter related, as well as maybe if this doesn't fit your needs, there might be another component or example that does. And it's kind of like what Spark Bar is doing. It's showing you a similar example, but using a bar chart as opposed to a line chart. So that's basically the documentation. At the top, we also allow you to change the theme. So you can switch between light and dark mode. And I apologize for the flash for those watching us. Switch back to dark mode, and you can jump between dark themes as well. So these themes leverage Svelte UX themes at the moment, but you could also, this should work fine with, for example, Skeleton or another theme library. It just uses CSS variables underneath the hood and basically Tailwind classes. We also have a link to our Discord server. So if you just have some questions or want to chat about it, that's the place to kind of go from there. We also have our GitHub repo and its issues. So if you want to file an issue and if you prefer to even just have discussions through that, that works. There's a link to my Twitter X page where I post a lot of updates as they come out. And then also a link to the companion library Svelte UX. I appreciate you taking the time to listen to my talk. I encourage you to explore the documentation and try out the library. And let me know what you think, as I'm always looking for ways to improve it. If you browse the issues on GitHub, you'll see the project has a lot of enhancements planned. If you liked what you saw, I would love for you to start the project on GitHub, follow me on Twitter, or join our Discord server, or maybe all three. I'm always on the lookout for feedback or more contributors to make the project even better. And lastly, I hope you have a wonderful day.

 Thank you.