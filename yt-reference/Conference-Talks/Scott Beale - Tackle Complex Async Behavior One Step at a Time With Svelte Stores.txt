 Thank you. Hello, and welcome to my talk on tackling complex async behavior, one step at a time with Svelte stores. My name is Scott, and I'll be covering how we can use custom Svelte stores to write easy-to-read, maintainable Svelte, even if we have complex interdependencies between asynchronous data. First, I'll start out with a little bit of information about myself. I am a full-stack developer who has been in industry about five years. I work at the Square division of Block in ecosystem engagement, and what that means is that I work at the intersection of many different teams' interests, which puts me and my team in a position where we are needing to aggregate data that is published across Square's ecosystem. We've been working with Svelte recently, and I've really fallen in love with how Svelte enabled us to write a very clean data layer. I'm going to kick things off with a short clip. First we have to call the Bingo service. See, Bingo knows everyone's name-o, so we get the user's ID out of there. Then from Bingo, we can call Papaya and MBS to get that user ID and turn it into a user session token. We can validate those with Oldenop, and then, once we have that, we can finally pull the user's info down from Raccoon. Now, does that seem relatable to anyone? That from the excellent sketch Microservices by Krizam on YouTube It satirizes back development but in front web dev we face similar problems all the time particularly those of us who work in large ecosystems We're grabbing auth tokens from one endpoint so we can pull user permissions from a second, and then from a third and fourth endpoint, we're collecting more data and so on as the user moves through our application. It's not an ideal world for our development experience, but it is the reality of having so much data at our fingertips, just not necessarily designed for our use case specifically. So what's our plan? If we don't approach these situations with a solid and structured plan that can be applied both to today's data conditions and tomorrow's, it is easy to inadvertently create a rat's nest of chains promises or asynchronous functions that is difficult to read and even more difficult to keep reactive and maintainable. Over the course of this session, I am going to dig into how we can break apart complex asynchronous problems using custom Svelte stores. For any viewers who are relatively new to asynchronous JavaScript, things might get a little confusing when we get into the nitty gritty of things. Luckily, all of the solutions we will go over here are contained in the open source Square Svelte Store package. So, stay tuned and we will arrive at a set of tools you can use to ensure reactivity, enforce best data practices like lazy loading, and enable our stores to simply manage our async data. But first, let's cover what is a Svelte store. Well, there are two ways to think about it. The first is the way that most of us usually think about it day to day. A store is a container for a value, and when that value updates, so does anything that subscribes to that store, whether that's a component, a reactive statement, or another store. But the other way to think about it is that a store is just an object with a subscribed function. You can pass a callback into that subscribe function and whenever the value of the store changes the new value is passed to the callback you provided This leads to an unintuitive concept. If you have two objects that share the same subscribe function, both objects can be thought of to represent the same store. Here you can see we've made two objects. But as they both have the same subscribe function, they represent the same store. Thus, updating one will cause subscribers to either of the objects to update. This is an important concept once we start writing custom stores. But first, let's look at some design properties that stores enable that make them valuable for managing asynchronous data. The first is that stores are reactive. A store updating will cause any subscribers to update without any additional work. This results in particular properties for how store data flows through our application. Data trickles down. Data changes flow in one direction from parent to any children to any grandchildren and so on. However, requests for data bubbles up in the opposite direction. Subscribing to a store causes it to subscribe to any parents it has, and those to any grandparents, etc. This results in the ability to isolate data. A derived store, for example, only cares about the data of its immediate parents. Subscribing to the store subscribes to the parents, but how those parents get their data does not matter to the derived store. This makes stores very maintainable, where we can swap around data relationships in one area of our application without affecting our other stores. Finally, we have the concept of lazy loading. This applies to asynchronous data, where we only fetch data from an endpoint when we need it. But this is also how stores operate. Stores don't begin to calculate their data or fetch data from any parents until we subscribe to the store. So when we write our custom stores we are going to want to tap into that property and only load asynchronous data when that store is subscribed to Now default stores are capable of performing asynchronous behavior However, when we start to build out more complex relationships, it becomes hard to maintain the principles that make stores so valuable. Let's look at this example. Here we have a store representing an auth token that we can get using a hypothetical fetch auth token asynchronous function. In isolation, this works within our principles. The first time anything subscribes to this store, it will run the function we've passed as the second parameter, which will call our async function. When that completes, it will use the set callback to set the value of the store. We've got isolation here, and we've got lazy loading, so what's the problem? Well, this works well enough for a simple use case, but there are some drawbacks. Primarily, how do we know when our data is ready? If we want to delay rendering of something in our app until we have a piece of data, for example, if visibility of a menu item depends on user permissions, Then we need a way to delineate between a store that has completed its asynchronous behavior and one that has not. So, we can work around this to an extent. We can check the value of the store, and if it's still the initial we've provided, we can assume that it has not loaded yet. However, this approach is fairly fragile. different stores might require different initial values that are difficult to use this approach with, and the kind of check is very poor for error handling. Another approach would be to pull async behavior out of the store and put it into a promise that you can await in your components. We can set the value of a writable store when the promise resolves, but then we're no longer lazy loading when subscribing to the store. We have to perform additional overhead to make sure things aren't hitting endpoints prematurely. We could use a readable store using the promise in its start function, but then we don't have a good way to reactively update the store if we need to refresh data. Ultimately, the main drawback of any of these store

 solutions is that it breaks isolation. To use our store, we can't just worry about the store itself anymore. We have to consider the external promise and make sure that this has resolved before we can use our data. This starts to become very onerous when considering derived stores. A derived store might have data that originates from several different endpoints, but goes through several layers of derivations. In such a scenario, the simple question of does my store have the data it needs requires a good deal of hard-to-maintain bookkeeping to answer. So, without further ado, let's start digging into how we can use custom stores to create a more streamlined and maintainable solution. First, let's take a look at the example custom store given in the Svelte tutorial. In a function that returns a store object, a writable store is created, and the subscribe, set, and update functions are destructured from it. Those functions are then used to create a new set of functions that are returned in an object. Since the returned object has the same subscribe function as the writable store, they are in fact the same store. However, instead of exposing a set and update function, the object return exposes a different interface for interacting with the store. With this general premise, we are able to add and restrict functionality to a store. Now, let's look at how we can use custom stores to manage async functionality. This looks way more complicated than our naive example of dealing with async data, but what we are doing here is stuffing all of the complicated overhead we discussed earlier into a reusable store. Once we start creating stores in our application, our application code will be much cleaner and more maintainable than if we had to develop a bespoke solution for each instance of asynchronous data. Let's look at how this works. Like a regular readable store this async readable store takes in an initial value and a function that sets the value of the store when it subscribed to However this load function is an async function that returns the loaded value of the store Or, in terms of promises, the load function is just a function returning a promise that resolves to the loaded value. Let's skip down to what our custom store returns. Like always, we provide the subscribe function that makes this a store. but we also provide load and reload functions. Calling load on this store will give a promise that resolves to the store's value. We'll come back to the specifics, but first let's look at how we can use this in our components. Here we create an async readable store that represents our user's name. To create it, we just need to pass in an async function that will fetch and return the data we need. In our template, or anywhere else, we can await username.load, and this will resolve once our store has its loaded value. Let's jump back and see how this works. Inside our main function, we define another function, loadValue. This is what calls the load function that has been provided when we create the store. However, load function is only invoked the first time loadValue is called. This means we can call loadValue as many times as we want without worrying about inadvertently making network requests. This way, we can load our store in as many places across our application as we need. LoadValue takes in a set callback that we can get when we create our store. This lets us set the store's value to the result of the load function. When we create the store, we provide load value to be called when the store is first subscribed to. Taking this approach means that data is lazily loaded automatically, simply through the act of accessing the data or calling load on the store. So this setup we just covered provides all of our design properties except for isolation The reason we don have isolation is this If we have stores that derive from our async stores how do we tell if the derived store data is ready Well, we can look at its parents, and if any of those are async-readable stores, we can await load for each of those. But that means you have the same problems with bookkeeping that we have with default stores. You need to do additional work every time you want to wait for a derived store to have its data by manually auditing where data enters your application. Keeping that in sync also poses a maintainability problem where any changes to your data flow need to be synchronized in multiple places. If you spend a second to think about the problem, you might realize, well, we're already telling our code where a derived store's data is coming from. And we do that by specifying the store's parents when we create the derived store. So let's try to tap into this by using another custom store and extending the load functionality we implemented for our async readable stores. Here is our custom store. Just like a derived store, it takes in a collection of parent stores and a function to map the parent store's values to the value of the derived store. The layout should seem familiar from our previous custom store, but here we are extending the functionality of a derived store. That means we get all of the derived stores functionality plus any that we add to it. Like before, we define an internal load value function. In this case, rather than loading new data, it loads any parent stores and then uses the mapping function to give us the value of the derived store. To accomplish this, we use a load all function that calls load on any parent stores. Let's look at how that works. Here's our loadAll function. It takes in a collection of stores, and then maps that to those stores' load functions. If any store does not have a load function, we simply get the value of the store Then we await all of the parent load functions to get us a collection of the parent store loaded values In our custom store we include a load property that calls load value. This means calling load on one of these stores will await any async readable parents and then give us the value of the store, giving us the ability to await the derived store's data. What's more is that because a loadable derived store has a load function itself, we can derive from another derived store, and this load ultimately awaits the origin of the asynchronous data, not just the store's immediate parents. In this way, we are bubbling up load requests using the same structure we have already described through the creation of our derived stores. Let's take a look at how this actually works in a component. Here, we define two stores representing an array of letters. One defined synchronously, and one fetching from a remote source using an async readable store. We create a loadable derived store that combines these two arrays, and then a final loadable derived store that represents the length of the combined arrays, called num letters. Now, we can use any of our loadable derived stores the same way we would use async readable stores, by calling load to await its value and then using the store's value in our components. This gives us isolation. When we implement and use num letters, we only need to concern ourselves with the data that it needs immediately. In this case, it only needs all letters. We don't need to care about where this data ultimately comes from. The fact that it comes from one synchronous input and one asynchronous input is irrelevant to the fact of num letters. We've isolated our store from that, and that enables us to build small building blocks out of stores that are easy to maintain and modify,

 as our application grows. What's more is that since a loadable derived store is purely an extension to regular derived stores functionality, we can safely replace all usages of derived stores in an existing Svelte application without breaking anything. That enables us to add async readable stores wherever needed in our app, and all of our derived stores will be compatible with them without any additional work. That is the pattern Block has adopted in developing Square Svelte Store. This open source project can be dropped into your application as a replacement for the default Svelte Store import. It includes all of the functionality of Svelte Store, but also extends that with new stores and new properties on existing stores. Included is the async readable store we covered earlier, as well as a re-export of derived stores to include the new functionality we covered with loadable derived Both of these have a couple additional features Most importantly is the ability to declare an async readable store as reloadable A reloadable store will fetch new data whenever we call reload on the store or call reload on any store that derives from that store. Also included are two additional types of custom stores, async-derived and async-writable. An async-derived store is useful for when you need to use store values in order to fetch additional async data. It works just like a derived store, but with an asynchronous function to get the final value of the store. However while regular derived stores will invoke that function whenever any of the parent values change including initialization an async derived store will only do so after all of the parents have finished loading This means you don't need to worry about creating unnecessary or premature network calls. After the stores have finished loading, any new changes to the parent stores will create a new network request. In this example, if we write to the page store whenever the user changes pages, we will automatically make a new network request that will update our results store. As ever, this store includes a load function we can await to ensure this store and any loadable parents have finished fetching data. The use case for an async writable store is a little more cryptic. So let's consider a situation. We have a user who has a customizable list of shortcuts. To support this, we have two endpoints, one for fetching a user's current list and another for persisting any changes to that list made by the user. How could we support this with our stores? Well, we could use a reloadable async readable store to fetch the user's current list of shortcuts. Then, when they make changes, we post to the persistence endpoint, and when that is complete, we reload the store. This is functional, but the problem is that our application will not update with the new list of shortcuts until writing and then reading is complete. This adds undesirable latency to the user's experience. Instead, we want to optimistically update the store representing the user's list as soon as they make changes, and then use that to kick off our asynchronous behavior. To accomplish this an async writable store allows you to set or update the value of a store the same way you would a regular writable store and then automatically perform any side effects needed The first two parameters in creating an asyncWritableStore work the same way as an asyncDeriveStore. However, you can pass another async function as a third parameter to an asyncWritableStore. This function is called after we set or update the store and thus can be used to kick off asynchronous side effects such as persisting the new shortcuts list to our backend. With these tools under our belt, we can break apart even the most complex asynchronous data flows by isolating individual steps using these custom stores. For each step, we only need to worry about the data needed for that step and not where the data originates. As we get to the end of this session, let's consider a more complicated example. We have a social media app that lets users share and view blogs. In a sidebar, we have a list of shortcuts to the user's favorite blogs, along with a blurb from the blog's most recent post. We would like to add a test feature with 5% of users, where we also provide a few suggested blogs alongside their favorites. As the user views new blogs, their suggested list of blogs also updates based on their indicated interests. To support this, we have a number of endpoints. A personalization endpoint provides a list of the user's favorite and suggested blogs. A preview endpoint lets us fetch a blurb for the most recent post of a given blog. A favorites endpoint lets us post updates a user makes to their favorites A testing endpoint lets us determine if the user should be included in the feature test And finally, a user endpoint lets us gather user info, including a token for identifying the user when calling other endpoints. So, we have some challenges here. We need the user's ID before we take any other step, and we need to query the testing endpoint before we will know whether to display suggestions alongside favorites. And whenever a user's shortcuts update, we need to update our preview blurbs to match. Without custom stores, this could get messy. However, by approaching this using our custom stores, all we need to worry about is one piece of data at a time. If you're interested in taking a crack at this problem, I've included a code sandbox that gives you the prompt and some mocked functions representing the endpoints. If you'd rather just see an example of how this would work, you can open the second link to see my implementation. Thank you for attending this session. Using custom stores to maintain reactivity, trickle down data updates, bubble up data requests, isolate data requirements, and lazily load from endpoints allows us to handle async data without additional overhead or bookkeeping. I hope the tools provided by the Square Svelte Store package will be useful in your development, and I look forward to growing this project with contributions from across the Svelte community. Stop by the ReadMe for more in-depth information about features, and don't hesitate to shoot me an email with any comments or questions. With that, I'll hand things back over. Enjoy the rest of the conference, and happy developing. Thank you.