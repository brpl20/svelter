 Thank you. Hey folks, today we're going to be putting Svelte in motion. More specifically, we're going to take a look at a few examples of high quality motion in native applications and see what it might look like to implement those for the web in Svelte. So this talk is going to take a simple format. I've built a relatively straightforward application. I'm going to gradually add motion to it to improve the user experience, taking the lead from some of these high quality native applications. But first, I think it'd be useful to take a look at an example of this kind of motion. What do we mean by native-like transitions or native app-like transitions? What does that actually mean? And what are the key characteristics of high-quality motion in native apps? I've got an example here, and this is the Apple Music app. And I think this app has some really nice examples of the kinds of animations that I'm talking about. When we actually look at apps like this, it's really hard to pin down what it is that makes them feel the way they feel. And I think a lot of it's just to do with polish and refinement, but I think there are a couple of characteristics that are really, really important to this kind of an experience. So the first one is just responsiveness. When you touch the screen, something happens almost immediately. The latency is really, really low, and it feels like you're actually controlling the elements on the page. And I think that's a really important characteristic. The other thing is performance. These animations are really smooth. They perform very, very well. and I think that is definitely a key characteristic of this kind of thing is just having really good on-device performance and I think the final thing is just attention to detail They just very refined And often there more going on than meets the eye There's actually often kind of multiple animations happening at the same time that gives that kind of natural feel. But I just think there's an attention to detail with the interaction design in native apps that is frequently not present with similar uses of motion on the web. So that's kind of what we're talking about when we talk about native animation. We're really talking about responsiveness, we're talking about performance, and we're talking about how natural we can make things feel. So having like lots of attention to detail, making sure the animations feel really good when you're interacting with the page. So now we're going to take this example pretty much, and certainly an example inspired by this, and we're going to start adding little bits of motion, but for the web. So this is our little application that we've got. It's just a simple viewer for some animal images. So at the top here we've got some animal categories. We can click through to see the individual images for that category. And if we come back down we can see we've got the individual images in these little horizontal scrollers as well. A couple of horizontal scrolls here. It's quite a nice pattern on mobile. It's quite easy to interact with. It's not as good a pattern on desktop. And we're just going to add a little bit of motion just to make the UX a little bit nicer. So the first thing that we're going to do is add some scroll snapping to these carousels. So when you kind of scroll through, it's really easy to kind of end up with like half on, half off screen or find yourself centered in the middle somewhere or something like that. And it'd be nice if when someone scrolled, it just automatically kind of snapped to see an actual image, because otherwise we're going to have to correct this behavior. So you scroll once, and then you're going to need to actually refine that scroll position. We can make this simpler for the user. So in order to do this, all we need to do is add a couple of CSS properties. There's no JavaScript. There's no dependencies required. It's a super simple technique. So we dive into categories. So this is the container. This is the scroll container. And we just add scroll snap type here. And we're going to add the axis, which is X, and mandatory. Now this won't actually do anything because we need a companion CSS property on the direct children of this scroll container as well. So we can jump into category here. We can see that box is the child so we can go down to box and we can add scroll snap align and set that to start And you can see it jumped slightly there but we can now see we got a nice snapping scroll. What's nice about this is it kind of respects default scroll behavior. So if you scroll very heavily, it will still scroll past multiple items, but it always snaps. In a quite gentle way, in a quite subtle way, making use of native platform features like this means that a lot of the implementation is solved for you. It'd be nice to get the same thing on here. It works really nicely with multiple elements as well. So we just need to go into this animal. So this animal component contains a list of all of our items. And so, again, container is the container. So we can go here and we can do scroll snap type. Again, X, mandatory. Save that. And this box is our child of the scroll container, so we'll go and find box. And we'll do scroll snap align start, and we can see it snapped into view. And this is really, really nice as well. So it will always kind of end up with one of these items aligned, no matter how hard or softly we scroll. and it works on all of those of course because we're using components and that's a really really simple feature that you can implement pretty much anywhere that you're using a horizontal scroller it's very common to see carousels where you have to do a swipe action that doesn't actually have any responsiveness so the actual scroll won't move until the swipe has been detected and confirmed and then it will animate whereas this just makes it feel much much more responsive And when we were talking earlier about making sure that our interactions are responsive, this is the kind of thing. When you do a thing, something should happen on the screen. So it feels like you're in control of the gesture. And then you can kind of pick up and finish off the animation. And that's exactly what this does with just two lines of CSS. The next thing I'd like to add is some page transitions. So we kind of snapping into here like this but realistically it would be really nice if we had some kind of a transition when this happened So it felt like some kind of state was changing on the page So we going to use Svelte built transitions for this and it going to be a really simple implementation So we're going to dive into this detail. So if we go into index, actually, we can see that we're importing detail here. And, you know, when the page variable changes to detail, I'm not using routing in this case, it renders the detail, and it kind of unrenders this. So we're going to jump into detail. I'm going to do something really really simple. So we're going to import from Svelte transition. And we're going to get fly. And we're just going to apply this fly here. So on this box here we are going to add the transition. The transition we're going to use this fly. I'm going to pass some custom parameters. So what I'm going to pass here is we're going to pass an x value of 500. So fly is going to fly something into the screen. By default it will also animate the opacity. So we're going to set the opacity to 1 to make sure it kind of stays on screen at all times. And we're going to set the duration to 250. Now if we click here we can see that this is now kind of animating in quite nicely. However, it is still a little bit janky, so in order to make this feel really nice we're actually going to animate the screen behind it as well. So we're going to jump into the index to do this. And we're going to do pretty much the same thing, so I think we'll do it up here. Same import. And we will do much the same thing here. So we're going to come down here, we're going to add a transition of fly. In this case we're going to set the y to 0, we're going to set the x to minus 150. We are going to change the opacity, but we're not going to make it go down to 0, we're just going to kind of like fade it slightly so it feels like a nice transition. And again we'll set the duration.

 to 250. Now you'll notice here that we haven't got the same kind of x value as we have on the thing that's animating in. So obviously the thing that's animating in is totally off screen to totally on screen. But we're not actually animating the homepage as it animates out totally off screen. We're actually just animating it a small amount. And it almost gives this kind of feeling of distance, and it feels just that little bit slicker. And it's kind of little tricks like this that make things feel nice when you're animating them. And it's also kind of, again, cancelable. So we spoke about this earlier as well, about how animations need to be very responsive, but you need to be able to say, well actually, what if I decide halfway through a gesture or through an action, I want to get rid of it. Can I easily reverse my decision? And this is a good example of being able to do that. And this is again, another, another little thing that just makes it feel that a little bit more refined, that little bit more polished and kind of helps the user to understand that the different levels, different hierarchies of the site can have slightly different page transitions. It can almost act like a visual language for navigation. So the final feature I'd like to add to this is the ability to preview these images. So instead of just having these little images I'd like to be able to click on one of the images and have them kind of scale up so that we can actually preview it. And I think I'll also add a background overlay so it kind of acts like a little lightbox. This is the most complex animation we're going to implement. And it's mostly complex, not because the animation itself is complex, but because there's a bunch of kind of things we need to take into account. So we're going to use springs for this instead of tweens. So Svelte ships with two different animations, springs and tweens. And a spring is a type of animation that tries to emulate spring physics. It generally feels quite natural. One of the benefits of a spring is that it's consistent no matter what values you're animating. So if you've got an animation that takes 500 milliseconds, if you only need to travel 10 pixels that going to have a very different speed than if you going to travel 100 pixels over the same duration Whereas springs don have a duration They finish when they finished based on some kind of model of physics They also have the benefit of feeling more natural without you needing to find the right easing. They're not always the right choice, but they are really, really nice for UI interactions and UI animations. So we're going to import the spring here. Apologies for my terrible typing. And in order to implement this, we need to track a few things. We need to track first and foremost the window width or the box width that we've got on the screen here. This is going to be a number, we'll default that to zero. We're going to track the height as well. We'll also default that to 0. And now we actually need to keep track of a number of things here. So we're going to create a new interface. I'm going to call it active. And this is essentially an object that's going to contain the index, the left value, which is a number, the top value, which is a number. and the origin, which is actually a string. This is going to be important as we progress through this example. So we're going to actually kind of... We're going to create this. We're going to create some default values. So our index is going to start with a minus one value. Left will be zero. These are wrong. Top will be 0, and our origin will be 0, 0. We're also going to instantiate a variable called overlay to decide when we should show or hide the overlay. We're going to default that to false. And we are going to instantiate a couple of springs. So we're going to have two springs here, one for the scale and one for the opacity. The scale is going to be the scale of the image itself And the opacity is going to be the opacity of the overlay So the overlay is actually going to be on the screen at all times. We're actually going to use that to measure the size of the screen. In this instance we can't actually use the window width because if we were to make this kind of bigger than I think 500 pixels it would actually kind of end up with a wrapping box that keeps it all in kind of a mobile view. So we can't actually use the window width, although you might be able to do that in a real situation. On the opacity, we're also going to kind of modify these spring values. We're going to set the stiffness to 0.2. And you can change just how bouncy and how stiff the actual spring is by modifying some of the options. So we've got a little bit of kind of state set up now and what we essentially need to do is we need to track the actual position of this item on the screen. Because we're going to scale it up and it's going to come outside of its containing box, we need to prevent it from clipping because if we were to scale this, say, by kind of like two times, it would kind of come down to down here somewhere, but the bottom part of it would actually be clipped. So what we're actually going to do is we're actually going to convert this when it gets selected to position fixed, so that it's not kind of impacted by its containers. But when we do that, we need to know what the actual position of this item is on the screen so that we can set that explicitly so it doesn't jump around. And that's why we're tracking this. We're tracking the origin, because depending on how close it is to the edge of the screen and indeed this edge of the screen we need to set the origin in a different direction because we want this to scale kind of top left to bottom right in this kind of a position. But for this image it needs to go kind of like top right to top left and so on and so forth depending on the positions. And of course we can scroll them so it needs to be dynamic. That's why we're tracking these and we're going to calculate these values when we click. So the next thing we need to add is the overlay. So the overlay is just going to be a div And we going to add a class to this And we add some CSS to that in a moment We going to add a click handler to this And we're actually going to bind clear to this click handler, which we'll populate the body of that in a moment. We want to set the style here to the opacity value of this spring. So we're actually using the dollar sign syntax because we want the value from the spring. The spring is just a store. And we're actually going to use this. This div is going to be kind of 100% high and wide. So we're actually going to use this to find out what the height and width of the screen is. So height is going to be wh. And height width is going to be ww, which is the variables that we've set here at the top. So now we've got this, we're just going to add a little bit of CSF. It's just a copy-paste job. There's nothing particularly interesting about this. It's position fixed. It's got a very high Z index. It's set slightly bigger than the screen to prevent any kind of clipping. It's got a background color of black. And the pointer events are set to none. So this is quite an important one. What we're actually going to do is we're going to go here. Actually, we can use this syntax. We'll use this nice new syntax here for this. And we're going to add one more kind of style property. And that's the pointer event. So we don't want this to interfere with the page in any way. until the overlay is active, at which point clicking that we want it to actually clear what's present. So we're actually going to set this to overlay, then we'll do auto, otherwise we'll do none. I've set the opacity to 1, so I'll change that to 0. And as we can see, nothing interferes with the screen. It's absolutely fine.

 and we don't need to worry about it. But when we click, we want stuff to happen. So what we're going to do essentially is when the image tag matches, when the specific image tag that we're iterating over matches a certain condition, we want to change some of the values. So what we're actually going to do this inline here on the element itself, I'm going to add a bunch of style properties based on the states. Basically, is this the selected item? If so, these are the changes that we want to make. So we're going to set quite a lot here. So the first thing we're going to do is style the position. So if activeEL.index is equal to i, and this is going to be the basis for pretty much everything, then we want to set this to fixed. Otherwise, we want it to be static, which is the default kind of thing. I'm actually going to copy-paste this conditional here because we're going to use it quite a bit. Again, style. This time it's going to be left. And we're going to do the same thing here. And if it is the same one, we're going to set the active el.left, otherwise we're just going to set it to zero. We're going to do the same thing pretty much with top. You can find active el.top, otherwise zero. This is a really important one, so we're going to do style transform origin here. Again, it's going to be the same thing. We'll calculate the transform origin in just a moment. We'll set this to origin. Otherwise, we'll just set this to 0, 0. We also going to modify the transform value So this is very important So if the style not what I had in mind So style transform I actually going to do quotes here So what I going to do here is we're going to set the scale. So we're going to do scale and now inside of the scale we're going to do... If it is matching the index, then we are going to set it to scale. Otherwise we're just going to set it to 1. And scale is always a numerical value anyway, so that's fine. And now we're going to do something kind of, I guess, maybe slightly controversial, but I'm going to set the pointer events here as well. I just want to be able to click through this basically when it's the active image, because it will allow us to kind of trigger the click on our overlay instead. So we're going to do this. Just make sure we've got our overlay as well. This just means that essentially if the image is big we'll be able to click through it and then the overlay will pick up our click instead. It's not really an ideal implementation but it's a quick and dirty one that gets the job done. And the last one is the z-index. So, style z-index. And it's the same story. We'll just set this to a... We can set this as a number. So that's what we've got so far. We're still not kind of... Nothing's happening still. But we can now start implementing our actual handle click. And this is where we're actually going to populate this active EL with the correct values. So the first thing that we're going to do is we're just going to check to make sure that we already passing in the index here So we just going to check to make sure that we actually got a reference And I just check if it equal to null And we'll just return. I can just do this instead. It's a bit simpler. So that works fine. So what we need to do here, it's a little bit more complicated than just getting kind of like the top and the left properties, because we actually have some margins to deal with. So we need to get the offset. So what we're going to do is we're going to create a new variable styles. And we're going to do window.getComputedStyle. I'm going to pass in the element, this specific element that we're tracking like this. And now we can get the offset. So we'll get the top offset. I'm going to do this by... We're going to need to pass in this so we can get a number from it. And then we're going to do styles. that. Hit style. Let's change it to styles actually. I'm going to get property value. I'm going to get the margin top for this one. That's a string. I'm going to copy this and And we're basically going to do the same thing here. We're going to get the left offset. We're going to get the margin left, like so. So we're going to need those values in a moment. So the next thing we're going to do is we're actually going to... Let me make this bigger. We're actually going to get the bounding box for the element itself. So we're going to deconstruct this. We're going to want the left. We're going to want the right. the top, the bottom. And we're also going to want the width. And this is going to be el.i.getBoundingClientRect. And now we can actually use this. So the most important calculation that we need to perform here is we need to decide which way we animate this. Is it, you know, top left to bottom right, top right to bottom left, bottom left to top right, or bottom right to top left? I going to do that by calculating the distance essentially or the difference between the left and the left and the right and the right So what we want to say is say we animating this penguin here we want to say, is this area greater than this area? And likewise, when we're animating this one, it's like, which are we closest to is all we're saying. And we can do that by just saying kind of like, which of these calculations is closer? It's actually quite a simple one once you kind of get your head around the box stuff. And we're going to create an array because we need to track the kind of the left and right, but we need to essentially do the same thing for the top and the bottom as well. See what am I closest to or what am I furthest from? And so we're going to do this by creating a new variable like this. I'm going to make it equal to an array. And in this array we're basically going to compare the left value, which is here. And that's going to give us this distance. But we need this distance. So we need to compare the width of the box to the right value. So we're going to do this by kind of like is the left, which is just already calculated for us, less than the window width minus the right position. So that's this minus this. this, and that's going to give us this value here. And we're going to just transform origins are in percent values, if you want, so we're actually going to do percentages like this. So that's going to give us the left and right. What about top or bottom? So we're essentially going to do the same thing, we're just going to compare the top, which is already calculated for us, because the top will be the distance between this and this. But now we need this distance as well. So that's going to be the height minus the bottom position. So we're going to just do WH minus WH minus the bottom. And the same thing again, 0 and 100. So this is going to give us our transform origin positions. Now all we need to do really is just take all of these calculations and figure out what we need to set things to. So we're changing these to position fixed. So that means we need to set the left and right values to the right values so that it actually kind of ends up in the same location.

 looks like a smooth transition, but we're actually going to change in some important values. I'm going to do that by taking the left value and subtracting the offset, because that's going to help us to take into account any margins that have been applied. So first and foremost, we'll set the active el.index to the index that's been passed in. This will cause all of those styles that we applied before to actually trigger. The next thing we're going to do is we're going to set the active bl.left. And we're going to set this to left minus the left offset. And this is going to be a pixel value, so we're going to do pixels. We're going to do the same thing with the top. This is going to be top, minus the top offset in pixels again. What have I done? There we go. Save that and get some semicolons for us. We are going to also set the origin so we can do activeel.origin and this is going to equal to... not that. This is going to be equal to pos0 space. And we need a percent here. We do pos0, percent. We do a space. We've got another of these. And then we can do pos1. And that's going to give us these values. Let's see if we click. Let's see if anything weird happens. So it working kind of like fine if you actually look at the we actually getting some position fixed stuff going on and then it will remove itself later It's working really, really nicely. But of course nothing is changing. So next what we need to do is we need to enable the overlay. So we're going to set the overlay, we're just going to set it to not overlay, kind of lazy but it should work fine. But we're not actually, again, we're not actually doing anything yet. We're not animating any values. Both our opacity and our scale are determined by the springs that we set up. So I'm going to wrap this in a request animation frame call. And the reason I'm going to do this is because you always get a smoother animation this way if you just let your changes settle before you start your animation. Animations are very, very kind of tricky from a performance point of view. And making sure you're doing as little as possible while you're animating is going to give you the best chance of success. So I kind of want these things to kind of settle. You could await tick, but I've generally had better results with a requestAnimationFrame call. So that's what we're doing. And inside of here, we're going to scale.set. And again, we actually need to calculate this scale because we can't just kind of multiply it by two because we have this margin to contend with. So I'm actually going to calculate this. So we're going to take the window width. We're going to subtract two because there is some other UI stuff that actually offsets the animation a little bit. And we're going to remove the left offset. We need two of those. And we're going to divide this by the width. And that's the width of the actual item. And that essentially going to give us a percentage value which is what we need for the scale Which is what we need for the scale You know we want it to be essentially full screen minus a little bit of margin So we going to do that and hopefully this will work And we can see we got some nice animations Now nothing else is happening, but we do have this nice animation. We just needed to wrap this in parentheses, by the way, before we divided it. Order of operations, anyone? And the next thing we're going to do is we're going to set the opacity. So we're going to do opacity.set, and we're going to set this to 0.95. So we don't want it to be completely dark, but we want it to be mostly dark. And that's working really nicely. So we've got a nice little lightbox thing going on there. What we need to do now is we need to be able to kind of get rid of it. So we're going to essentially just implement this clear function. And again, it's pretty much the same thing all over again. So we're going to do the same thing. We're going to add a requestAnimationFrameCall. I'm going to make this an async kind of function so we can actually do a bit of stuff inside of it. And we're going to await. So all springs return a promise so we can just, spring.set returns a promise so we can just await them. So I'm going to promise that all the scale.set, we can just set this back to one now, its original value. and we can set the opacity to 0, which is what it was previously. But of course, we still can't click. And the reason we can't click is because we still have our overlay messing around with things. So what we're actually going to do is we're going to reset the active EL to make sure it doesn't interfere with anything. And I've just got some defaults here. We essentially just going to set it back to what it was in the first place like so We don need that And then we going to set overlay to false I'm going to set this to true. It makes no sense to set it to what we're setting it to there. And now we can always guarantee that we're going to be on screen, relatively centered. We can see we've got a nice alignment in the center as well. And that's our application done. Now we've got this really nice, smoothly animated application. Not perfect. I think one thing to bear in mind when you're dealing with animations is when you're running things in dev mode, it's going to be a lot slower because frameworks include a lot of kind of dev time overhead so when you're doing any testing make sure you're testing in production mode but this is pretty smooth for the most part and it's feeling pretty nice and we can kind of quickly cancel them and it feels very responsive it's also important to keep your springs and your animations pretty snappy users don't really like waiting around we as engineers might think it's fun when we implement these complex, long-winded animations. But realistically, you don't want to get in the way of your users. You're just trying to improve the experience, not make it worse. We don't want to frustrate them by making them take a really long time to perform some kind of an action. Okay, folks, well, that's all from me. Thanks for listening, and I hope you found this useful. Thank you.