 I'll be talking about Svelte 5, Runes Explained for View Devs. So, first of all, a little bit about myself. I'm a husband for quite some time now. It will be 15 years in a few months, and I'm a father of four kids. I originally started learning robotics, but then jumped into my passion of web development and became a web developer. So I joined the dark side. I'm currently a web enthusiast at WUM. I'm also a musician because with four kids, full-time job, it's not enough. And because that's also not enough, I'm also one of the founders of Swell Society Vienna. That's the reason why we're all here. So why runes? Let's start there. One of the problems that runes solves is like the universal reactivity primitive for Svelte. So right now we have in Svelte 4 two different ways to do reactivity. We have stores, which are mostly implemented inside of JavaScript or TypeScript files. And then we have our normal component reactivity, which looks a little bit different, where you can have your let count equals zero, and it will magically update in your template when you update the count value. so that would be one of the examples signals are way faster so there are actually some measurements out there comparing some of the implementations with Svelte 4 and then upgrading to Svelte 5 and having a faster running application um signals are actually just instructions to the compiler um so as we we see uh later on it not a wrapper around a value but in in development itself you still get access to the raw value and the raw type of that value you working with and not a wrapped version like a proxy or something like that. And one of the other goals was that it's not magic how it works, but that it still is magical. And it will also simplify some of the stuff that is currently baked into Svelte and where some of the JavaScript syntax is kind of borrowed, stolen for some of the reactivity that is currently in Svelte 4. So an example, the let keyword is kind of borrowed and on compilation, it takes on the role of being a reactive variable in the end, in the compiler output. So how many rooms do you guys think are there in Svelte 5? what's the dates today we started with four and no sub runes that would be that would be like an hour long talk if we also would talk about sub runes let's stick to runes six twelve twelve okay three or four okay Well, I think if I remember correctly, it should be actually seven of them. Wonderful. Yeah. Those are actually 100 words, but don't worry. It's not 100 different rooms currently in Slums, a five previous release candidate. So let's start with one of the simplest runes. And remember, we want to kind of compare and see how the svelte 5 runes are translated for view devs. So the state is actually pretty simple Instead of let name equals Svienna it now becomes let name equals dollar state Svienna So it's actually just telling the compiler, hey, this is something that I want to be reactive in the future. And then, of course, we can change it. This is a little bit nonsensical, but it's just... a really small example to have the picture a little bit bigger on the presentation. The comparison in Vue, in the nice green box, is you import a ref from Vue, except if you're using Nuxt, all those stuff is all imported. and then you create a reference or a ref which is the reactivity model for view, create the name variable and then if you want to change something it is the name dot value that lets you update or get the value out of it and then in a template pretty similar to Svelte, you just have double curly braces. I have just a big question. When you use like this, in view you import the rep and in Svelte you do not import. It's like built-in. And does IntelliSense work with this? Okay, so I'll use I know what you mean. So yes, the type is automatically inferred because whatever you pass into dollar state is the type that gets returned. So because dollar state and all of the other runes are just compiler hints, the authoring experience when you write a component stays exactly the same. And it's just a wrapper that is kind of ignored except when it gets to compile time, then there is some magical stuff that's happening. Yeah, so I also want to kind of point out, in my day job I work a lot with Vue or mostly with view setting variables I don know how many hours of debugging I already did because I forgot the .value in, for example, an if check, if name, .value. And then, yeah, because the name variable will always be truthy. so that doesn't really help in if checks for example and there's no warnings currently in the language tools so the next one is derived any guess what derived will do a computed value so if we have one value the count of 10 and we want the doubled count, we can derive the count and say derived is count equals two, which is kind of times two, which is kind of linking up two spreadsheet cells and then creating a new output. The same thing in view looks really, really similar again. You have your ref for your reference, and then you have your computed in that case. So, derived computed are connected. And your double count is a function that's executed and returns the count value times two. And then, again, in the template, in the HTML, it's pretty much exactly the same thing. in view it just has double curly braces on both sides. So also still pretty similar from reactivity model perspective on how you develop with it. The next rune is effect. Any guesses on what this could do? It does side effects. Woohoo! 100 points for Sentry. So why would we use that? We can use that for, for example, for some canvas

 calculation. So to reduce the size a little bit, I just have the size for the canvas and whenever the size gets updated somewhere else in another component or somewhere down here, the update canvas function runs and updates a rectangle, the size of the rectangle inside of that canvas element. so that would be one of the side effects effect replaces a lot of things in Svelte 5 so unmount is one of the examples unmount gets kicked out or deprecated it's still there and effect kind of takes over the responsibility of the unmount behavior so if you don't have any of the reactive state inside of it it will just run once on initialization and then we're gone pretty much because there will never be any side effect elements so yeah canvas is a great example loading libraries in the background lazily would be another example for I know sentry or something like that if you want to load that lazily you could do it with an effect. For view, it's again pretty similar the way it is written. It's just some different keywords. So instead of dollar state, we have refs again. Also the binding of the canvas is another ref. And then we watch the size variable. And And whenever the watched reference changes, there is a function that gets executed and then it updates the canvas. So one noticeable difference here is the effect automatically extracts whatever value, whatever reactive values are there and tracks all of them, all of the signals. but with the watch you have to be implicit and say this is the value we are going to track and it doesn't really matter what happens in the callback function one of the nice things in the callback function is you get a new value so you don have to do Well, it's not new value.value. It's not new value.value. Don't get me started on that. Yeah, dollar props. Any ideas what we would use dollar props for? It's for error having. it's for oh close close it is for defining props of the component so previously the syntax in Svelte 3 and Svelte 4 we had export let some exciting variable name for example name and age and had those exported as props now it's more implicit and we destructure the incoming props. One of the benefits here is that we can destructure the rest props a little bit more easily. And it's also a very known syntax inside of JavaScript. That behaves the same here in comparison to export let. So this is a nicety. if you want to type it with TypeScript also really easy you can just bang on some type after the closing of the object don't put it on the props there's some issue there currently intended or not intended I'm not really sure but then in the template again if you have I snuck in a little bit more here the if syntax so if we have an h because it can be null if we don't pass it in to an optional prop then we also display a p tag with the h income but this writing also the name is optional yeah it is it has a fallback value and is theoretically optional and yeah it would then just say my name is my name is yeah so yeah this was kind of the limit and stretching a little bit in Vue This is not exactly the way how I would write it at my workplace because we mainly use TypeScript, but I wanted to keep with the JavaScript way of doing things and not mix and match. So in view, we have define props as a function, which returns the props and we pass in an array with the type, if it's required, if it has a default, and all of the good stuff, as mentioned before. Name on the svelte is actually not required. So I should have removed the required here as well and put default as empty string. So also template again really similar. We have the vif property on the element, which conditionally renders it. So a little bit of a different syntax between view and Svelte, where Svelte kind of wraps it and then view has it as a property on the element itself. So any guesses on what will be next? Bindable. So really fitting with props that we just looked at. Bindable is a very explicit way of telling the Svelte compiler this is a prop that can be bound from the outside. So how does it look like? Actually, pretty simple. So we have an assignment on the prop, which can have a default value. So if we want the name not to be required, we can say it's an empty string if nothing is passed in. If we want the name to be required, we just would leave that empty and say bindable, brackets open close, and then it would be a required prop to be passed in which would have the possibility to be bindable One way someone might use that would be for abstracting text elements with labels and all of the fancy stuff, where the input of the text field is bound to one of the props that's passed in, but because of styling, it's not directly accessible. For view, this looks also quite similar again, but instead of defining props, we have I think since pretty recently, we have defined model. That's a pretty recent change. I was glad to see that because I will change something in the code list that I'm working on where we can define the model name and it will automatically set up the two-way binding because before the change, it was a little bit more tricky to do that. So I would have taken up a little bit more of the screen if I would have done that example. So really happy. So behind the scenes, the define model sets up events that are getting passed up again. So that's kind of how the two-way binding works. And on the outside, it would be like the V model colon and then the variable name in our case. main where we could bind a ref from view to that element and get the update values back out again. So, another cool one would be the inspect room. So, anyone brave enough to guess what the inspect Error handling. Quite a good guess. So the way to use it is you pass in your state variables or your computed values or derived values.

 And it will inspect and console log them to console. One of the cool things about inspect is you can override the default behavior. And if you want, you could actually set a debugger statement if some condition is met, which would be pretty cool for debugging some weird edge cases maybe. Also notice here that on click without the colon passed in directly as a prop on that button. So whenever we click the button for increment or whenever we update the message value for the input, it will console.log count and message. So whatever you put in inspect it will log all of the values. So if you would like to separate them you would have an inspect count, inspect message and it will only log when the one that is defined changes. Yes? Yeah, this is basically just an effect with the console log or is there anything in color? it's basically an effect with a console lock so it's a pretty much a wrapper yeah plus you can like with the extension you theoretically get a little bit more than an effect because you can pass in a function a callback function instead I'm not exactly sure where. I think it's in dot something. We can take a look at the docs. Dot width, I think. Dot width, yeah, exactly. And with the dot width, you can debug with whatever you want. And in the width function, in the callback function there, you also get access to the type of update that happens on those variables which might be interesting for the debugging purposes But I a console log debugger so I don really care The same thing in view is a little bit bigger again because we imports at the top again, but also the setup is pretty similar. We watched an array of count and message. So whenever count or message changes, we log the count.value and message.value. If I say it often enough, I might remember at my day job. And then the click handler and the model is pretty similar to what we have in Svelte land over here. So the next one, Ermin, do you know what is Dollarhost? Yeah, it spits out who is hosting the meter. No, it's actually pretty cool that I have this in here as well, because it is for custom elements. So this will give you the reference of the custom element, like the dis variable inside of a custom element. So, yeah, we didn't talk before what talks we would do. So, yeah, honorable mention of Svelte and custom elements two times in one meetup. That's excellent. That's very popular. is this the only usage plan just for the custom elements? so if you want to for example create dispatch an event you will do the dollar host which is this of the custom element I assume you can listen to wherever you're using custom element you can just say get the element by ID, whatever, my element, and then with the form of the Rant. I mean, you can select custom elements by attribute name as well and then listen to greetings Or what you could do is just put it on the body because events bubble up Don worry about it Is the custom event like just omitted or is that actual? Oh, that's the custom event. That's just normal JavaScript. so this is kind of created like the new custom event is creating a new custom event with a custom name and then some details and the dispatch event is I believe something to do with the custom elements and how they do their events and pass them upwards So this is like because in before the Svelte, the way to dispatch events, it is documented and I use it multiple times. But this is just for custom elements. Yeah, this is just on the dollar host room. And you get the custom element functionality on the dollar host room. which would be in that case for dispatch event. I think that's the raw thing that you would get in a handwritten custom element as well. But create event dispatcher still exists, though. Yes. It doesn't exist. Yeah, it's different than that. Create event dispatcher is for self-components and how they do this is a very custom element thing. Specific, yeah. And one more thing. You mentioned that custom events for web components bubble up by default. Because Svelte events, you have to let them. Yeah. All DOM events and all custom elements bubble up. But Svelte specific. Svelte 4 don't bubble up. But Svelte 5 might bubble up. Yeah, they might. if you shake them hard enough I don't know yeah I haven't tried that one as well but I think I believe I heard that there might be some change there as well but I not exactly sure But it would make the Svelte behavior closer to the platform because the HTML behavior is if a click event if enter event happens it doubles up It will be the app on, but I love the fact that you have to be explicit. This goes there. it does not go there I mean you can just handle it and then it will not go anywhere be explicit of where it does not go yeah so this brings the count up to 7 if I remember correctly and I want to finish with some observations to value or not to dot value or not to dot value so a little bit of annoyance coming from svelte and mostly working with you is that the dot value syntax is needed in your script block but in your template block you don't need to use it because it's automatically done for you well you cannot do it in a template because If you do dot value in the template, it will scream at you that it's not available. So that is something that a view developer has to keep in mind. A Svelte developer with rooms and a Svelte developer without rooms doesn't have to. yeah another difference is the reactivity model the way it works in view you have to import it if you're using Nuxt 3 for example you don't have to do it maybe there are some other tricks that I'm not aware of but in Svelte it's compiler it's done like it's just compiler hints. So they react that you don't have to import the dot props or dot bindable because they are not really functions. They are just hinting the compiler, hey, something different than normal JavaScript syntax needs.

 to happen here. As we've also seen in the comparison and also like looking at the stuff that I work with, there is usually a little bit more boilerplate involved when working with view files, but nothing too bad. Signals in most cases should perform better. And if they're optimized, they will perform better. and yeah done with the talk thank you so much for listening any questions I have just remark I think like one of the main interesting points like comparison view 3 and Svelte is like state management how view 3 does state management I mean, Svelte 4 or 5 does it. In Svelte 4, you have to use states. So you do it differently in the component and outside of the component. So in Svelte 5, you use runes, but you still have to do like this, the filename.svelte.ts in order to use runes outside of the component. And in Vue, you just can do it everywhere you want to do it. I mean, the Svelte runes, you can use them outside of Svelte components as well. I think you can do it. Yes. You can use them only in those .svelte. Yeah, exactly. Because this was a conscious decision because you might have some TypeScript or JavaScript files that don't really need to be compiled. so that dot svelte is another compiler hint if you would say it like that to kind of skip that part of compilation that file in the compilation which I think kind of makes sense and might prohibit some weird edge cases where library uses internally some room specific stuff and then it's falsely detected as, oh, this is a rune thing. Let sprinkle some svelte magic on top of it and then it stops working and no one really knows why So I think that a good decision in the way the compiler hints work. I think it also doesn't have to end with Svelte.js but if you have test files, it can be Svelte.js that's Svelte in the green day DSO.js. That's a good thing. I haven't tested that, but that's probably true because it, yeah. I did not test it as well, but, like, this is, like, one of the small things I think Vue is, like, a little bit more, a little bit, a B is better than Svelte. So, like, you can just name the file whatever you want, and you can put, like, this derived state or something there and use it directly in. Yeah, so the trade-off there is you have to import it. Yes. So those are the trade-off. File name, import. Yeah, the Composal and View are really good. Those can now be done in Svart, right? Yeah, so with runes, they're pretty similar. The way that runes handle reactivity and the way the code looks, is pretty similar. Yeah. I saw another question here. Yeah. Yes. Is it possible to untrack dependencies inside the backhook? Yes. There is a cool helper function. Do you want to guess what the name of the helper function is? Untrack? Yes. Excellent. 100 points to you as well. Because I was working with Angular signals and it's actually exactly the same. Yeah, maybe they borrowed from there. Possibly. Yeah, so yes, like all of the helper functions and all of the, are they called sub-runs or? My next talk should be all the sub-runs. Like for our talk. Yes, sub-runs and the second thing, I I read somewhere I think it in the slide 5 blog post or something that you should be using the large effect quite carefully Yes At the same time you say bye bye to on bye to a lot of things due to dollar effect So can we use it carefully or should we replace all our work on-mount? Well, yes and yes. So, if you replace your on-mount logic with dollar effect, that's a valid use case. But I think they want to warn against overviews of dollar effect. Overuse would be, so right now with the dollar colon syntax, you have kind of the possibility to do effects and computed values in the same syntax mashup. That was perfect. I didn't see it all the time. So now it's more separated. And if you want to really have like a computed thing happen, you use the computed and don't, like if you use the effect for changing variables, that's probably the better use case would be to use derived. Which is a great talk because we all have so many questions about runes. I was counting on that. Perfect. Speaking of on-mount, if you have a server-side server component that uses on-mount function, it gets tree-shaken during the build, since it's on the back. If you don't need it in server-side, on-mount code gets deleted. But I don't think that's the same thing with effect, right? It will be the same. Effect has no effect on your server-side bundle. And effect always runs in client-side. Yes, this is one of the cool things. That's your client-side boundary, if you want to put it like that. So everything that needs to happen in client-side only, this is where it goes. So as you mentioned, in effect, we can import the file. Yes. or lazy load JavaScript lazy load MD files would be probably better to do that server side but you could You can import a web component Woohoo Yeah? Is there anything I need to think about in terms of memory management? Because in Vue, if I look at the object, the object is also this thing in itself. So if you pass it around to other parts of the program, and then you remove the reference, I assume that the whole object is going to be removed. and Svelte Momentum 1 at least is that there is something that they compare as us additionally to the value. Yeah, so the great question. So the question was if there are any memory concerns. So if you compare Svelte 4 to Svelte 5, the code output and the memory consumption as far as I know are lower Svelte 4 is already pretty competitive in the way it handles things compared to other frameworks and I would say it's not really a concern because it's getting better than Svelte 4 especially with recomputation it should be way easier with signals that are built in behind the runes because like the dependency tree that it builds in the background between all of the runes that work together especially in more complex applications it's quite cool because of the the way it invokes a recomputation only when the parent value actually changed. So there might be like a dirty flag on the parent, but then when the actual value gets called into the child signal, I think some people call it the sink because it receives the value. if nothing changes then whatever you have in your signal on the receiving end doesn't recompute and it just says okay my parent even though it was dirty nothing really changed so I can just relax and don't do maybe every

 intensive computation and just pass it down to my children that everything is fine false alarm speaking of memory leaks and on mount does effect also have a function that you can return that will run when the effect ends yes there is I think it's exactly the same you just return a function but I'm not 100% sure. It's probably a good time to just take a look at Svelte 5 preview. So for the effect so there should be effect effect effect yeah so you can return a function and you can clear the interval or whatever needs to be cleaned up right also sorry I just said that it's also interesting some of the compute derived by default if you do derived you cannot pass in a function you have to do derived by yeah which kind of makes sense because like those rooms are just empty shells They don't have any functionality. So the type you pass in is the type that you get out. So if you would pass in a function into derived, it would return a function because derive doesn't call a function that... Right, but if my function would have like returned, like still for that line, they like come to work, you know, I would still return the same thing. I think just the types of issues, I think, there are the Yeah, so if you have something... If you have a little bit more expensive checkups or want to do loops, for example, then you can do the derived by and it will do that for you. but yeah derived so this is a little bit closer to the syntax that we have in view but this in my opinion is nicer to read and less typing and those are the sub-rules like dot5, dot3 yeah those are the so for effect there are three different ones for state there are like snapshots if you want to I starting to talk about subruns I stop Next talk Don ruin the next talk Now I heard it like sub sub Do you know the page components.party? The what? Components.party? Yeah, you linked it on your page. Yes. I just don't remember why I linked it. Oh, yes, I know why. Because it's really useful. Like you did in-depth comparison with you, but the components.party is really useful to compare with any other framework. Not as in-depth as you did. Like you showed a lot of room that are not there, but it's really useful. Even for the first one. Yeah. So actually a great thing. the component party. This is the basis of the code stuff that I used. So you will see some of the stuff. So you can compare Svelte 5 against U3, but you can also put in Svelte 4, for example. And Svelte 5, and then you see the difference between Svelte 5 and Svelte 4. Might be especially interesting on mount. so you have the effect and on mount what we talked about so this is a cool resource especially if you're thinking about migrating a project that doesn't have too many dependencies from Svelte 4 to Svelte 5 so you can have like a cheat sheet so to say and then jump really easily from one place to the next and see the differences I noticed that also when you showed the room effect versus views effect views that there was watch effect in view yeah that's a little bit different and I haven't used that at work so I wasn't really sure and I didn't include it. Because it works the same. You don't have to specify dependencies. Yeah, yeah. Yeah, I remember. But there were, like, I think I tried it one or two times, but it always bit my butt. So I stopped using it. Also, I noticed when you showed the room of Binance, I think it was recently that Richard said that you said you can bind to the value, but now it's you must bind, or I think it will error out. They're bindable? Yes, inbindable. I don't know if it's changed. Can, not must. Yes. Thanks. So you can bind from the outside, but you don't have to. Which is, I think, better because it would be stupid if you kind of have a multipurpose thing and then you have to. Yeah. Okay. Cool. Thank you. Thank you.