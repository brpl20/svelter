 So I guess I'll jump in. Mine is less a talk, more an experiment. I'm talking about a bunch of different technologies put together in one project. I think I called it Package and Package Inception or something like that. If you're curious, you can read up on Twitter or on our Svelte Society Austria website. I have a little teaser here. Yeah, so I kind of wanted to take you along with the little experiment that I thought about. And it's with using Tuborepo. So the stuff that I did in preparation was to kind of initialize Tuborepo. What Tuborepo does is it saves your output. in your... I think I should build it. No, that's too big. It saves the build output, like all the different steps, and caches them pretty smartly. It also synchronizes those build cachings across teams. So if you work on a team, you can save up a lot of build time, especially if you use a lot of CI CD, you can reuse those cached field steps just in your CI CD and be done a lot earlier and the worker is free to jump onto the next task. So, just to show you how that kind of looks like, you have the .tubo folder and it has just some information about the output of the terminal. So also the output of the terminal is part of the cache. And you can, in the configuration, you can also define which outputs will be relevant for cache. So it does some smart hacking under the hood to speed up build time across teams. So I'm using Tuborepo in combination with PNPM. PNPM is pretty great to have multiple packages inside of one repository. So as you can see, we have this apps folder where all of our apps live. And then we have a packages folder where all of our packages that are shared across the apps are used. So for a great example, you can extract away your ESLint configuration, which is actually pretty easy. I think I just copied that out from one of the projects. and then we can reuse it inside. There's workspace. Yeah. So you can reuse it inside of one of your apps. You might be even to be able to reuse it in one of your packages, but I'm not sure there. So with this workspace, it kind of looks through your packages that you have. by the name in the package JSON and uses that package. So that's really nice if you, for example, have a lot of different cell applications in that one repository, you can reuse your custom ESL config, share it across, and if you change it in that one package place, place, then it will be updated and reused across all of them. So you have only one, you only need to update it once. Yeah, you could probably also do that with tests, maybe, I'm not really sure. Yeah, so another interesting thing, even already jumped in that a little bit, you have the possibility with Svetkit to kind of generate your packages through Svetkit. And the cool thing is, if you take a look here in the apps folder, you have this lazy action and you have the lazy action down here in the packages. And the way this works is that you kind of find this. This is, by the way, part of my packages. I moved some of the or extended some of the common logic samples from the project that we worked on and published them as MPM packages, for example, the lazy action. So inside of the Svelte config, you have this option inside of kit to define where you want your packages. And as it happens, you can auto-generate it into this packages folder. And now this lazy action is available to install inside of your mono repository. So for example, in the stocks folder if we jump there stocks we could do a pnpm install I'll be lazy and copy the name. And it should take it. I did not take it. There we are. So there, package.json. . Oh, wrong folder. Good. So in the dependencies, we now have the, yeah, we have the lazy action with the workspace installed. What we can do if we don't really care about the number, which is what I usually do is use the star. So it updates automatically and you don't run into any issues there. So you kind of, this is where the inception starts. So you can, with this lazy action, you can, if we go outside again of that, outside in the root of the project, you can run pnp run package, which I already did, so it wouldn't do nothing. So we will run turbo repo, extend it a little bit, run package, which will run all of the package commands in all of the apps in parallel. So it's pretty cool. And we had no changes, so it was just checking if anything did change. If there would have been a change, let's just simulate that for now inside of source lib. Let's jump inside of here. Maybe we want to also log that. We'll hit the shortcut windows.to use emojis. My most used shortcut, I think even more than copy paste. So, we want to have an update here. And if we run the package command again, if we run it, then it should. Let's see if we update. Have a look. No, okay, then I probably have my pen out. Packages, dependency. Okay, that's interesting. Live coding. Live coding, yeah. on that. Let's run all of the dev servers in parallel. No problem here. Something. Again. Yeah, there we go. Okay. So now we kind of successfully republished internally in our MonoRepo this little update inside of the package folder. So we have now a new action and we have this console log that we added in the listener. So we already installed it in the... down a little bit and it's... working on that is actually pretty easy. So if we go here, inside of the main route of this documentation page where we could describe what all of the different packages that we have are doing. So it's probably and working with Optocomplete as we already saw today. It's not. It's just. There you go. Do I do it linked? I'm not sure about my own package here. lazy action index. What do I export? Default. Okay. So it's just, it's not a named export. Okay So we can use this lazy action now And we can see on this lazy action we also have this nice type syntax highlighting Also inside of the template, which is pretty nice after working on a NUX application for some time now, where we don't have code completion inside of the template and really missing that. So we can now reuse that. And if we go into the app. It start of the development server. Oh, yeah. Okay. They should now see that too small that we've added a list enough for the image here. which of course immediately resolves. But if you take a look, for example, at the page where we use that, then there are a lot of product images. So if you scroll down, you see them loading in lazily. So that would be a good use case for that package. So if we jump over. Before we continue, any questions so far? Did I lose anyone along the way? Yeah, can you just share quickly, like what the goal of Monoregpo, like how do you use it? I don't really use it, so it's more an experiment, as I said. But the idea behind the Monoregpo is that you have your reusable code that you would use in different projects that you have that right there with you. And have it declared as a package and can use it as a package and then just deploy your different apps or websites through CI, CDO, whatever you use to the different locations that you want to put them in. So if you have your UI library, as Ivan said, so your tomato button, you can have that in your... ... like this. You can have it as a package. You can have your tomato button package and reuse it across your projects. One great example would be to have, so this is a little bit what dipping into what our designer does. So our designer at our company, he is pretty fluent with Vue. So he kind of builds the design system for projects. He builds them out as Vue components and publishes it to the web as a website for us developers to take a look at and play around with. So as we're using Tailwind in a lot of the new projects, he also has a lot of the Tailwind styles already predefined and documented in the style guide, which is awesome. So it's, I can, we can do the best job at developing like copy pasting when we have that set up perfectly. So this would be a great example to have a monobank example, to have documentation, to have your style guides as another app and then have the live app and you can deploy them all independently from each other and maybe even have some GraphQL server also So, deployed to a different backend if you use static export of your site, your frontend site. Does that answer your question? Yeah. Good. Is it used across different projects or for one repository? So you kind of have different projects inside of one repository. Yeah, with the visit and so on. Because normally you can use, for example, a private and demo repository and take all the pictures. Yes, you can do that. But it's... You can only access to photos you want and so on. That is true. But with that, you kind of open yourself up to, like, if you have two apps where you use your UI components, I think that's kind of fine. but if you have to manage five or ten different applications where only maybe the configuration changes because you have ten different clients to update all of those projects, that's a lot of work. And if you have that, if you have it set up as a mono repo and just pull in the latest UI components that are just there, then you kind of save yourself from doing that work manually. But how is it reflected in Git? Basically, do you do all this like Everton as one repository? Yes, it's one repository. So this is one repository and it just has the packages folder and the apps folder, but you're pretty free to define. So if I want to share packages between two projects or two repositories is it like copy paste and one to another You can either copy paste or of course what you can do if you need to share it Like if you want to, for example, if I would want to put all of my packages into a monorepository, have one page for documentation. So I can use all of the packages, don't have to npm install all the different ones. But what I can do to share it outside of the project is, of course, go through the packages that I have here and publish them to npm. So that's another option, another step that I can take down the line anyway. So your packages depend on each other when you publish, you can make sure they are all synchronous and you only publish one, wait to the second one, publish the third one and then... Yeah, so with dependencies exactly that's a very good point. Like if you have interconnected and packages that depend on each other. And if I would write tests, I would also tell you it would be... Why did we just leave at the beginning? I would also tell you that it would be easier to test if you have it in a monorepo, because then you can check for all the interconnecting pieces and see that the parcel pieces come together. Yeah. It was cool to have you here. Thank you very much. nice to meet you see you present next time yeah so yeah maybe just PMPM is also great to save space, especially if you have a huge sub where you reuse your node modules across many different apps because I think they use Simlinks to set up all the node modules. So we can save a lot of disk space by using PNPM. And configuration actually looks pretty easy. You kind of define your pipeline. Everything except for these little packages in here and some small adaptions came out of the box. And you can define also So a little bit more complex build procedures where you have, for example, your build depends on, like this is depending on your previous build, but you could also put in that it depends on your linting and depends on your type checking. So, please, my friends here. And yeah, so you can kind of think of in the TurboVapor, you can also think about like pipelines of how you build and package or lint your project. Yeah, there's, I think there's not a lot that I could show you that wouldn't be repetitive at this point. I mean, created a package, packaged the package, reused the package in the apps folder again. Of course, package. Packages. Sorry. Yeah, spelled packages. You can Google's packages and yeah. The persistent store I talked about, which is actually pretty small and you just get a store. You can write, read it, have the subscribe function where you update the local storage. And yeah, you can also read and write hooks if you want to manipulate the data before reading or writing it to store, which we kind of used to save a little space and not put all of the product data into local storage, plus just the IDs. And then when we extract it again, just enrich it with the card. How to deal with the card? A little bit, yes. Yeah. So I guess I'll finish here. Thank you all for coming. I think there are no more questions. There is no more to each commitment. So yeah, I've been really sloppy. Yeah, I have too much work. you have the add-on for the emoji because I have this. In VS Code you can have an add-on to automatically? No, that's not automatically, but it's proposing you select this and you know, fix will be above. Yeah, you should go on the YouTube and see the... Yeah, so yeah, I'll just finish here.