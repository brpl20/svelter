 So, anyways, so today I was thinking, what should I talk about? Like, because we were, to be honest, we were a little bit thinking, okay, we don't have enough of talks. And there is, I personally do a lot of things that are on the backend side and that are in Laravel or PHP or WordPress or basically anything that's server-side rendered. and where we don't necessarily need the whole front-end stack, so we don't need the whole SvelteKit app or Next.js app. Of course, there are also some projects where I work where there's SvelteKit or Next.js, but on many, they're also not. So basically, I've been always thinking, no matter what kind of web app you use nowadays, at some point, if you want to provide a good user experience, you need to have some kind of interaction. So not everything can be server-side rendered and not every click should be like basically new page load. And basically the new standard, and it's actually not so new, it's just like I don't see it used so much, it didn't really take off our web components. So I want to ask who have heard of web components at least. Perfect. I was hoping for this answer. Who have used web components in production? Okay, that's also great. Who has... Did anyone build a web component? Yeah, okay, perfect. So what did you use to build web components? I wanted to try that with that embed stuff I talked to you about. So like the components have this nice property that the styles of code. Yeah. But there were there were lighthouses there. So there's . And also I did not just how to make light component without the . Yeah. Because it requires like putting every component or maybe you're already I hear Okay So so like thanks for sharing So basically like for because this is also going to be online pretty much just one or two people built web components So basically what I want to show or what I tried while I came to this talk is because I've heard at some points that someone in some maybe changelog or whatever mentioned, hey, we did an update in Svelte on how to build better web components or they updated the API. I think in Svelte 4, they did a lot since they moved. I was like, okay, I remember there was this change, so I want to check how to do it. And then I went to the Svelte.dev docs. And I started following the... I can actually show it. Why not? So if we go to Svelte.dev and we go to docs, there is, where is it? Custom elements API. So basically there is an API that, I'll zoom it in a little so you see, there is an API that tells you can, with a couple of configuration things, you can say it's felt options, custom element, give your element a name, and you're off the build custom components. But basically I was like, okay, where should I put the custom elements through in the compiler? It just says put it in the compiler options. So I went there. I was like, yeah, I tried it on one place. It doesn't work on the other. It doesn't work. I couldn't figure it out. I'll get back to this. But basically, that was my motivation, that I could not easily figure it out from the docs. And I spent some time, so I want to share how I did it. But before I continue, first, let's talk about shortly who I am. So I'm Ermin. I've been doing web development for the last 15 years. I started with PHP 5.4, did a little bit of Rails, then Laravel, then WordPress, then went through the whole e-commerce frameworks and basically content management. So basically, I did a little bit of backend, a little bit of frontend. And then I tried React, built a couple of projects with React and didn't like it so much. And then Svelte 3 came out and I was like, this rings the bell. This is great. I love it. And then, yeah, I'm combining these two. So what are the web components Basically it a web components as web components don exist There is no thing called web components So basically, web components is basically more of three APIs combined together. One of them is custom elements API. Second is shadow DOM. And the third is HTML templates. So basically, I'll open the custom element API on Mozilla just to show you a little bit how it works. So basically what the custom element API is, basically a way to create your own HTML element. And same as if we would want to create JavaScript applications without any framework, it gets very complicated, very fast. We don't have a state management. We don't have a template, like clear template. And basically we would need to attach shadow. We need to kind of inline the styles. We need, you know, basically we need to manually create elements. So there is not a clean way. So basically this resulted in people figuring out, okay, let's make this a little cleaner. So there are frameworks or like libraries like Lit or Stencil, which kind of are helpers on top of these functions. and like also since sometime there's also since Svelte is compiler, Svelte can figure out, oh, we could also generate web components and people already know Svelte. So yeah, let's do that. Okay. So how to see, how to recognize web component is that basically web component, or like element, custom elements have the dash in the name. So basically, if it's something dash something, that's a custom element. So if you inspect something, because all of the native elements do not have dashes. And actually, it's a requirement. If you want to create a new one, you cannot create a custom element without a dash. So basically, it's probably just there making sure that in the future, if they release a new element, it doesn't interfere with the standards. So why should we use web components? So what are actually the use cases? because we have already frameworks like React and Svelte and Vue for interactivity. And then the question is, why would we reach for a web component in which cases? So first things first, it's official web standard. There is even an article, basically, that a little controversial that tells that web components are going to outlive all of the frameworks And it probably somewhat true because if it in the browser we've seen how slow are things to disappear from the browsers. It takes sometimes decades, you know, just to remove them. So basically if you build something on top of web components, it's likely going to last. There is already support for all of the major browsers. So you very seldomly, if ever, need to use polyfills anymore. So if you're not using Internet Explorer, you don't need any polyfills. You can easily reuse them. So what means reuse them? You can reuse them in any framework. Actually, since recently, also in React, because React didn't support Web Components out of the box up until 19, I think, version 19. But basically now if you have a web component, you can just include it in Svelte, in React, in Node.js. So like if you can just open index.html file, put the component and it's going to work. Encapsulations or basically web components have something, it's an option. I think it's on by default, but basically they have the shadow DOM, meaning that they behave kind of like an iframe, let's say. where basically if you have styles and scripts, they're not going to interfere with the rest of the page, meaning you can go crazy. And when you include it, it's just going to be in this small box or whatever, like everything. And this can be a desired outcome, but sometimes it can lead to limitations as well. So it's important to actually research or think of what you want to do. And if you need something that reacts with everything on the page, maybe it's not the best idea. Yeah, and interoperability. So basically this is also similar to what I meant with reusability is basically that you can build that component in one place and then use it everywhere. Incremental adoption. So basically if you're coming from, I don't know, old school monolith backend app and you need to introduce reactivity or reactivity, like interactivity in certain parts, but not everywhere. It's very hard to rewrite the whole app. You know, it's hard to convince even the management of the company to say, oh, you know, let's just rebuild everything next. But you can do like one view by one view or like,

 one component by literally building one that component and just introducing it in one place and then second in another place. And then if enough of these gets built, maybe you can propose the next step of combining them. And one more thing is the longevity. And what I mean by this is I'm in web development for long enough that I have still apps that are online that are like from 2009, from 2010. And usually the ones that are still online and still working and still generating revenue are the ones that are built in technologies that don't change often. So in contrast, I have apps that are built in React in 2019 and 2020. And already if I run NPM installed on the new project, there is no chance I can, it's like, forget about it. It's like people will say, yeah, yeah, in theory it works, but none of your dependencies work. You have to upgrade everything, so it's a major job. So basically what I mean by longevity is that since you're not, so if you use web components in the older system, you're not dependent on the latest version of NPM. You can still run your old system, and that component is going to work because of the official web standards. So the next thing is why not to use web components. Okay. So first, maybe not obvious, maybe obvious is there is no server-side rendering. So like if, or at least as of today, there are some tries, there are some workarounds, but there is no official server-side rendering for web components, meaning that if you, like, for me, server-side rendering is often important for e-commerce projects where I need good search engine optimization support. And if, yeah, like I've researched a little and certain people say that it doesn't influence search engine optimization results, but whom to trust, I don't know. The second one is the accessibility challenges. So basically it's not as straightforward to build, especially the right encapsulation of focus and things So basically it quite hard to move them from shadow down to outside and the other way around So this could be a little hard So the next one that we take for granted in all of the other frameworks is cross-component state management. So since basically web components work pretty much as other HTML components, they're on their own unless you introduce some third-party state management library. So comparatively worse developer experience. When I say comparatively, I compare it with all the frameworks we like, like Svelte. Okay, again, I missed this. So basically, the reason why we have this talk is to show that maybe at least the last point is something we can change by using Svelte to do it. so the next question is how to actually build a web component using Svelte and as I've shown already there is a page on Svelte's website that shows how to do it but it was not completely clear for me because I feel like it's outdated and maybe I'll try to open a PR or something but in the meantime I just want to show I've also seen on a couple of threads on Reddit and on Discord there are questions of, hey, it doesn't work where do I put this, where do I put that So basically, in order to build Svelte web components using Svelte, it's easier to start a Svelte project and not SvelteKit project. So basically, the thing is, if we go to the website of Svelte.dev and see getting started, basically, npm creates Svelte at latest will generate SvelteKit app. And this is, of course, we can still set up generating web components, but it's way harder. So basically what I found easier is doing PMPM create beat Svelte, like this is the project name, because this will generate just simple Svelte project. So not SvelteKit, but just Svelte project. And this is something that I really used to like about the Svelte, that you can just start this Svelte project and not SvelteKit, not the whole thing with the adapters, but yeah, maybe it will get easier after a while. I want to go to jokes And one of the first things like if we started on something on the introduction They mentioned this one and then they mentioned the wheat one Okay, if you want, there is a lot of resources. Yeah, here. Perfect. Yeah, great. So it's like they call it the alternative, but I also think it should be like the primary. Yes, because I mean, I get it. So like SvelteKit will help you with routing and everything, but for web components, we don't need this. So after that, we need to configure Svelte.com.js by adding compiler options, adding custom elements through to compiler options. And then the last thing is we need to add a few... So we don't have to add this in theory, but I find it easier, and I'll show you why. It's basically defining where do we want it, how do we want it, switching to be immediately involved functions. So, yeah, I'll just show you quickly an example of how the project is generated, like how this is the wrong thing. So basically, the VEAT config, I'll show you just one more cool thing, but basically in the Svelte config, we literally just added compiler options, custom element true. And in VEAT config, we added to the build config name. So entry is where we import all of our Svelte components and then we will automatically move them to Web Components. What's the file name? And this is Svelte Web Components, short and format. It's immediately like IFEF. Anyway. Yeah? Yes. Anyway. So basically, there's one more thing that I added that you do not have to include, but I find it quite easier. So basically, in order not to build every time this particular file manually by running PMPM run build, there is a fun plugin built by Shaneev here in audience. It's called Watch and Run. It's basically a read plugin that does exactly what it tells. It's watching certain files, and then when they do, in this case, add change or unlink, it will run the function So basically this way when you run MPN run dev it just gonna build it every time you change the function So basically this way when you run NPN run dev it just going to build it every time you change the component So basically that that And then in main JS that we pointed in beat config or TS, whatever someone prefers, we just import the components. So for example, there is a component called split. I'll show you in a second what it is. that at the top has Svelte options, custom element, and then name of the element. And the thing is, maybe in some cases you want to use, because when you do this, this is only web component, but maybe in some cases you want to have this both as Svelte component and web component. So maybe you have a Svelte application you want to use. In this case, you can, instead of here, there is in the docs, let me see, yeah, here. So basically you can define the same thing basically in the file where you're building. So you would do it like this. So remember you have to have some prefix and line. So let's do split and then you will do split.element. So basically when you have this, then you don't have to have the front to top line in case someone needs it. Yes, so what the split does, I'll just show you quickly. The split actually splits two parts of the app, and I use this in the presentation that's phpapp. So this is kind of crossover. So basically, this presentation you're looking is a server-side rendered phpapp. It's just index.php, not much, and I use web components to make it a little interactive. So like basically everything that you've seen, for example, this is kind of fetched and see like I'm at the moment using my keyboard to show these things. And this is all done with the web components. And I'll show you shortly how. So basically, this is my PHP app. I have one line router that works. I built it today. So this is just a list of everything. And so I did this just to show that, you know, if you're working a bigger team where you have hardcore back-end guys or girls, you know, who are building these old-school apps that you can use web components to actually make things a little bit interactive. So, for example, the part that I built here...

 like this divider. It's often you kind of need, in the application, you have a navigation on the left side and the content on the right, and it would be nice if you can just kind of make it smaller or bigger, kind of like in VS Code or whatever. So I just decided to build a component. To be honest, I asked ChatGPT to build it, and it worked perfectly. So I'll show you. Anyway, so like how it's included in the code, there is just, it's called Svelte Web Component Split. If we go back here, there's a split exported as Svelte Web Component Split. So basically, what does this have? It's horizontal. It has, so it exports the variable or like prop direction, split ID. And then these are internal things. So what it does is basically, when I click and pull, It just changes the CSS style and sets this, for example, for 150 pixels and this for 600 pixels or whatever. And what I also figured out what would be cool is, like, what if I refresh? It stays where you had it to begin with. So that's kind of a fun part. It's for the users anyway. so what's the cool part is sorry I'm jumping from one to another so basically how we add the left part and the right part is using slots so very conveniently in web components and Svelte they're both called slots and it's exactly the same thing so it's kind of good convention so basically we can say we can just add to a div prop that's called slot and put a name so we can use name slots and the same for both of them. We can pass the props and that's pretty much it. Another part that I add is Svelte Web Components Enhance. This is also something that ChatGPT built and basically what does this do is it encapsulates the whole app and basically it listens for certain events that are being clicked. So for example if I click arrow up it will check whichever link I had at the moment selected It will go to the previous one and send a fetch request And then when it comes back it will basically populate So it kind of acts like a little client-side router. I built this in 10 minutes using ChatGPT, and it works quite good. And if I go down, it's basically first going to check if I have any hidden elements, show them. And when I show all of them, so this is all happening, I'm clicking the arrow down. when it shows the last one, it will load the next page. So basically, this is something that is, all of this is done by web component. And basically, if I would be a front-end developer and maybe there is not too much of flexibility in the old backend system, I could build this functionality and I wouldn't need a backend developer to change much. The cool part of this is, So basically, like, see, this is where we built our Vite Svelte Web Component file. So if I delete this, everything is going to work. There is not going to be interactivity. There is not this divider or whatever, but the app still works. It's still clickable. It's not interactive. But the thing is, the cool part about Web Components is since they are default Web Standard, the slots, basically, even if, so like what, I can wrap this into anything and we'll just kind of, you know, if, so if there is no, if there is no functionality defined in JavaScript into this, it will just treat it as a div basically, you know, it will just say, okay, no problem. I don't need JavaScript. I'm just going to do my, do my job. So I'll just put this back, refresh, comes back. so that's that we've shown how so basically I told before that I did not use Svelte built web components in production but I used other web components in production like a lot actually and for example there is one that's that's I don't know not so well known in non e-commerce or non 3D space but there's a component called model Viewer and it wraps the whole 3.js and a lot more into web components. So you can super easily just load your 3D model and show it on the page. And it not only that I just go to examples It has also like for example animations and it has AR VR So basically this is all just wrapped into Web Component And why I'm sharing this, it's more because Web Components are not built only for a stylized button with extra event, but you can actually build a proper thing. Like, I don't know, they're very performant things. So whatever you can do in the other things, you can do. So MC, this is a web component. It's just called model viewer. Allow camera controls. What do you want to allow? Where is your model? Where is your environment? And it loads. So another place where you can look into web components is webcomponents.org. And this is more of kind of like MPM for web components. I mean, not really. It's more of a directory, but basically you can see what are the popular ones, what are the featured ones for example there are many from Adobe because they're using them in their Spectrum design system so the cool part is you can just import it in any project you don't have to even have a build system set up so you can just load it or you can go to their website and see how to use them yeah so what else And yeah, one of the big ones is Shoelace. I don't know. It's kind of funny, fun fact. I don't know if someone have heard of Shoelace, but basically there's one guy, the guy who built it. He wanted to kind of make a twist on the bootstrap, reference bootstrap, Shoelace, but better. So he figured he'll build web components library, so not just like Boots, but that was a long time ago. But it grew into a very nice library. And why I'm sharing this is because they also have something very interesting, experimental. Let me see. And this is something that I've been worried a lot about. Where is it? They have autoloader. So basically what means autoloader is like for example at the moment in Svelte what we shown is that when you generate map components it will just merge everything into one huge file And of course the more things you have there also CSS and it kind of adds up So basically there no code splitting you would have to export component by component And then in your other file you would probably have to import them like component by component but basically their shoelaces doing it. I've seen more people doing it that they're autoloaders where basically you just load one script and it detects which custom web components are used on the page and which will load styles and assets just for these particular ones. So yeah, that's pretty much it for today. Do you have any questions? Yeah, I have a question. Because you said you are building with Laravel a lot of clean things. And I was curious, how far can you go with web components, for example, by combining that is this possible? And is this also possible to explore the web components in different frameworks? and will they behave as the same or how would it look like? Because I was thinking about webpoints for a lot because I actually think I have a really big gallery for Laravel and Angular. And I don't want to do other things with it. I don't want to do other things with Angular and Angular. Web So Stencil and Lit are great, but I think they're more lightweight examples. Because with Svelte, first advantage is if you already know Svelte, it's much easier. But the second is you have built-in state management, for example. You have built-in animations. You have everything that's already built into Svelte. You can use it in web components because Lit and Stencil are basically just helpers. They're tiny libraries, like three kilobytes or something, right, that are just simplifying how you generate in the first place. So I think this is a big advantage of Svelte. So the second question was...

 two-way binding, right? So the thing is, you cannot do... So this is something that I mentioned, I think, in WhyNot, and this is, where was it? Cross-component state management, yes. So the issue is that it basically behaves pretty much the same as the regular HTML element. So what does this mean? it means that one-way binding is great. So basically, it's going to be reactive whenever you change the content of the tag. So if you change the value, you know it will update. So this works fine. But if you want to do it the other way around, you have to do some kind of events. You have to do event listening. Which I'm sure there are helpers and ways to do it easier. Custom elements. Yeah, custom events. Yeah, exactly. With the normal dispatch, you mean? Yes. Yeah. Was there another question? That was a bit sure. I have the same thing. That's why I actually started, because I also have places where I need to do it on two, like the same components on two spots. And that's why I started digging into it. Yeah. You mentioned the slots, like the same text source slots, the same for web components. in the Svelte. And I'm going to be an announcement which we made for what's called IMP, IMP, said that everything is going to the exact of the Svelte. So the thing is, in Svelte itself, I do not enjoy slots. I prefer snippets. So I didn't start using Svelte in production yet. I think we had this conversation before. But I always found slots a little bit like they're out of place in Svelte. Because I've worked with another template in engines that solved this in a much nicer way. And I find that snippets solved better. But in web components, this is very convenient because web components themselves call this functionality slots. So it's kind of easy to mentally connect them. Yeah. And the second thing like I was always wondering like yeah that why the comments have a lot of jokes negatives but I think they really useful for you know you don't need accessibility as much if you don't need SSR, so there's not as many libraries a library loading אתfasten Whoops! So I was having the same question, but now if you go and check Microsoft, Adobe, and pretty much any enterprise, they're all having web components as well. So I think it's slowly changing, and teams are realizing this. I mean, obviously, I already mentioned why not, and we have this screen here, so there are limitations, And of course, if you need server-side rendering, you have an issue. And this for a lot of people can be a big limitation. So if you're having a customer-facing portal or a website, you know, and you want a unified design system that's built out in something, you probably, this is a big blocker. You know, like if you cannot server-side render it, you know, you cannot have, you know, like a website or a web store or product page or whatever. So I would assume this is maybe one of the reasons. but like internally for tools people are moving towards it. I think it was also the lack of, first it was the lack of the browser support for a long time because you know if some of the browsers don't support because I think there was also kind of a little issue that initially the web components were for APIs and then Firefox stopped support in HTML includes and then the others were like okay we don't know how stable this is so like everyone kind of put their hands a little back. They're like, let's revisit it later. And I feel like people are revisiting it now, basically. Probably also the authoring experience. Yes. Exactly. So there was no tooling around it, really. So I think Angular first became popular and React and Vue and people kind of overlooked it And overall I feel like the bare metal web tooling or APIs are quite complex And as I've shown in one of the earlier slides, basically creating that component using just JavaScript is quite hard, and that's why nobody does it really. So yeah, I think it took time until tools got built. it's preserved in the yes it's in local storage here it is Yes. It just saves it here. Yes. And then it loads it from the local storage if it exists. And if it doesn't, it... It's too small. Can I zoom in? You want to see it in the code? Let me see. Yes. I'm not probably sleeping during this No, I didn't show the code The thing is like So the thing is See, this is, I don't know 123 lines of code And I generated this with like 7 chat GPT interactions And it worked great So, yeah Yes So, what about Are there any changes I don't know I would assume so. Yes, but I don't know. So basically there is the Svelte 5. I think the focus, the thing is even in Svelte 4, there is no focus on that component. So there is one caveat I spoke with Gianni as we're coming here. I just, I spent an hour because I made all the presentation and all of this like today. So I spent it. So the most time I spent, I couldn't get slots to render. So basically, no matter what I did, if I put things inside the slots, they just would not render. There was a long standing back that was still working up to 4 And after 2 1 until all of the year So basically what I read I also read through 20 issues today And basically the issue is see like I refresh this, there is nothing. It's gone. So basically, they're like, oh, yeah, everything works with scripts up, but slots. You have to put scripts under everything so the slot stops start working. Anyway, I'm glad that you asked because I wanted to mention this. Yes, but if you put the scripts at the end, then you'll see your slots even in the later versions. It didn't. It's not fixed. I have the latest version. Perfect. It works on my computer. Cool. Okay. Thank you all for listening. The server also renders the blade files on the server, and you said that there are some issues with web components with server-side rendering, or does it behave with blade files? What do you mean? What's the question exactly? Blade will get rendered. Oh, they will get rendered. Okay. So blade is server-side rendered anyway. So just think of web components as regular HTML elements. Like, imagine select. Ah, okay. Now I get it. Now I understand what you had on the... Yeah, no worries. Okay. Yeah, got it. Yeah. Thanks. Sure. Is there some kind of experimental SSR? There are ideas and concepts and proofs of concepts, but not in really... I mean, I think it's the same as with HTML elements. I mean, HTML elements work without JavaScript, which is great, but web components don't work without JavaScript, which is not great. But cool thing that I've shown, I don't know, should I include studio or Western? So the cool thing.

 is that if you use slots, it will just render, it will just, if there's no JavaScript over there, some issues will just read as a div, so basically you can build some kind of fallback, which is fine. Cool.