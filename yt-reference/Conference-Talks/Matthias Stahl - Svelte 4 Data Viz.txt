 Thank you. Hello everyone, I am Matthias and I am a data visualization designer. I work for the German news magazine Der Spiegel, which is one of the largest newspapers here in Germany. And today I want to show you how we use Svelte for data visualization. So why do we use it? And also a little bit look behind the scenes, how we use Svelte, especially together with D3. At Der Spiegel in Hamburg, Germany, we have a graphics desk with around 20 people working in graphics, working in design. We also have developers and editors. And we all love the combination of Der Spiegel and Svelte. Well, they also have quite similar logos, as you can see here. And let me show you why we use Svelte. But let me first start to show you which types of visualization we usually produce in the newsroom. Because in the world of data visualization, I think that visualizations for the newsroom are a little bit special. There could be really simple graphics and charts like that one here. They could be static also like that one, which is a little bit more customized. Here you can see a map of sunken ships, the German and Danish coast. And there are graphics that might be interactive pieces that might be a little bit more complex like this tracker of the German government or of the popularity of the German government where you can click hover and get more information by exploring the visualization. And for all these different types, these different levels of complexity, we have three special requirements in the newsroom. Speed is the first one. So we need to be very fast as the news cycle goes very quickly. We also need to be very accurate because we are read by so many people and we are even read by, let's say, politicians or other decision makers. So it's really important that everything that we publish is really accurate. And then there's originality as a third requirement. So we want that our readers can see, okay, this chart, this interactive piece, this is now from Der Spiegel. So this is something that we produced. So I think these three different requirements are really important when you do data visualization for the newsroom. And especially for the more complex and interactive pieces that we build, we found that spelled in the lovely combination with D3 is really the way to go, is really also the easiest and most effective way to go. But before I show you why, I want to recapitulate a little bit what is different between Svelte and D3. And especially I want to show you the things that Svelte and D3 respectively are really good in. So Svelte is of course really cool for everything, which is DOM manipulation. So when you want to change the DOM, when you want to be reactive to user inputs, to data, to whatever, then Svelte is made for it. Just think of the dollar sign and the reactive statements in Svelte. So this is really easy. Interestingly, you can also do that with D3. There is the select function, for example, where you then also can bind data to different DOM elements and then you can make the DOM elements react to the data and so on. But it's quite cumbersome in D3, so Svelte is better for that. Also, Svelte has all the batteries for really great transitions. They might be CSS they might be JavaScript it doesn matter Svelte comes built in with all these tools that you need for good transitions And a couple of transitions are already built in. And then there's everything about the user interface, you can say. So when you build up your app, when you design a simple button, a navigation bar, you can have your Svelte component for that. And you can put it in a toolbox and you can take it whenever you need. So Svelte is really good to build up your user interface. On the other hand, D3, of course, also has its advantages. So D3 is always good for the math and the paths. So when you want to calculate something, it could be scales where you transform from your data coordinate system to the pixel coordinate system of your user screens. or it could be more complex operations if you think, for example, of map projections. And then there's the paths. As you might know, the basis for many data visualizations on the web is SVG, scalable vector graphics. And one of the most flexible, if not the most flexible element in SVG is the path element. And D3 comes with a lot of functions that make it really easy to work with the paths and to calculate the attributes for the paths, for example. And lastly, I would also say D3 is really cool when it comes to transformations. This could be just number format transformations or date format transformations, things like that. And there's also a big difference between Svelte and D3 when it comes to the actual coding style. So Svelte has a really declarative style. So when you code Svelte, you really write HTML and you really describe how your app is looking like in the browser. If you see Svelte code, you can easily imagine how a website, how an application looks like. On the other hand, D3 has an imperative coding style. So that means you say, do this, do this, do this. And in the end, your browser will produce the finalized image or graphic. And that means it is much harder to read the three code and to immediately understand how the result will look like So I would see it like that Use Svelte as a basis to build up everything and then see D3 as just another function library that you can import into the Svelte world. And then you just use the function that you need. So I today would recommend, do not learn D3 on its own if you want to do data visualizations. immediately learn it together with Svelte from the beginning on. Now, I have talked a lot about the theory behind our data visualizations and many data visualizations in newsrooms around the world. Now, let's come and look a little bit behind the scenes. And I have selected today one example, which is about the Nobel laureates that we had since 1901. And let me change for that to my browser where I opened the interactive piece that we produced. So when the Nobel Prizes were announced last year, we thought, well, it might be nice to just show who the current Nobel Prize winners will be in December last year. and we decided to build up a scrolly telling piece, which means that you have a background where all the visualization happens and in the foreground, you have these moving content boxes that are little explainers for the things that happen in the visualization behind. And we start with the 2021 Nobel Prize winners and yeah, we had a focus on the German ones, of course. So we were able to highlight some of those here. And this whole application, so everything that you see here under this red bar of the Spiegel website, is really made with Svelte and D3. And now when we explained the current Nobel Prize winners, we show them in the context of all Nobel Prize winners that we had since 1901. And here by color, you can see the different price categories like physiology or medicine, physics, chemistry, and so on. And now we do a little, well, statistical analysis. So we just use now the different shapes.

 and aggregations and clusters to dive into this data set. So here we can see that there are a lot of prize winners for physiology or medicine, but not so many for economics. This is quite natural. And then when we go a little bit more down, we can see that we are able now to highlight prize winners that got the prize more than once. And then, of course, we can go to different arrangements, like also for example how many women were there how many men and you can see like the imbalance and then we highlight again this year's Nobel Prize winners and then of course we do not have to stick to these like circular clusters here but we can also do like histograms here this is now the age distribution or we can split up the histogram again by price category and can learn okay for the Nobel Peace Prize. There is really some Nobel laureates that were really, really young. And of course, we can highlight again and again people and then go back from the histogram view, for example, to another circular cluster view where we highlight some countries until the end, where we go back to the initial cluster where we show Nobel Prize winners that were born in Germany. So this whole application was built with Svelte and it needed to be built very quickly. We also have a certain style for visualizations at Der Spiegel that you can hopefully see here a little bit. And of course, it also needed to be very accurate. This is data-driven, of course, in the end. And all these three requirements can be achieved by using Svelte. So I said it will be a look behind the scenes. So this is now just behind the paywall. Now let's go back behind the real scenes. And let's just go to my code editor where I already opened this project. And what you can see here first is that I love to use as many components as I can So for everything like histogram axis everything that can be separated a little bit from the rest I tend to use components And this is a good idea because from there you can build up then component libraries that makes it really easy to reuse components in the future. And this is what we do all the time. And this is important to be quick and to get some originality because your button looks then the same every time. And this is what we want to have, at least in our company. But I want to focus now on one component here, which is the laureates component, which is basically the whole background component where all the Nobel laureates are shown. So these little circles that you've seen in my browser before. And here within that component, you can see that there is first a canvas component. and you can see that this is not an HTML canvas here. It's really a Svelte component. You see the capital C here in the beginning. And I'll tell you a little bit more in a second about that. But what you also can see that within the canvas here, I have an each block on my rendered data and the rendered data is just all the Nobel laureates with like their X and Y positions where they should be positioned because I calculated somewhere else these different layouts and then say, okay, which chapter are we in? Okay, now Laureate A needs to be at position X, Y and so on and so on. And so we can just render over the whole data set and for each Laureate data point, we can actually draw one Laureate. This happens in the Laureate Svelte component again. And here you can see that we also love the idea of encapsulated data. So this Laureate component only needs to know its X position, its Y position. It also needs like a radius, a color, so some stuff for the appearance. There might be also an image. And then also like, is it highlighted? Is it in the background? Is it shown or moved to some delay and so on. So this is just the information this Laureate component needs to know, nothing else. And then this is what you seen before Everything is embedded in this canvas component because here for this special visualization we cannot rely on SVG as the technology to really draw these circles It would be possible, however, with so many circles, all the transitions that we would have between the chapters, they wouldn't be so fluid, so effective as they are right now. So here we have to use canvas. and I hear a lot of people and also me three, four years ago saying, oh my, when you use Canvas now, then it's really going into an imperative coding style because the Canvas API works a little bit like D3. You have to tell it, do this, do this, do this, draw a circle, draw this, draw this, but you cannot really outline your complete buildup of the app in a declarative style. And I want to do that because we work in small teams that change all the time. And I want my colleagues that they can easily read my code. And for that, I want to be very declarative. And this is why I use this trick that I have this special canvas component here. And on this canvas component, I can just loop over my laureates and draw them. So, but how does this work? So I would say that we start the other way around and look first into the laureate component here. So one of these laureate components looking like that. And let me just give you a complete overview. So you can see a lot of JavaScript code like here in the beginning. You can see, okay, here's my X and Y position coming in. That's really where this laureate circle is drawn on the screen. Then you can already see here is the get context function from Svelte. So it grabs variables from the parent element, which is the canvas here. This register, deregister, and invalidate. Those are three different functions. Then there's a lot of other stuff. Then very central, we have this draw function. This is really interesting. Let me come back to that in a second. We have some Svelte lifecycle functions and more JavaScript. And that's surprising. There is no HTML and no CSS in this component. And this is what we call renderless components And if you want to know more about them I will show you a little bit how they work here in this example But I would also recommend to watch the videos of Li Hao He is a really good explainer when it comes to that. And I learned also how to do that by his videos, which is really cool how he does that. but now let us go back to this draw function that I marked here already because the draw function as its name says it draws the circle and the draw function gets the CTX which is the context of the canvas we have right now no idea where this context is coming from and then you can see here in the first line it translates the pen basically to draw to the X and Y positions And I will show you later why it is not directly X and Y and why we have this dollar signs here. And then here in this part, the actual circle is drawn. And then there's just a little bit more design. If there's an image, we draw also an image and so on. But well, the draw function is defined here. We have no idea where this context is coming from. And let us have a look how that works. here in the life cycle functions we can see that on mount we call the register function that we get from the context from the parent which is the canvas component so the canvas component is giving us this register function and we call it with the draw function as a as an argument and then we also immediately called invalidate. We have no idea why we do that. But for sure, when this component, when this laureate is disappearing, then the deregister function is called again with the draw function as an argument. A lot of question marks, I would say, what's happening here? We register somewhat this draw function. Interesting. But then there's some other stuff. There's also this after update, it's just one line, but it's like the centerpiece of this whole component, I would say, which means every time this component is updating, then call the invalidate function. The invalidate function again is a function that we get from the parent component, from the canvas component. We still have no idea what it is.

 is doing. And I think now is the time to have a look into the canvas component. So let's go to the canvas component. The canvas component is looking now again a little bit different. This is a, I would say, quite normal component. We have like width and height that could be set. There is an update function, which is interesting in a minute. And there is also here set context, which is interesting because now we can see, aha, here's the place where this register, deregister, invalidate functions are defined. Cool to know. And here we can see, okay, register takes an argument, which is just called fn function here, which could be the draw function, you remember, and we put our draw function from each of the laureates into this draw functions array and the other way around when we deregister we cut out our draw function from the draw functions array and then there's also invalidate and invalidate is really interesting because invalidate has this line here which means we do a request animation frame whenever invalidate is called and we execute the update function. Okay, update function, you remember, we just saw the update function here on top. It's that one. So the update function, the update function works with the context. We still do not know where the context is coming from. The context is a part of the canvas. It's the access to the canvas. And there's just some some simple lines here, which just cleans the canvas whenever something is updated. And then it gets interesting because now we go to our draw functions array. We iterate through this array and we call each draw function with the context. And now we know, okay, here's the context coming from. And the context, where is the context coming from? Defined here, it's coming from canvas. and canvas itself is in our HTML part here a real HTML element. This is the canvas element. It's bound to the canvas JavaScript variable. And additionally, we have this slot here, which means okay this component here can take children even though a canvas an hdml canvas cannot take any children but here with this svelte component trick we make the canvas taking children at least virtually okay so we've seen now that the register function brings our draw function from each of the Nobel laureates into the draw functions array and all the draw functions in the array are executed when invalidate is executed. Okay and we remember now when I go back to laureate.svelte this invalidate function is called whenever there is an update. So that means if I give new xy coordinates to one of the laureates then I get an update. Okay then my canvas is newly drawn. Well, that's cool because now I just need to send new data to my laureate component, encapsulate it, and I do not have to worry about the canvas at all. It will just update automatically because of this registration of the draw function. that's quite cool but that's not enough because now we could say okay now i'm still in the laureate component and well renderless components for using canvas is really really cool and would be for me it would be a sufficient reason to say okay i go for swell now all the way for all the visualizations but there's even more i told you of transitions for example so if you remember in the draw function here, we draw our circle not to the xy coordinate, but we drew it to this $tx, $ty. And those are stores. And those are tween stores. So let's just have a look where tx and ty are defined. You can see that here. It's just by calling the tween function. And we set in some tween parameters, like how long should the transition be? because the cool thing about the tween stories, it has a value, that's the value you set. And when you change the value, the difference between the old and the new value is animated or there is a natural transition over time. And this is exactly what happens here. So sorry when I jump again a little bit to the bottom, but exactly here, when X or Y changes, because tx and ty is updated and animated And I read this animated value in the draw function by and every time a little frame of this transition happens the after update function here is called because the component has intrinsically updated. invalidate is called as subsequently. And that means that I do not have to worry about showing this transition on the canvas at all. So there is tween, which is cool as such. And then it can be coupled to this whole renderless component system to build up a complex visualization in a declarative coding style with renderless components on canvas. So now you've seen how such a visualization system could work. And now you might wonder, well, he has talked about Svald Love's D3. And yeah, maybe you've seen it, but we came across a little bit of D3 here as well. There is more in, but I'll just show you a little highlight if I go back to the Laureate component. You remember this was the component for each of the single circles. Then we draw these circles here. And to draw the circles, I use this pi generator, which uses this pi function. So that is just a path generator, which produces the path for the circles of the Nobel laureates. And this pi function here really is something that we get from D3. And this is exactly what I mean. You build up the whole application, the whole user interface, everything which is reactive DOM manipulation. And so, and then you look, okay, now I need, for example, this circle. And then you go to your D3 library and just take out what you need. And this could be just this simple pi generator function here, or it could be scales and, and, and. So there is much more. And this is I think how data visualizations can be built in a really really effective way So these are the Nobel Prize winners since 1901 And if I go back to the three main requirements that we have in the newsroom for data visualizations, you can maybe see how Svelte helps us to achieve them. so we could just import any other javascript library let it be d3 let it be like something like flubber or something else what you need in visualization you could just import it and use the functions that you need nothing else because you remember svelte is there for all the dom manipulation stuff and for everything else which is more complex which is more specific You just pull in your library from outside. Then the whole thing about concept abstractions. I just showed you one example with the renderless components to use or to build up a Canvas component that can take children so that you can use the Canvas API in a declarative manner. That's really cool. Then with the whole component, with the stores, so that you can separate data manipulation stuff to stores, for example. you can build up component libraries. You can even build up store libraries. So we at our company, we have like a toolbox of different components that could you reuse all the time. We have a toolbox of stores that we could reuse. We also have a toolbox of transitions and actions and so on. And that's really cool. And it helps, of course, to have a high speed during development, but also to be accurate because you reuse components that were tested. And then the whole hierarchical concept about the components is not only valid for the components, but also for the data concept behind. So you have your data for an application, but single parts of the application do only need to know parts of the data as well. Like the Laureate component, which just needs to know its X, Y position and some stuff to like the color and opacity and things like that for the appearance. So here Svelte is a really, really great help. And with that, I want to encourage you to go to github.com slash Spiegel Graphics.

 where we try since recently just to publish code from our more complex visualizations. And you can also go to my personal website, hicks.com, where you find also other larger visualization projects, mostly together with the GitHub link to go into the code base. And with that, I want to say thank you very much for your attention. and I hope you had a little bit of fun and learned a little bit. And yeah, I would say have a nice day and see you soon. Bye.