 Hi and welcome to from zero the package by the end of this talk and I want to show you how you can create some npm package with the help of SwellKit. SwellKit is the application framework on top of Swell. It's the official application framework and it can be used to or it helps with bigger applications because it supports code splitting. It has a file-based routing system for the server side rendering and also some other useful tools. And I recently also found out that it also can be used to create NBN packages. And that's what I'm going to show you today. And I'm going to share your screen for the presentation. I'm Ivan, I'm a senior software engineer at AetheraTec and we write a custom software for our customers and since a few months we also use Svelte and SvelteKit in some of our projects. And in one of those projects I had to solve a problem recently and we have some light and dark backgrounds and we wanted that all of our components react to or depending on if If they are rendered on a light or a dark background, the component uses the better looking variant of it. So if you have a dark background, we want the component to render the light version and also the other way around and without telling the component itself that it should render the light variant. So everything gets automatically detected. And the implementation took some time. It was not so easy. That's the initial thought. We came across some edge cases and yeah, when we were done and confident with the implementation, I thought that this project could be good to share to others because maybe they also So all those struggles struggled. And so I decided to share the implementation. And the easiest way to share something in the JavaScript ecosystem is to create an NPM package. And I Googled a bit. And then I saw that Setkit provides a way to do that quite easily. And now I will show you how we can do that. For this example, let's say we want to create a component library with some components that we want to use throughout all of our applications. To get started with a new use velkit project we can initialize it with the mpm command and I will name it Vienna demo and this command will go through some steps and we can choose between a demo application or a skeleton project we choose an empty project For the people who know me, I can't do anything without TypeScript, so I will also choose TypeScript here. Congratulations. And for linting, formatting and testing, we say no for now, but in a real-world application, you should probably also say yes to all of those options. Then let's see into the project, into this project. And for a component library, you probably also want to share some of the components should have the same look and feel. So you probably want to create some variables for those files, for those colors and fonts. Let's start with that. We create a new list folder and in here we create a varia.stss file. We also need to install SaaS. Note. Take advantage of SaaS in the cycle project. And let's create our first variable. It is a tomato, which is a little color you haven't seen before. Because we initialized the project with TypeScript, the Svapre-processed package was already configured for us. And that itself only knows JavaScript, HTML and CSS, and it provides that preprocessed package that also adds support for other language variants like JavaScript and also STSS or less post without me needing to configure it It just adding this line which was already done by the setup process So when we have our combo variable, we can use it in our first component, create a button that's that file. And let's use the variable to style the button. And we need to tell the preprocessor that we want to use STSS on that style attribute or else it will just use the usual CSS. Let's import the value. Back from the cover、 our button. Let's try to render this button. The auto import gets it wrong. Is it configured? It should be out of the question. I'm not sure. It was changed in recent version. You should create a PR. And if you now run the dev server, We have seen the power button on the whole screen. I forgot to render this logo here. You can see the button render change. Looks like the red. Best color ever. And yeah, but if we want to create a component library, you probably don't just want to style the button. We also want to add some complexity to it. So, we will add something to the script section and let's export a new variable and we call it loading. We can set a v4 value to the variable. So we don't have to set it on each component instance here. But a button usually also could have some other props, for example, type-battery-wood. But we got an error here because we haven't defined it on the component props. But you usually don't want to write each or define each property for that button. Luckily, Swagfit also provides a way to... So we don't have to specify them all. We can use the $$REST props feature. And once we save the file, we won't get an error here, because this file tool sees that we use that REST props feature and opens the button up for all properties. But now it also accepts everything, but that's probably not what we want. We can fix it again and add type safety by defining the special dollar box type here. Set it to a partial of an admin. html element has an interface defined where all the properties are defined and with the start we say that we mark all of those properties as optional. Now we also need to add the properties that we manually have defined here to this object. It's a bit redundant and ugly for now, but I think this will change in a future version. And now we have a custom button component with our loading flag and also we get code completion the code completion and also type safety concept number in this type here so We are not just restricted to components, we can also export some functionality or actions. An action as well can be used to enhance any HTML element with custom functionality And we can do that right now Let create a new And we define a new or we export a new action here. We give it the type of detection. We need to import it on . And we can specify generic parameters here. The first one is the type of node we want this action to be used on. For now, let's say we want to use it on a paragraph element. And as a second argument, we can say it's a number. This action should be applied on the paragraph and by defining a number, we say the amount of number of characters that this paragraph should show. So everything else gets... Thank you. And so we set a maximum amount of characters we want to show. Our first parameter is the node, the second is the length. And let's check for the length. And if it's bigger than our tank, we pass in. We use a substring here. We can now use it on our paragraph. Thank you see. The And we now see that it's created and we also can define the amount of characters we want to display. So let's say we now have our, compete with our component library and we want to share it. We then can just run the package command that comes with each site project. And when you first run the command, you will get an error. Because Velkit wants to provide a good developer experience and says that it will automatically generate TypeScript definition files, even if you aren't using it in your component library. So it will try to automatically infer what you want, what are the properties, and it creates the corresponding types of definition files. So it delivers a better developer experience for the consumer of the component library. And we can disable it or we just install it. And we run the command again. Now we should see our files inside this generated package folder. If we take a look at our button component, we see that it doesn't contain TypeScript anymore and also our STSS file gets compiled and we see our variable timeline here. The reason behind that is that this package then can be used by any other project, even if they have a setup of TypeScript or STSS, and it opens up the... It's not restricting the user to have a certain setup of the project. And also the TypeScript file we see is now a normal JavaScript file with the corresponding time script declarations. Also we see it here for the button component. Everything else that's inside the slip folder just gets copied over. The readme file gets copied over from the main package. And a new package JSON file gets generated with all the exports defined that we need. So we don't really have to do anything. We just created some files in the slip folder. And now we can go into this package and into this folder and publish it to npm I have already done that and I will show you how we now can use it Let's create a new project with the command we used before. We once again get asked what we want to use. We want to start our new skeleton project. For this time, we are not choosing TypeScript. We are using JavaScript with djs.doc comments. It offers the same type safety features, but with some additional overhead in writing those comments. I can go into this demo. Startup.ps code. I'll install dependencies and also install the package we just released. We wait for the npm install to complete. We now have the component library installed and you can use it here. the auto mode format. It doesn't manually import it. Just the button then it should be recorded. No, it doesn't. Inside of the script. Again, that button, I don't know where this is. We'reIONAL naprawdę verändert two right now. We want to click that. GoT Wolff Director the server. And we see our custom button. And like I said, we are not using TypeScript here. We don't have StSS installed. It just works out of the box and we also get code completion and strong type safety support out of the box because the button was created with type safety. Yeah, that's it. I hope I could give you a quick overview how to create a component library and publish it to NPM. You can find examples on my GitHub page. inside this Vienna Meta Package demo. Any questions? This build-in package, did this come with Svelcat? Svelcat, yeah. It's a beta version, but it works quite well. If you later decide to use some custom or advanced functionality from Svap itself, for example, the stores or context, then the consumer of the package has to add two configs to their B config, because the context needs to get bundled into the real application. So like if we would have store like. As fast or so that then get functionality. And this would work without those two additional lines of config. But you then have to two times the. The store functionality in your application one time from your component and the second time from your application. But in theory you could create a package that's not going to be used in self. Yeah, you can create anything you want. It doesn't really have to be consumed by a site application. That's very fast. Yeah, actions. Actions can be used on other elements. So Imperial can make an action which is kind of exporting the store or something. For example, that I did was to have a persistent store which maps itself onto local storage. So when they reload the page, it's still there. there and that should also work outside of the Svelte context because you just need to use set and subscribe functions. It's part of the packages. Thank you for folks who don't use Svelte. There is also Svelte and SvelteKit. the smell kit kind of gives more of a functionality it's like kind of compared similar to next areas we also have several several problems and okay Thank you.