 Thank you for having me. Well transitions allow users to understand where things come from and where it goes to. Much like this button over here. When I click onto it, it falls into the center and the title of my talk floats up. Yes today, I will be demystifying transitions in Svelte. And how am I going to do it? Well, we'll dive into Svelte transitions level by level. At the first level, we'll learn how to use transition in Svelte. The second level, we'll look at how to author a transition in Svelte. And the third level, we'll go deeper and take a look at how Svelte compiles and handles transitions under the hood. My name is Tan Lee Hao. I'm a software engineer at Shopee. Shopee is an e-commerce platform in Southeast Asia that is based in Singapore. I grew up in a lovely town called Penang in Malaysia, which has the best street food in Malaysia. Such as char kui teow, stir-fry flat rice noodle, or rojak, an aclactic fruit salad with palm sugar, peanuts and chilli dressing. And well, these are just one of the many great street foods that I hope to try again after the pandemic is over. But last but not least, I'm one of the maintainers of Svelte. So level 1, using transitions. Here we have a list of items rendered using the H block. When we add or remove item, the item appears and disappears in an instant. We have no idea where the item is coming from and where it disappears into. To add transition for the item, firstly we import a transition from a svelte transition. Here we import fade, and to add entrance transition for the item, we add in colon fade to the div. Now the item fades into existence. To customize the transition, we can add parameters such as duration or delay. And for exit transition we use out colon fade And if you want both entrance and exit transition you can use transition colon the transition name There are multiple built transitions in Svelte such as fly slide scale or blur and many many more. The list is not exhaustive, which I recommend you to check them out in the docs as well as the tutorials. 2. The transition contract. Not sure if you have heard about the store contract in Svelte, which states that if any object follows the store contract, that object can be used like a store, where you can subscribe to it and read the value like using a store using a dollar prefix. The same thing goes with transition. A transition has a contract. Any function that follows the transition contract can be used together with the in, out or transition directive. Here is how the transition function should look like. It's a function that takes in two parameters, the element node the transition is applied to and the parameter that is passed into the transition. And it should return an object that describes the transition or return a function that returns the object. The object should contain properties such as delay, in milliseconds how long work before the transition starts, duration, in milliseconds how long the transition takes, easing, the easing function which I'll explain later together with CSS, a function that returns a CSS string and tick a callback function. All of the properties here are optional, if not specified. The default for delay is 0 ms, duration is 300 ms, and the default easing is linear. Usually, you would want the transition to be customizable, and that's where the parameter is for. You can return the delay or duration passed in the parameter from the user. Now let's talk about easing. Easing describes how much an animation progresses at different point of time throughout the animation. For convenience sake, we describe time from 0 to 1, begins with 0% and ends at 100%. Here as the red dot moves from time 0 to 1 along the red line the value of the ease time grows linearly with time Well the easing function that we looking at now is the linear function The ease value grows linearly with time. However, if I switch to cubic in, the ease value grows in the power of 3 with time, which is described in the cubic function over here. Here's why we use 0 to 1 for time, because 0 power 3 is 0 and 1 power 3 is 1. So after we power 3 the value of time, we still start with 0 and ends in 1. But the easing function does not have to be a polynomial function. Here I'm using bounce out, which have like if-else case for different parts of depending on the time. Or we can call a function, another function within our easing function, such as this one, bounce in out. So how do we calculate time? At the beginning of the transition, record the start time. And throughout the transition, we have t, the time passed since the starting time, a millisecond. We divide the value of t by the duration of the transition. So now we get the value 0 to 1 for t. So 0 is the beginning of the transition and 1 at the end of the transition. Now if I pass t into the easing function, in this case bounce ins out, I'll get the is value. The value does not go from 0 to 1 directly. And if I use the is value to calculate how much I need to translate an element, I'll get an element that bounces in and out. And that's how the CSS function works. It takes in t, and you return a CSS style in string that will be applied to the element. You also have u, the second parameter, which is 1-t, the reverse of t. And as you can see, if you use u instead, then the element moves in the opposite direction. So if you use transition an element into view, the t will go from 0 to 1 but if you transition an element out of the view t will go from 1 to 0 And if you want to manipulate element beyond CSS you can use the tick function It also takes in t and u the same way as CSS function. One very common use case of this tick function is to create a typewriter transition. Do note that the tick function is going to be called on every frame. If you want your application to be buttery smooth 60 frames per second, make sure the tick function is fast to prevent jank. So we covered all the properties in the transition contract. Let's take a look at an example of a custom transition. Here I applied a different font style to the element. So the text stays bold and maroon for the first 40% of the time, and then italic for the next 40%, and then back to regular text. Well, 40% of the time is debatable depending on the easing function. In this case, we are using linear easing, so it is exactly 40%. As you can see, you don't have to limit your CSS transition to just CSS transform, or having to interpolate the value of t. The sky is the limit. Likewise, the text stays at coming soon at the first 40% of the time, before changing to the original text. Level 3. Compile transition in your head. This is a reference to the series of blogs I've written, Compile Svelte in your head. Be sure to check that out. As how it usually starts with CompulseFeld in your head article, we're going to explore how we can write a transition in vanilla JavaScript. There are a few technologies at our hand that we can make use of, and the first one is CSS transition. We add transition property to a selector, describing which CSS property to be transition, the duration, easing function, and delay. And when you change the value of specified property, in this case opacity, the opacity of the element will transition smoothly based on the easing function. So here I add the class to change the property to 0 and back to 1. However, CSS transition is a bit restrictive.

 You have limited easing functions. No offense, cubic bezier is great. Another thing CSS offers us is CSS animation. We can define keyframes of the animation and then apply it to the element using the animation property. We can have multiple animations happening at the same time, as well as we change the value of the transformation. We can have different easing. Notice that we can still use linear easing in the animation property. So the keyframes will happen linearly, but as the transformation in each frame grows in cubic power, the element translates in cubic easing. We are no longer limited by the easing function provided by CSS. If the transition is not CSS-based, we can use JavaScript. JavaScript. RequestAnimationFrame lets you tell the browser that you wish to perform an animation, and the browser will call the function provided for your animation update right before the next repaint. As you can see here, we can create a loop using RequestAnimationFrame, and the loop function will be called on every frame right before the next repaint. In the loop function, we have similar code as we have seen earlier. We calculate the duration since the start, and then set the text content based on the duration pass. So with CSS animation and JS animation, let's see how we can implement transitions in vanilla JavaScript. So here I have two buttons, add and remove. So add will call the insert new item and remove will remove the item. So now we want to add transitions. Before that, let's take a look at the styles files. So here I have two CSS animations, flyin and flyout. So I want to call the flyin animation when I add the item and when I remove it, I want to call flyout animation. So here as soon as I inserted the list item into the list, I'm going to add the style animation. So I'm called fly in 500 milliseconds linear no delay and no repeat and yeah So if I click add now you can see that it flying in Right. So for the flying out animation, here I play the animation, fly out animation. and instead of removing the item immediately i'm gonna remove the item 500 milliseconds later right so it's take five milliseconds to play the animation and wait for five milliseconds before i remove the item from the list so let me show you what we have right now that's great right so now the next thing i want to do is to have like a bounce fly-in animation instead of like a normal fly-in well i could manually write css animations like manually write out the keyframes over here but i would rather generate it using javascript so the first thing i'm going to do is i'm going to copy the svelte async function so i'm copying out the bounce function. The thing I'm going to do is to add a function called generateAnimation. So this file is going to generate the keyframes dynamically. First is that I'm going to determine the duration of the animation. So it's going to be 200 milliseconds, which is 2 seconds. Then I'm going to have a keyframe so this is like how many number of keyframes that i'm gonna insert into the animation keyframes well i don't have to insert too many frames it depends on how long the duration of the animation is going to be right so it's going to be at most 60 keyframes per second because the browser won't render more than that. So 60 frames per second would be 16 milliseconds per frame. So calculate how many frames would be using duration divided by 16.66. Right and then the next thing okay so probably I should round it up right Because we want the total number of keyframes then we're going to loop through this number. So now I'm going to create a rules. So I'm going to have keyframes over here. I'm going to name the animation bounce in. I'm going I'm going to fill in the frames over here. And to add the rules, to apply the rules on the HTML document, I'm going to create a style tag first. And then I insert the style tag into the document.head. and then I'm going to append, insert a rule to this style tag. So it's called style.sheet.insertRule and pass in the rules string. This will insert the rule bounce in. So now the next thing I'm going to do is to fill in this part. So what I'm going to use is using array.map. So I'm going to fill in this array with null and then map it. So what it's going to look like is that over here is a string. and support so it should be something like a percent and then we're gonna transform x translate y sorry translate y and then number pixels right so we're gonna fill in the zero percent and zero pixels based on the rule. So firstly, I need to know that the t, right, as we've seen earlier. So the t here is calculated as the index divided by the number of keyframes. And then the is t will be based on the easing function So we pass in the t value to the easing function And once we have the isT I going to fill that in over here So what I have is, we're going to start from 0 to 50. So I'm going to start with negative 50 to 0. Okay, so I'm going to start with 50 pixels and then slowly moves to 0. Right, so 1 minus t will give me 1 to 0. It will give me 1 when the t is 0 and then 0 when the t is 1. Right, so I'm going to move from 0 to 1 and then times 50 will give me 50 to 0. And then for the percentage, this will be based on t and it's going to be a percentage. So I'm going to times 100. So it's going to be 0% to 100%. And this should be the is t. And lastly, what I'm going to do is to join all of them with new line. Next one we are going to do is to have a 100% case. That's because index starts from 0 all the way to n-1, right? So we're going to have the n case where n will be the maximum number of keyframes. So here will be the target. So it will be transform translate y to 0. That's all. So let's see what we have. So before we're going to see what's going to happen, we're going to use this generate animation. So we're going to generate animation once. and then instead of using a fly-in animation we're going to use bounce-in save that and now we have a bounce-in next thing we're going to try to do is have like a typewriter exit for the list item so that can't use CSS animation so we're going to use a JS animation of salvation.

 So firstly, we're going to design a function called start.js transition. That takes in an element and a callback function. So how does that work is that I'm going to use it first. So I'm going to pass in the list item that we're going to remove. and then the callback function is actually this one where it will be called to remove the list item when the animation is done. Right. So over here, I'm going to start the loop. So we have a function called loop. And over here, we will request animation frame loop and copy this over here. and then so this will create like a loop for each frame and when we start we again we need the duration same thing we're going to do like two minutes two seconds so it's 2000 milliseconds and then we're going to have we're going to record the start time and we're going to record the end time that will be the start plus duration right so to do the typewriter kind of effect we need to first record down the initial text content of the element so here i'm gonna say text equals to list text content so here in each loop we're gonna know what's the time right now so that now it goes to date dot now and then if the time is has already passed the ending time then we're going to call the callback function and end it right here right so this will break the loop and it will not gonna go in finite loop anymore if it's not past the end time meaning we are still in the transition so now we want to know what's T value over here so calculate T minus the current time with the start time and divide by duration and make things easy the is T for now is going to be T So it like a linear easing And then we going to have to set the text content based on the isT So I'm going to slice the string. So it's going to call element. So it's a text. This as well. Sorry. so it's going to text.slice 0 math.round times 1 minus is t again it's the same thing is t starts from 0 to 1 so I'm going to get 1 minus is t so it will go from 1 to 0 So 1 will be full length, so it times the number of length will be the full length, and then we slowly move to 0, which is 0 length. We're going to slice that part of string and then set it to the element text content. So here I bounce in and type right to exit. The next thing we're going to do is to have a util function that combines both CSS animation and JS animation and that will resemble like how Svelte animation looks like. So right here we're going to have a function called transitionIn and that will take in and elements and duration, delay, easing, CSS and tick. So it will be taking in whatever the transition contract is passing in. So firstly we need to create CSS animations, So we're going to get the name. We're still going to call bounceIn because I'm lazy to think our new name. But for each bounceIn, we're going to have a custom identifier. So I'm going to use i. So let i equals to 0 So every time we call transitionIn we create a new animation name so depending on like what css functions you are passing in a different function will create different css animation rules next thing is we're going to copy what we have previously so we're going to copy like the duration and the keyframe sorry probably just the keyframe right and then we copy the code for generating the rules so now instead of bouncing we're going to have a custom name and instead of having manually a hard-coded transition we're going to have CSS. We're going to use the CSS function to generate it for us. So we have is t over here and 1 minus is t and here as well so we're going to have CSS 1 and 0 right? So this is the n and this is the beginning Now, next thing we're going to have is we're going to copy how we're going to insert the style sheet. And lastly, we're going to apply the animation to the element. So instead of doing this, we're going to have it over here. It's going to be renamed to element and bouncing with rename as name. And then this should be the duration and this is going to be the delay. Right, then the next thing we're going to do is that, let's try this out first. transition in and then we going to have delay is 0 duration is 500 milliseconds And then CSS will be pu return transform post translate y px template literal and then this would be u times 50 for example close this and let's take a look yep still behaves the same so the next thing is we're gonna incorporate gs animation inside transition in as well. Right, so once we've inserted the rule over here, we're gonna start the JS transition as well. So we're gonna copy the start and the end time. and then we're going to copy the loop. And here instead of, so here at the very beginning we're going to call tick at 0 and while it It ends instead of callback, we're going to call a tick 1 and 0. Over here, it will be tick is t and 1 minus is t. And that's all. So tick, I'm going to have tick over here. That's nothing. So just make sure everything still works. So we're going to use the transition in for actually transition out last item. So, yeah, CSS can return an empty CSS string.

 But then for the tick, we're going to have if t equals to 1, we're going to remove the child. Right? But then over here, we need to change the string as well. as well. So let's see we copy this one. So we record the text at the beginning of the transition and when it's transitioning, we're going to copy this to set the substring of the text. So else, gonna... Yep. So add, remove, add, remove. Right. So here we refactor transition into one function that takes in the transition contract. and we have duration, delay, easing, CSS, and tick. And we reuse it for both transition in and out, right? So it doesn't have to be for just adding things in. It could be an out transition. As you have seen how we can implement transitions in vanilla JavaScript, let's see how transition is compiled by Svelte. If you have read my CompulseField in your head blog series you should know that createFragment function To those that haven read it and have no idea what createFragment function is well go read it What are you waiting for Anyway, a createFragment function is part of Svelte Compile Code. It returns an object describing how to create, mount, update and destroy elements for the Svelte component. You can think of it as Recipe for Svelte Components, and Create, Mount, Update and Destroy are the basic operations of all Svelte Components. Here are two more operations added if you use Transition, Intro and Outro. And let's see how it's being used. Say if you have an itch block. So in the main createFragment function, you create an itch block, and you have to create each block function that has the recipe to create elements for individual each items. In the createFragment function, we call transitionIn and transitionOut in the intro and outro function. This will in turn call the intro and outro method in the individual item block. And when the each block has changes, say adding a new item into the array, Svel will also transition in the newly created block. And when the item is removed from the array, Svelte will start a new group of outros, transition out of the removed items, and synchronize the outros. Let's take a look how the intro and outro method look like for each item. First in the intro method we create a bidirectional transition for the div the the element we apply transition on if it has not been created and run it to 1 For the outro method on the other hand we run the transition to 0. Here both of the intro and outro is sharing the same transition object, so if the item is added and removed immediately, we can run the transition to 0. The intro animation is cancelled and outro animation is played immediately, depending on the outro or delay. If you only use the IN directive on the other hand, then only the intro transition is created. And likewise, same thing goes if you only use the OUT directive. Now let's take a look at how create IN transition looks like. Hopefully you can see some resemblance with the vanilla code that we've just written. We're going to look at the create in transition as the create out transition and the create bidirectional transition is almost similar in structure. So firstly, we have the start, invalidate and end. And the start will call the go. So we'll take a look at the go function. So the first thing is we create the CSS rule where we construct the keyframes and then we insert the keyframes into the style sheet and then we apply it to the element. Next we start the loop. So if you look into the code for the loop, it's using requestAnimationFrame. Before we start we need to record the start time and the end time so we know when it will end and start and we call the first tick function If the current time has passed the start time we calculate the is time and call the tick function And if the time has passed the end time, we'll call the tick function one last time. In the beginning of the loop, we dispatch on intro start event and when it ends, we dispatch on intro end. And of And of course some cleanup after that. Well, here are some source code references if you are interested. First is the internal transitions, where the transition in, transition out, and create in transitions method are being defined. Following is the internal style manager. Here is where you can look at Svelte's code on how to create new keyframe rules and manages the style sheets. Lastly is the runtime transitions. That's where you import Svelte transition from. You can check out the code for let's say fade, fly, slide, crossfade and many other transitions. So finally, a recap. We have seen how you can create a transition in Svelte, author a transition in Svelte, and finally how Svelte implements transition mechanism. Hopefully, transition is no longer a mystical feature to you, and I hope to see more creative transitions coming up. So tag me on Twitter or Discord at Lee Hau Tan. If you created something cool with transitions, I look forward to see them. And once again, I'm at Lee Hau Tan and Twitter, following me where I post cool and fun knowledge about Svelte. Thank you and enjoy the Svelte Summit.