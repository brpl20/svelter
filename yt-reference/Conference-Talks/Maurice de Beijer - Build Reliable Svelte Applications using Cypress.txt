 Thank you. Hi, welcome to this session on building reliable Svelte applications using Cypress and test driven development. My name is Maurice De Beyer, the problem solver. If you want to read more about me, check out my website. This session is not about me, so let's continue. But before I do, a bit of shameless self-promotion, I do have a Cypress course on Udemy. It's the highest-radius course at the moment, so if you're interested in learning more about Cypress, you're welcome to go there. What are we going to cover this session? Well, we're going to take a look at what cypress.io is. And we're going to take a look at how you can use SvelteKit and a SvelteKit application with Cypress to test drive your development. We'll look at creating pages and components, as well as testing APIs. And I'd like to cover running your test on a CI provider as well, but we won't really have time to get into that. But I'll provide the code for you anyway. So what is Cypress and why should you care about Cypress? Well Cypress is this great tool. And this is the Cypress website. Like every great tool it has a great website and pretty good documentation. And it's a testing tool for modern web applications. So browser-based applications. It allows you to write tests in an easy manner using JavaScript or TypeScript. It's got an interactive runner which would let you step through the different steps of your test. Kind of a time travel debugger so you can see exactly what went on in which step. Very useful when you're debugging tests. It will automatically wait for elements to appear. So if you clicking on a button for instance and that button hasn rendered yet because the application is still waiting for an Ajax request you don manually have to go and wait and check whether it there, Cypress will do that for you. It will also record videos of all your tests, not just locally, it will do that on the CI server. So if your test fails, you can just download the video and see exactly what the test was doing, which is a pretty nice way to debug your tests on a remote machine. It will also fake out the network if needed. By default all Ajax requests are going to go to the real backend, which is pretty good, it tests your real application completely from end to end. But in lots of cases you want a bit more control over the data returned or how Ajax requests are actually executed. In that case you can intercept those and you can fake them if you want to, or just check on whether specific properties are there or not there. Another neat thing is it can retry failing tests. Now ideally tests will never fail unless they are really broken, but it turns out that with end-to-head testing you sometimes have flaky tests. Flaky tests can be kind of painful. of leads to you just rerunning tests to see if they pass again. If you just hit the rerun button, why not let the tools do it for you? Cypress can do exactly that. You can run it in docker containers, you can download extensions from it, all very neat. Another nice thing is you don't need any external drivers. No web driver APIs. Cypress will run inside of the web browser and doesn't need any external drivers. which is pretty neat. Now you can't really talk about testing without talking about the testing triangle. I've got the testing triangle here. And at the bottom are our unit tests, where we create small tests against small pieces of code, which runs really fast. And above that we've got integration tests, where we kind of write a similar style of tests, but the chunks of code we test are somewhat larger. Now these are fine, and you should definitely do them, but they tend to lead to tests which are somewhat, well, not representative of what your application actually does. You might end up with lots of tests which actually pass but your application doesn work And above that we got end testing which is what we doing with Cypress And right at the top we got manual testing where a user actually goes, or a test professional probably, actually goes through your application and tests it. Now those manual tests are never going to go away. But it's slow, it's a manual process, which makes it not very repeatable and expensive. so while it's needed for some special cases, you should minimize it. Now there are lots of mimes on the internet about over-relying on unit tests. And I kind of like this one. I've got a glass sliding door, and it reacts to someone walking up to it and opens. And that works just fine. It was unit tested and perfectly fine. And then there are the two little gates. they also have a sensor about something or someone approaching, and they will open up. And again, they were unit tested, they work fine, they do the job perfectly well. But if you put them together, they interfere. Because if one closes, the other detects it and opens, and that triggers the first again. So that's what you get with overall lines on unit tests. But like I mentioned before, unit tests is not something that should go away. There are lots of things which are very easy and good to unit test. Things like algorithms, small details, these kind of things. You shouldn't write end-to-end tests for those. Write unit tests there. Now a wise man once said, the more your tests resemble the way your software is being used, the more confidence they can give you. And that wise man was Kent C. Dobbs. He's the author of the testing library. Great set of tools to bolt onto Jest for unit testing. Great to test Svelte components with Jest. But also to help you with Cypress end-to-end testing. Now I'm not actually going to use that in this demo. I'm going to keep things simple. But these tools are highly recommended. Now what are we going to build? We're going to build a small Movies browser application using SvelteKit. It's going to look like this. We going to fetch a set of movie data from the MovieDB a service on the Internet We going to display it in this card format There is a bit of a navigation at the top between home movies and an about page And we'll do that in a test-driven development. And how are we going to test those? Well, of course we're going to test them with Cypress. And we'll see different tests like these. None of them are there yet. yet, we'll create them, but we'll see those run and test our applications. And we're going to do that in a test-driven approach. So I'm going to write the tests before I actually write the code. Now what's already done? I have prepared this a bit. I have done an npm init svelte.atnext with the application name. And I said no to the option of using TypeScript, even though I'm a TypeScript fan. I also left out ESLint, not that important for a small thing like this, but I did use Prettier for code formatting, just to keep things nice and pretty. So that resulted in an application which looks like this. A standard SvelteKit application homepage, nothing much to see here, just a link to SvelteKit documentation. So that's done. I also added the dependencies. I did an npm install bootstrap, because we want a bit of styling, and I want to keep it simple as well. And I installed cypress. So those are in place. I also created a few components, just to save some time. I've got a simple header component. It creates a navigation bar at the top of the page, and lists the three pages. Home, Movies and About. That's already in place, but it's not actually being used yet. So that's done. Next I created the MovieCard component. A pretty simple Svelte component, nothing special there. It receives the movie as a prop. It renders the movie with the image, the title and the overview, in a card, in the UI, with the standard bootstrap styling. So that's done as well. One other thing I did, I already created an about page. If I go to localhost port 3000 slash about, we can see that about page. So that exists as well.

 Now let's write the rest of the application in a test-driven style using Cypress. In order to open Cypress, you can run the CypressOpen command. And I added that to my package.json right here. So the command cypress colon open runs cypress open. And I've also got the cypress run command, which runs it in a headless way. CypressOpen runs it using the interactive CypressRunner, which is the typical runner you use when developing tests. Normally you would just be able to run Cypress open, but in the case of a SvelteKit application that would actually result in an error, so we first want to create a Cypress configuration file with a minimal setting in there to prevent that error from occurring. We'll create a cypress.json file. I'll add a $schema option, that's optional, not required, but it helps with IntelliSense. But the option I really want is that plugins file. By default, when we first run Cypress, it will create a whole scaffolding for us, including a standard plugins file, but that's not compatible with CommonJS, and as a result it will fail. We don't really need it, so we can set it to false and it won't create it. If we want it later, we can still add it back. We create a common JS file, a CJS file, and we add a pointer to that file right here. And then it will work just fine. But as we don't need it, I'll just set it to false to skip installing that. So with that in place, we can do a Cypress open, and it will create the basic Cypress layout, folders and files to get started with. So there Cypress opened, and now I could actually run one of the standard tests it generated as an example. Here's a simple to-do spec they provide as an example. These examples are quite useful, but we're not actually going to use them right now. Now I could go and delete those example tests, not a big deal, but I'll leave them for reference because the examples are kind of useful. So your typical next step is to add two more settings to the cypress file First the base URL where the application lives You don want to code that into your test because it makes it a little harder to change things And we want to hide those sample tests. So the base URL points to localhost port 3000, and using the ignore test files, we ignore the two sets of generated tests, which were as an example there. Now in the test runner we can see there are no tests whatsoever. So let's start by testing the navigation, the header component, which we're not rendering yet, but like I mentioned, we're doing things in a test-driven development. So we're creating tests first, and only then are we going to implement the functionality. We'll create a new test specification, the navigation.spec.js. We'll describe it using the describe block. In the before each, which runs before each test, we'll go to the homepage using sci.visit. We'll navigate to the homepage. And then in the first test, we'll test whether we can navigate to the Movies page. We'll locate the nav element using cy.get with a selector for the nav element and then inside of that we'll look for an anchor tag with the text Movies. And we'll click on that and we'll check whether the path equals Movies. And then we'll do the same for the About page. Again with cy.get we'll get the navigation element. We'll search for an anchor tag inside of it, which contains the text about. We'll click on it, and we'll check whether the path name of the location is equal to slash about. Now remember, these tests are going to fail, because we haven't actually implemented the navigation yet. The header component exists, but isn't rendered yet. In the test runner we see that navigation spec, and if I click on it, We can see that it starts up, but we'll see it fail pretty soon. We see the get for the nav element fails both on the about page and the movies page. Now we have the header component which will render that but we not rendering that In SvelteKit if you want to render something on every page the typical way to do it is to create an underscore underscore layout dot Svelte file a template and then in there render whatever you want on all the pages. So let's go and do that. In the underscore, underscore layout dot Svelte component, we'll first import bootstrap, so we've got the global styles available. Then we'll import the header component from the library folder. And then we'll render that header component inside of a container. And we'll add the slot component so we can render all the actual content. And now if we go to the browser we can see the header here. So we've got home, we've got about, and we've got movies as well, which doesn't exist yet, so that still renders a 404 error. But we'll fix that later. Let's run our tests. And now we can see that all our tests pass. Even the Movies page test passes even though the Movies page doesn't exist yet. But we can see here that we can find the nav element, we can find the anchor tag with the text movies. We can click on it, and with the red dot you can see where the click occurred. You can actually control that if you want to. And then we can see that we retrieved the path from the location, and that it matches slash movies. So even though it's a 404, it still renders on that path, and that test passes perfectly fine. And in the navigate to the About page. Again we can see we find the nav element, we find the anchor tag for About, and then that renders and the path name with the actual page being rendered is there. So we can see exactly here what happened on each step. Now it's nice that our tests run, but we really wanted navigation to the movies to fail. So let's add an additional test there, that we actually know that we're rendering the Movies page. We'll add a check using Sci.Title, whether the title for the page is equal to Movies And we do the same for the About page where the title should be About And at the same time we check whether there is an h2 header there with My name, Maurice the buyer, that that exists. And now if I check the test, they automatically rerun because the test specification was changed. And we can see that the test for the Movies page now fails, but the navigation to about and the details there pass perfectly fine. But here we can see that the title was an empty string where we expected it to be movies. Let's go and create a movies page so this test actually passes. In a typical test-driven development fashion we do the minimum required, we create a movies folder with an index.svelte component, and we set the title in the headers to movies, because that's the only thing required for the test to pass. And if I rerun these tests, they pass perfectly fine. No 404 error anymore. So we can see an empty page here, we can see the home page. It's an empty page, but the header is there. Great. Now having an empty header there is ok, but we really wanted to see cards of movies there. So let's go and add a few movies in there. Again, first we'll write the test. We'll test whether there is an H5 element looking for the Shawshank Redemption, and that that exists. Well, right now the page is empty, so that test is going to fail again. As expected, we can't find the Shawshank Redemption in an H5, and the test fails. So with the failing test, let's go and implement that functionality. Inside the Movies page we'll import that MovieCard component, and we'll create a prop movies, which we're not going to set externally yet, but we're going to default it to a couple of movies, the Shawshank Redemption, and we'll add Pulp Fiction to it as well, both with a small overview

 and an image. Having a movies prop like that is nice, but it still needs to be used. So let's create some markup to do that. We'll create a main element, put a header in there, create a card group, and then loop over the movies, and render that movie card for each movie in there. So now if I go to the browser, I can see that the movies page renders two movies. And if I rerun the test we can see that our test passes as well. Now if we go to the movies page, the URL, the title is there and we can also find the header we are looking for, the Shawshank Redemption. Sweet. But we don't want to hard code these movies, we really want to get those from some API. And we're going to get this movie information from the MovieDB, a nice service on the internet which has all the information about movies you'd ever want. Now the MovieDB requires the use of an API key. So here in this .env file I added a registry for the .env.local key, and I've actually got the real key in the .env.local file. But if you want to use this, go to the MovieDB, register there, create your own v3 API key and paste it in here and you can run the same code. But of course an API key like that needs to be kept private, so I don't want to use that from the browser. I want to create a server-side API which uses that key and provides only the required information to the browser. doing it in a TDD style again, we'll first write the test, and then we'll do the implementation. So I'll create a new specification, moviesapi.spec.jazz. We'll describe that we're doing the movies.json API, which doesn't exist yet. And in there we're going to do sci.request to do an ajax request to the server. We get the body from that and then we check whether that contains the shape we want So there should be movies in there There should be 20 in there and we check the first movie whether it has a property ID and that type number and whether it has a property of title, and whether that's of type string. I'm not going to do the other properties there. I would typically include all the ones I care about, but that's enough. So now I want to run this test, and of course as we don't have the implementation yet, it's going to fail. So let's add the implementation. We'll create an index.json.js file, which runs on the server. We'll import that API key there. We'll export the get function, because we're only going to fetch data. And in there I'm going to fetch the data from the movie DB. I'll get the top rated movies, pass in that API key, tell them I want the English version, get the data from there, and I'm actually going to return that. So that's the server-side endpoint complete. So now our test should pass. Rerun the test, and we can see it went to the movies.json API endpoint. It found an array with 20 elements in there. It grabbed the first element and it checked whether it has an ID property, which it had, which was of type number, and the same with the title, which was of type string. So we can see that our test passed here. Now we want our Movies page to actually start using this API instead of the hard-coded list of movies we were previously using. We'll add another script to the Movies page. In this case, it's the context module. We'll export the load function, so this will run on the client if we're doing client-side navigation or on the server if we're rendering a page directly from the server. We'll go to that Movies.json API endpoint, get the data and return that as the Movies property so we'll inject that into the running component. And now if I load the application in the browser we can see the Movies page rendering a much bigger list of movies And we can still navigate between them Nice. The Shawshank Redemption is still here, so our end-to-end Cypress test is still gonna pass. Sweet. Now there is one problem with this end-to-end test. I'm really dependent on external data during my test. I don't control the movie DB, I don't know what is going to be returned, and this list of top rated movies is going to change over time. I'm pretty sure the Shawshank Redemption is going to be on page 1, it has been for a long time, but eventually it will be pushed down, more popular films will show up, and my test will all of a sudden fail when this is pushed to page 2. And that's not exactly what we want. So let's create another specification where we fake the response from the API request, the movies.json. And we don't really go to the movieDB, but we use a fixed known set of data. Create the third test, the movie.spec.js, so it tests the movies page. And just like before, in the before each, we're going to visit the homepage. But then we're going to use cy.intercept to intercept a request to the movies.json file. You can do several things with it. We're giving it an alias here, so we can actually use it in the test. But I'm also specifying fixture here, which means that it should respond with the content of a predetermined JSON file. So this test as a result is going to run faster, but it also gives us more control over the output. Then inside of my test I use cy.wait to wait for that movie's AJAX request to have been done. And then I get the response from that, that resolves with a promise, it gives me the response, and the body of that contains all the movies. And then instead of hard coding, I'm going to use the actual data returned from that fixture file to drive my test. So I'm checking whether there are enough cards, and the first movie in the JSON is checked against the first card the second against the second card etc Now in this Fixers folder is where Cypress is going to look for movies And that doesn't exist yet, but I have one prepared right here, so I'm going to drag that in. And that looks like this. There are just four movies in here. The Shawshank Redemption again, The Godfather, with their description, their backdoor of pub, and the ID. Just the data needed for the UI. And now I can run that specification, and we can see that it runs and it tests all the different bits of UI. Also nice, I can run all the tests. We can see I've got four different tests which test the complete application, and it just takes 2.64 seconds. So these tests run pretty fast and are pretty easy to maintain. So just for reference, some slides with the tests I just created. This is the last one I just did. You'll also find the GitHub Action in the source code. I'm not going to describe it, but this will basically run on GitHub whenever a push to the main branch is done or a pull request is opened to the main branch. and it uses a special Cypress action to run. Really nice and pretty easy. If you want a copy of this presentation, go to the top link, theproblemsolver.nl slash presentations. You'll find a link to lots of presentations I did there. If you want the code, take the second link or scan either of the two QR codes, which will take you there as well. Cypress is a great tool for end-to-end testing. End-to-end testing makes your tests much more reliable, gives you much more confidence in your application than just relying on unit tests. Highly recommended. Write tests that resemble the way your users interact with your application. Great approach. Great for TDD. Test your APIs. There is a lot more you can do with Cypress. So have fun with Cypress! And thank you for watching this presentation!