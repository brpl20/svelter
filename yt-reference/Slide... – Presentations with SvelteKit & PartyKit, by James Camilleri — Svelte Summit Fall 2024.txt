 Intro Intro Intro Intro Intro Intro Intro Intro Intro Hey Zvelt Summit! Super excited to be here! Although, to be honest, this is the first time I have pre-recorded the talk instead of giving it live, and it's super weird. Also, I just spent 45 minutes recording and then realized I had the wrong mic hooked up. Anyway, I'm James. I'm a software developer based in London, although I'm originally from Malta. And today I'll be talking to you about making slideshows in SvelteKit. This is a little hobby project of mine. And it came about because inevitably, every time I needed to give a presentation, I would spend hours, if not days, trying to get my slides together. A simple task would just spiral into hours of debugging CSS and trying to get the zoom right, so I inevitably built a tool to get all this out of the way. The entire tool is built on SvelteKit, but we're also using PartyKit for some cool WebSocket integration, and that lets us do things like synchronize the view across multiple browsers, to do things like have note screens or presentation view, or even a little remote that you can use from your phone to move the slides forward and backward. So we'll talk about that in a bit. This is all inspired by Reveal.js, which is a cool tool for making HTML-based slideshows. Reveal.js is a super cool tool, but it's quite SPA-oriented and didn't quite play nice with ZveltKit when I wanted to get some of the more advanced functionality to work. Today we're going to talk about making a slide deck using the tool, the templating system that you can use to give every slide just the right look, how we leverage VELT's transitions, and also how we make some pretty cool animated backdrops, and then finally how we use PartyKit to get the remote control and presenter view working. The entire crux of the application is just a list of slides. I didn't want to write out the HTML for every slide because that could get a bit boilerplate-y, and while Markdown is super cool for easily getting your text out, it gets a bit tricky when you want to do anything more complicated with it. So a simple array of slide objects seemed like the best way to go This is in fact the slide list for the current presentation we going through There templates that you can define for each slide and all the content you need to show in the slide is passed through as a prop. You can also add notes to individual slides and that will show up in the notes view or the presenter view or on your phone if you're using the mobile clicker and that's super handy for reminding yourself what you're supposed to be saying. There's also a slide resolver function and what that does is pick the most appropriate slide for the given content. I'll show you how that works in a bit. There's markdown processing and we can also embed things like iframes, images and videos. Code highlighting is also built-in with Shiki. That's pretty handy and the nifty thing we're doing here is importing a bit source code as a raw string using veet's raw parameter. The app is using URL-based state, so the current slide index is stored in the URL, and that is pushed through to the current root. That is in turn pushed through to the slide view component, whose job is remarkably displaying the slide. So with that slide, with that index, the slide view component will pull out the appropriate slide information from the canonical slide list and then use the resolver function to figure out which template it's going to display. This is an example of a simple resolver. It's basically a function with a bunch of if statements in it. So each slide goes into the resolver function and using the properties available on that slide, you can figure out what the most appropriate template to show is. So in this case, if we have a slide with a code key, we're going to obviously pick the code template. In the case of slides that only have an H1 or an H2 and no other content, we're going to display them as a center title. And you can add as many variations and as many templates as you want in here. And there's always a fallback default template if nothing quite fits the bill. Here's an example of a super simple template. It is in fact the code template that is used to render all the code samples, so the one you're looking at now. Again everything comes in as a prop and we using Shiki for the actual highlighting The HTML itself is super simple It just the title and the injected formatted code We talked about Markdown previously. Markdown is great and we're using the Svelte Markdown package to automatically render Markdown in our titles and in our main content. So that's again super simple template and it just works. the slide view component sets up some global styles and then uses the slide index to pull out the current slide from the canonical list of slides and passes that through to the template resolver to actually pull out the slide component so super simple stuff you'll notice we're using the new Svelte5 syntax for rendering variable components. So rather than using the old Svelte colon component syntax, it's just actually putting the variable in as a live component. You'll also notice that we're keying the slide index, and that means that every time the slide index changes, shifting from one to the other, we get an automatic transition out of the box. Transitions themselves are super simple to set up. It's just a matter of grabbing the existing Svelte transitions and picking the ones you want to use, or writing your own in the traditional Svelte manner if you're so inclined. Config is done through this function that actually receives the current directions. You can have different transitions for whether a slideshow is moving forward or back, and that lets us decide if we're going to slide left or right in this case. And now for some fun stuff, animated backdrops, because we're over subtle gradients. Since everything in the slide is a Svelte component, we can make some pretty nifty animated backdrops. This for example is made entirely out of animated SVGs, and this is what you get when you first download the template. This is a slightly more complex one and this is made with Trelth. This, by the way, is the most meta part of the presentation. This is a slideshow about Svelte built in Svelte embedded in a slideshow about slideshows in Svelte built in Svelte Shout out to the Threlt team for building such a nifty library The previous example and the backdrop for the current slideshow are all built in Threlt. So that's really cool. And speaking of background components, this is the background component for the current slideshow. You'll see we're using a Threlt canvas over here. and every background receives the props for the current slides. You can do things based on the current slide content in your background, such as setting it to dark mode. We're using Svelte 5 encapsulated state over here, so that's creating a little sub-function that always returns a reactive number dictating the direction the slideshow is moving. and we're also using something interesting here which is a seeded random number generator. So the idea is you create a random number generator based on a particular seed which in this case is a concatenation of the current slide index, the title and some content and what this means is that for that seed the random number generator will always return the same sequence of random numbers, meaning it's random but predictable, and I'll tell you why this is important in a bit. The actual animation itself is just a lovely thread component that does all the cool stuff in the background. So here's an example of Svelte 5 encapsulated states, which I'm just throwing out for those of you who are still warming up to the new syntax. A bit of gotcha you should always pass reactive state around as some sort of getter because you want that to be recalculated on the fly every time the state is being accessed also we've got an example of the effect dot pre rune being used here this is important we want to calculate the direction which way the slide is moving before the dom actually updates otherwise we get into a scenario where we have two updates, one animation going one way and the other animation going the other. So, predictable randomness. Why? Why not just use mat.random? Well, the main reason is that it allows us to have a repeatable sequence of events. So, if you look at

 the location of the orange cubes in the backdrop, those are random, yet predictably so. If I move to the next slide and then move back, the cubes are in the same place. So this means that if I'm syncing my presentation across all of my audience's devices, everyone's backdrop will look the same. If people access the page at random, they're always going to have the same position of animations that require some element of randomness will have that random effect but also replay consistently every time. This allows us to synchronize that randomness across multiple devices. This is how we get these seeded pseudorandom numbers. I'm not gonna lie, this code is completely beyond me, it's doing some funky maths which yeah, I'm not cut out for. So thanks to Bryce if I'm pronouncing that right, probably not. Thank you for your contribution to the internet because I have no idea how this works but it does. Onto the actual threat animation, there's a lot going on here so I'm going to skim through most of it and kind of stop on the interesting bits. We're using tween stores to store the values that need to be transitioned. So in this case it's the intensity of the two lights on the backdrop, there's one on the top right and one on the bottom left. And we're using the fromStore helper and that converts that into newSvelte5 derived state. Got an effect over here that triggers whenever dark mode changes. and that's going to change the opacity of the lights according to if dark mode is active or not. This is the main workhorse of the entire animated backdrop. It's a large chunk of state that's holding an array of blocks. Each block is a piece of Svelte reactive state that's encapsulated in the gloss, and that is holding information about the position of each cube, its rotation, its color, and I'll show you how that works in a bit. And again as mentioned previously we using state getters to return the latest value of any reactive state to make sure all the cubes are in sync So we just using an iffy here to generate this first block of state once Could have pulled that into a separate function, but this seemed quicker. And here we're using another effect to pick three random cubes to highlight. Again, as discussed previously, we're using the seeded random generator. so those cubes are going to be the same for everyone doing the slides and always the same when you move from one slide to the other as in when you move forward and back your cubes will be highlighted in the same place they were before as opposed to the same cubes being highlighted for every single slide and here we're actually just updating our block state we've got a rotate function and a set color function and that's going to trigger the highlights and the rotation these are the lights mentioned before and here we're using a handy 3js tool called an instanced mesh now what an instant mesh is instance the mesh so an instant mesh is a tool for displaying large numbers of the same geometry it saves on rendering time and improves performance by basically grabbing the same object, cloning it multiple times, and then adjusting transformations and colors on it. So in this case, we've got this single rounded box geometry, and that's being replicated for each of our block states. And each block has its own unique reactive position, rotation, and color. Finally, we're also adding additional lights to any of the cubes that are highlighted. so the three orange cubes in the backdrops you'll see just around here they've got this little glow emanating from them that's actually a point light within the cube itself and that is only being rendered if the cube is highlighted this is important to note because once you get more than five six lights in a 3js scene performance slows to an absolute crawl so So we're selectively turning lights on and off according to which cubes are highlighted. This is the Svelte 5 Reactive class. Again it pretty big and it one of the largest things I written with the new syntax so there probably stuff that done Hopefully please let me know if there better ways to do this Here are all our tween stores. We're storing the rotation of each cube, the position because our highlighted cubes are kind of pushed out forward from the backdrop, saturation and lightness for the color and the intensity of the lights in the highlighted cubes. lots of reactive state here lots of derived state with the from store helper and this is just derived state to create a color string that gets fed into 3js we're using the current direction of the transition to deduce how we should delay the cube's rotating so if we're moving forward we need to start our animation from the left to the right and if we're moving backwards we need to start our animation from the right to the left so if you look at the backdrop here we've got transitions one way and transitions the other way so that's our derived state And these accessors over here will allow us to constantly retrieve the latest version of each cube state. In this case, the position, rotation, color, and the intensity if they're a glowing light. There's also the option to extrude cubes, set the color, and actually adjust their rotation. 3.js uses radians, which is a bit of a head-scratcher if you don't know. lots of weird jank until I figured that out. Also, fun side note, so the random number generator, again, predictable numbers in the same order, which means if you don't call it the same number of times, your sequence of numbers is off, and I've basically accidentally recreated a React hook. So if you are implementing something like this, obviously it's a single sequence of numbers that is always going to be the same. You have to call the function the same number of times each render if you want those numbers to be predictable Anyway that our Svelte 5 reactive class So next fun thing we going to talk about the remote control functionality So how we going to synchronize state across multiple applications with WebSockets and PartyKit. What is PartyKit? I hear you ask. PartyKit is this cool serverless library. It's built on Cloudflare's durable objects. So lots of info on CloudFlare's page if you want to learn more about durable objects. But the idea is that it allows multiple serverless applications to share the same state. So there's a single piece of fixed state and multiple applications, despite being serverless, can hook up to that state. You can access the shared state through Particator via HTTP requests, or in our case, WebSockets. This is the basic architecture of how we're sharing that state across instances of the app. We've got our host application here. And what that's going to do is generate an ID, which is the room ID for PartyKit. That is going to be used as the central address for all the clients to connect to. So the host will generate a new PartyKit room. and PartyKit will store the information. In this case, the key piece of information we need is the current slide. So that is stored as a piece of shared state in Cloudflare's durable objects. Any other client that connects to the same ID is going to be pushed through to that same room and they can retrieve the latest value of the current slide from there. So anytime the host value, the host application pushes a new current slide, that current slide is automatically reflected via WebSocket updates to all the listening apps. And the same functionality can be used for view-only slides, for using a remote control, for a presenter view. It's just WebSockets all the way down. There's also the problem of authentication in that we need to be sure that clients in view-only mode don't suddenly have access to your presentation. Because the last thing you want when you're giving a big presentation is some guy in the back row on his phone flipping your slides for you as you're trying to talk. So,

 This is solved in a super low-tech way. Do not repeat this kind of authentication to store your client's credit card details. But essentially what we're using is a shared secret. So upon initially creating a session, the host remote is going to generate a secret. That secret is going to be passed into Partikit and used to authenticate incoming requests. any new clients connecting will provide that secret if the secret is available they will be allowed to push state if not they can only draw state from the shared store so in this case if for example we're sharing a public link to access slides the link will only include the shared id but not the secret, which means that any client trying to push state will be barred because they don't have that little piece of code that's going to add them to a list of allowed clients. On the other hand, if we're opening presenter view or adding remote link, we're going to pass the secret along as a query parameter. That query parameter is going to be picked up by the client and passed on in the initial request. Once that initial request is made, the code within PartyKit is going to remember which users or which clients are authenticated and which are not. Simple, no fuss, not very secure. Again, do not implement this for anything serious, but perfectly fine for moving slides back and forth. Okay, it's demo time. I'm going to show you how this works in practice. So let's get out of full screen mode. And you can see that we've got our current slide here in the URL, that's slide 28. First thing I'm going to do is hit P to bring up my presenter view. And you can see that, actually I'm going to do it again, watch the URL as that happens. So you're going to see, we're going to open a new tab and we've got the secret appended there at the back. So we now have the current slide ID, the current presentation ID over here, followed by the current slide and you can see that our slides now match up. If I move backwards on the main slide my presenter view would also update If I move forward on the presenter view my main slides will also update Notice again back to that control randomness you can see that the random background matches in all versions of our slide We've also got this handy little notes view over here. And if we go back to the main slide, we can also trigger a remote control view. So by hitting R, I'm going to bring up a shareable QR code. Again, current slide listed over here. The presentation ID over here and the secret over here. This is prerecorded, so you can't do any damage once this is out because I'll be in bed. Going to grab our phone, a simple QR code reader. Pick that up. and you can see here we've got slide view and that's bringing up my notes and buttons to move forward and backward and that is again all working live over web sockets and all of these states are now synchronized so if I pop back to my presenter view you can see that's also synchronizing in the same way. So that's handy. Last-minute addition to the app was a notes view so that again same thing rather than showing the entire presenter mode it just shows the notes. Notes is a read-only, an example of a read-only route on the app so I can't actually change what slide is visible from this page but if I go back here and flip a slide back and go back to the notes page You'll see that's updated with my notes for slide 27. So yeah, that is PartyKit and live slide synchronization. That's it for the demo. I'll now dive into how the PartyKit connection and server is actually set up. And it's pretty simple. So if we look here, this is just a single class. We're using a couple of private fields to store important states. So the secret which we going to use to authenticate clients against a set storing all the authorized client IDs the current slide which is really the most important piece of state that going to be stored and we also storing the total slides just so no client accidentally pushes the presentation past the last slide. The onConnect function is called naturally once any client tries to connect to the server. We're going to try and pull out the secret and the total slides from the URL, just from the query parameters. And if the secret is present, we're going to add them to our authenticated list. And if it's the case that it's the first time we're receiving a secret, we're going to make the assumption that this is the initial host setting up the session and use that as a canonical secret to check against. Any clients with a secret are added to our authorized set and once a client is added we're going to notify any other parties connected that a new client has been added this realistically is currently just used so that once you open a remote qr code once your phone connects it'll automatically dismiss the qr code which is just handy to find out that things a connection has actually been made Other than that, whether a client has a secret or not, anytime something's connected, we're going to propagate the latest slide number. And that means that if you connect from the wrong URL, once you connect and receive that server state, you're automatically going to be updated to correct most current version of the slides. onMessage function is called for every message that's received. First thing we're going to do is block any unauthorized client. So if the ID of the client making the message is not in our list of authorized IDs, we're just going to ignore anything they try and do. Whereas if not, we're going to parse the slide from the payload they've sent, sanitize it to make sure they've not accidentally pushed us before the beginning or after the end and then broadcast this new data to every single connected client so that way i can push state updates from the main slides i can push state updates from the remote the latest version on every message is going to be propagated to all connected clients and that's all done in maybe 40 lines of code which is pretty impressive given you have instant real shared state via WebSocket in a serverless environment So well done Bartikit Looking at the implementation from the remote side, i.e. the actual application on the browser, the class is slightly chunkier here, but it's doing much of the same thing connecting to the shared state. Again, I'm going to skip through the less interesting code, storing and restoring some of the session parameters in local storage. And that's just handy. So if I need to refresh my core slideshow for any particular reason, it'll automatically set up in the same connection and I won't need to reconnect all of my associated clients. This is how we initially set up our first session, just a random UID for a presentation in secret. And this is the key function that's actually calling initializing the whole shared session. So the meat of it is over here. So this PartySocket function, PartySocket class, is actually going to create a live WebSocket connection to PartyKit. We're pulling out the host, which is public and shareable, setting a particular ID for the room, and this ID is what other clients are going to use to connect to to ensure they're sharing the same state. Secret and total number of slides are passed through on a query parameter. The rest of it is just plain old WebSockets, so we're adding an onOpen function, which will register various handlers once a WebSocket has been constructed. And we're registering an onMessage handler, which will update the in-memory store of our current slide once a message is received. So anytime that WebSocket state is being propagated down, this onMessage function will trigger and update our local state. As mentioned before, we're also using status updates to hide the QR code once the device is connected. So that function is called from the host. So that function is called from the host.

 We have a similar function in the same class, which is going to be called from the client. In this case, again, very much the same thing. We're passing a presentation ID and we're passing a secret. The secret, however, is optional. So if we don't pass a secret through, a connection will still be made. We just won't have right access to change slides or any other updates. exact same functionality where we're creating a new party socket, sending the party kit host, presentation ID, and secret if applicable. The on open and on message are doing essentially the same thing, just on the client side. And that's it for me. So we've been over how you can knock a slideshow together in Svelte, how you can create animated backdrops and fancy transitions, and how we can use shared state to synchronize multiple slideshows across multiple devices Slides are obviously available online This entire slideshow was done from the Netlify hosted presentation You can access them here Source code for the slides is here. And the source code for the template, which you can clone yourself and use to make your own presentations, is here. That's pretty much it, folks. feel free to get in touch I have an email address you can find me on github by their dreams come Larry I think I'm James come Larry on discord and occasionally float around this belt discord server so you can ping me there if there's anything you'd like to know although I am notoriously bad at any sort of social media so terrifyingly sending me an email might be your best bit and I feel old saying that. I'm also on the Svelte Society London WhatsApp group, so if you're local shoot a message there and come meet us at our next Svelte meetup. Thanks for listening and hope you enjoyed the Svelte Summit. That's it.