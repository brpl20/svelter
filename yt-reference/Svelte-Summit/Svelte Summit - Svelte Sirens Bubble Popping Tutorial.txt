 Hello and welcome everyone to Svelte Summit. So we are the co-founders of Svelte Sirens. I'm Jen Ashley. I'm based in London. Hi, I'm Willow. I freelance with Svelte and I'm also based in London. Hi, I'm Steph. I'm based in Austin, Texas and I work at Rissell as a developer advocate. Hello, I'm Brittany Posma. I am based in Holland, Michigan and I am a developer experience engineer at Netlify. We provide a safe community for women, non-binary people, and allies to learn, build, and teach about Svelte. We have monthly talks with people from around the community. We also do live streams showing how to integrate popular tools into Svelte. You can see upcoming events at SvelteSirens.dev slash upcoming RV previous streams at the latest route. Stick around and I'll lead you through building a bubble popping game to get started with some of the basic concepts in Svelte. Svelte is a JavaScript framework that gives you some amazing tools to develop powerful applications. I'm Brittany Posma, and in this tutorial, I'll show you how to use Templating Blocks, Custom Transitions, Stores, and Actions in Svelte. You can get started with this tutorial by heading to the StackBlitz link in the description or cloning the repo for yourself. In the styles.css file, you'll see I'm using OpenProps, a CSS custom properties based library with some of my own custom properties and some default styling as well. This file is imported into the layout component. Inside of layout.svelte, you'll see the basic structure of a .svelte file. We have a script tag where any JavaScript goes, the markup section that is a superset of HTML and the style tag holding any CSS that is scoped to this component. Only the main tag that is inside of this layout file will have these styles applied. Svelte does this by adding a hashed class that is different for each component. The only other unique thing about this file is the slot tag. This represents where Svelte should put any children of this component. We're using the layout.svelte file inside of the app.svelte file. This is the root of the Svelte application. We're wrapping the layout around all of the markup for the app. And if we inspect this page, we'll see everything is inside of the main tag, where the slot is located. And the footer is outside of that. Now let's start adding in some functionality and talk about templating blocks. Templating blocks are a way of expressing logic in the markup of a .svelte file. There are several types of blocks that can be used. If, each, await, and the key block. Today we'll be focusing on the if and each blocks. And each block in Svelte allows you to iterate over an array and render the markup inside for each item inside the array. In the bubbles file you can see that we already importing the bubble component from bubble Here we can use the array method from JavaScript and a Svelte each block to render the bubble component multiple times. We'll use the underscore to skip over the name portion of the array and give it an index of i. At this point, each bubble would be exactly the same, but repeated 10 times. Let's add a random function and use felt style props to create different types of bubbles. A style prop allows you to set a CSS custom property by passing it from the parent to the child as if it were a prop on a component. We already have a random function that we can use and take a look at over in the utils folder. We'll see a random function that takes a min and a max value and creates a random number for us. It's basically just doing a randomized JavaScript function. So we're going to import that and use that in the bubbles.svelte file. And then on the bubble component, we'll pass in some new props. We'll add a scale property with the random function and use some random numbers. We'll do an offset property that uses the index and the random function. And that has to be a percentage, so we need to wrap it in quotation marks. Then we'll do delay. That also needs quotation marks and we'll use the random function and this one will be in milliseconds. And the last one we'll do is speed, which also needs quotation marks. And we'll use the random function again and this one needs to have seconds. Now we have 10 different bubbles coming in, but we can't pop them just yet. Let's head over to Bubble Dots Felt to try popping some bubbles. Over in the bubble component, we're going to create a popped variable and set it to false by default. Now down in the markup, we're going to use an if block from Svelte to wrap the div with class bubble to say if not popped, show what's inside of it. Then we need a way to change the value of the conditional. So we need to create a pop function to change the value of popped from false to true. We can add any JavaScript event listener onto an element by using the on colon and then the name of the event. In this case, click and set it equal to the function you want to call, which is pop. And now when we click on the bubbles, they pop. Inside stores.js, we already imported the writable function from Svelte store. We have some stores created and local storage functionality already set up. You can see the Session Store helps us track whether or not the game is still in play. The Score Store helps us track how many bubbles have been popped. The Final Score Store helps us track the winning score inputted by users as the score that ends the game. And the Last Score Store helps us track previous high scores. Writable stores are created by exporting a variable. These are turned into objects by Svelte with the subscribe set and update methods They then used with a special piece of sugar syntax in a Svelte component with the dollar syntax The store value can be read and updated anywhere by adding the dollar sign in front. We need to create a new store for the total bubbles. We'll use a writable store and set the default value to 50. Back in Bubble.Svelte, we'll import the score store from the stores.js file. Inside the pop function, we want to increment the score by 1. We'll use the set method and the $score syntax and add 1 to it. Now over in the bubbles.svelte file, we'll use a few other stores. Import the score, final score, and total bubble stores from stores.js. Here we need to create a reactive statement. These will rerun any time a value they depend on updates. The reactive statement is declared with a dollar sign colon. The syntax may look a bit odd, especially since stores use a dollar sign before the variable. We want to replace the array function below with a reactive statement linked to the total bubbles store. So we'll use a new array and pass it the total bubbles store. Then we'll replace the array below with the new reactive statement bubbles. Next, create a new Boolean called show bubbles and set it to true by default. Now we can run a reactive if statement. And if the score and the final score are the same, we can set show bubbles to false to hide the bubbles. We'll use another Svelte if block around the bubble component and only show it if show bubbles is true. Next, it's time to power up the game controls. Inside the app.svelte file, you can see the game scenes already in place. There is an input component that will eventually allow you to update the winning score and the total bubbles. The bubbles component that we've already been working on and the game bar component that has a lot of functionality already implemented. We're importing the fly and fade transitions from Svelte Transition, which can be used in the markup with the transition colon fade. Or, to only do one side of a transition, an in or out colon syntax can be used and parameters can be passed to customize the transition, in this case the y value to fly in from, and the duration. Next, we're importing some stores to use throughout the component. In the reset game function, we're checking the score and last score stores to see if a new high score has been achieved and setting the current session to false. We use that function on the buttons below with the on colon click syntax. We creating another reactive statement to hide any bubbles if the score and the final score are equal Then we using those stores in another Svelte if block to either show the winning screen when score and final score are equal and the session is still active, or the game session if only the session store is true. Now let's head back to app.svelte and import the score and session stores from stores.js. Create a start game function that will set the score to zero and the session to true. We'll use another if block to show the input component when the session isn't true, and then add the start game function to an on colon click on the button. Then if the session store is true, show the bubbles and the game bar component. And now if we click Start Plopping, our game works! Now we can hook up our inputs to allow the game settings to be changed. Inside of inputs.svelte, we need to import the final score and total bubbles stores so they can be updated. To bind a value to an input, Svelte provides more syntactic sugar to allow two-way binding between a variable and the input. Using the bind colon value and setting it equal to the store variable will keep the input and the store in sync throughout the application. Now we can see that the winning score and the total bubble's store values show up in the inputs. We can try changing those values, but if we reload the page, it doesn't stick. Let's save our file and then go over to stores.js. We want those values to be able to persist through a reload. So let's refactor the total bubble store. Create a new variable called saved bubbles to access the local storage value. Next update the total bubble store to use either the saved bubbles or an initial value. And then we can subscribe to the local storage value by passing in a callback function to set the local storage bubbles value to the bubbles value. And now all of our game functionality works. We can change our game settings. We can update the winning score, the total bubbles. We can start popping. We can win the game. We can start the game and it persists through a reload. If you're ready for some bonus content, head over to prismic.io slash blog slash try-svelte-build-game hashtag bonus and check out more bonus content on custom transitions, adding confetti to the winning screen, and giving the bubble pop some sounds. Thanks so much for watching this Svelte Sirens bubble popping game tutorial. I've been Brittany Postma. and subscribe this video to see more Svelte Sirens and Svelte Society content and head over to SvelteSirens.dev to see all of our upcoming talks.