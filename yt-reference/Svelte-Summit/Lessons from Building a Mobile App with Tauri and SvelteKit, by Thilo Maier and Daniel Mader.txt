 Hi, I'm Thilo and I'm a software engineer at Imperius Technologies. And I'm Daniel, I'm also a software engineer at Impiers. Today, we would like to show you what we learned when building a mobile application for iOS and Android using SvelteKit in the front end. Let's go! One of the products we are working on at Impiers Technologies is a mobile app called Unimi that allows users to manage their digital identities. The identity wallet is completely free and open source and follows standard protocols to support the upcoming EIDAS 2.0 regulations. For our other products libraries and services, we chose the Rust language for its stability, performance and security features, and so we asked ourselves if we can also use it for our mobile application. Of course, we're also very big fans of using Svelte in the front end, so we were looking for a solution that lets us get the most out of our small dev team. That's how we came across the Tori framework. It allows creating mobile apps with a Rust core that binds to iOS and Android system APIs. The frontend can be built using any web frontend framework as long as it produces HTML, CSS, and JavaScript outputs. Perfect! It also has strong security concepts and compiles to significantly smaller app sizes compared to other frameworks since it relies on the system-native web view instead of bundling an entire node runtime into the app. Let's have a closer look at the differences to a classical web application. Since Tori's Rust Core does not expose an HTTP API, we can also not make use of the Fetch API. But Tori offers an Invoke API instead, which works in a similar way. Tori also does not have a have a higher level concept of message formats or a predefined abstraction to sync application state across the front end and the back end. So the question is, can we apply patterns that already work well for web apps to a mobile app as well You have to be aware that a user can close a mobile app at all times and this should not lead to errors or unexpected behavior in your app In order to perform predictable state updates and keep state management complexity low, we applied the Redux pattern. Let me show you how. We are wrapping a single invoke inside a dispatch function that can be called anywhere in the frontend. In the Rust backend, we then run reducers that apply the business logic to update the application state. On a successful state update, the backend emits an event containing the new state back to the frontend. The frontend, we then use a Tori event listener to listen for those events and set them to a writable store. Now every page can subscribe to that store and will have access to the entire application state to construct a view. nicely decouples the frontend from the backend. While applying the Redux pattern does sound like a possible performance issue at first, please keep in mind that we are not communicating over a network and thus have near zero latency through interprocess communication inside the app. However the Redux pattern still doesn't scale well since the application state grows over time when more and more features are added to the app. You can consider breaking the application state into smaller feature states that are updated individually or even move towards a different architecture such as querying the backend only for the data that is required by the current view. This would introduce a separate frontend state from the backend state which can also introduce other complexity. Tori is is less opinionated on this than you might like. You can do whatever suits your app. Lesson two, we're not running a full stack SvelteKit app inside Tori. So let's have a quick look at Tori's architecture again. So SvelteKit runs inside of WebView and then it can communicate with the Rust backend. But nowhere here do we see a Node.js server. And a Node server is what you would need if you wanted to use SvelteKit's full stack features. And that's the reason why we have to use Adapter Static. And it's really crucial to understand the limitations of Adapter Static. So let's have a quick look at two settings. So the Tori documentation recommends these two settings. Now the first setting Prerender True means that Adapter Static will generate an HTML page for every known route And the indexed HTML file is what Tori uses as an entry point to render the SvelteKit app inside the web view So this means that the SvelteKit app that we're building for Tori is an SPA, a single page app. Let's have a quick look at the Unimi code base. Since we do not have a node server, we cannot use any server-side features of SvelteKit. That's also the reason why you won't find any plus page.server.ts or plus layout.server.ts files in our codebase. This unfortunately also means that we cannot use SvelteKit form actions. So when you write forms in your Tori app, you have to make sure that you handle your forms client-side only. While we can't use server-side load functions, we can use load functions inside plus layout.ts or plus page.ts files, because these load functions run on page transitions client-side. Rather than calling fetch, in a Tori app you should use invoke. Invoke is very similar to fetch. It can call a Rust command on the backend, and you can add some options, and it will return some data into your load function, which you can pass on to the page that you're rendering. Lesson three. Console log and logging are your best friends when you're debugging a Tori app. You might know that with Tori, you can not only develop mobile apps, but you can also develop desktop apps. And when we run Tori in dev mode, then we run the desktop app. So what you see here is a web view on macOS and this web view is powered by Safari. So even though it's a web view, we can right-click and choose Inspect Element. And what we see here are indeed the Safari DevTools, but it's a stripped-down version of the DevTools that is missing some crucial features. For example, it does not include the responsive design mode. Now a typical debug situation that we often encounter in our Tori app is that something does not render properly on a page, and we need to check what is going on. In our app we load data mostly from Svelte stores and then we want to see what will be rendered just before it is rendered. Let's assume that the route that renders the credential has a bug and we want to see the credential data before it's being rendered. This is the corresponding SvelteKit route and one thing we can do is we can just use Svelte debug directive and render the credential So when we go back and then navigate again on the credential route we can look here at the variable and we just need to look for the credential and then we can inspect the credential. Another thing we can do is we can use reactive statements and do a console dir. So in this case this statement will be run just before the page is re-rendered. This time we need to make sure we're looking at the console tab in the Safari DevTools. We click the route again and then we see the console here, down there, and we can inspect the credential data that we render on the page. To wrap up this lesson, I would like to mention that Tori comes with an optional logger. This plugin allows you to log from the frontend to the terminal and thereby get consolidated logs from both the Rust backend and from the frontend in your terminal. Our final lesson for today is that delivering cross-platform mobile apps as a small team is incredibly hard. We are only eight colleagues at Empirce Technologies, so when we heard that Tori is combining two technologies that we know, WebViews and Rust, into mobile apps, we were really excited. Tori is not the only player in the space of developing mobile apps in a non-native way. there are many others, but as far as we know, Tori is only one of two that fully embrace web use to deliver mobile apps. We currently use Tailwind and Swell Transitions, but we have to admit that our Tori app is far from looking native. Because it's incredibly difficult to create a native look and feel with a web app. You all know it. But the web API in browsers keeps improving. For example, Safari 18 has just rolled out Vue transitions. And that's why we're optimistic that with Tori, we will eventually be able to deliver a near-native user experience. Talking about Tori, we would like to give the Tori team a big shout-out. They have just released version 2, which added support for mobile apps. So head on over to the Tori website and give it a try. And of course, only in combination with SvelteKit. We will continue our exciting journey using this technology stack and see where it takes us. We hope you enjoyed watching this video. Bye!