 Hello, hello. I hope you guys are having a lovely Svelte Summit so far. I know I have. And today we're going to be talking about TanStack, and specifically query and table, and how I use them inside a SvelteKit project. So just quick introductions. Hi, I'm Zeyu. It's like hey you with a Z. I'm a software engineer. I'm currently at Pomerium. I sometimes do some live coding streams on Twitch, twitch.tv slash Zeyu underscore dev. And more pertinent to today, I've been doing a lot of Blue Sky and App Proto experiments lately, and all of them are in SvelteKit. Two prominent ones are MyBee, which is a third-party Blue Sky client, and Roomie.Chat, which is more App Protocol specific. and that's more of like a discord replacement which is really cool because it was local for crdt all that jazz and all of that is built in svelte kit so today i do have some demos under summit 2025.za.dev i'm gonna go back over here this is the local version of it but But you guys can see that we have a few demos here and there's also buttons to GitHub. So if you click on any of them, it will go to the GitHub repo with the appropriate lines highlighted. So if you want to take a look at what we're actually doing, there you go. So just a quick primer, what even is Tanstack? It's a bunch of libraries, open source, maintained full time and supported by the community. both through just like open source contributions, issues, like making adapters for different frameworks, as well as sponsorships. And they say that they're independently focused on the developer and the user experience. And today we going to be focused as I said on two libraries in specific query and table So first query a really popular library What even is it So, oh, I forgot I put animations in there. Query is an async state manager. So, that basically means that it just checks whatever function you give it. It just checks if the async data promises if it resolves or if it errors out. and the state in between, whether or not you're in the middle of fetching it, fetching the next page, et cetera. It's atomic, so that means that it can be used in different parts of your packages. It's not necessarily, like, top level. And it does a lot of DX for you, like caching. It is technically framework agnostic, but they have a lot of different adapters, some validation, refetching, et cetera. So, how do you actually use query? First, you just want to make sure that a query client is available throughout your entire application. This is as simple as creating a query client on your layout.svelte and then having a query client provider passing that through. And you can see we're also using Svelte query dev tools to make things easier when trying to fetch data and trying to look at if there's any issues there. Now, a basic query is composed of two things, a query key and a query function. Now, a query key just is the unique identifier for each query. Like, in an application stack, you could have multiple, right? You could have multiple profiles you're fetching, different feeds in the context of Blue Sky. If you guys don't know, there's a lot of custom algorithms that you could choose as a user. So trying to load those in, you'll want to have that siloed into its own query. So query key is how you do that with an array. And then the query function is a promise based method that either resolves or throws an error. So this is a basic one where all we're doing is just fetching my blue sky profile. And you can see here we're not doing like a fetch, we are using the app protocol SDK using the app protocol agent and we just grabbing my profile and returning the data Now this is Svelte so how do you do things reactively right As I said earlier, it query checks and keeps track of whether or not you're fetching, if it's loading. And how do you do that? How do you show that in your UI? Well, it's Svelte, so easy thing to do. go ahead and just use some if blocks. And we can use the, sorry, we could use the store that's given by the create query function to get its state. So we could check whether or not it's fetching or if it's successful. And then here at the bottom, you can see I'm using a const block so that it's much easier to see what the data actually is, which is just my profile. And then we're just rendering the snippet to show it off. And that's what this bit here is. And you can see at the bottom, if we get the dev tools, you can see that the Zayu profile query, that's where this is, right here. Now, as I said earlier, you can have multiple queries throughout your application. A lot of them probably gonna be very similar. So in this case, we have a profile query, and we want to just get different profiles based on different handles. But it's the same thing, right? So instead of doing const a equals create query, we could just create a more generic function here that passes a handle, and we could just add the variable into the query key array to make it more specific. And then from here, we can go ahead and do multiple variables, const A and const B, and then passing in different handles. And those will be siloed correctly. Now, we can do reactive queries as well using the function before. So you can see here we have let handle input. That's, you know, if you have an input tag, you can just bind the value to that state. I'm using the debounce utility from rune.dev just to make sure that we not querying every single letter as we type it in And then we can wrap the actual create query in a derived function to re the fetching right To make sure that the data is correct. And you can see here that debounce.handle.current, that's obviously reactive there. And of course, since we're using input now, sometimes they'll throw in a handle that doesn't exist. So we want to do some error states. And we could do that by just adding another else if into our if block in our DOM template. And we could check if the query has an error. And if so, we just want to show the message. So you could see here, we could do bsky.app. That's the official Blue Sky handle. And then we could also do like Svelte Society.dev, right? And that loads it correctly, and you can see in the dev tools here that these are different queries. It's the profile query right here. So they are siloed differently. And then, of course, if you error out, let's say I forgot the V in Svelte Society.dev, it goes ahead and tries to load it, but eventually it'll error out and it will give us our error. All right. So one of the things like in social media, usually you just have a lot of posts and a lot of an array of data that you want to paginate through. So you want something like an infinite query. So an infinite query is similar to a create query, but with two main additions. First, you want to use create infinite query. And then here we have initial page param and underneath the query function we have get next page param. You can see in our query function as well we have a new parameter called page param. And in our case here we are fetching this felt feed by Paolo. And since it's a feed we want to paginate through the data. So we get the feed and App Protocol has it so that you have a cursor parameter that you could add in to the actual query to make sure that you're fetching

 the next row of data. So when we get the feed and return the data, we return both the feed and the cursor. And then whenever we want to get the next page, we want to ensure that the cursor is getting returned correctly. So when we return the data with the cursor, when we fetch the next page param, we go to the last page, find the cursor, and then we're going to pass it back into the query function. And then you can see here at the bottom, we have a select option as well. This just allows us to transform the data that is returned by query function. And as I said, since this is an infinite query, the data is returned in pages. I don't want to iterate through each page. So instead, I'm just going to grab all the pages and return a flat array. And rendering an infinite query is as easy as using an each block. You can see up top here, felt feed query dot data. We're just getting each one as a post and then rendering it with a snippet there. And then to manually fetch the next page, you can see here we have a button. On click, we just need dot fetch next page to trigger it. So if you go over here, this is currently the Svelte feed, so there's going to be a lot of Svelte Summit-related posts here. But if we add next page and scroll down even further, you can see we've added more and more data. Okay. Switching gears to tables. What is Tansat table? Table is a headless UI library. Table is not a component library. So actual table tags and components, you have to do all that yourself. And all table does is manage the logic, state for data with an accessible API. And you want to make sure that you pair it with some custom markup and design. Now a quick caveat here, the current, if you try and just install tanstack slash svelte dot dash table it is going to sorry it is going to error out on you when you use the create table create Svelte table function because it currently if I remember correctly it currently grabbing data or importing packages from this Svelte internal, which I believe is only server-side only. So, whenever you use create Svelte table, it errors out on you. So, hopefully that gets fixed soon. But for now, we are using Simon's package, which is a test stack table 8, that's the current version, for Svelte 5, and it's almost a drop-in replacement. So the APIs will be similar, it's just we're going to have to use this for today. Okay. So for this demo, we just want to fetch the following list based on the handle that we searched earlier. So this is an infinite query. As you can see, it's derived because we're using the same debounced handle that we were using earlier. So we want to make sure that this is reactive we added some stale times here to make sure that you know we don't want to keep refetching every time so the stale time here makes sure is that everything is fresh and we have some infinite query stuff like initial page param get next page param as well as the select which makes the data flat. Now, the table library has a lot of functions that you're going to have to use. To make a basic table, we're going to have to use something called a create column helper. And you just pass in the type of data over here in the type definition to make sure that the data is correct. There's a bunch of different ways that we could use column helper here. but I'll just go through that later on as we go through. So actually creating the columns. So the columns are just an array, and then you use the column helper to create each individual column. So in this case, we're using a .accessor helper, which from before you could see, which is based on the data, and we can use that data to sort and filter which we do later on so you can see here we just want to access the handle We going to give it a header of handle That what we going to use to identify the column We're going to show it as a T head, TR tag later on. And then we just go ahead and for each cell, so for each row and then that column, we're just going to return the header. Now, to actually use the columns, we go ahead and make an options object, and we want to make sure that it's reactive, so we're going to use derived here, mainly because of the following query.data. We're getting that from the query function, and if there's no data, if it's erroring out, we just want to give it an interior ray. You have to have the getCoreRowModel function, and you could just use the basic one. I believe that you could customize it even further, but just doing this is enough. And then the table itself is going to be reactive, so we want to use a derived rune with the option. So you can see it creates felt table here, and that's the whole error with the actual official svelte table. So yeah, so that will be enough to render the basic bit here. Oh, I forgot that this is erring out. So if we do that, scroll down, you can see the code that we just went through is enough to render just this column right here on the left. But we have a few other columns here. as you can see. So let's go through that. Oh yeah, you can see we're rendering it here. In this case, we're going through each header group and then just showing off the header. Now, what if we want custom components per cell? In this case, you can see here if we go back, the name column over here, it's not just one, sorry, It's not just one, how do you say it? Property, sorry, one property of the data that getting passed through that getting returned You can also see we have the avatar as well And that another part of the row right So this has to be a custom component So how do you do that Well, we use something called the render component function. And all we need to do is give it a svelte component. In this case, I have a thing called profile cell. And then pass in the props. So the display name right here, cell.getValue, that's what we were using before for the display, for the handle, right? But the avatar here, to get that information, because it's not part of that column, we want to just grab the full row and get its original value, and then grab its avatar, right? I believe there is a proposal slash, like, a feature coming in soon where instead of just rendering a full component, you could render a snippet. I tried doing that and it was giving me some errors. So we're just doing just a full Svelte component for now. And then to actually render said components, we use something called flex render here. So for each row, you can see here we're grabbing each cell. And then from here, we're using this flex render function, grabbing the actual cell, grabbing its context, and then we're putting that inside a const block here, and then using it as an actual component inside the td tag. Now some few utility stuff for table. First is sorting. So you could see here, we have a few things. We could sort by handle as well as create at, but we can't sort by name. That's on purpose for this demo. And so you could see here, we are amending a bit on the previous display name with the custom component. We're amending it with enable sorting, and I'm setting that as false because I don't want people to sort through that, but I do want to sort through the created at date, so whenever the profile is created. So you can see here we have something called a sorting function. There are a bunch of tutorials on how to create custom sorting functions. The main one that you would find elsewhere are like fuzzy finding.

 But they have a bunch of built-in options. And for this one, since it is a date time string, we could just throw in a string called date time and it'll automatically do the whole sorting for you. Then we go ahead and create a sorting state, which is just an array. And then we have this onChange function. We're passing in the sorting state type here, which is just an array. And then we update it. And then inside the options object that we were using earlier to create the table, we're going to add three new properties. Get sorted row model, which is built in. On sorting change, which is our set sorting function that we're making up here. And then we're going to give it the state of sorting. Now, in terms of actually using it in the UI, each header you can see here, we can check whether or not it can be sorted using .get can sort right here. And then from here we have some default ascending, descending, or neutral states. So based on that, we can go ahead and show the appropriate icon. But on click, we can go ahead and use the function getToggleSortingHandler to go through the different states of ascending, descending, and then neutral. So you can see here, as I said, we can do handle, ascending, descending, and then the default is neutral. And the same thing with createdAt, which is using dateTime, ascending, descending, and neutral. Now another utility that we could use with table is filter All we need to do is add a filter function Just like before you could have custom functions in here but we going to use a built one and it just checks whether or not the column has a certain string. And then basic input bind value to a search term. And then from here, we want to add in a new options property called getFilteredRoleModel. Very straightforward there. And then we want to go ahead and update the table when the search term changes. So we're using an effect for this one because we have to use table.setGlobalFilter and then pass in that search term. You notice here that I'm using two lines here, tableSearchTerm on its own and then untrack. This is just so that we want this effect to run whenever the search term changes, but we do not want to run this effect whenever table changes. Otherwise it's going to do like an infinite effect render thing and that's a whole hullabaloo error. So we want to use untrack here when we're running this function. So yeah, so you can see here if we want to go ahead, I'm just going to try and grab Chris over here. There you go. And it's sorting, or it's trying to find names based on that. There you go. Great. So altogether now in the more production type application, We're gonna go ahead and just do a quick demo here. So those are the ones from the, or this first page right here is from the presentation. But you can see we have two buttons at the top here. We have a search and a profile button. So the search right here is using sorry the search function here is using the query key as dependency demo that we were talking about earlier as well as infinite query So usually you want to go ahead and make sure that everything is inside a derived room. We create an infinite query. We use the debound search term right here to make it reactive. ahead and search it return the data and then transform the data into a flat array so if we go back in here if I search for myself you could see oh roomie.chat shows up that's nice you can see that zay.dev that all loads in correctly if we want to do svelte.dev there you go there's a lot There's a lot of people that show up. And then we could click through any one of these. So in this case, we're going to go to Svelte Society for now. And then this is a profile page. So the default would be my account, but we're going to do Svelte Society.dev. And then for this page right here, I didn't realize that it is not full screen. you can see here that we are basing the query based on the handle. Now, this should be derived here. I forgot to do that bit. But you can see that we're using the page state to grab that handle, what do you call it? Slug right here inside the URL. So p slash handle, we want to grab whatever that is, and we pass that into our query right here. then from there we're going to make an infinite query grabbing the author feed and that's what this is you could see that there's only like two here I know Svelte Society has more that because in our select here I am also not only am I making sure that it a flat array but I also filtering to make sure that there are no we not showing off replies or reposts So that's why there's only two here. But we could definitely load more and more and more since it's an infinite query. And then from here, you could see that it's not just like a normal post feed. I'm showing this off as a table. So I just have two columns here, the likes and the text here. So if I search up summit, just like before, you can see every single summit-related post pops up. It's getting filtered there. And this is through table, not through query. And then we could also sort by likes right here. so that's using all the things that we were talking about earlier making sure that the text itself is not sortable making sure that the like count is we're using the alphanumeric function the built-in function for this one and then adding some set sorting functions and then having the options here. And then we have that effect from earlier. So that's pretty much it. Where's the actual thing here? That's pretty much it. Thank you so much for coming to my summit talk. You can go ahead and find me in a lot of different places. My website, Blue Sky, Twitch, when I start streaming again, you can see me fumble live. GitHub, as well as the actual demo site from before. Thank you. Thanks, Aya. you