 Hello. Hi, everyone. My name is Mike Rourke, and today I'm going to be giving a talk called Svelte in Orbit. So here's a quick overview of what I'm going to cover today. So I'm going to give a quick rundown of FreeFlyer, which is the astrodynamics software I work on. I'm going to try to teach you the fundamental concepts of orbital mechanics in like five minutes. And finally, I'm going to walk through some code that demonstrates these concepts in an orbit visualizer app. So who am I? Well, I am a software engineer from just outside of Chicago. Absolutely not an astronaut, but I am married to someone that knows their way around Photoshop. My expertise is primarily in web development. I spent the last seven years or so building desktop applications with Electron professionally. I've worked in finance, logistics, virtualization, robotics, and now the space industry. So the past five years, I've been at my current company, which is AI Solutions. So who is AI Solutions? Well, we don't actually build or sell any AI products. We build stuff that's way cooler. So we have several product offerings. They all do different things in space. And the product I'm going to be talking about today is FreeFlyer. So FreeFlyer is a flight dynamics software for satellite mission design analysis and operations. It's been used in a lot of space missions. You might recognize the first three. This visualization here is from the MMS or the Magnetospheric Multiscale Mission. So this is studying Earth's magnetic fields. So NASA used FreeFlyer for complex maneuver planning for four satellite tetrahedron satellites in a highly elliptical orbit. So FreeFlyer has a bunch of features, too many to list here, but it's really good at visualization. So I was hired to build the next version of FreeFlyer using web technologies. I'll be demonstrating some of these techniques we're using in the visualizer app. But before we get to Svelte, I'm going to quickly cover the basic principles of orbital mechanics And don worry there won be a quiz at the end This is just basically here to show you what involved behind the scenes when rendering an orbit So back in the early 1600s a German astronomer named Johannes Kepler published Kepler Laws of Planetary Motion. There are three of them. So Kepler's first law basically states that the planets orbit the sun, not in perfect circles, but in oval shapes called ellipses. The sun is located at a specific point, which is the focus within that oval, not in the exact center. So that means that the distance between the planets and the sun is constantly changing. Kepler's second law says that a planet moves faster when it's closer to the sun and slower when it's farther away. And it always sweeps across the same amount of orbital area in the same amount of time. Kepler's third law, this one's a mouthful, but it indicates there's a mathematical relationship between a planet's distance from the sun and how long it takes to complete an orbit. So the farther a planet is away from the sun, the much longer the year will be. So you can see here, Mercury only takes 88 days to orbit the sun. The earth obviously takes 365. Saturn takes almost 11,000. so kepler's laws form the bedrock of orbital mechanics uh he in fact he's a pretty big deal he even has an orbit named after him it's called a keplerian orbit so a keplerian orbit is the emotion of one body relative to another as an ellipse parabola or hyperbola which forms a two-dimensional orbital plane in three-dimensional space now in order to visualize an orbit uh you need to be able to parameterize it a word that i have said so many times but it took me a while to get the hang of. That means to mathematically define the position and speed. A Keplerian orbit is parametrized using these six Keplerian orbital elements. So I'm going to cruise through those now. Come on. Okay. So two of the elements define the size and shape of the trajectory. So first up is the semi-major axis. The major axis of an ellipse is its longest diameter. That's a line segment that runs through the center and both foci, which ends at the two most widely separated points of the perimeter. So the semi-major axis is half of that. It's the longest semi-diameter, or one half of the major axis, and it runs from the center through a focus and to the perimeter. All right. The eccentricity is a dimensionless parameter This determines the amount by which its orbit around another body deviates from zero So a value of zero is a circular orbit Between zero and one form an elliptic orbit One is a parabolic escape or capture orbit. And then anything greater than one is a hyperbola. Whenever you see in like space movies where they do, what is it, the slingshot maneuver, that's a hyperbolic orbit so it can go towards the planet and away from it without having to fire its engines. Inclination. So the next three elements are going to define the orientation of the orbital plane. So the inclination, this defines the angle between the orbital plane and the reference plane. The right ascension of the ascending node. So this defines the angle between the reference direction and the upward crossing of the orbit on the reference plane. That's the ascending node right there. The opposite end of that little dash line is the descending node. It's also referred to as the longitude of the ascending node. Okay, we have the argument of periapsis. This defines the angle between the ascending node and the periapsis. So the periapsis is the nearest point in the orbit of a planetary body about its primary body. The apoapsis is the farthest point, and the line between them is called the line of absides. And then we have the true anomaly. So the true anomaly defines the position of the orbiting body along the trajectory measured from the argument of periapsis. And this is the only orbital element that changes with time, which is pretty cool because you can represent an orbiting body in three-dimensional space, and five of the parameters that define the position of that can be fixed. And if you want to know its point along the trajectory, you only need to know the time it's at and then what that true anomaly is. So that was all the Keplerian elements, but there are a couple of things that we need. So So, Keplerian elements define the position of an orbiting body relative to a fixed body at a single point in time. We call that the epoch. So, the epoch is just a fancy term for the date and time. There's a lot of different epoch systems you can use. There's TAI, UTC, UT1, GPS, etc. You also need to know the acceleration. I'm not going to walk you through the math, but here's the equation for that. This is derived from something called Newton's Law of Universal Gravitation. So, what about computers, right? So there's a question I'm guessing you want to ask, which is how do you represent these elements programmatically? So the Canvas API, for example, it doesn provide a set eccentricity or a get inclination method You need to convert these ORBA parameters into something computers can understand So we use a state vector for that A state vector is a set of data describing exactly where an object is located in space and how it is moving. So since the canvas represents a Cartesian coordinate system, we can convert the Keplerian elements to a Cartesian state vector to render the orbit. So just like the Keplerian elements, there are six elements in a state vector. Rx, Ry, and Rz, that's the position. And then Vx, Vy, and Vz, that's the velocity. You use the same epoch for time. So these elements are defined with respect to some frame of reference. You can't define the relative position of something without a point of origin. So what frame of reference would you use? Well, if your spacecraft's orbiting the Earth, you'll probably end up using the Earth-centered inertial system. So in this system, the origin is the Earth's center of mass. The z-axis is coincident with the Earth's rotational axis, positive northward. And the xy-axis coincide with the Earth's equatorial plane. So plus x-axis points towards the vernal equinox, and the y-axis completes a right-handed set. And if you're wondering why I'm holding my hand like this, this is called the right-hand rule. So this is a really handy technique, pun intended, for determining the directions of vector in three-dimensional space. So plus C is your thumb, plus X is your index finger, and then Y is your middle finger. So it takes several steps to convert the Keplerian elements to a Cartesian state vector. I'm not going to talk through all these. I've already gone through enough physics stuff already, and you're probably all at your limit. So let's get into this visualizer. So now that you've all mastered orbital mechanics, I'm going to walk you through a Svelte app that's going to leverage some fancy web APIs to visualize an orbit. and then we're going to implement a tiny slice of FreeFlyer using only web technologies, and I just do need to give some disclaimers here. So this code is not production grade. I wrote it for this presentation. Nothing has been benchmarked, and I'll talk about that a little later on why I had to mention that. And we are using some of the techniques that I'm going to show you in the next version of FreeFlyer, but unlike this app, all of the space math, as I call it, all the orbit calculations, those aren't going to be done on the client. we have like a whole separate library that does all the astrodynamic stuff so it's a separate process okay with that being said let's take a look at our app okay i know it's a little dark there but so here's our application i mean there's not really a whole lot to

 to it in terms of inputs. Yeah, hey, you know? So the sliders on the left here, you can see correspond to the Keplerian elements. I cheat a little bit. So I made the true anomaly read-only because that's the only element that changes with time. And I cheated even more and made the epic also read-only. So whatever time you load the page is the time that it starts orbiting. So down here we have the orbit period. This is the amount of time it takes for the orbiting body to complete one full orbit. And then the orbit speed is the speed of the orbiting body at the current point in its trajectory. So the apogee and perigee height, that's the height of the apoapsis and periapsis, respectively. When you're orbiting the Earth, it's a geo, so you say perigee or apogee. and like I think like Jupiter's like perijove and apijove and perihelion and apihelion for the sun so that's why it's this perigeon apogee height this propagation scale slider so this is going to change the speed of the animation not the orbiting body so keep an eye on this orbit period here it's 10.784 hours to complete one orbit if I change this that number doesn't change and it's a scale because if I go all the way to done one I promise that this is moving but it's just moving very slowly. And propagation, by the way, what it means to propagate a spacecraft, it just means to move it along its orbital trajectory. Okay, so let's play with the sliders a bit and see what changes. I'm going to bump this back up. So semi-major axis, if I bump this way up, it's going to increase the radius of the orbit. If I drop it down, it's going to go down here. If you go too far down, actually, let's do this. Let's bump the eccentricity and drop that. now you are colliding with the earth as soon as it turns red. Not a good thing. And you can see here it makes it more of an ellipse. If we reduce this inclination here down to zero, let's see if I can get this working. And then let's make that so this is no longer doing that. Let's make this a circle. Let's drop that down. So inclination of zero, you can see how it's pretty much right on track with the equator. Changing that inclination then is just going to bump that up. So if we do a really high eccentricity a really high semi axis and you could see how it affecting the apogee height and the perigee height The apogee height is much much higher than the perigee height, and this is pretty cool. You got to love gravity. So if you notice the orbit speed, as it's approaching apoapsis at the top, it slows down, and as it's approaching periapsis at the bottom, it speeds up. So you can imagine if you're under the earth here, you throw a ball in the air, It's going to slow down, slow down once it gets to the top. And then it's going to start picking up speed once it gets to the bottom. So the right ascension of the ascending node, it's kind of tricky if I can get the right angle here. But if you change this, you can see how it changes that. And then if we get a top view here, changing the argument of perigee is just going to rotate this guy around. I think that's all I had to cover here. Yeah. So that's that. Okay. So that's the app. and now I'm going to walk through some code. So I'm going to, this is pretty much the rest of the presentation talking about this code. I'm going to take a bit of a bottom-up approach because I tried taking a top-down approach and it got too confusing. So we are going to start. Can you all read that okay? Yeah? Is the font big enough? Do I need to make the font bigger? Bigger? All right. We have this renderer class. So this is using WebGPU to draw the orbit animation to the canvas. And this class is managing rendering for all the objects being drawn. So there are object renderers here for the earth and the orbit trace and stars. There's this attach to method. So this is passing in some canvas details that the renderer needs. And those values are getting assigned to local class properties. I'll talk a bit more about that towards the end. You don't need to worry too much about that. The update canvas size here is just changing the dimensions of the canvas. The set RA and dec, so that's the right ascension and declination. So that's the camera angle. So this is using something called a viewpoint. The viewpoint just has a bunch of state data for determining when the user is manipulating the animation view angle via pointer events so it can update the view angle accordingly. The initialize method here, this is called from attached to. So for anyone who hasn't ever written any code, this is all just like WebGPU. I'm not even using a library for this. If you want to create a triangle with WebGPU, first you need to invent fire because there's so much code involved So this is just going through and doing all of the jubilee of WebGPU APIs to get all this stuff set up and initialize resources And the draw method here same thing It's just getting a bunch of stuff using the WebGPU APIs, and it's rendering all of the child objects. This method here just takes in a state, so a Keplerian state, which is just an array of numbers that correspond to each of the Keplerian elements. The reason why I'm using an array and not an object is because this is using WebAssembly, so you'll see why I did that in a little bit. And then the epoch, so whatever the current time is at its orbit here. So this is just whatever the current time is so it knows where to render the orbiting body and such. Okay. I should probably mention, by the way, my colleague Rob wrote all this WebGPU code. He has a background in astrophysics. There's so much wild stuff happening behind the scenes. You can see even here the Earth orbiting is changing based on whether or not the planet is facing the sun. I do not possess the amount of physics necessary to do that. I'll say that. So in the interest of time, I'm not going to dig into each of the object renderers. Let's see here. So inside of the constructor of this class, I am passing in this orbit calculator. So the orbit calculator, go to that. This is the mechanism that we use to convert the Keplerian elements to a state vector, or more specifically, the X, Y, and Z position of the orbiting body. So this is just providing a public API for our orbit calculations. The initialized method here is dynamically importing a JavaScript file that compile and instantiates a WebAssembly module that exports a bunch of functions that does space math. So the JS and WASM file, this was generated by AssemblyScript. If you haven't heard of AssemblyScript, it's really neat. It's just a subset of TypeScript with a few limitations and more rules. So if we go here, so this file is using AssemblyScript. So we have this static array. This is a special AssemblyScript type that has just a fixed amount of elements. So that makes it more performant. And then let's see. AssemblyScript is much more strict about requiring type annotations. So there's no, like, number like there is in TypeScript. you have to actually say like it's an I32, we're using this float which I just aliased. So this is a floating point 64 bit number And the exported functions in this file pretty much just map one with the methods in this orbit calculator class So you write your code in an assembly script, you run a command to build it, it spits out a bunch of files, one of which is a WASA module and then a JS file to be able to make it easy to get all of that information and load those methods up. So I could just talk through a few of these methods. So orbit speed, orbit period, apogee height, perigee height. These just correspond directly to the inputs on the form. You have this calculate orbit trace points. So this takes this Keplerian state and it turns those values into an array of x, y, z values. And then we use those coordinates to draw the line, this green line. That's the orbit trace. The Keplerian, the Cartesian position. So this returns the x, y, and z coordinates derived from the specified Keplerian state. And then we have this propagate state. So you pass in the Keplerian state, you pass in a certain amount of step size seconds, and it returns an updated state with that orbiting body propagated by that amount of time. So you may have noticed, like I had talked, I just kind of breezed over acceleration. There's no references to any kind of acceleration here. So since we're doing just an Earth orbit, we don't have to mess with that. But if we were trying to like model an orbit around Jupiter or something, we would have to also accommodate for acceleration in these calculations. Okay, so we have a renderer, and then we have an orbit calculator. So tell the renderer to draw stuff and pass it Keplerian state. The renderer is using the orbit calculator, so it's just assigning it to this private variable, and it's also passing it to some of the child object renderers, so it can do some calculations behind the scenes. But the nice thing is, inside of this renderer, this is the only place where you have to care about Cartesian stuff. Everywhere else in the app, you're just dealing with the Keplerian elements. Okay, so we're going to go up a level here. So we have this orbit render loop class. So this class here runs in a web worker, and you can see here it has an instance of the orbit calculator and the renderer. Some of these methods are just pass-throughs to the renderer. No need to worry about that. And then I'm storing a bunch of state here that's needed by the renderer and orbit calculator. So I lumped the state here into internal state into two categories that we exposed publicly. So there are inputs, orbit render loop inputs, and these correspond directly to the editable fields on the form and the is propagating and propagation scale. So this is propagating is just a Boolean hitting this pause button. Let's bump this up so you can see.

 See what it's doing. If you hit this pause button, it stops. And if you resume, it's continuing the propagation. And the outputs here, these are the read-only values. So you have these two read-only coupler elements. And then you have the calculated values. I'm going to talk about those in a bit because that's where it gets kind of spicy. So put a pin in that. So inside of this class, we have this start method here. So this is starting a request animation frame loop. within this loop, it's syncing a viewpoint method. This is just manipulating this private viewpoint property and telling the renderer to change the camera angle based on some conditional logic. And then while we're on the topic of viewpoints, there's also this set viewpoint. And this just allows you to say, hey, here, given this viewpoint, change the camera angle so you could do that imperatively if you want. So back to our RAF loop, we also call this propagate method. So this is taking in this high-resolution timestamp. So if you're familiar with request animation frame, the first argument to the callback is it's like a high-precision timer that you can use to do whatever. So we're determining how much time has elapsed in seconds. We're getting a step-size seconds, which is multiplying by the propagation scale. If propagation is taking place, we say propagate the state by that amount of seconds, update the Keplerian state, update the current epoch based on how many seconds it was, update the outputs, which is where it's going to get spicy, and I'll talk about that in a bit, and then pass that information off to the renderer, and then it does all the drawing based on that state and epic. Magic. Okay, so the reason why we have to do this, here we go. Okay, I'm sorry. So this, we're doing this here, this timestamp minus the previous timestamp. The reason why we're doing that is because that high precision timers based on whatever the frame refresh rate is of your monitor, which is usually 60 hertz, which maps to 60 frames per second. So you can't just always rely on, if you have a higher frame rate monitor that can support that, you need to make sure you're getting the right amount of seconds based off of that refresh rate so it'll look a lot nicer. So behind the scenes, I will mention, we are using TAI for the EPIC system. So we multiply the EPIC by this constant to convert it to TAI. TAI is the International Atomic Time. It's TAI and not IAT because that acronym is in French and I refuse to insult any French people in the audience by attempting to pronounce it So it calls this update outputs method which again I going to get to And then it calls draw on the render instance So let see At the very bottom of this file, we're using comlink to expose a new instance of this render loop class. So comlink is like a wrapper around workers. So you don't have to mess with like post message on message. So it's a really nice way to abstract away a lot of that work. OK, so we're going to go up another level. Now we're finally going to get to some felt stuff. So this is where the sausage is made, so to speak. We have this orbit animation class. So this is in a Svelte.ts file, so it's using a rune. So inside the constructor, I'm instantiating the orbit render loop. I'm using this new orbit render loop constructor because Vee provides the ability to say, like, you know, question mark worker, and now it can load a new worker instance. I'm passing that into comlink.wrap. So what that's doing is it's saying take the class and now make all of the methods asynchronous so you can just call all the methods on that class without having to do anything, and behind-the-scenes comlink's saying post message, on message. It's handling everything. So just like, again, it's a really nice abstraction. Let's see here. So we have this inputs property right here. So this is a state rune, and this is storing all of those orbit render loop inputs. So remember, the inputs are the editable fields on the form. So that's the Keplerian elements and the propagation state. All of these getters and setters here, so the setter is setting the inputs field equal to the value. The getter is just getting that field back. And in the constructor here, we have this effect. So whenever any of the values of inputs changes, we just take a snapshot of state. We send that to the render loop. We say update inputs. Takes those inputs and assigns it to the private method or properties in state. and then inside of the render loop, since we're just using a request animation frame loop, we just need to update those fields and then the render loop is picking them up and updating stuff. So we have this Keplerian state assignment. We're not actually inside of the loop, the propagate loop, we're updating this, but we're not clobbering those values because the only value that's changing in the Keplerian state is the epic. We need to specifically update the Keplerian knowledge from the UI. So that's why that's not like causing one thing's updating another and canceling each other out. Okay so I going to jump up a little layer here really quick So in our app file we only have two kind of entry point components We create a new instance of the orbit animation assign it to the state room So this animation then is going to be passed to all of our components, and it's bound in the properties form. We have all the slider fields here, and those values are bound to the corresponding property of the animation. so like i said getters and setters so let's talk about the outputs so just like the inputs we have this output state rune so these are just getters because they're just returning the value of whatever the corresponding feel is from the outputs now uh there's the way we're updating these is this is where, like I said, it's going to get spicy. So technically, comlink provides a proxy API, which what that means is you say, I create a callback. I say, whenever these values change, update these fields in this class, I can send that callback off to the worker. The worker gets that, and it's like, oh, the output's changed. I am going to go ahead and change them. And then on the main thread here, like it would update the rune. But I'm not going to do that because That's no fun. So there's a lot of back and forth there because if you think about it, this epic at a propagation scale of like 100,000 times is just like the amount of back and forth that the worker would be doing with post message and on message would be, it's just a lot of communication, a lot of chatter. So inside of the initialize method of this class, I'm calling this update outputs using shared memory and it's getting this shared memory object. So let's take a look at what this is doing. So it's creating this shared memory object that's calling create shared memory. So what this is doing is I'm creating a new shared array buffer with enough room for six 32-bit integers. And then I pass that buffer into this int32 array in the constructor. So a shared array buffer represents a generic binary data buffer that you can use to create views on shared memory. So the generic part here is important because you can't really do much with array buffers because the bytes could represent anything. You can make it bigger so it holds more bytes, or you can move these bytes to another array buffer but that about it So by passing the buffer into this n32 array I saying hey the bytes in this buffer represent six 32 integers The n32 array by the way, that's part of the typed arrays API. So typed arrays have been around for a while. There's a bunch of different ones for various sizes of like integers, floats, and big ints. And like the property count here, which is six, just corresponds. I have this shared memory property index, since we're dealing with an array, it just makes it a little bit easier to access elements in an array by their name. All of these properties correspond directly to the read-only values on the form or the outputs. Okay, so back in the orbit animation class, I passed that shared memory here. Oh, that's spoilers alert. Oops. Where did it go? Here we go. Nope. Nope. There we go. Okay. So, I passed this into the render loop.initialize method, and this is just saying, hey, here's a shared memory. Save it for later. So, remember how in the propagate method here, I'm calling this update outputs. Well, what this is doing is this is calling this set shared memory value function. So you pass in the shared memory, the name of the field you want to update, and then the value. Inside of this, we have the properties that we require here. So I have this multiplier variable. So the problem that we have is if you could see the orbit speed and the orbit period, those are three decimal places. We created a shared array buffer that's storing six 32-bit integers. you cannot store decimal places in an integer and you cannot use a float typed array inside of a shared array buffer so i'm doing kind of like a i don't know like a hillbilly float so what i'm doing is i get the property multiplier which is just i take the values that i want and i say hey for orbit period and orbit speed that's three decimal places let's just multiply that number by a thousand uh and then i call um i round that off so now it's an integer and then i call atomics I pass in the shared memory. I specify what index it is, so like for the epic or orbit speed or orbit period. And then I put that value in, so that's using atomics.store. Okay, so back in the orbit animation class, inside of this update outputs using shared memory, I create another request animation frame loop. So if the spacecraft's currently propagating, it's just going through each of the outputs,

 fields, and it's calling get shared memory value, which is just going and doing the opposite thing. So it calls atomics.load. It's getting from the shared memory buffer. It's getting that particular property based on the index, and then it's dividing that number by 1,000. And now we're back to a floating point number. If you need, like, this is just a visualization. When we're actually doing this, like, in space, you can't play fast and loose with this kind of stuff, but for the purposes of this presentation, it's fine. So the cool thing about all this is I don't have to do any worker communication. We're just sharing memory between the main thread and the worker thread, and that's how we're getting the updates. So that's like the calculations and the form and the outputs and how we're handling all those. But as far as how Svelte works with what's actually being displayed, so back in our app component here, we have this orbit display. The orbit display is just checking if WebGP supported in the browser. If it's not, it shows a warning. But if it is, it shows this canvas. So all of the animation initialization and such is happening inside of this on-mount hook. So it initializes the animation which is just kind of forwarding stuff up to the renderer in the render loop It setting the canvas element width and height attributes equal to the DOM element size So the reason why we have to do this and pass this to this attached to is because we using an off canvas So you can see here, transfer control to off-screen. So what you can do is you say transfer control to off-screen. You have an off-screen canvas instance. As soon as you have that off-screen canvas instance, you can no longer access any information about the DOM element. element. So we take that and then we pass it to the worker, but we need to tell, that's why we have that update canvas size. So whenever you resize the screen, the canvas size changes. We need to let the renderer know about it, but we can't just use like a resize observer in the worker, which is why I have this observe canvas resize function. And all this is doing is it's saying, hey, anytime the size changes, make sure to call this update canvas size, which is calling the render loop dot update canvas size, which is calling the renderer dot update canvas size. And it's just setting these variables, these properties equal to these values. And then this is getting used in all of the places in the child object renderers. I also need to pass in this device pixel ratio. If you're not familiar with that, that's like on a retina display for example that like two So that is the ratio of the resolution in physical pixels to the resolution of CSS pixels So if we didn do this this would look like hot garbage on like a macOS retina display. Yeah, so... Oh, yeah, one more thing. So in terms of how the... Let me just move this out of the way. So this viewpoint here, like I'm... You can see the cursor turns into a little grabber, and then I can move it around. This is updating the viewpoint. So the other thing that's happening inside of this spell component is it's like whenever the pointer is pressed down, it just does all this stuff with the viewpoint to set viewpoint information based on where the mouse was clicked, and it gets pointer capture. As the pointer is moving, it's getting the right ascension and declination, and then it's setting that viewpoint. And then when you hit pointer up, it releases pointer capture, and I kind of have to do this janky thing where it sets the viewpoint once you release the pointer, but you have to wait like a little bit because all of these set viewpoint calls are asynchronous. So if I pull down the mouse here and then like I let go, there's a bit of a delay. That's because it has to send one more. If I didn do that it would like you let go of the mouse and as soon as you start moving it it would move it too quickly So like oh what the heck I released the mouse I didn want it to keep moving Okay let see So that the app Svelte has really made it easy to orchestrate rendering and animation and updating it in response to input changes. Runes are a really powerful mechanism for managing reactivity while still being pretty easy to wrap your head around. I'm really excited to keep using Svelte to build astrodynamics products, as well as for my other side projects. We have two products right now that are using Svelte at my company, and pretty much anything we're building going forward is going to use Svelte, and everybody kind of is leaning into the web thing. Okay, so one more thing I did want to mention. Oops. There is a cooler version of that app coming out that's going to be publicly accessible. It's called Orbit Architect. It was built by one of our summer interns, Natasha. so as soon as that's available I just don't have a URL let, I can post it into the Discord, I just did want to thank my colleagues Rob and Connor, they helped me a lot out with this, they actually do have formal education in aerospace, special thanks to our sponsors and the conference organizers and then super kudos to Kev because he's just been running around like a chicken with his head cut off and doing all kinds of great stuff, so thank you so much for your time applause applause