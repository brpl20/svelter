 I think I have the cringiest title of them all, right? From Svelte Component API to SSR Heaven. And I have to be honest, it wasn't me. It was ChatGPT, right? I just prompted, like, can you give me some cringy title? And he gave me this because I thought I'm never going to be picked for this, right? And now I'm paying the price. So, a little bit about me. My name is Savet. I am a software engineer based in Oslo, Norway, and I work at a company called A-medium. And if you want to see the back of my head, it looks something like this. It was quite funny because if we go here, this is actually Svelte Summit landing page. And this is from Sweden, so it was kind of a little bit funny. so why do we why did i want to make this talk so when i first started with svelte right um i tried the svelte kit on beta because then it was actually in beta and i tried to make this real-time app and my managers they they didn't approve svelte kit being in beta right but i I made it up anyways. I was like, I'm going to do it. It went nowhere. But I did learn a lot about SvelteKit. And then I moved teams. So, and I was like, SvelteKit now is version one. Let's do that. And my team lead was like, let's go for it. I'm like, yes, go. But the thing was around the same time, internally company, went from Express to Fastify and then we rewrote all of our backend logic in the team to Fastify. So we had these two developers that were just backend developers and we wanted them to work on SvelteKit as well, but it was kind of different APIs and then we decided, you know what, we're just going to remove SvelteKit, it kind of became a bottleneck and we're just going to use Svelte and Fastify. So for some time, we used a SvelteKit with Fastify, with this handler function. It was kind of janky. And then we just went to SBA Svelte and Fastify And that works great But there was always this nagging thing in my head How can we have Svelte without SvelteKit but server-side rendered, right? So when I tried to do this, it was like Svelte3, and I don't know why, but when I tried to import Svelte3 function, as an import, as an ES build, it didn't work. It just worked on common.js and as like require, and I don't remember why, but I was like, okay, I need to do something else. So then I found ES build API, and then I found that I actually can have just a memory code and output that, and that worked great. So I built this package called Svelte inline bundler, which would basically use that. It would take a raw Svelte component, build it on the fly and just give you the output and actually entered it in the israel competition like two years ago and i didn't win so guys when you don't win don't do like me okay don't be like you know sad you know don't be bewildered you know don't be like what happened now don't be mad you know and don't fantasize about just bringing it all down in a revolution you're going all polar trade is. Don't do that. So I was thinking, I'm going to make my own framework screws felt. I would have been very victorious, but yeah. Then I calmed down, ate something, and it was all okay again. I'm good now. I healed. So there was this colleague of mine, and this is back of his ad, and he posted once this link to some kind of SSR benchmarking tool and I was like, okay, like a repo and I saw Rich Harris had a commit there and I'm like, okay, I'm going to see this at least and I saw that they had this new render function in Svelte 5 and I'm like, okay, what's this? I decided to give it a try and it looked something like this right? And I was like, wow, this works really great. This is actually all that I wanted. And I'm like, okay, I'm going to try to do something with it. Tested it, works great. I like I need to make a talk about this right I don see anyone talking about this I didn see any like Redis posts anything I like we need to talk about this So what are we gonna do today We're gonna look at the SSR, how we build Svelte for SSR, how we import it to server, use the render function, how we use the CSS, how we actually send query params as props. Of course, we need to add reactivity, because why not? And the last part is HMR. I don't think we have that much time to go into the proper HMR. So we're going to just have, as I call it, we have HMR at home. We're just going to have a little bit like a lighter HMR. So first and foremost, we have this big Svelte file, right? Hello, world. Yay. I think you're all familiar with Svelte. and we're just exporting it to build it as a module. So first and foremost, we need to put SSR as true. If you don't do that, we're just gonna build a browser bundle, and that, no, servers don't like browser bundles, I found out. And then we're gonna have a input as home, because that's one component. We're gonna have a home component or home view. And here basically entry file name is gonna have home slash index JS. So I already actually have that somewhere here. Here, here. And it's working. Wow. So we can just look at the index here and read config here. So I already did this beforehand. and I thought I'm going to come prepared. It didn't help with the video issues, but that's not the story. Sorry. Ah, Zoom. Of course, of course. Yes? Thank you. So how do we actually register views on the server and use them on the server? I'm using Festify here. you can use whatever you want, Express, Hono, U2U. But I need to just a second there we go But I need to give a shout out to a package called fastify type provider Zod because what this package actually does is enables you to use Zod as a schema validator, and it's really great because it gives you types, it gives you schema, and it gives you actually documentation if you want to use that. Just use .describe, and it will just pop up in the documentation. because we're just sending HTML string. We have the string as a response. And then here is the magic, right? We just say, we're gonna render SvelteView, we're gonna create done and send it as a string. So here we're just basically getting the built, already built bundle from the client, as you can see here. And then we are importing that file. It's really easy. And then we're using this render function. This is the magic, right? We're using render component, and it will give you three properties, head, body, and the third one. And when we do that, like when we send it from the server, we just basically package it in a stringified HTML, and it just works. So, now we need to add some styles, right? we need some kind of styling for our application. So we're gonna do a little bit of kind of live coding, not that live coding, so kind of cheating coding. And we're gonna have this here. Can I just copy the whole shebang? Like this. And we're gonna look at the bundle. Now, we see this first problem, right? So if, if, of course, sorry, my bad, my bad. Like this, great. And maybe zoom on this as well a little bit. Yeah, you can do this. So the first problem we see is that we don't have any styles now because we didn't build them, right? So we need to actually build the styles. So what I decided here to do, and you can do whatever you want, but I decided to kind of compile everything into this one module, right? And that's why you need this compiler option CSS injected. So let's add this to the...

 We need config here. Boom, boom, boom. We actually need to do something on this server as well. There we go. There we go. And here we go. Maybe this is here. And if I'm lucky enough, and I'm not lucky enough, of course, we're just going to see if we did actually do anything here no let me there we go now we have styles thank you so you know actually my wife she is a UX designer and if she had seen what kind of CSS I have here, she would have killed me. But that's another story. I'm going to deal with that later. All right, so now we have styles. We are actually rendering the component on the server. Everything's great. Life is good again. Now we need to add some props because that's kind of the whole point with server-side rendering. You can send some query parameters, you can send it down to the component, and we'll just render it, right? So let me start with props, because you all use Svelte 5 or Svelte 4. I know it's kind of divisive, but let's say we all use Svelte 5, right? Yes, woo! And then you're just exporting these props from your component, and then we can just use it like this. Hello, world, my name is Ensum. Some kind of prop. So in our server, we would actually write a query string and validate because validation is important, really important. And we will send it to our render SvelteView function, which I already made. And you see now we're just taking the props as an object because we don't know actually what it can be right now. And sending that as a parameter in render function. So let maybe try and do this in the code as well Let me just go to my index here Now we have this and then we need FuseRouter There we go. And we have this as well now. And it's red because we didn't do anything with the utils. This one here. So, we just need to, I'm just going to do this because. There we go. So, in theory now, if I write something like this. Ta-da! Now we already did a lot, right? So we have rendering, we have props, we have styles. Life is really good again. So this is our list, right? We actually checked all of the things we need to check. But what about reactivity? That's the important part. So I'm just gonna use this here. I'm gonna bundle it here. And just to be sure. Is it like this? Right. So what's supposed to happen now, really, is that we have this input tag, and when we do something in input tag, we should get a new state. We should bind it, and it should work. And if I do that, nothing happens. I know, this is really bad. This is really bad. Do any one of you know what we need to do to make it work? Good one. Actually that a good answer but not the answer we looking for now Anyone else Yeah So, what we actually need to do, we need to hydrate our server-side rendered bundle, right? So, let's look at the presentation code. Because what's happening now? You see, when we build actually this as a server-side rendered kind of build, we all just have this payload out, which is some HTML, but we see that it doesn't have absolute no reactivity because it's Svelte or server-side bundle, right? So we need to build a hydratable bundle now. So the index file, Svelte file, is the same. But we're going to make a new file called hydrate. You can call it whatever you want. You can call it SvelteKit if you want, whatever you want. But it's basically a hydrate function that Svelte provides, and it's kind of different. It's not the same as mount, but it will just look at your existing tag, and it will just update on that tag. But we, of course, need some kind of a preloaded state that we have on our server side. So we're going to interface a window with the preload state. And here it is, hydrate. We're just going to say hydrate on a component, and we're going to target this element here. So let's take this and create a new file called hydrate.txt. TS. Boom. Boom. Let me just use this. And start a little bit more. And then we need to build actually the hydratable bundle. So we're gonna use this, like Vite has this properties inside when you build, and we're gonna call the property mode, because then what you can do, and we can actually see that in a package here. We can see build for SSR and build for client and then this mode is gonna be super helpful right Because we can say now that if we gonna build an SSR plugin we're gonna output it on different folders. And you can see that here. And then we need to target what we're gonna build from the different folders. Now, if it's an SSR, I'm gonna target the index. If it's not, then I'm gonna target the hydrate file. And then lastly, because we're gonna look at the HMR, we don't wanna build CSS on both of the bundles, right? Because you can do that, but it's gonna be pointless, you have two places. So we're gonna build CSS only if it's not SSR. So I'm gonna take this one, and go to our vidconfig, there we go. Gonna make it a little bit prettier. And did we forget something? Nope. So if everything goes according to plan now, if everything goes according to plan, we should actually be able to do this, today's message is, it did not go according to plan. Let me just see. Yeah, yeah, and I know of course why. Because we actually need to register again a little bit better this time. So what we need to do is, it's basically the same server, but now we have this hydrate property that we're getting back from the render-svelte-view function, and we need to send it when we actually create are done. So here it's really easy though. Before we had just one file which is this server side rendered file with this bundle but now we have a client file which is our hydratable bundle. And we need to say to the browser first load the server side bundle and then just hydrate it with the hydratable bundle. And and just find where the client file is, and return, we just read it now. Because here is the thing, you can do this in multiple ways, right?

 You use your server as a CDN to actually just, you know, export all of these files. You can just stringify the whole thing and just put it in your DOM if you want. I'm doing it like here. Or you can just have your kind of schema, and then you can say, I have this component here, I have this component here. How I'm going to do that on the server side is all up to you, right? So our stringify DOM is going to look something like that. like this. We have the script file now, which is a our preloaded state is our property skin. And then we have this hydrate script which we just hydrate it on now. So if we take this like this and we take this and copy it here like this. Now, if I'm not mistaken. And I may be mistaken again. Let me check. Do this. I am mistaken again. I just need to see what went wrong. We did do this. And we can actually see now that in the bundle we are building, right, But we get loads of activity like set text. Don't save. And I just need to see what happened, what we did wrong here. This network, local host. Oh, yeah, we don't have any state, but we have. Ah, of course, my bad. We don't have any identifier here. Of course. There we go. Now, let's just... And we just need to see if we're targeting the rest to get them by ID. Now for the third time maybe now it going to work Yes we have styles people Yeah And then for the big reveal It just works. It works on the third time, though, but it just works. Just like SvelteKit. Woo! All right, so. We did this. So now we have built for server-side rendering. We have done everything here. We have reactivity. This is great. The one thing that's kind of bad now, right? Or multiple things, but one of them. Is that if I do this, right? if I say today's and just message. I can do this, right? I need to refresh the browser every time. Like, if I do this red, I need to refresh the browser. And that's going to, it works. You can, we can develop like that, but nobody wants to refresh the browser in 2025, right? We want the changes to happen instantly, right? Yeah, 2025. So what we need to do is make some kind of HMR, because the whole point with what I wanted to show is we don't need kind of the big external frameworks, right? We can do it at home. We have HMR, we have Selt at home, right? So we're going to use, we're going to just look at what HMR is, And HMR, if you're not familiar for hot module reloading, is kind of a simple concept, but it's really difficult to do it correctly. So the whole concept is that you have some WebSocket server on your server, right? And then you're sending those messages to your client and updating your module like that. When I say that, it sounds really easy, but it's really, really difficult. So for today we going to see how can we do kind of homemade HMR to update CSS without restarting the browser So I already made these files but what we need to do now is to take this bit of code, and this is gonna go into the client, into the browser side. So we can do this here, and we can import this. And then we also need to register our WebSocket in the server because we're going to take some data from our server to our front end. And we're going to do this. Boom, boom. Boom, boom. So we don't want to have HMR in production, right? because we just want hot module reloading when we develop. And that's why, you know, if it's a dev mode, register this plugin. So let me just save everything here. And try again. And go here. Because we want to see now if it actually does something when we save the code. So, simple browser. This is really great tool to open the browser inside the VS code. And we want to hide this bit here maybe. We want to, where is it now? Split to the right. And we want to have some Svelte code here. So, if I'm not mistaken, I have been mistaken today, so if I'm not mistaken now, right? When we update this bit of code, then we should see the updates directly inside the browser. So let's see it. Background color red. It just works. Like, who needs SvelteKit, right? We have SvelteKit at home. No. But yeah this works really nicely for a CSS changes like let me just change it to five Yeah it works You know I gonna get yelling when I come home from my wife, like this doesn't look good, to be honest. But the problem now is, let's say we do something in here. Like we have today's blah, blah, blah, blah, blah. If we change something here, then our state disappears. So the state handling and the module reloading is the most difficult part here. We're not gonna do that today because I think that this warrants its own talk. Maybe idea for the next summit, if everything goes according to plan. But let's just look at the how we can actually do CSS in HMR from a local server. So we need two things. We need our server code, which is something like this. So you have to register a route on your browser, some kind of WebSocket route, and you can see here that we are setting it with WebSockets. And what we want to do is we want to see when the dist folder has been changed, so when we build a new bundle, right? And we want to watch it in the node, and want to say, you know, I want to see this bundle and I want to see all of the files that have been changed there. There is a little bit slight issue with that. Let's find out. The watch triggers this callback when folder changes, but not when the actual files have been built. And that's a bit sad because we need to use the interval to check when the actual file is built is there. So if the file exists, then we just read the file and we send it down the socket as a string. And in our client plugin, we just connect to our web socket. We say, ah, here's some message. Everything's good. Everything's good. And then here, we just get our script, which is hydrate. We remove it. we create a new script, we push in the code, and we push in the new script into the DOM, and it just updates itself. And this is why it's important to have a CSS inside

 and not on the server bundle. Because then we can just replace this one module and it replaces everything it needs to replace. But again, this doesn't work on the local state, on the multiple stuff. And you know what? We did everything today, right? Somehow we managed. And with that, I'm just going to say finish the end. Before I'm done, I'll just, do you guys have any questions or anything? Silence, that's a good sign. That's a really good sign. Thank you, guys. We'll see you next week.