 It seems like everyone has been waiting in anticipation for the epic finale here. Is everyone ready? Yeah. What do we think we're getting today? Like, are we going to, is it going to be a surprise talk again? Or do we have, do we know what we think he's going to talk about? I mean, obviously he doesn't really need much introduction, but today we've got the creator of Svelte himself. Please, everyone, give a big round of applause for Rich Harris. Wait. Is this the alpha prototype version? What do y'all think? Should I give him the mic? Can he give the talk? No? No. Thank you. I appreciate it. Yeah. You did a great job. Thank you. I guess we need to try this again. So let's see. Can we get it this time? Export Rich Harris, please. Oh, he's ready to give the talk. I think if you've got 30% more rune energy, do you think you can talk about reactivity? Yeah, sure. Yeah, okay. About the derived rune, can you write the derived rune in the master branch? Is that out? Okay, that's not rich. Thank you so much, rich number two. so if we didn't get it right the first time we didn't export it maybe we should import rich Harris can we get it right this time can the rich Harris come out I mean this this one Definitely. Right? That's right. Yes. The real one. I'm going to talk to you about promises. What? It's not me? You going to talk about promises Oh it not you Okay Yeah I thought it was It still beta we still in beta guys thank you he not in there what what is this nonsense all right is that enough suspense we're good can we please get the original production ready rich harris out here ready to give his talk before another bearded genius, I can't say it, shows up. We may need a panel to decide who's the real one. Thank you. Oh, that was absurd. Thank you. Okay, I need some slides. All right, here we go. We did it again. We did it again. we had our first in-person Svelte Summit in Stockholm in 2022 as many of you know and it was such a special time and I wasn't sure if we would get to do it again but I think we topped it I think we topped it this has been this has been a wonderful two days and I haven't met lots of you yet and I do hope we get the chance before we all go our separate ways it is a real privilege to share this stage with so many wonderful speakers. I've learned so much from each of you. Can we give a big Svelte Summit show of appreciation to our speakers? And can we keep it going for our wonderful MC Brittany, the other Brittany. Thank you. And everyone who had a hand in organizing this event, our friends at Main Matter, all of the conference sponsors, Kareem, who's been the Discord manning the live stream for all of our virtual attendees. Hope that you can join us in person next time. And that goes for you too, Kareem. And to the man who made all of this possible, the one and only Kevin. There he is. You're the best, dude. So this talk is called What Svelte Promises. And some of you might have seen this document, which talks a little bit about what we're trying to do with the project. Among other things, it's a reminder that we were the original vibe coders. But today I want to focus on this bit. Dream big. Choose the right tool for the job is sensible but boring advice It makes us small in our ambitions I want us to dream bigger I don want to feel like my tools can handle evolving requirements or that if I want to dabble in a new field, I need to learn an entirely new way of working first. Even if it turns out to be unachievable, I find it valuable to ask the question, what would it take for SvelteKit to be the best framework for any app, whether it's purely static content or a real-time multiplayer app or an offline-first productivity app or even something built for an augmented reality headset. In other words, the promise of Svelte and SvelteKit is that it will become the best framework for doing everything, at least for web apps. Although if you've been paying attention to Paolo's work on integrating with links, then you'll know that even that constraint might one day be a thing of the past, and we'll be able to build native apps using Svelte as well. And by the way, if that's something that would be useful for you or your company, then the main matter folks who have been backing this work would love to talk to you. So go and find them at the after party. Now, I get that talking about making the best framework for doing everything kind of makes me sound like a bit of an out-of-touch megalomaniac. I get it. But the desire to make a framework that you can use for anything is less about a plan for world domination and more about laziness. If I want to try out a new technique or a new library or a new deployment platform or whatever it is, I don't want to have to learn a new language or a new ecosystem or a new set of conventions first. Yesterday, I was telling Grisha and Michael from the Threlte team about how a while back, I wanted to try making an augmented reality web app for my Quest 3 headset, and because of Threlte XR, I could just do that in a SvelteKit app where I'm most comfortable. Because ultimately, I don't care about that other stuff. I just care about the thing that I'm building. And I know that no one cares about frameworks is a weird thing for a framework maintainer to say at a conference about a framework, but it's true. Svelte for me is two things First of all, it's this It's an excuse to surround myself with people who love the web and the open source ethos as much as I do I've made so many lifelong friends through this project and I hope that many of you have too If everyone stopped using it tomorrow, that would be fine because this is the bit that matters But similarly to Veet, it's also the thing that gets out of my way when I want to build something So how are we doing on delivering on those promises? On the Svelte front, things look pretty good. We kept our top spot on things like the state of JavaScript survey for several years running even though the user base has grown from a small cadre of true believers into a larger community of more casual users But for CellKit, things aren't quite so rosy. They're not bad, exactly. We're in the number two spot for interest, right behind Astro. But when you look at the absolute values rather than the rank, we're trending downwards. It's true that almost everything in this space, Next, Nuxt, Remix, Solid Start, is also trending downwards. The exceptions are Astro and Fresh, although Fresh is very niche, so it's really just Astro that's bucking the trend. All of these projects are probably affected by a lot of the same factors, but there's only so much comfort that you can draw from that. The reality is that for SvelteKit, at least, we are not currently delivering on our promises. A lot of the complaints that we hear about SvelteKit it can be boiled down to a few common things. It's too monolithic. I can't just use the bits I want. I can't effectively compose applications. It's too opinionated. It really heavily promotes server-side rendering and file system-based routing. It's too magical. It has generated types and things like that. It's too self-coupled. Your data loading is tied to your routing. Your routing is tied to the file system, all of that sort of thing. It's not granular enough. I can pre-render at the root level, but it's all or nothing for that root. And I can only invalidate at the level of a load function. And so when we've sat down and talked about how we could fix some of these issues, the thing that we keep coming back to is async. It turns out that a lot of SvelteKit's design is essentially working around a crucial limitation of Svelte itself, the fact that you can't work with asynchronous values directly in components. It's why we need to have load functions, so that we can get data into components immediately instead of having to have spinners everywhere. For load functions to work, they have to be tied to the router. For you to have type safety in your components, we need to do some kung fu with generated types and esoteric TypeScript compile options, which I think is quite clever, but it really shouldn't need to exist in the first place. If we could change that, if we could build the right primitives into Svelte itself, then SvelteKit could potentially become a thinner layer over Svelte, built from more composable parts, with fewer of the drawbacks that people have encountered. All we need to do is solve async. So here's the reveal. this talk is actually called, what? Sveld? Promises? I suspect some of you probably saw this coming because a lot of you have seen this discussion that we posted last month.

 I think it might actually be the first time we've had this many emoji reactions and not a single thumbs down. But for those of you who haven't seen it, allow me to introduce asynchronous felt. First off, we are not the first people to try and solve this problem. React ships suspense in 2022 and React server components soon after. And these give you a way to await promises and side components in a way that is coordinated, so you don't see a bunch of loading spinners popping in and out of existence at different times when you navigate, which is a horrific user experience that's sadly all too common on the web. Other frameworks like Solid and Vue have their own versions of suspense. So there is prior art here, but candidly, I don't want to dwell on it too much because while we've studied it and learned from it and we're grateful for it, the reality is we don't think anyone is doing it quite right at the moment. We have some requirements. We want to just use await. Framework-specific APIs should be as sparing as possible. It should work anywhere, not just inside your script tag or inside your markup. Work should happen in parallel whenever possible. You want to do the right thing automatically. Coordination should be automatic. You shouldn't have to manage independent loading states separately. And it should still be possible to update the app while async work is happening in the background. I've been working on this for the last several months, and I think I know why no one has implemented a really nice version of this yet. It's because it's really fucking hard. But I think we've finally cracked it, and so let me show you. So let's imagine that we are building a times table app. And because it needs to be production grade and web scale, we're not using the unreliable multiplication operator. We've set up a globally distributed multiplication API with multiple redundancy and edge caching and all of the good stuff, AI-powered and the rest of it. So for now, we need to add something called a boundary so that we can show a pending state when the app first loads. This is a temporary requirement. We're hoping to get rid of it, but for now, we do need it. And then inside the boundary, we put the content that we want to show. So in our times table component, we have a bunch of promises already. How do we access their values? well we just await them Let that async in So as with suspense APIs that exist in other frameworks, the updates are all happening together. So the N only updates when all of the things that asynchronously depend on N are also ready. Otherwise, you'd have an inconsistent UI with things like 2 times 2 equals 2, which we definitely don't want. And you'll notice that even though these awaits look sequential, we don't actually treat them as such. Because we know everything in your markup is essentially a pure expression. So there's no reason that we can't run them all in parallel. We're not going to make you contort your code with promise.all and stuff like that. We can just do the right thing on your behalf. We can turn this into a loop as well. You get the exact same performance characteristics either way. and if I click the button multiple times, I get multiple updates. There's no gotchas around stale state, as you may have experienced in some frameworks, and importantly, if there are updates happening in the background while asynchronous work is going on, like this ticker at the bottom here, that continues to update even while async work is happening in the background, and I can use a wait wherever I want. I can put it at the top level of a component, and all these fetches will happen simultaneously for the three different Pokemon. I've also got on a weight in the image's source attribute, which ensures that the image is loaded before it gets rendered to the DOM. This is useful for preventing layout shift and pop-in, which always makes apps look a little janky. I can also use it in a derived expression, which will automatically update whenever its input changes. And you'll notice that when an input is focused, we make an exception to the rule that updates are synchronized because we definitely don't want to overwrite the value of a focused input. Instead, we let the rest of the UI catch up to it. And besides loading data and images, await is useful for lazily loading components only when you need them or for delegating expensive computations to a web worker so that your main thread stays jank If you need to know if there ongoing async work you can use effect.pending, which at some point between the last time I ran through this and today has broken. last night I was talking to Yepi from Storybook and he asked a very good question which is how do you test this stuff how can you ensure that the DOM is in the proper state after all of the background async work has completed so we brainstormed a little bit and we came up with an idea and I had a chance to implement it over the lunch break it may or may not work we'll see so we import settled from Svelte and then inside our event handler, anytime we change some state, we can await settled. And then hopefully... Okay. It wouldn't be a Svelte Summit without some blue confetti. We miss you, dude. We can hope that you can make the next one. Okay, so you might reasonably ask how does any of this actually work? And it's a good question. And we've never really talked in depth about how anything works in Svelte 5, beyond saying vague things about fine-grained signal-based reactivity. And it's time to rectify that. So if you'll indulge me, I'd like to invite you into my rabbit hole where I've been for the last several months. The guy who took this video made me promise that I would somehow shoehorn it into a JavaScript talk one day. There we go. So when people talk about signals, they're generally talking about three things. Sources, derivations, and effects. Sources contain values. Effects are things that react to changes to those values. Derivations are both values and reactions. They update when their dependencies change, but effects and derivations can also depend on them. So you end up with a dependency graph with sources at the top and effects at the bottom and derivations potentially in the middle. A source might be something like count equals state zero. A derivation might be something like double equals derived count times two. and an effect might be a function that updates the text content of an element, or it could be an effect that you define yourself with the effect rune. In a real app, this graph will obviously look much more complicated but the essence of it is just this Now when count changes we don rerun effects immediately Instead we follow the edges of this dependency graph and mark reactions as dirty or in the case of a derivation, sometimes maybe dirty because it could reevaluate to the same value. And then we wait enough time for any other sources to update, but before the browser repaints, and then we run the effects. Sometimes if an effect depends on a maybe dirty derivation, we'll skip it if it turns out that nothing actually changed it's not quite that simple we don't just want to run these effects immediately because this text update for example could be inside an if block and if the if block is destroyed we don't want to have run that code and updated that DOM in some cases it could even cause an error if you did that because you could be accessing a property of undefined or something like that so instead we put all of the effects in another graph where your root component is mounted at the top and other effects are recursively nested inside it. And when an effect is marked as dirty, like this one, we mark all the edges between it and the root as dirty so that we can traverse the effect graph from top to bottom efficiently by skipping over any branches that we know are clean and preserving the sibling order of effects, which is not a guarantee that every signal implementation gives you, by the way. So far, I've been using the effect in a very generic sense, but there are actually many different kinds of effects. There are the effects that you create with the effect rune or effect.pre. There are the effects that update text nodes and DOM attributes. We call these template effects. Things like if blocks and each blocks and key blocks are called block effects, and the things immediately inside those blocks are called branch effects. And if you have an await expression inside a derived or in the template, then that creates something called an async effect. Because unlike a normal derived, which updates lazily, if we see an await expression in a drive, we have to proactively update its value, so we create a new effect for that. So in the async world, when we process the effect graph, we do it a little bit differently because we don't want anything to update in the DOM while async work is still pending. We still traverse the effect graph from top to bottom, but instead of running template effects or user effects created with the effect ring, we put these into an array. And we do the same thing for async effects. And when we run block effects, instead of putting the newly created DOM, creating the newly created branch into the DOM, or taking an old branch out of it,

 the DOM, we create elements in an off-screen fragment and stash the append or remove operation away in a callback. At the end of that process, nothing has actually changed. But we have an array of async effects and an array of template effects and user effects and an array of callbacks. So if you're not waiting for any async work to happen, then we run the template effects and the block callbacks, which brings the DOM up to date. But if we are waiting for async work, then we run those effects and stash all of the other effects away for later. And so when those newly created promises resolve, we mark the stashed effects as dirty, and we do this, repeat the process, and just do this as many times as it takes for all of the async work to settle. We're not done quite yet. The last thing we need to figure out is how to handle overlapping updates. Because suppose you change some state that results in an async update, and while that update is ongoing, you update some other state, like the ticker. It would be no good if unrelated updates were blocked while async work was pending. The way that we handle this is with time travel. Whenever you change some state, we store both the current value and the previous value, so when these fast updates occur, we can temporarily revert the slow update. Otherwise, by processing the fast update, we would show the slow update in an incomplete state, which is no good. A really interesting fact about this, or at least I find it interesting, is that it works flawlessly with state that appears to be mutable. What I mean by that is you might push to an array or change a property of an object, and as far as you, the developer, are concerned, you're just mutating stuff. You're not having to copy this and deep clone that like you do in some frameworks. And yet this time travel mechanism lets you unmutate the object because it's actually a proxy backed by an immutable source. So you get the ergonomics of mutability and the semantic guarantees of immutability and without the performance drawbacks of having to clone stuff. You don't tend to get that with other frameworks. I know a lot of you are thinking, I'm sitting here in a literal greenhouse and the only thing standing between me and a cold beer is a lanky nerd talking about graphs. And this is complicated and hard and no one cares. And I will concede that you might have a point. But this is why we do it. We solve these problems as best we can so that ideally you don ever really have to think about them You can just write code and the right thing will happen We trying our best to just stay out of your way So, you can use all of this stuff right now, thanks to package.pr.new, which is a brilliant project by our friend Mohamed at StackBlitz. All you need to do is install using this URL, which references the pull request where this work is happening, and add the experimental.async option to your compiler config. We would love to have your feedback. Some of you have already tried out the experimental release and found bugs, most of which are now fixed. I guarantee there are many more waiting to be discovered. But even when this PR lands, there is still a bunch of work ahead of us. We need to make it work with server-side rendering. Today, during SSR, you'll just get the pending state. But in almost all cases, it's better to do the async work on the server if you can because you can avoid round trips. If your server is physically close to your database, then it's going to take less time for the user to see the data if they can get the HTML with the data already there than if they have to make a round trip from an empty shell page. We also need to make it possible to do speculative updates. That way we can pretend that a piece of state changed, trigger any resulting async work, and then decide whether to apply the result. With that ability, you could, for example, hover over a link, and the framework could start fetching the data for the new page so that if you do end up clicking on it, we can navigate immediately. This all sounds quite complicated. To my knowledge, no other framework has managed to pull this off, but it's actually quite similar to how the async updates that I previously described already work. With those two pieces, we could potentially start to rethink how we do things in SvelteKit and move away from the pattern of loading all of your data in load functions and towards a more self-contained and granular approach, which is the key to addressing the pain points that we talked about earlier. And I want to talk briefly about what that could look like. Earlier this week, a bunch of maintainers and a lizard got together for a team offsite. And it's the first time we've had the opportunity to do this. A-plus would recommend. And we got a bunch of stuff done. Dominic and Manuel built the first version of what we hope will become the official in-browser Svelte dev toolbar. Teaming led a... There he is Teaming led a deep dive on a pull request from Luke Hagar that will eventually add real support to SvelteKit and also finished up a PR that will make it much easier to build client-only single-page apps in SvelteKit. And we... Round of applause for T-Ming. And we all spend many hours discussing a project that Simon is leading. that will bridge the gap between the server and the client in a way that dovetails really nicely with the await stuff. It's early and it's very unfinished, and I probably shouldn't be sharing these ideas with the world just yet, but what the hell, this is Svelte Summit, so we're going through. Who's heard of RPC? Sounds like one of the lesser-known Star Wars droids. It's actually a well-established concept in computer science called remote procedure calls. The remote part means it's happening on a remote computer, i.e. a server. Procedure is an old-timey word for function. There is a subtle semantic difference, but it doesn't really matter. And calls is because it's designed to make it look like you're just calling a function instead of thinking about the underlying mechanics of communicating via HTTP or whatever it is. And there's been something of a revival of RPC in the last couple of years, thanks to projects like TRPC and implementations of the concept in front-end frameworks such as use server in React and Solid. People have long been critical of the idea. This is from 1987, I think, and it still contains a lot of relevant wisdom. And I personally have been very skeptical of things like use server. I think it's a serious mistake to have client and server code in the same file. Your server code is generally going to need to access sensitive information like API keys and environment variables. And if you're porting that into a module that runs on the client and hoping that tree shaking will keep it out of your bundle, You're basically relying on magic and dumb luck. It's also possible to accidentally reveal sensitive information via source maps. And as a matter of human psychology, having server code defined right alongside your client code makes you forget that you're actually exposing a public HTTP endpoint to the world that anyone can call with any data. And this may be a little bit overly paranoid, but people have been tripped up by this. And in some implementations, like React, you're not just passing data explicitly via arguments, The framework is actually serializing values that the server function closes over as well It convenient it very convenient but I just don think it a good idea And I not alone Even the Remix team have basically said at this point that co server and client code in the same file is a mistake, and that was sort of their whole deal. There is one project that I think is doing this stuff right, though, and that's Telefunk. In Telefunk, you put your remote functions in a module with a special file extension that gets transformed by your bundler, so that when you import these functions into your client bundle, you're actually importing something that makes a fetch request when you call it. On the server, you're calling the function directly. And as far as TypeScript is concerned, you're calling the function directly. So you get all of the type niceties that you're accustomed to. It's simple, it's more secure, and it doesn't involve any magic like serializing closed-over variables, and it's just easier to understand. But it doesn't have everything that we want to have in the SvelteKit context. We want to be able to use our existing error and redirect helpers. We want to be able to serialize anything that you can currently return from a load function, including promises and things that you might have custom transport hooks for, like dates and sets and maps and all of that sort of thing. We want to be able to stream nested promises and async iterables and so on. And we want to be able to use get for some requests so that we can take advantage of HTTP caching, but post for other stuff. And perhaps most importantly, we want to be able to refresh what's on the page following a mutation. So we're planning to introduce something to SvelteKit called remote functions, and does come with a caveat, like this is only partly implemented, but we're feeling pretty bullish on it. Anytime you have a .remote.js or .remote.ts file, we inspect the contents and generate a client-side interface based on what you export. So in here, you can interact with your database and you can safely access server-only stuff like environment variables. One of the things that you can export is a query. This runs after your handle hook, so you can get things like the current user If it runs during server rendering, the return data will be serialized and sent back in the HTML so that it doesn't need to run again when the client app first loads, just like your load functions behave today. And on the other side of the fence, you can just import this and use it directly inside your component using a wait. Let's say you want to add a new to-do. For that, we can create a command. Just like queries, you can access the request event inside here. If we error, it's the same as erroring in a load function. It'll bubble up to the nearest error boundary. And since we know what's a query and what's a command, we can make sure that you don't accidentally make mistakes

 like running a command during render, for example, instead of an event handler. We also know that if you run a command, it's likely that your queries are now out of date so that we can rerun them automatically for you. If you want to be more surgical about which queries rerun after a command, you can do this. If a manual refresh occurs immediately after the command completes, SvelteKit won't automatically refresh everything. This wouldn't be SvelteKit without progressive enhancement, so we plan to have a form version of command as well. And this function returns an object with a method and an action and an on-submit property that you can add directly to a form element, or even better, you can just spread it onto the element. And it'll work without JavaScript, but if JavaScript is available, it will submit the form and update the page appropriately without a full page reload. I don't know why you're clapping. We haven't actually built this yet. This is just sample code. Appreciate it anyway. You can also customize what happens when the form submits so that you can do things like implement optimistic UI really easily. And you can access the result of the most recent submission or any validation errors that occurred. The next one that I want to show you is pre-render. A lot of you, if you've used SaltKit, you've probably encountered pre-render at some point. The idea is that you can generate HTML for a given page at build time rather than server rendering on demand when a request comes in. We use it on Svelte.dev a lot, for example, for the documentation, and it's incredibly useful because in the documentation, we type check all of the code samples and generate hovers when you hover over interfaces and things like that. Number one, it's much too slow to do that on demand for a request. Number two, it prevents us shipping incorrect code samples because they would cause the deploy to fail at the type checking stage But it only works at the root level pre today only works at the root level Either a page is pre or it not which means that if you have a mix of static and dynamic content on the same page you can't use pre-rendering. You have to server render everything on demand. But with this, pre-rendering happens at the level of individual functions. So you can have some dynamically server rendered markup, but when you navigate to another page, you're just getting a blob of JSON from the nearest CDN point of presence, which is probably a few milliseconds away from you. Of course, it doesn't always make sense to pre-render stuff. You might have millions of pages in your content management system, and if you tried to re-render all of them on every build, it would take forever. But what you can do is generate stuff on demand and then reuse that response for everyone else. Exactly how to implement this is going to differ from platform to platform. On Vasell, we have something called incremental static regeneration, which is preferable to using HTTP cache control headers because cache is a region specific and cache invalidation is hard. So cache is something that will probably need to be provided by your platform adapter, but query, command, form, and pre-render are all things that we hope will work out of the box everywhere. So I'm pretty excited about this stuff, and I hope that you are too. I know that it sounds like I'm talking about a lot of change, and change can be scary, so I want to reassure you that this will all happen in consultation with you and the broader community, and we're not going to suddenly take away your load functions or anything like that. And I don't have a timeline for any of this. All I know is that the future of Svelte is full of promises, and hopefully full of promise. Thank you. Thank you. you