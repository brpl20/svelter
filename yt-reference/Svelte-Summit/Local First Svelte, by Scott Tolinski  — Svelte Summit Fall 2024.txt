 Hey, what's up real quick? I have a new course on Svelte 5 basics out now at Syntax FM on YouTube. Give it a watch. We cover everything you need to know if you are new to Svelte 5 or Svelte. Hey, what's up? My name is Scott Talinsky, and today I'm going to be talking about local first software within Svelte. And this is going to be how you can make native feeling apps written in web tech. There's going to be a lot here. We're going to show some code. We're going to talk techniques. We're going to talk very broad, but also very local to Svelte. So once again, My name is Scott Tolinsky. I am the co-host of the Syntax podcast. If you need a web development podcast in your life, well, check out Syntax at Syntax.fm. I'm also an executive producer over at Century where I get to work on Syntax full time. You can find me at any of these places, Syntax.fm, Tolin.ski, or on any of the socials at s.tolinsky. I think this question often gets ass. People hear the term and they might see it on Twitter, local first. It's a buzzword right now, right? And let me tell you, I have some cool stuff to show. But what about the term local first? The term local first, you know, one of the quintessential blog posts here from inkandswitch.com has seven ideals. And this is like really what true local first is all about. One, no spinners, right? Your work is there at your fingertips. When you open up an application, it's not having to wait for the network request to be available. Even if that's your data, that data is on device, that application is working and ready, you can just get to work. There's nothing worse than maybe like opening up a note taking app and having this idea in your head. And you're just waiting and seeing that spinner, maybe your connections not good, you're waiting for something to happen so you can get this out. Another one is your work is not trapped on one device, meaning that I can take my work that I'm doing from my phone to the tablet to my computer, right? Nice and easy, something that I tend to do often myself Next is that the network is optional as in if the network itself might even have bad conditions or less favorable conditions or you know even just no network at all Now not all applications need this type of functionality. But when they do, it's really nice. You know, I'm a snowboarder, I go on the mountains and half the mountains in Colorado do not have good network conditions. So if I go on my phone, I'm on the chairlift, and I need to do something, And I don't have an ability to use this thing offline. It can be really frustrating. Four, seamless collaboration with your colleagues. Have you ever made a grocery list? Maybe you're with your spouse or partner at a grocery store. You both have a shared list. You're on different sides of the store. My wife and I do this all the time where we're constantly adding things to each other's shopping list so we can grab it. And that way we're not sending text messages back and forth and we can check off what we're picking up. So seamless collaboration, something like Figma, something like Notion, any of these multiplayer apps. Number five is the long now, which means that this thing will exist long into the future because it's built on technical things that don't require a third party out there to be working. If you've ever played a video game when they shut their servers down and then that video game is completely useless, that's the problem this is trying to solve. Six, security and privacy by default, meaning that because everything is local on your device, that is your information. If it does go into the cloud, they expect it to be encrypted. Seven, you retain ultimate ownership and control, meaning you own your data. You can take it with you, download it in a format that you can use later. Sounds pretty ideal, right? But practically, though, you're going to do all that stuff in every app. Not every app needs those features anyways. And I think there's a lot of cool things about working with local data in the context of maybe a local first app that you don't need to have all that stuff to be able to take advantage of. So practically, in my mind, and this is just a wide view of this, a practical application of this very well may just have local data and it has work offline. You know, granted that those don't follow the ideals of the idea of local first. However, if it has local data and works offline, that to me is a huge win for many of these applications. If you've ever used something linear or superhuman, you know how fast these apps can be So why local data Well that exactly it One it fast as hell This stuff absolutely cooks You don need things like optimistic UI because when you hit a button and it saves it to the database it saves it to the database. You don't need to fake save it to the database, right? And because of that, it feels native. It feels like a real app on your phone. The latency is so gone that you don't have to worry about how it feels. For your users, it feels good, right? That's a big thing about web apps, especially ones that aren't properly using these features to be fast. Maybe they're not even doing optimistic UI. You click something, you wait even like 300 milliseconds, right? Too long. Three, it can work on any network condition. Like I mentioned, spotting network, these types of things are going to make the apps feel a lot better for users. So that's what it means for a user. But what does it mean for developers? For developers, it means you're doing a lot more client-side JavaScript, specifically because if you rely on the server for everything, when that server isn't there, yeah, you can use a service worker to cache some things, but when that server isn't there, the application should still be able to work. So that means you end up writing a lot more client-side JavaScript, which isn't necessarily a problem when it feels this fast. And that also means that these applications are definitely better suited for things that are an app rather than a marketing site, right? Because we don't necessarily need that SEO in the same way. Two, on-client database technology. Typically, this could be something like an index DB, which is kind of the easiest option. There are people putting Postgres via Wasm in the browser. There's people doing SQLite in the browser, but you can get by doing a lot with just index DB. Three, the last one here, is possibly if this data needs to be persisted somewhere to a database is like a network sync. So I hit a button, it saves it to my local database in the background, just doing a sync. And in fact, let's dive into that because the sync server might do a few things. The sync server might even handle conflict resolution, right? Perhaps I hit a button and you hit a button or we type on the same line. How does the application and database respond to that conflict? Not every app needs that depends on, you know, how often data is being updated and by who, but there's also pushing, pulling and polling. You might push information up to your persisted server You might pull information from your persisted server in the background or you might have a polling process that says do we need new data Do we need new data you know at an interval but you might also even have like server sent events to trigger a poll, you know, so there's a lot of different things here. And lastly, a persisting to a database, whatever that database technology may be, you need to have a way to persist it to a database. So to break it down, you may often see diagrams like this. And I'm not picking on PowerSync right here. PowerSync is a good technology. But oftentimes you go to any of these local first service sites, and they have these crazy diagrams, and they're often way too overdone. And I want to simplify. Here's the most simplified version of this type of thing. So in a typical website, this is, you know, this is very simplified here, you have a client, the website, the app, whatever. It requests information from the server. That server may grab it from a database. Then that server sends it back to the client, renders it, right? That's all happening in kind of a linear process. This, this, this, this, right? Now, with a local first app, it might look something a little bit more like this. You have your client, and that client is first grabbing information from the local database. The first thing it does is check to see if that information's in the local database. Most times after the initial load, it's going to be there and it's going to load instantly. It's also going to kick off a background process that's going to sync. It's going to hit the remote server. It's going to find out what the data that it needs to make the local database complete with up-to-date information if there is any. And it's going to hit that remote database. It's going to grab what it needs and it's going to send that information along the backend and it's going to save it into the local database and update the UI. That whole process can be that fast if, of course, you're sending just the patch messages and things like that. Maybe the initial data load, if you have a lot of data, might be kind of heavy. But because the information is coming in from that client database, that local database, first and foremost, that page load is like that. There is nothing stopping this application from loading except from local JavaScript, which, of course, you can cache pretty hard as well. So what does it mean for SvelteKit devs specifically? Because here we are at Svelte summit and I want to talk about Svelte stuff. So for Svelte kit developers, it means that you end up not using server actions that much because you can imagine in a world where you're saving to a local database on the client from the client, there's not a lot of reason to use a server.

 to store a database. Really what happens is you're saving it to that cache and then there's a sync process that's being triggered from the client and then that sends it to the server. Now that doesn't mean you won't use server endpoints at all in SvelteKit. You can actually host your syncing server inside of the SvelteKit app yourself. I'll show you an example of that later, but you can just have an API endpoint to receive either that push pull or whatever that sync server may look like, right? And largely client-side rendered websites or pre-rendered websites. Now we might have pre-rendered sites for marketing pages or a pre-rendered shell, but we oftentimes are going to be working with client-side data, as I mentioned before. You also can't rely on data from the server for that initial load. So that initial load, it could be happening in a load.ts, but it's probably not going to be happening in a server.load.ts as much, right? Because we want to check first and foremost if that data is available from the client before we try to load anything from the server, right? So that data coming in from the server is often happening from a sync process and not from a data loader. Five, global stores. Because of the sites are client-side renders, we don't have to worry about some of the pitfalls of global stores in a server context, server rendered context. That means we can have a global store and not have to worry about things like contact or having insecure data, perhaps because that store is being used in a server site. If your templates are all being rendered only on the client, that global store is just a client store, if you think about it. And then six, you're often using a service worker for offline support and caching. So let's get into the libraries and techniques here because it's not an all or nothing bucket. And there's different ways you can do this. In fact, we have applications that are local only. And local only means that the data does not persist to another database. There's also a local cache in a manual sync where you actually have to write that sync process and what's happening on the server. And then there's also a full takeover, like you're using their whole system, and it kind of does it all behind the scenes in a way most of the time. I'm going to go in deep on some of these. So local only, oftentimes what you're using is indexed db now i tend to use something called dexy dexy.js and this just makes working with index db a little bit easier kind of like orm ish and it really nice and easy because you know what you can just pop in a Dexy create a database and save it right from your Svelte store and sometimes you using stores to sync deserialize or serialize the data and I'm going to show you a couple of apps that we built for one we built a desktop application in Tori for syntax and it's it's pretty amazing this thing rips and I'll show right now. So the syntax production assistant, as this thing runs, we have a Svelte custom data store. And you'll see here that every time we do a save of anything, right, like we hit a save, we want to save some data. The first thing we do is we get the current data from the local DB. And we get the updated data, we merge them together. And then we put it into the local DB. And then we run the sync function, the sync function really just updates our client store, because we have a state value here that is then made available to the user. So basically, anytime we save anything, we're just merging the data into the local database and putting it into a Svelte store. Now, this looks like it might be several things if you're used to working with a remote database, but when you're working with a local database, saving until indexed DB takes infinitesimally small amount of time for the most part to the point where I can save on every keystroke. And I'm going to show you another app that I built. I won't show the code here, but it's largely the same. And this is an invoice app that I built. And this is saving everything directly in IndexedDB itself. In fact, let me even pop this open here in application. IndexedDB invoices, and here's my invoice data right here. This is another SvelteKit app that actually saves information on every keystroke. So if I'm coming in here and I want to change this, I can instantly hit refresh. and you can see that the application is persisting this information because, again, I'm saving this on every single keystroke. This app is publicly available on my GitHub if you want to check out how I did this, but it's really just SvelteKit and Dexy. Those are the two technologies that we use for this, nothing else. So let's talk about maybe a little bit more intense version of this. Like, what does that look like? And this one is more intense only because you have to do a lot more work, but it ends up being a lot more full featured in the end. So for instance, you might have a local cache that you're saving and updating to. And like I mentioned, in the background, a sync might be happening. I changed this data it pushes that data up in the background or perhaps data was changed somewhere else there a server sent event it triggers a pull on the client side And there you have the push pull sync system that I talked about The reason why this gets complex is that oftentimes you're working with more things than just, oh, I made a change, let's push it up. What you're dealing with is patch messages. So something like Replicash does this, and it does this really well, but it is a lot of work. I'm going to tell you that right now. Because when you have a Replicash system, you you push and pull, but what you're pushing and pulling and saving into your database is just chunks, tiny little chunks, patch messages. And it's up to you, the developer to understand those patch messages to parse them to know what version your database is at and know if the patch message coming in is from a version that is newer than the one on the server. That means you have to keep track of versioning yourself. And there's all sorts of version strategies, whether you're versioning the table itself or versioning an individual row or it's it's actually more work than you may expect but for that more work you get a blazingly fast app that works incredibly well locally and has a sync process and i've built a couple apps this way and one of them has a really easy strategy for this and one of them is much more complex with replicash so my breakdancing app called the break or the break app is is using naive sync with Dexy and I naive sync isn't a thing I made this up as a term but it's just a very naive way of syncing I made something save it to the local database in the background something changed like it doesn't work with multiplayer it doesn't work with conflict resolution very well but if I'm one person using this application on my phone, and I'm not expecting there to be any other conflict there, it works exceedingly well for that. And there's also this real sync with Replicash. Now, if we take a look at my HabitPath app, this is using Replicash. And I could pop open the network request here if we want to see some of this what's going on. Again, it's storing data in patch messages. And every time I click, you do see that there's a push happening in the background. But But now that push is just completed. And even though that push took some time because it's having to do a little bit more work, you'll notice that the client side responded very quickly. In fact, I can toggle this many times. And look, it's only after I stopped toggling this many times that the push goes out. What so cool about this is that it feels native to the user And mind you I updating the local database here I not doing optimistic UI at all I saving to a database And then that push happens in the background So you can see just how fast this application can be. To take a look at some of that code, I'm not going to show too much from this app because we could be here all day. But I want to show you what a push message might look like. So the push message is coming into a SvelteKit API route, right API sync push. When that push message comes in, first thing we do is obviously we check to make sure that the user has been authenticated. I have a auth package that puts the user information into locals. So if that user has not been authorized or authenticated, they just get bounced right away. And again, it's just a request, even though it's a push message. So that server side cookie, the HTTP only cookie I have gets carried along there. But from here, we actually open up a transaction inside of my database technology, and I start to grab all of the patch messages that are coming in. But the first thing I do is I check the versions of all of my things. And if you want to see just how very broadly intense this is, this ends up being, let's see, a 15-step process. And that doesn't even include where we actually update our database. It turns into like a big old switch statement at the end. But what we're doing here is we're checking versions for things. We're calculating the next version, and we're seeing what information is new and what information is old. And at the end of it, we end up saving it to the database and telling our application, good job, it works. There's also the break app that I mentioned. Now, this one actually uses PocketBase as its database. So if you want to see an example of local first with PocketBase, I think this is a good one to check out. and largely what we're doing is yeah we're subscribing to one of our collections here and if something has been created or updating we put it into the database and we tag this little needs sync to be false because it's just come in from the server right and then we update our felt store with a dot push and likewise delete we delete it but for the most part what you're doing here when you're adding things or running a sync is very similar to how we did it in the indexed DB and Dexy by itself like we had with the production assistant app where essentially all I'm doing is when something happens I run a sync process. That sync process checks to see which of the local moves flags have a needs sync property on them and if there is a

 needs sync equals true, what does it do? It sends it along to the server to create it, delete it, update it, etc. Right. And that's pretty amazing. Because each time we save, we just end up creating the updated move, we put it into our local DB, and then we sync, then we check our local DB, and then we make sure everything runs accordingly. So it ends up being very, very simple. And again, this is the entirety of how we're working with the database. Since it's pocket base, all of these calls happen from the client side. All right, let's get back into it. There's also these full takeover ones where it's triplet, evolu, instant db. These ones require much higher levels of buy in triplet is effortless. It's a custom ORM. It's open source, you can check it out. It's fairly new. And I want to say a lot of these are fairly new. So they're possibly be dragons, right? evolu is is effortless that you can self host it, it uses keysly as an ORM. So it's not like you have to learn a new ORM if you know Keasley. But they have a built-in auth system. I love this project, but they really are pushing this mnemonic auth system on you. And I got to say, I don't know if users are going to flock to want to use this. I think it might turn off your average everyday user. Technical folks, yeah, they might like it, but your everyday user is not going to want to save a mnemonic somewhere instead of creating a password And there also InstantDB which is newer It effortless It a custom ORM it feels more like working with something like Firebase or Pocketbase But it closed source you can self host it And it doesn require major buy in If you building an instant DB, you are you are building an instant DB sort of like Firebase, right? But I also think there's like another option here that I'm really excited about. Now, there are several future options. I think Prisma is working on something we talked to the folks at at Prisma on a syntax episode, they talked about working on local first. So if you're a Prisma user, you have that to be really excited about. I think there's a lot of these new technologies about to hit really hard. One of them is zero zeros from the folks at replicash. And because replicash is so mature, they've been working on it for so long. They basically took some of those ideas. And it's like, what if what if we did all that for you and made a platform that you can bring your own database, you can bring your own information, but we're going to do all the hard stuff, all caching, all the syncing, we're going to do all that for you. And I'm not going to spoil too much about Xero here, because they've yet to do their full announcement of what it is. But there's a really great blog post on this that just kind of goes over their ideas for Xero. I personally have gotten my hands on Xero. I personally wrote these felt findings for it. So once it releases here and you use Xero Svelte, you gonna see just how incredible it is Now the last thing I wanna share is something that working on You know this is not complete yet And in fact because zero is not released yet chances are by the time you hearing this this won be available as it will be But I working on this as a SvelteKit starter with zero. And right now it is a SvelteKit starter with Pocket Base. And I've been using it to rapidly build apps. But I actually have been always wanting it to be a local first platform from the start. And I've had this kind of dream of a local first Meteor with Svelte. And the idea here is that out of the box, you would get effortless local first via Xero, you would have auth, you would have templates. In fact, that's something I think a lot of full stack frameworks kind of get wrong these days is like Meteor came with a login template. When you started, you could just drop that into your application. And you had a login, right? You didn't have to use it, you could always use their functions to do login and build your own. But the default one was really pretty good. And that's kind of what I want to get out of this, right? It also comes with an email system. So just simply by loading up the application, all emails will be printed to the console. Unless of course, you have your email details for your, your email sending service. So that way, you just plug those in and bingo, you have your auth, sending emails, sending verification links, all that stuff out of the box. So it has a base theme with a built-in grid system. Of course these are all drop features that you do not have to use if you don want to but there is a fluid text system There is a really super great grid system and a default theme with CSS variables and some really great default classes out of the box which, of course, you can dump for your own CSS framework of choice. There's also an ORM. It uses drizzle behind the scenes to do your migrations, to build your queries for the server side, and also take care of those migrations and stuff we need for the auth, right? It uses Postgres via Xero. And the best part is it's 100% Svelte 5 and SvelteKit based. So I'll be having a lot more on this right now. If you do want to get involved with this project, you can find it on my GitHub. It's just drop hyphen in. Again, right now, it is a fully functional pocket base starter that I've been adding on to. It's in pre-alpha, right? But I have been using it to rapidly build apps. But I think the dream for it could be so much bigger. So if you want to learn more about this project, get involved in its development and see where it's at. I'm really excited to share with you what this could be once we're able to show more with Xero as a platform. So that's all I have for you today. I want to say thank you so much for giving this a watch. Again, syntax.fm. If you want to stay involved with new web tech, check out what's going on, get explainers, or just listen to two dudes who really love this tech talk about it all the time. So thanks so much for watching and listening, and I will see you in the next one.