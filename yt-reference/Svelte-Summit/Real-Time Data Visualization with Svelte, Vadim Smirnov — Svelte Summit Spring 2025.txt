 All right. So thank you all for spending time with me. It's really awesome to speak with you and for you folks. It's an incredible event. I'm really, really happy and proud to be a part of it. So my talk is called Real-Time Data Visualization with Svelte. So before I dive deeper into the talk itself, I would love to introduce myself. My name is Vadim, as I already mentioned. So, like, I'm a front-end developer and a developer advocate. And at Developer Advocates, we do nothing and everything at the same time. But jokes aside, I focus on developer experience, content creation, doing fun stuff on the internet just to make sure you folks are supported for the products I work for. So, basically, you have an opportunity to get content that help you to move faster, more confident, and just to understand how you can benefit for specific tools I interact with. But today are, you know, a special day for me specifically. So I want to, you know, like use this opportunity to brag a little bit and also do some warnings. So three things are happening for the first time. So what are those? The first thing, I'm speaking at the Svelte Summit for the first time. And this is incredible. it's incredible because i didn't expect this to be like such a welcoming like family-like community because usually like we are like a family it's a red flag in tech industry but here it's another story because like i actually feel like it's like a family vibe because like it's like everybody knows each other it's really comfy community so i really regret that i joined it only now but really lucky to be a part of it right now. So besides that, I'm exploring this wealth lore a little bit deeper because before that, I was like on a hello world level. So that is not something I'm proud of, but it's a great opportunity for me to like learn in public by this talk. And also hopefully I will encourage some of you to maybe like become a speaker one day. Like if you're not sure if you want to do it or not, this is a great opportunity for you to say like, yeah, just do it because it's such a fun experience. and you're able to learn something new for yourself and help others to feel more confident as engineers. And I'm using RIP Build.js for my slides. So this is something I regret doing because apparently I don like a comfy smooth life So I introduced another complexity So if something will look a little bit awkward on slides I apologize I tried my best to make it look good But let's actually focus on the talk itself. So why real-time database in the first place? And this is like a screenshot of a really like typical, you know, dashboard analytics. And you see those all the time. I don't have to introduce you to like what some analytics tools are you for sure. saw some version of it. But let's just break it down for us to understand the problem statement and what we're working on a deeper level. So real-time data is mostly for stocks, analytics, and other tools, like for example, personal money trackers or some kind of fitness tracker or whatever else. So it's everywhere. Data is everywhere. So we work with data on various forms and shapes, and basically you need it. And there are some specific needs for that. So it should be really fast, very performance. And basically, you don't want to wait and you want data to be like very informative and helpful. And it should be like a good UI and a good UX. And Svelot is the real deal here. This is just, you know, like just a hook for the next upcoming part of the talk. But Svelot is the real deal here with the D3 help. Obviously, D3 is not the only solution. but in the scope of my specific talk, D3 is a part of the stack I'm using. So let's talk a little bit specific about things I used in my setup. Basically, this talk is going to be me introducing how I actually built it, so my specific implementation. So let me know if it makes sense to you after the talk, so I'm really open for the conversation. Just elaborate and just see how you feel about that, how you think about that. So I used state, basically, to be redundant for reactive state. I used derive for computed values. I used effect to run, basically, the whole heart of the real-time data visualization and plotting. And I used, obviously, props to declare components props. That's it. That's not the only things that are available with runes. There are a lot more. But this is a chunk of those that are available that you can actually use and build things. So for my specific use case, that was enough. but yeah, let's proceed to the next day. So enough of that chit-chatting, let's actually see the code itself. So I use SvelteKit just to kind of like get the boilerplate like for my project just because like I wanted something like quick and simple just to kind of like have the foundation And obviously majority of yours or if not all of you are familiar with how to create this but still why not include this as a slide. So yeah, this is the entire setup of my project. I didn't want to overthink it. I didn't want to make it too complex. So it's just the page itself where I displayed basically the chart and the chart component itself. For the simplicity of just explaining how the foundation of that could look and how you can scale from there, that is more than enough. So let's just really quickly focus on the chart component itself because first I want to introduce how the chart component looks and then we will transition to the page component and see how we generate the data and kind of pass it over to the chart component itself. So first, obviously I imported D3 because it's going to be used quite often. And also I declare some things as a props. The props is basically the data. Data is going to be an array that I pass over from the page level. That's basically where I'm going to generate the whole data set, the whole mock data. So it's going to be an array that I pass to create some visualization. And also just define a very basic set of props just to kind of set up the width, height, and some specific margins to kind of display the whole chart, the whole plot. I specifically don't pass it from the page level, I just define it as hardcoded values because that's enough for the demo, but for the sake of responsiveness and for the sake of some dynamicness, you can work with that from the page level and pass it from that. So the next part is some specific set of variables that I use for DOM reference. Basically the SVG variable, two variables that are related to axis, and the path element basically we should use state and later on you will see like why it is a thing. And next for the chart component I have the last value, previous value, this is basically for me to kind of like create the line itself and I have the spiked value the right value, so basically this is the one I use for animating like if the differentiation between two specific points is going to be too large there's going to be like a pulsing effect and you will see in a few slides and that's how it's gonna look from the code perspective and CSS animation perspective. So just to summarize I using props for the data input I tracking DOM elements with the state and I computing the right values with derived to be a little bit redundant but yeah So now let's focus on the implementation, sorry, not the implementation, but integration of two tools, basically this thought in D3 itself. So I use effect. This is basically the whole heart, the whole foundation of how it actually generates things. And here I'm starting to use D3 API. So basically const x and const y, obviously, is responsible for the axes. And the line itself, it focuses on the line for the chart. So this is all we need to kind of make a very simple basic foundation we can work with as a starting point. The next part is basically updating that data with values so we can get some kind of dynamic value. And with the effect power, we basically get this update, like it triggers every single time something updates from the data perspective. So next part is obviously styling. So from the styling perspective, I apply some, you know, consistent hard-coded cells, something I don't want to kind of like mess with. I just declare it once and don't work again with it. So this is just, you know, kind of like some CSS that I need to kind of visualize that stuff. And the next stuff is basically the way I animate that stuff with the CSS. So here I use this stroke-array property to kind of like affect the animation part. And also I use the browser feature, the get bounding client rect, which is basically you can look it up on the MDN. It's something that is available for you with the browser. So just to kind of like trigger the animation part. So with the power of some CSS and some browser API, you can actually just re-trigger the browser just to kind of like force two animations to run again. And this is the SVG template. This is basically the specific point of the chart, the specific like circle on the chart that is gonna be affected once we kind of like trigger the effect part to be again a little bit redundant with the naming. But yes, you can see that here I pass the path element to the path of the SVG element, and also for using the each cycle, I kind of create the circle element on the chart, and also...

 I have the conditional pulse class, and this is the stuff that is related to the differentiation between values, which allow you to kind of like see if the value is, if the differentiation between two values is too big, we basically see the pulse and effect. And obviously some CSS, just to kind of like make the actual pulse effect happening. So obviously some SVG-specific classes just to kind of like for, you know, coloring and stuff. and then just the animation itself. So nothing to outreach, it's very simple, very minimal set of styles. So now we can transition to the page component just to see how we can actually pass the data and how we generate that stuff. So we import the chart component. Next, we define the data and we kind of define it as an array, like empty array of state and using state rune for that specifically. I use like you know you can use 50 points and like for I just simplified it for the demo it's all just for the 10 points but it's up to you like for the limitation but obviously like for the real thing you're going to have limitation and you're going to work with web sockets because you know like having like working with like a huge amount of data is not really scalable if you will so for this example as just you know like 50 10 up to you like what's the limitation and obviously like I just simulate because this is a mock data, so using the set interval, I just simulate the real-time effect, just receiving that data from somewhere. And this is the basic very simple implementation of the markup the template itself So it just a div with a chart and I pass the data which is the only prop if you remember from the chart component which was not defined with a default value, and this is the only prop that I should use to kind of pass the data so the chart can be created, basically the line itself on the chart can be created. And some styles. So I would love to talk, just to reiterate, just to kind of sum up with some key patterns I used. Using the props, I kind of like passed or defined the component inputs. Next, I did like perform the track and DOM element with a state. Next, obviously, again, I'm being a little bit redundant, but computing derived values with derived. Next, basically the heart of the whole setup is the effect room, basically which is like responsible for changes, basically triggered every single time we'd like update the data. and the conditional class application would be like class name and then the condition itself, which kind of like triggers the implementation of additional class if we need one. And the animation concept. So for the SVG animation, I use stroke-array and stroke-offset. That basically helped me to kind of like manipulate the cells as I expect those to look, and you will see in a second how it's going to look. So the CSS confirm animation, I use those for basically the pulsing effect, basically where the differentiation is a little bit large. So you will see the pulsing effect. Next, the conditional animation with pulse, again, like it's just kind of the same thing. And with like the get bounding client rect, I trigger the browser to kind of like force the animation again for the new value the update of the value And now I would love to just to show you how this whole thing actually looks Boom, boom, and if I refresh, so this is a chart, and yeah, it generates, like I limited it to the 10, so you can see the pulse and effect, you can see updating the value, and it generated 10 values, And here is the whole chart, the whole kind of like real-time data visualization. And Svelte is responsible for the DOM manipulation. And D3 is responsible for actually drawing this kind of like chart. So just to summarize that stuff, I just want to kind of like address the developer experience part. Because this was actually really satisfying for me to see. Because with Svelte, I get like really minimal boilerplate. I was focusing on the right thing, and I was just not, you know, over-complicating things for myself. With React, it's a little bit more verbose and a little bit, you know, like, more complex, like, in terms of the implementation, and you should take care of more things. And with Angular, it's just, you know, like, a proper ceremony. You should just, you know, like, create a lot of, like, boilerplate code. It's good for maybe, like, scalability and just, like, for consistency if you're working with large teams, because, like, some kind of code convention maybe that exists from the default is good. for that sort of purpose, but for my specific case, it was just like a meh moment because first of all, it actually did what I needed, and it was actually like the minimalistic proper setup that offered me everything that I need to kind of create the setup So as the closing thought I would love to kind of address that D3 and Svelte is absolutely powerful for data visualization and it just was very straightforward to use very minimalistic and very effective in a way because I just created a bunch of variables past the right data, animated that stuff with CSS and generated the mock data. Simple as that. Not overthinking that, not working with some React hooks just for introduction of a new level of complexity. Then with SVG, with reactive guidance, that allowed me to kind of like simplify the complex visualizations. And basically this animation was a lot easier because of the reactivity of spell. So basically like this value has helped me to use SVG and CSS to kind of like animate that stuff without a lot of code. basically I have like a bunch of dynamic variables and a bunch of CSS values that allow me to do that. And performance benefits of Svelte was just fantastic and incredible for complex dashboard because I already can see that I don't need to kind of like think too much about how to kind of like scale it from there for a small data set, for a larger data set, and for the even larger data set like some enterprise level, you obviously use some kind of bank-end logic and just isolate the front-end and keep it simple. And the Svelte part handles that amazingly. So that was it. So thank you so much. It was a great pleasure speaking with you folks. Feel free.