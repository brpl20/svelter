 . Hey! . So, hey everyone. My name is Krisha, and I'm here today to talk to you about Threault. Threault is a framework for creating 3D web applications with 3.js and Svelte, which is your favorite frontend framework. You can see some examples here. But before we dive in, some words about me. I've been a lifelong 3D nerd. I started out toying around with 3D software like Cinema 4D and later combined it with programming. Currently I work at Lotum, which is a German game developer and game publisher. But in the past I worked as a freelance software engineer and mainly was supporting and collaborating with artists to create net art projects, of which many were implemented using 3.js. So as I said, Threault is Svelte and 3.js, and to be able to appreciate Threault, you need to understand what the big deal is about 3.js and where it actually might fall a little bit short. So let's first start there. The underlying technology of 3.js is WebGL, Web Graphics Library. Now you might wonder, why do I need an abstraction for that? Well, the reason is the left side here. It's really a crazy amount of code that you need just to draw a single cube. And just yesterday I heard the joke that in order to learn WebGL, you must first learn how to make fire. Enter 3.js. From first look, it's already way less code, but most importantly, the API is based on concepts that you already know. You know what a camera is. You know what a scene is. You know what a group is, a material, a texture. Chances are you even know what a mesh is or a geometry. But if you look at the 3.js documentation and have a look at the style of the API, like how it feels, then we see some similarities to another API that you might be more familiar with. Does anyone know what I'm trying to get at? It the JavaScript DOM manipulation API So it kind of a similar style you could say And now let think back to the last time you built an entire app just like that. I guess never. Nowadays we have our beloved frontend frameworks, like Svelte, that allow us to avoid manipulating the DOM directly and instead represent everything declaratively. But what does declarative actually mean? Declarative means that we can more easily reuse code by writing components that ideally have no side effects, are self-contained, and yet remain interoperable. Declarative also means that we can use control structure and state management of our framework to reactively create and remove entities or objects. and decorative means that we don't have to worry about certain implementation details because the structure itself and the life cycle of a component handle many aspects that we would otherwise have to implement manually. Of course, when reality hits, not everything is best handled declaratively. Animations, for example, and especially games, are implemented running a continuous frame loop. So most of the times you will end up with a mix, but that's also just like your regular DOM app, I guess. Ultimately, though, what we achieve is one thing above all, and that is scalability. If you've ever developed a 3.js application of a certain size or a complexity, you'll notice that it becomes problematic quickly. And this is where Thread comes into play. Thread allows you to use the full scope of 3.js declaratively with just one single component. So it's not a wrapper in the common sense. For example, if you want to instantiate a camera, it's no longer this imperative syntax of, okay, new perspective camera, but you just use the T component. It's a little bit for the guys that are sitting a little bit further back. I should have put it a little bit up. It's this T component that you use for everything to instantiate pretty much everything that 3.js has to offer. Thread takes care of instantiating the object, adding it to the parent object, cleaning up when the component is unmounted applying props and everything This is how we create a visual object in 3GS that is called a mesh And this mesh consists of a geometry and a material and together they define the shape and surface of the object. But enough talk, let's dive right in. Unfortunately, this one went into sleep again. So, one second. Yes. All right. Okay. So this demo is all about creating a product configurator. And let's say we are tasked with, let's say we are working at this electric scooter company and we're tasked with building a product configurator. People should be able to select the color of their electric scooter and get a good idea of how it will look like if they buy it. And I don't want to step on anyone's toes, but maybe, maybe we'll build something that visually looks quite well compared to the majority of car manufacturing configurators in 20 minutes with one engineer. But let's see. I hope so. So first we'll have a look at what is actually there. I just created a regular SvelteKit application. So nothing too fancy going on here. You notice there is like this routes folder. It has a layout page, page, page, page, page file. All the usual bells and whistles. There is some tailwinds. But there are also some things that you don't see in a regular SvelteKit application. these two files. The first one is a GLB file, that is the 3D model that you get from your design department or something like that. The second one we'll come to later. Then there is this mysterious file called model pipeline, also later. We have a little bit of global state. Who doesn't like global state? We notice this pattern, right? This is Svelte 5 class members as runes automatically get getters and setters. So I using that to create a simple global state of the paint color and the seed color of the scooter that we try to build And if we go to page.swell.tvc, okay, let me just do it like that. Can you read that, by the way, or should I make it even bigger? Bigger is good? Okay. Okay, I'll leave it like that. It gets really hard to, I don't know if you ever did that, but it's really hard if it's super large. Yeah, so the page that we see, it's very basic. Let's have a look at what it actually looks like if we open it up. So this is the page, nothing really to see here. We have the ability to select the colors, but nothing is really visible. And inside of this blue stage, we want to have our electric scooter and be able to have a look at it. Again, sorry. Yeah, the first thing we need to do is we need to implement the canvas component. that, I made a little note, canvas goes here, that's exactly what we'll do. Maybe one thing before that, I already installed all the dependencies because I don't trust conference internet. But if you want to install Thread, it's basically quite simple. This is the Thread documentation website, it's Thread XYZ, and we have a little installation section here, and you can you can choose what packages you want in your Thread enabled app, and it will give you like an install script. In this case, I used core, the core package you cannot really deselect, of course, the glTF, extras, and because I'm using TypeScript, this is also what I'm selecting here. And if I run this, everything gets automatically installed, of course. So I did that before, as I said, So let's jump right in. I'm going to implement the canvas component here. What this does is actually

 a lot of things. It sets up all the rendering for us. It also creates the actual canvas element that it renders in, and the canvas element will take up the entire space of the parent element. So by styling the parent DOM element, I can just easily tell it, hey, this is where you should render. the thread is heavily relying on the context API so this is also what it sets up it sets up a scheduler, a default camera so basically everything that we need and as I said we are using the context API really heavily so everything that we do must happen inside of this component a good practice is to immediately go here and create this scene.svelte file. This is where everything happens now. And whoop. That's good. I'm going to add that here. By doing so, if everything I'm doing is in this scene.svelte file, I cannot be out of context. So I'm exclusively working here now. So first things first. Do we see anything now? No, because our canvas doesn't have any content in it, right? The next thing that we do is we want to have a look at this model file that I have in this static directory. GLB files are basically the industry standard when it comes to 3D files that are for sharing 3D content with web applications or in web applications. There are two file types, GLTF and GLB. Usually you want a GLB file because it's just way smaller. But this GLB file, it's binary, so you cannot really see what is going on in this file, and that's really unhandy. so Threault has something that is called that is a CLI and it's called Threault GLTF and if we run that with this script that what this script is about it just like a nicer interface to run that CLI So I have like a all the way down there all the way down here I have like an NPM script that I can run and a magic Svelte component appears. So this CLI automatically transforms GLB files, 3D files. Thanks. This CLI automatically transforms GLB files into a third component. And we gained a lot from that, actually. It's introspectable. So we see actually what is in that 3D file. We see the individual nodes, the meshes, the materials, and there is even an animation in here, which is called driving. So it's type-safe. You cannot access stuff that is not in this GLB file. And another thing that is really important is that we are using this... I'm sorry, people... We call this hooks. We are using this used GLTF hook to load the model, cache it. That means we are saving on network round trips and also model passing. But that would also mean that we cannot have the model twice in the scene because we cannot really reuse some stuff that is inside of this file, especially meshes and groups and everything that is kind of deriving from the 3.js object 3D. So what this CLI also does is it recreates everything that we cannot reuse and it reuses everything that are reusable. For example, geometries, materials, like you see here. Everything that is reusable is reused, and everything else is being recreated. So it makes the most efficient way to deal with GOTFs. Yeah, so we now have this ready-to-use Svelte component. It includes, this is what the markup looks like. There is a lot of these T components that I already talked about. Import T from SvelteCore. and the CLI basically transformed the contents of the GLB into what you see here A lot of meshes in here And we can now go back into our scene file and just drop it in here. And let's see if that changes something. Ooh, not too bad. Something's missing. It looks weird, right? By the way, this is what the scooter looks like in Blender. It's straight from Sketchfab, so credits go to Minghao Lu, and it wasn't actually an electric scooter. It just removed the exhaust. Yeah, so this is an electric scooter now. Yeah, but you see there's some difference in the rendering, right? This is pitch black and this is nicely lit. Any ideas what could be the problem? No light, yes. This is the number one thing that people fall into, the number one trap that people fall into in the beginning. No light. We could now set up a very intricate lighting situation, but there is a really easy way to do that, especially if it needs to be cheap, so it needs to run on really bad hardware. And if you want reflections, and you don't necessarily need good shadows. And the way we do that is with an environment component. And this environment component is from Threat Extras. Threat Extras is a collection of abstractions, like a huge collection of abstractions that you can use to just put in your scene, be happy with it, or use as a starting point to make your own solutions. it has a property called URL and because I don't want to type it out I just saved it here basically what this URL resolves to is this is tiny this HDR file down here HDRs are images that contain way more light information you could say than regular images. Some of you are probably familiar with that. And we can just pass that URL to this HDR to this component and it will take care of loading it caching it for further requests and stuff like that So okay we are getting somewhere We do have way more, like, we do have some aces up our sleeves in terms of environments. Like, this is, for example, the latest development in our environment game, which is a dynamic environment. so you can have a Threl scene be your environment dynamically and set up the lighting like that. Super nice. But I'm not going to deal with that now. I just use a pre-made HDR. Okay. The camera position is a little bit odd. I think that's the next thing that we're going to tackle, and we do that by creating a camera. Now, Threl already creates a camera for us, but we cannot really use it. it's not accessible, it's just to render anything if the user didn't specify a camera. For that we are now using the T component. And we are creating a perspective camera. And we see that we also get types. The types are inferred from 3Js, nothing is hard coded, no prop application is hard coded, it follows a strict rules set, but it's not like we said, Like we said, yeah, like if this is perspective camera, then that, but it's just, it's very generic. But we need to provide some props in order to tell Threl to render with that camera. And one of them is make default. So now we are rendering with that camera. But the camera is like underneath the scooter. We cannot really do anything about that, with that. So next thing we have to do is change the position of the camera. There is a property called position. You also see that it's type safe. So it's as type safe as possible while still giving you a little bit of flexibility. Type true is not assignable to type. Ah, yeah, interesting. So we have the possibility to pass a number, an array of numbers, or undefined. We are going for the array of numbers. And what that actually does is, if we first, maybe it makes sense to create a vanilla camera.

 Vanilla 3JS camera. New perspective camera. And this camera has a property position. That's what we want to manipulate. And this position property has a method called set. X, Y, Z. And interestingly enough, this also matches this signature. And this is because if there is a set method on a particular class, we use that to apply the prop. So in this case, the array that I pass to the position prop is used to invoke the set function with the values that we pass in. So camera position.snow, yes, okay, that was close. Camera position.set is basically the same as passing values in here. And that's exactly what I'm doing. I fumbled around some different values, so I don't, yeah, that's how it needs to look like, trust me. It's going to look better in a second. One thing that, yeah, we also probably want to change the field of view, FOV, to 30. way more narrow, we don't see anything anymore. But we also want it to be slightly interactive. So one thing that a lot of 3.js applications include are the orbit controls. The orbit controls are pretty simple. You can orbit around an object with your mouse. It's from the infamous add-ons or examples directory in 3.js, I don't know if you're familiar with that, a lot of the contents of 3.js actually live inside of an examples directory, and they are not actually part of the 3 module. That means we cannot make use of the T component directly to create orbit controls, because the T component is only able to instantiate objects that are exported from the 3 module. Instead we are again using an export from extras with the same name OrbitControls And okay, we can do something here, that's nice. Yeah, but it doesn't feel right. So to make it feel good, we enable the damping and we let it auto-rotate. We change the auto-rotate speed to a little bit less of what is default because it's obnoxiously fast otherwise. And somehow the camera is way too low. And for that, there is this target property. That is basically the target where the camera should look at while using the orbit controls. And in order to do that, I can target is again, a vector three, just like the position of the camera, so I would be able to implement it with an array, X, Y, Z, but now we can also make use of another quite fancy API of Frelz. We can make use of pierced props, so we can target individual properties of the vector just like that. So this notation sets the property Y of the vector target to 0.6. I'm going to do the same with Z, just to have the correct angle. Okay, so this is all good, I guess. But yeah, selecting the colors doesn't really do anything yet, so we didn't really build anything meaningful yet. But that should be fairly easy. For that we go into scooter.svelte, so the file that has actually been created by the CLI, and have a look for the main body. And we see that the material that is being used here is called glt here, is called paint. And we can again use pierce props to set the color. Material appState paintColor and where is the seat SeatColor. Woo! Now, as a little bonus, I'm going to add shadows back in because this HDR lighting, it's really cheap, but it doesn't come with shadows when you're doing online rendering, so real-time rendering. For that, we are going to use another extras thing. It's called contact shadows, and we're going to give it an opacity of 0.4, and so it also, like, it's grounded. We can, yeah, this is the final output. but I think it's already, it's not even 20 minutes, I think. 19. I think that that worked quite well. Back to presentation mode, one second. Yeah, so the thread team hasn't exactly been well behaved. In the past, we dug into Svelte internals to optimize things like event handling. I think Rich already mentioned that once, or to provide transitions on 3.js objects as if they were DOM objects. And as a result, we had to undertake a major refactoring when it comes to Svelte 5 support. But now Svelte 8 is out. It's quite stable. It's more stable at the end of the day. And it now supports Svelte 5. Now, obviously, we've only scratched the surface with this demo. There's really so much more. And as we already saw in the demo, one of Thread's main incentives is to facilitate an ecosystem of interoperable components and modules that you can just use in your projects. The Thread Extras package provides more than 50 common abstractions that otherwise you'll find yourself copying into every new project. They are production grade, but they may also serve as a starting point to adapt to your own needs This one we saw already in the demo It a CLI that transforms 3D files into Svelte components ready to use introspectable and type safe Then there is a Rapier package. It provides components and hooks to easily use the excellent Rapier physics engine with Svelte. There is TheaterJS. TheaterJS is a JavaScript animation library with a professional motion design tool set. Think of it as After Effects for the web. It's really cool, actually. And the creator of TheaterJS even thinks it's the best integration out there. It's funny because he made the React integration. Then there is one that has a special place in which it's hard. The XR package allows you to easily create XR apps, including hand and controller support, teleporting, pointer controls, and it even integrates well with the Rapier physics engine, as you can see here, like Beat Saber and stuff like that. So this is the SvelteKit application. Placing content and making layouts in 3D is actually really hard. The Flex package uses the yoga layout engine by Meta that some of you might know from React Native development. which implements the Flexbox spec and allows you to create flex layouts in 3D space. And last but not least, Thread Studio is what I call a spatial programming tool set. It's a hackable user interface that sits right on top of your Thread application and allows you to visually manipulate objects during development. Every change that you do in the interface is immediately written back to your code without proprietary data formats and such. It feels a bit magic. It's not yet mature. It's not yet ready for the big stage. So stay tuned about that. Threault wouldn't be possible without the effort of really a lot of people. First and foremost, of course, the team behind Svelte itself and the whole Svelte community. So here goes a wholehearted thank you to all the people who contribute to Svelte and the greater Svelte ecosystem. And if you want to learn more about Threault, feel free to check out the documentation page and join our Discord server. Thank you.

 Bye.