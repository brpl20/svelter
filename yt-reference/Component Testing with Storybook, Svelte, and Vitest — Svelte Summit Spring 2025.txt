 So that was quite the hike. We have to live up to it. Before we do anything, we haven't had a onstage selfie yet. So bring your best energy. Let's do a... Oh, I got to turn it down. Let's say Rich on three. One, two, three. Rich! Yay! Thank you. All right. Great talk by Dominic. It was like the full spectrum from unit test to end-to-end test. And I'm going to focus on the component testing part and how you can do that with Storybook and VTest for Svelte. My name is Jeppe. I work on the Storybook team in Chromatic. That means that I get to spend my whole time working in open source, which is just great. The cherry on the top is that I am responsible for the Svelte integration of Storybook, and I just love that because I love you, I love Svelte, I love everything about it. UI in the year 2025 is complex to build. We all know components. You can have this cool chart component where you want to show some data, and all of a sudden, this explodes into multiple scenarios. Because now you need to show a different type of chart when it's a wide view. You need to show warnings with other colors. You need to show errors with other colors. And all of a sudden, this component takes in a bunch of props, and you have like 50 or maybe even 100 ways that this component can be shown and used. There might even be modes, dark mode, light mode. There might be a mobile versus desktop. And this is just the tip of the iceberg, because then you add it to your application, and then the user starts navigating, and now the component needs to be used in a bunch of other ways. You need to consider different languages. You need to consider different kinds of styling. Is the component, does it have small bundle size? Of course, accessibility. There's just a lot to building UI today. And keeping track of it all is really hard Maybe you tasked with building this chart but in actual sense another team had already built this chart You just didn know because you don talk with them regularly or whatever And so all of a sudden you have all of these components scattered and when do you use which And what can we do about that? I guess there are many solutions, but the solution we're going to present today is Storybook. How many of you know what Storybook is? That's a lot of hands. How many are using Storybook with their Svelte work today? It's also quite a lot of hands. Cool. So the fly-in is that Storybook is a front-end workshop for your components. It allows you to work on your components in isolation, completely separated from the application. You can build out your components, you can do development on them, and you can also build up this catalog of components. So, not only just this is my button component, but also this is what the button component shows with these props and in this state, and maybe even in this mode, you can build up as many stories, as you call them, as you want in this catalog. And these stories is what we're going to try to dive into later. We have more than 30 million monthly downloads of Storybook. Because Storybook has been around for a long time, I think more than seven years now. And we've kept evolving. And as Brittany said a few years back, it wasn't as great. Now it's hopefully better. It's just to say that Storybook is getting more and more mature. And that's just lovely. Storybook and your stories, they live alongside your application. They are not in your application. So you have your application, which might be SvelteKit or SvelteBeat or whatever, and then you have Storybook next to it. They both reference the same components, but they don't interact with each other. So you're not deploying Storybook to your users. It doesn't become part of the application. You can think of your stories similar to how you're thinking about tests. When you write your test, you put the text next to the component files, but they're not part of the application. The biggest difference is that the syntax of tests is written in a way that it's very much sequential steps. You do A, B, C, D, and that's great for logic. But the story syntax that we going to show today is hyper on the UI complexities that we just talked about So having a lot of different scenarios for a second component So the syntax is very different and optimized for UI. We have a gazillion integrations in Storybook. Some of them are core and some of them are community maintained. And one of the biggest core maintained integrations that we are proud of is the Svelte integration. Not only does it work very well with Svelte, but we also have a Svelte-specific language that we've developed to make the Svelte environment better. We wouldn't be able to do this without the great partnership that we've started with the Svelte maintainers. About two years ago, Ben McCann, who isn't here today, started to reach out, and we really have a very powerful partnership with the Svelte team, And they are very active in helping us, and we give them feedback. And it's just been absolutely amazing to work with them. We even have Storybook in the Svelte CLI that Dominic also showed. So when you create a new project today, or if you want to add something to your existing project, you can't see it. But in the bottom, it says Storybook. Because you can easily just add Storybook to a project, and it works out of the box. as long as it's a big-based project. So let's get a quick fly-in on Storybook and Stories. What you're seeing here is the classic Storybook UI view. That's what loads up when you start Storybook. In the middle, you have the button, which is the component that you're testing. It's completely isolated from the rest of the UI. It's in a separate iframe. We don't mess with that at all. On the left side, you have your sidebar, or what I used to call like the catalog of your components and which states they can be in. So you see here we have a button component, we have a header and a page in the bottom. And then for each component, we have a set of stories which represents what this button can be. It can be a primary or can be small or large. We also have a bunch of add-ons. So what we're seeing here is the add-on panels. There can be many of them, but this is the controls panel, which is the the most used one, that allows you to, on the fly, change the props that are being passed in to whatever component you rendering In Storybook they called arcs Don ask why That just how it is But it essentially props And so you can change these to change how the component behaves This example is written using the Svelte.csf syntax that we're just going to fly in now. Every story file starts with a meta definition. Is this big enough? Good. And the meta definition of the file is sort of like the common things that all stories in this file should have. In this example, all stories in this file are supposed to work on the button component, and the prop label should just be button. All of this is overwritable per story, but this is like the default common things. And then we use Svelte to define stories. So, you take the story component, you give it a name, and then you set what arcs defines this story. And this is the primary true. And you can define as many stories as you like, just with a different set of arcs. And you see that the secondary story doesn't have any specific arcs because it's just the default ones. Because this is Svelte syntax, you can use whatever you want. You can use runes, you can have snippets, and all the jazz because it's a Svelte component. That was enough slides. Now we're going to go into demo mode, and then I'm going to go into a bit more detail. So this demo is based on the Svelte demo application that you get when you create a new SvelteKit application today. this Wordle, which is like Wordle guessing the correct word. Thank you. Wow. And you type in a few letters and you do a guess. So here I can type admin. That was not correct, but N was the correct letter. I can do new story. O is correct, and so on. So we're going to use this for our demo today. This demo is divided into a couple of components. We have components for the single cell, which would be like one letter. We have like a row as a component. You have the grid. There are plenty of components. And I've written some of the stories for these components. So this is a story for a single cell that is a close match. So it has a blue border.

 And it has a letter in it. And we can easily change any of these props. And we can do like, maybe it's an exact match. Oh, and then it's in blue. Maybe it's not. Not that interesting. It doesn't do much. So there's also a row. And we'll speed through to the grid, which is like the board. This is where you have your letters and your words, right? The grid is a bit more advanced in which kind of props it takes in because you have an array of guesses and answers. but it's still the same thing. So this is a story that's empty. There's nothing. We can also have one where we have pre-written, I guess, audio, or maybe we're even mid-game. And similarly to above, I can change the current guess. I can maybe even zoom a little. Oh, then you can't see the grid. Well, imagine you could see the grid. And then we can type in, and then you can see the grid above has the guess. So that's fun. Let's look at what I've done to build this. So this is the grid stories file, similar to a test file, but for stories. We start out with the meta. I point to the grid component. We set up a few default arcs and then some niceness to make it look good. We also have this render property here, which basically tells Storybook this is the default thing you want to render. And template here is pointing to a snippet, because you can use snippets in your stories. So we're basically telling Storybook or Svelte, render this snippet. And I'm just using this snippet here to inject some styles, and then to put the grid component into the rendered stuff. And then we use this snippet throughout each story. And you can see here we're just changing the arcs for each story. We're doing nothing else special. And if I were to change any of these, they would reflect here. We can try and see what happens. So if I do guess on train and press Save, we'd now have train as the story. This is fun. Oh. So this isn as fun because you can interact with this This is just a grid I can type anything in the I can't play the game because it's just a grid. And that's because the Swirdle demo, the interactiveness is implemented in a SvelteKit page, and then it has a form, and this form, it takes in the inputs, and then it submits form to the SvelteKit server, and then it gets the answer back, was it right or wrong, right? And this is not the page, this is just the grid. But SvelteKit pages are just components. They are superpower components because they can take in cool props that pass, that SvelteKit passes in. You can import stuff in SvelteKit, but they are still just Svelte components. So we can write stories for our pages. I've done that up here. And so the Swerdle page is what you're are seeing here. Now we have the full game that we can actually interact with. So now we can guess on stuff, store, it's very close. Maybe it's this. No, also pretty close. Maybe it's story. And we can keep playing. And now we actually have interactivity, because we are writing stories for the page of Subkit. We can also still pass in some props to begin with and to keep playing with. There's nothing wrong with that. We can even say that we've won or that we've lost. So now we have an interactive story that we can do stuff with. But it's still a bit cheating, right? And if we go to the way they're defined, is that I'm not going to go into much detail because I'm doing some stuff here to mark out the server of SvelteKit because Storybook does not have the server. So everything that runs here runs on the client. And so we're basically intercepting the submit and then doing all of the things that the server would do. We're just doing that directly on the client instead. There are a few reasons for that that I'm not going to go into in the interest of time. But essentially, we are rendering the page, And then we have a few stories. But as I said, this is cheating because we're still passing in props. We not interacting with it And I can interact with it manually but if it manual it not a test That QA That not what we here for So with Storybook we have a concept of a play function A play function allows you to write interactions to your stories. And so if you go to the typed guesses story, maybe you didn't see it, but I'm going to replay it. It starts out empty, and then it interacts automatically. So it uses the keyboard to type in the guesses, and we win every time. This is pretty fun. And you can even see the interactions. So there's an interactions add-on, which tells us all of the steps that it did that I've defined. I'll show that later. Essentially, it types in books, and then press Enter, then types in props, and then press Enter. And that's fun. But not only can you see the steps, you can actually scrub through them. So if I press this step, it's going to stop at this step. This is great for debugging your test. Maybe something went wrong. It wasn't supposed to do this. And then you can say, oh, please stop here. And then you can inspect the DOM. You can do like inspect element, whatever, because this is just DOM. Oh, it's because the letter was wrong, whatever. You can go through each step. So now it presses enter. So it's submitted. And then it types again. You go through and so on and so forth. You can even interact with it in the middle of the test. So I can do stuff here that would, of course, break the test because it doesn't expect that. And so that is the interactions. At the end of the play function, I have an assertion where I am expecting the restart button, which is this one button, to be in the document. And so now we not only have interactions, we also have assertions. I also have a clicked guesses story, which does the same thing, except that it uses the on-screen keyboard. So if we go here and we scrub through, you can see that it clicks with the mouse on the keyboard now because they turn red. But this story is failing. And why is it failing? Let's go through to the assertion. It expected to find game over, but we actually won. So we were supposed to lose here And if we look at the source for this we will see what going on So in this play function the API for this is similar or it exactly the testing library API. So if you've used testing library before, you have these expect to be in document or get by role, find by query, whatever. That's what you use here. So what I'm doing is that I define a few guesses for each guess, get the phrase letter in the guess, click the keyboard, the on-screen keyboard, and then at the very end of the guess, click enter. That's basically what it does. And then we expect this to be here, but it's not because we won. So if I change this to something wrong, we'll now see that it passes because it did find the game over. So now we have rendering the components, we have interacting with the component, and then we have asserting on whatever. I haven't done this here, but you could put assertions anywhere you want in the middle. This is sort of what makes up a component test. So in here, I'm actually writing a component test where we have arrange, act and assert, if you know about that paradigm. But we still have to manually visit the story to see it play out and to see it fail. That's not you can't. I can't do anything with that. I'm not going to manually visit the stories. And that's why we've built the VTest add-on that we are releasing very soon. So you haven't noticed, maybe, especially not in the back, but in the bottom left side of my screen, there is this run tests module. We call it the testing module. I hope you can see it a bit better now. When I expand it, we have an ability to run component tests. There's also a watch mode that does whatever Dominic just told you about. And if we press play, it will spin up the test in the background. It will run all stories, and it will test them. And it will say, I ran 62 tests. And there was one failing, one interaction test failing. 62 is the number of stories that we have written here. And the one that's failing is this click guesses one. I haven't written play functions or interactions for all of my stories, maybe a handful of them. So 62.

 could be misleading. What we call that is we call them render stories, which are stories that just have render function in them. What they test is that you can render your component without throwing an error. So it's not as useful as if you had assertions, but it's more than nothing. And so now all of a sudden, we can run tests across all the stories. Not only can we run these interaction tests, but if you notice, there's actually also an accessibility checkbox here. And that's because Storybook has an accessibility add-on as well. So if you open the accessibility add-on panel here, we can see that we have one violation, eight passes, and one inconclusive. So the violation is, let me get this up again, we should use proper heading order and don't skip heading levels. And then it tells us the element that has the violation is the row one element. And I know for a fact that that's in the row component. So when I go to that, I can see, oh, the row heading, which is not visible, it's hidden, is h3, and it should actually be h2, because otherwise we would be skipping h2, which is not good for accessibility. I'm gonna change this to h2. I'm gonna rerun my accessibility test. Now we have violations And so now we get accessibility tests even for render stories and they will show up So let's get the error back, and let's enable accessibility and do another run. What you'll see now is that we get a lot of warnings in the sidebar. By default, accessibility violations are warnings, but you can configure that to be errors or nothing. And this allows you to gradually fix your accessibility issues without blocking everything. Cool! We have accessibility. Everything is in the UI, but that's still not in the CLI. So, what goes on behind the scenes is that we have a vTest plugin that we are setting up for you when you add the add-on. And the VTest plugin will convert or it will transform all your stories, the ones you're seeing here, to be VTest tests. So behind the scenes, they become like it, describe, whatever. And VTest just thinks these are regular tests. The config is very small. You pass in this plugin and then VTest will just see all these stories as tests. That means that I can run vTest. I'm passing in the Storybook project because we added it as a workspace, but you could run all of them. And then it will go through each story It will do the exact same thing as I showed in the UI And we have one failing because we still have the click guess is failing There a lot of DOM stuff in there But it says, I expected game over. So now you can run all of this in your CLI as well. This is powered by VTES browser mode because we want it to be as close as possible to what you're experiencing in the browser. And you can run this in your CI environment or whatever you want. This integrates with your unit test as well. And everything that Dominic showed you regarding VTest Browser Mode works here as well. Okay. I believe that was the demo. To recap, write stories with Svelte, run them from the UI or run it with VTest, which is basically just what the UI does. You get accessibility testing built in. You get code coverage. I didn't show that today. And all of this is powered by Storybook, Vtest and Axe. We use Axe for the accessibility testing, if you know that. And of course, a play right behind the scenes. All of this is coming in Storybook 9, which I can announce today. Storybook 9 is going to be released on May 19. So you look first to know. Thank you. And Storybook 9 has a huge focus on the testing part that I just showed you, but we've also done a lot of other stuff especially on the bundle size So this is the dependency graph of Storybook 8 versus the one we have for Storybook 9 We done a lot of work to slim down stuff get stuff out with the help from the e-18e community. They've helped us a lot with knowledge and with inspiration and also contributions. So we're very thankful for the e-18e community. Not only is the dependencies fewer, but we also have a bundle size that's almost cut in half. And we're really happy about that. We're not done yet. We can go even lower. It'll take some time. We'll get there. A special shout out to these guys. All of you are great Storybook users that give great feedback on all of the things that we are building now. You are great partners in helping us doing the integration, but also giving feedback on, oh, I want the syntax to do this instead. And it's just We just love working with you. And the way that you give us knowledge on, oh, I used Storybook over here and it didn't really work. Okay, we'll fix that. So thank you to all of you that are here and, of course, everyone here. The code I showed today is available on the Svelte Summit testing repo that Dominic also has. We have docs for Svelte, which have also just been completely revamped. And just thank you for listening. Thank you.