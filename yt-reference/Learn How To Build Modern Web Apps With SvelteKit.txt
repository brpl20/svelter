 Hey friends, I hope you're excited about learning Svelkit. If you don't know, Svelkit is a Swiss army knife of web frameworks for building resilient apps that run anywhere where JavaScript runs. This is a compilation of the Svelkit series I made, and we're going to learn a lot more than Svelkit, like learning about web fundamentals which is transferable, knowledge you can use anywhere. So in the first part we're going to learn what Svelkit is, which is going to be a really comprehensive introduction, so what is Svelkit, what problems does Svelkit solve, and etc. So I really want to give you that mental model to understand what you're using. Then you're going to learn how to set up Svelkit from scratch to understand how it works. I want to give you confidence to understand how Svelkit works, so you're going to have more confidence when you're working on your app. Then you're going to learn everything about Svelkit routing, which is pages, layout, nested route, which is really powerful in Svelkit. Then you're going to learn about Svelkit API routes and server-side rendering pages, so how do you get data to your pages, data fetching, and etc. In the next part you're going to learn everything you should know about working with forms in SvelteKit, because you can't do anything without forms, and Svelte makes it super easy to work with forms including progressive enhancement. And to be honest, just by watching these five parts is enough to get started, so you can start making a to-do app, because that's really great to use everything you learned so far, because it involves creating, greeting, updating, and deleting something. But then if you want to learn about more advanced things, you can learn about advanced layouts in SvelteKit, You can learn then about SvelteKit hooks, which is SvelteKit middleware. And then of course if you want to deploy your application, you can learn how to do so at no cost using Vercel, Supabase, Prisma and PostgreSQL. The only prerequisite for this course is that you know some basic JavaScript. And if you want to learn Svelte, I have an entire series on learning Svelte you can watch first. And this is going to teach you Svelte from JavaScript, where I'm going to show you a JavaScript example and then I'm going to show you the equivalent in Svelte. So if you want to support me, you can like and subscribe, or you can become a patron if you want, starting low as $1 amount. And of course, if you need help or have questions, join the Discord and you can get help that way. And I also want to say that the best way to learn is to get your hands dirty. So don't just passively consume content, challenge your mental model, try it out. That's the best way to learn. Alright, but enough talking. Let's get started. Swellkid is the Swiss army knife of JavaScript frameworks. SwellKit is basically a meta framework built on top of Swell for building rich web apps. But it easier to honestly think of it as a backend framework that uses Swellt as the component framework First let have a look at the SvelteKit landing page So it fast fun and flexible SvelteKit is powered by Vite, and speed is baked into every crevice. It's fast setup, fast development, fast builds because it has live reload. So if we can see, here is Vite. SvelteKit uses Vite for the server and server-side rendering, hot module replacement, so when you make a change to your CSS, or JavaScript is going to update immediately in your browser. SwellKit is fun. No more wasted days figuring out bundler configurations, routing, server-side rendering, CSP, TypeScript, deployment settings, and all other boring stuff. Code with joy. SwellKit is also flexible. Most JavaScript frameworks force you into something like static site generation or being a spa or server-side rendering, but you can do everything with SvelteKit. You can have a single page application, a multi-page application, server-side rendering, static-side generation in a single app. And I'm going to show you more about that later. And if you don't trust me, the best quote is from Scott Olinsky. What Svelte allows us to do is to write code. How profound is that? But jokes aside, SvelteKit is built on top of Svelte. If you don't know about Svelte, I have an entire series where I teach you Svelte through JavaScript if you're interested in that. And if you already didn't know, Svelte is a UI framework that uses a compiler to let you write breathtakingly concise components that do minimal work in the browser. The best thing about Svelte is that you can use the languages you already know, HTML, CSS, and JavaScript. It's a love letter to web development. Another amazing thing about SvelteKit is that you can deploy it anywhere. You can pre-render your sites, you can run it on a Node server, you can deploy it to Vercel, Netlify, Dino if you want, thanks to SvelteKit adapters. SwellKit is basically a machine that turns a request into a response. So you're not tied to something like just Node.js and you can deploy it anywhere. If you're familiar with other JavaScript frameworks, SwellKit is to swelth what Next.js or Remix is to react. But philosophically, SwellKit is closer to Remix where it encourages you to use the web platform and progressive enhancement to build more resilient sites. This might not mean anything to you right now, but don't worry, we're going to go through everything. I going to show you examples what makes SvelteKit great so don worry if you lost or you don understand everything because you going to dive deep into those things later SwellKit blurs the line between the frontend and the backend It makes the integration between them seamless since it has control over both which means you can start working on your project and not suffer from decision fatigue since it's opinionated in the right way. You can use SwellKit for example to create an API just like you can with Express, which you can use inside your application but you can also expose it to the the world and if you want to do that you need to set up course and all that fun stuff but let me just quickly show you what I mean. So here I have a simple plus server ts file and this really isn't important right now but I just want to show you how simple it is to make an endpoint. So for example here I want to fetch a list of posts from a database so we can pretend that I'm making here a database call and I'm going to return posts with just an array of objects and then I'm going to use this JSON helper from SwellKit to return the post so I don't have to write my own response headers and etc. And if we look at the sidebar, so let me just go here and I can reveal in Explorer View. So you can see I created an API folder, which is not convention. You can name this wherever you want, like banana, etc. So I created API post and I created this server file. And just like that, I can go to localhost 5173 slash API, the folder I created, slash post, and that's it. Now I can use this API inside my app or expose it to the world. And that's how simple it is in SwellKit. This is cool and everything, but where SwellKit shines is when it comes to data fetching for your pages because of how seamless the integration is between the backend and the frontend. And it gives you type safety, so you don't even need something like TRPC. And let me show you what I mean. So here I have a SvelteKit project and I'm just going to fetch a post from the database. Again, we're going to pretend that this is some post. So here I have another interesting file, plus page server TS. And this is similar to our own endpoint before, but this is a page endpoint. So this is exclusively responsible for fetching some data from the file system or database for your page. So you can see here we have this load function and that's really not important for now. So you can again pretend that you're fetching something from the database. we're going to get the post, the slug, the contents. You can pretend this is some content management system. And it's simple as just returning the data from the load function. And now in our page where I have here data we get type safety for free because Svelte generates the types behind the scenes for us So if I hover over data we can see ah here is data here is the post etc And now when you do whatever in your template or here, you can see you get great auto-completion. But don't worry if you're scared of TypeScript or don't know TypeScript, you can use JS doc with regular JavaScript so you can also get great types. And let me show you an example of that. If I go to the Sveltee documentation for example I'm just going to zoom out so I can get the entire view and here you have this handy toggle so for example let's look at an example here so here it's importing this type whatever but you're like okay I don't use JavaScript I'm just going to I don't use TypeScript at this I just use JavaScript so you can just toggle that and it's going to give you the JS doc version so you can just paste it over this is how you learn what a type is and you can go on your way. But yeah, I prefer TypeScript, so let me just go back here. And again, now you get the data from the server. How awesome is that and easy? SwellKit has a strong emphasis on convention over configuration. SwellKit sparks joy because it doesn't get in your way, so you can start hacking at your idea and not spend hours configuring things. I mentioned how SwellKit is a VIT plugin, but that's an oversimplification and sounds like a weekend project considering the problem it solves. So here is the big question. Why would you use SvelteKit? What is wrong with Svelte? There's nothing wrong with Svelte. Svelte is a separate project and you can implement your own routing and etc. There's packages for that so you can do whatever you want and they're always going to be separate projects. So if you're thinking that SvelteKit somehow replaces Svelte, that's false. It's just a recommended way to build Svelte tabs because of all of these things. So what is the problem that SvelteKit solves? Well, SvelteKit does routing for you, so you have file-based routing, it solves server-side rendering, it solves data fetching as we've seen before. The best part, it's zero config, so it configures ESLint, Prettier, TypeScript, testing with Playwright, and VTest out of the box. So basically, when you scaffold AsphaltKey project, you get questions in the CLI, and you can pick whatever you want from these options, and it's going to be configured for you. But of course, zero configuration doesn't mean no configuration, so you can configure it however you want. This is a more spooky sounding one. What does code splitting mean? Well, basically SwellKit is smart enough that it knows the data for each page, so it knows what to load in terms of CSS and JavaScript for every page. So an awesome thing in SwellKit is you can get preloading, so when you hover over

 link, it's already going to start downloading data for the next page, and those precious milliseconds are going to be a huge gain in terms of perceived performance. SwellKit also handles environment variables for you. And this just goes beyond just being able to import environment variables because it's going to save you when you, for example, try to import some secret environment variables on the client. It's going to be like, hey, you can do that, and that's going to be the end of the story. So SwellKit is going to try its best to set you up for success. And also, unlike other frameworks, SwellKit has configurable rendering. You can have server-side rendering, static-side generation, and client-side rendering in the same application. So for example, your marketing pages can be statically generated, your app can use server-side rendering, and you can even disable server-side rendering and disable client-side navigation if you want. Basically, once your first page loads, it uses server-side rendering because server-side rendering is faster and better for SEO. So if that's something you need, you can just enable it and you don't have to just make a single choice. And also the best part of it, it configures deployment for you so you don't have to think about that. You don't have to think about optimize bundle sizes and etc. It just works. SwellKit is the best of both worlds. It's server-side rendering with client-side navigation. What does that mean? So here in the example where we fetched our post, in a regular single page application this would just be some JavaScript shell and we really wouldn't have the HTML in our source which would be bad for SEO. While the Google search engine can parse JavaScript, it shouldn't be relied upon because it takes compute, so you really can't rely on that for SEO. So if I go for example here and say page source, we can see our HTML is right here. So this is really great for SEO. And we can see some interesting things here. So what is this? basically this is responsible for hydration, but it also loads the client-side router. And what does that really mean? Basically, the first time you load a page in SwellKit, it's going to server-side render it, so it's going to give you the data from the server, and then after that it basically becomes a single-page application, so you retain that awesome user experience using a single-page application. This wasn't using client-side routing. when we would navigate from link to link here, our page here with Refresher, but that's not the case with SwellKit because the router kicks in. So for example if I go to App you going to see everything is going to stay smooth and there is no page reload And as I said most frameworks make you decide between server rendering or pre everything but SvelteKit lets you choose what method you want on a per-page basis. I also have a handy diagram here to show you how a spa works, basically, if you're used to that. So basically, when you're using a spa, you make a round trip because first, all your JavaScript has to load before you can even request data from the server. So you have the server, it takes a request index.html and this downloads some shell where it just uses JavaScript to populate content and change things on the page. So then you have a get request for the API post and then you can get your post and show them on the page. But with server-side rendering and the benefit of this is that you do this all in one take. So before you even show the page, you can just say get API post, and then you just get the data in the index.html or whatever. And then you might be asking, but okay, what if this takes some time to get the data? And the answer is then you have a problem with your infrastructure or caching, which is great because it's more easily solvable than just using a spa and relying on JavaScript. So to repeat, SwellKit apps are server-side rendered by default for speed and SEO, so search engine optimization, but once the page is loaded, the client-side router kicks in, which makes your app feel like a spa to avoid reloading the page between page navigation. So let me just quickly show you how awesome it is to be able to set what rendering mode you want on a per-page basis, or even for the entire site. So here in my project, in the root layout, I have this plus layout TS file, and if you want it, you can pre-render the entire page, so you can set here pre-render true, and then you can change this for individual pages, so this would override it, but I'm going to comment this out and I'm going to show you, for example, if I go to the about, for example, I want to pre-render this or whatever, and here I have this about folder, nothing special, here is the file with some styles and HTML. So I can go here and then I can say pre-render is true, so it's going to pre-render it, and then I can even disable the client-side router so I get zero JavaScript. And this isn't going to work in development, so you need to build your page. So I'm going to say pnpm run build and I'm going to run preview. This is going to take a second and let me just quickly show you how awesome this is. For example, here is a special generated SwellKit folder, so you can see here in the output, pre you can go to pages here and here is the about So this is just going to compute and advance the data you need for the page And as you can see there is no JavaScript here So for example I in the build so you can just go to 4173 and then let's just view source, and you're going to see it's the same thing. So there is really no JavaScript here, which is really awesome if that's what you want. So right now, even the router from the SwellKit isn't loaded, So when we navigate to home, our page is going to do a hard refresh because the client side router hasn't kicked in yet. So for example, if we go from about now to home, you can see how it does a hard refresh. But for example, now, since we're on home, if we go back to about, it's still going to be pre-rendered everything, but now it's going to use the client side routing. So you can see how awesome this is. So here's another example where this might be useful. So if I go to app here, let me just go to the sidebar. I'm just going to close this. And here is my app. So here, let me just uncomment. So here we're fetching. Actually, let me just open the development. VPN run dev. Go back to that. And of course, the URL is different. Say 5173. So here you see internal error. And why is that? Remember how I said that your components run on the server and client? So for example, if we continue using the client router, I go to home, back to app is going to work, because this is just in the context of the browser. But if I refresh the page, so someone visits your page, for example, and this is going to run on the server. And what do you do now? There's a couple of things you can do, but again, we can just change the rendering mode. So here in our app, we can go to page TS, and we can just disable server-side rendering. and how awesome is this and we did on a per page basis this is just amazing to me and completely mind-blowing since most javascript frameworks force you into using server-side rendering or pre-rendering everything so it uses the web platform but what does that really mean one thing i love the most about swell for example links you don't have some weird wrapper for links because it's just regular html as you can see here in the navigation i didn't have to import some weird component or whatever else I just wrote regular HTML. But what does it really mean to use the web platform? Let's have an example if we go to the login. So let see how simple it is working with forms in SvelteKit Again if I go here to the example there is no weird component I had to import etc I just using the form And this is the beauty of SwellKit because you going to spend more time on MDN learning about the web platform than some weird abstraction that's only useful inside SwellKit. And SwellKit uses the web platform, meaning you're not learning some framework-specific abstraction, but using web standards like the Fetch API, the Request and Response Object headers, form data, cookies, and etc. So you're not going to read the Svelte docs on some of these things, you're going to read about and learn about the Fetch API, which is transferable knowledge. You might have forgotten how forms work if you use traditional JavaScript frameworks over the years, right? So here I have this interesting action, which really isn't some weird SvelteKit thing, it's just a URL, right? And this action points to something awesome, this plus page server TS, which explores these actions. actions, and actions basically you can just define a method you want to run when you run something from the form. And here on this object you can get access to the request, cookies, you can do whatever. So question for example, how do you get data from the form? Well of course using the web platform and using the form data. So you can go to MDN and you can see, okay, new form data, and you just pass the form and you get the form data. So here on this page I can for example say test, one, two, three, four, and before I submit let me just open the terminal. Remember, this is going to run on the server. So here is where you can set all your cookies, and CellKit also exposes a nice API for the cookies, so you don't have to import your package and etc. So here's where we can get the credentials. We can just say data get, because remember, this is just the web API for how to get data from a form. You can get the name, password, and then you're going to console log it out to do whatever you want. So now when I say login, you're going to see name, test, and password 1234. And that's how easy it is to work with forms in SwellKit. SwellKit apps are more resilient because they use progressive enhancement. Your SwellKit apps works before JavaScript if you haven't noticed. In this example, we're not even using JavaScript. Remember how we typed in test1234 and pay attention to the browser because this is going to reload the default form behavior, right? You can use progressive enhancement in SvelteKit if you want to progressively enhance the user experience. And this is really simple. So here you can enable this Svelte action enhance. And you can just go here. You can say use enhance. And basically when JavaScript is available on the page, it's going to use it. So instead of disabling the default form behavior,

 and implementing what the browser does yourself, SwellKit really makes it simple to use the web platform and progressively enhance the user experience when JavaScript is available on the page. So if you're curious, this basically does the equivalent of if you weren't using this, you would be doing something like on submit, and then you would be like handle submit, and then you would have to go here in your JavaScript function handle submit, you would get the event, and then you have to say prevent default and then you would have to fetch etc but notice there is not a single fetch here because SwellKit does all of it for you let me just remove this and let me just show you that this is true it's going to remove this so we just had to use enhance let me just save it I'm going to open the terminal again and now when I go here I'm going to say test 1, 2, 3, 4 and notice how we're not going to get a refresh here we're just going to say login and now we're using JavaScript. And how great is this? We talked about this briefly, but SwellKit runs where JavaScript runs. SwellKit by default uses the Node.js adapter, but it can run anywhere where JavaScript can run requiring zero configuration thanks to adapters. You can even write your own adapter, but one of the supported environments are Cloudflare pages, Netlify, Vercel, Node.js, where you can even pre-render your entire page using the static adapter. And there's even community adapters for things like Dino and etc. But also keep in mind, If you're going to run CellKit in an environment that is not Node.js and you're trying to use Node.js file system API, for example, that's not going to work. So here we can see a documentation here, the adapter. So supported environments, Cloudflare pages, Netlify, Vercel. And this is really simple as that. So for example, if you want to deploy to Vercel, you just point it to your GitHub repository and that's it, basically. It's going to work. Or you can create a Node version. And there's many other things you can do. You can export your own custom server using WebSockets and etc. if you need that. So here is the adapter static. So you have community adapters. If you go here, there's Dino and other ones like Bun, I think. So yeah, basically this is very interesting. SvelteKit makes the deployment story really easy. Let me also briefly mention that SvelteKit is also great for making component libraries. So you can package and publish your packages on NPM, and SvelteKit helps you create and publish packages if you're working on component libraries using Svelte package So a component library is similar to a SvelteKit app but the root is going to be inside source slip And when you run Svelte package it going to do everything for you and you can publish it directly to NPM So you can see here is the packaging. And if you're a library author or maintainer, SvelteKit also makes this process really simple. All right, friends. So I hope you're excited about SvelteKit and want to learn more. And remember, SvelteKit is made for everyone. SvelteKit is an open source project governed by Rich Harris and a team of core contributors. The development is funded by the Open Collective and Vercel, but it's not governed by a corporation whose goals are ambitious and unclear. The future of Svelkit is bright and I hope you give it a try, but be warned, in case you do, you might not want to use anything else, and side effects include a permanent grin on your face. I don't know about you, but when I'm learning something, I want at least a high level understanding of what makes it work. Understanding what makes SwellKit work is going to give you more confidence using it as you get more familiar with it, like getting to know a friend. And there's a lot of people that are newer to development and don't even know about these files and they're going to be the same across most JavaScript projects. I'm going to show you how to set up SwellKit yourself without a CLI, but don't worry, we're going to use off-the-shelf parts instead of doing SwellKit from scratch. After that I'm going to walk you through the SvelteKit CLI and explain every file so you at least understand the purpose of it. And if you're one of those weird people that want to understand how SvelteKit works under the hood, well, I'm that weird type of person that made learn how SvelteKit works that you can read or watch. So you can go here, you can get the popcorn, or you can read it or watch it. Alright, so let's get started. I'm just going to create a new tab so we don't get distracted. And I'm going to open a new terminal. and to be honest with you it's been a while since i actually created a project from scratch because i'm so used to using some cli but basically in the post i use npm but honestly if you want to save your hard drive please get set up pnpm because it's going to reuse packages for your project so it doesn't destroy your hard drive and i really love it so i'm going to use pnpm here but the commands almost map one to one with npm but that's up to you so i can say pnpm init and basically it's going to create this JSON file, so let me just close the terminal, and here in the sidebar here is a package JSON, and I just like to remove most of this junk. We're going to add scripts ourselves. Basically we could have created this file by hand, but basically that's how we do it. Save this. So let me just open the terminal and we going to need some packages So what is the minimum required amount of packages for SvelteKit And it surprisingly a low amount So there four packages we need to install I think So let's go. We can say PNPMI. We need to install them as a development dependencies. So you can already see. Here is VIT. Then we need SvelteKit itself. SvelteKit is just a VIT plugin, so that's why we need VIT. And then we're also optionally going to install the adapter and Svelte for the component framework. So I'm just going to install it like this, and this should populate our package.json. Give it a second. And you can already see the blazingly fast speed of PNPM. And this is just because I saved this file, but if I auto-form it, I'm just going to prettify everything. So let me just close the terminal so we don't get distracted. And at the top, I'm going to declare that we're going to use a type module. And you might see this in CellKit projects. we're definitely going to see it because Selkid uses native JavaScript or ECMAScript modules. And what it basically means, if I go here, so that's basically this syntax. So you can say import package from package. And in the past, this wasn't supported by the browser, so you needed a bundler to transpile this so it understands it using the old common JS or require syntax. So if you're familiar, maybe something like this, require, and then you do this. And basically, this is using the native JavaScript modules as part of the spec, and that's something that browsers understand. Okay, I'm just going to close this, and basically, I'm just going to add a type here, and I'm going to say module. Here you can see it offers us common JS or module. Another thing worth mentioning is if you're using native JavaScript modules, and you want to use something that's common JS, you can just suffix it with the .cjs type in your project, and it's going to work. So that's great, but we're going to need some scripts to run the development mode to be able to build the project in Preview. And basically, scripts are just a way to run some script from your file system, usually from the Node Modules folder. So I can go here, I can just say scripts, and then we're going to add one for development. And then we can just say Vite Dev. We can add one for building the project. Vite Build. And then let's add one for preview so we can say VIT Preview now let me just save and it's going to auto format by the way If you want auto formatting in your editor You can go to your VS code settings and enable format on save So if you using prettier is going to do everything for you basically Or you can look it up how to do it for the editor you using And basically that it we just need to do a couple of more things So SwellKit requires a Vite config at the root of the project. In the previous part I talked about how SwellKit is a Vite plugin and I'm going to show you that. So let me just close this file I'm to open the sidebar. I'm going to create a new file which is going to be named with config.js. Let's just keep it simple. I'm going to close the sidebar. So let me just import the swellkit plugin that's exposed from swell.js kit with. So here we can also include some jsdoc types. we can say type import wheat and we can just say here user config so we just get auto completion since we're not using typescript for this file so here is the magic sauce so we can just say const config now we specify wheat plugins and what wheat plugin we want to use swell kit of course and that's basically it this is the beating heart of swell kit and we just need to export the export-default-config, let's just save it, and that's basically it. You can also optionally include a Svelte config file so you can get preprocessing and adapter to output your project. And I'm going to explain what it means in a second, so let's do that because we can. So we can say Svelte config.js, and now I'm going to import the adapter reinstall so we can say from Svelte.js adapter auto. And now we're going to import the preprocessor. We can say Vite preprocess, and it already autocompleted this for me, which is awesome. So let me just include the JS doc here. We can say type import. It's going to come from SwellJS kit. And from here, we just want the config. And now we can also give it a config like we did for Vite. So we can say cons config. So we're going to declare a preprocessor. So you already see how we get great autocompletion. And then we're going to say Vite preprocess, which we imported. And now options for SwellKit. We can say kit. We can specify an adapter. And we can just use the adapter. And also don't forget to export your config. Export default config. Save it. And that's it. So let me explain what these things are.

 A preprocessor transforms your .svelte file before passing it to the compiler. In this case, Vite preprocess handles TypeScript, PostCSS, and SCSS or SAS as some of the language flavors, which you can read more about in the Svelte documentation. So if you go here to integrations, it tells you the same thing I did right now for preprocessors. As you can see here in the Vite preprocess section, Vite plugin Svelte offers a Vite preprocess feature which utilizes Vite for preprocessing. And you also have some other fun preprocessor you can use or whatever. And basically this is a really fascinating thing. You can, for example, make preprocessors that maybe turn your .svelte files into slidex or whatever. That's actually a fun little project I worked on previously, and I might make a video on that in the future. I talked about it previously, but an adapter is used to adapt your SvelteKit app to the deployment target. You can write your own adapter, but the supported adapters include Cloudflare pages. You can go here, you can host your SwellKit app, no problem, with zero configuration. Netlify, awesome host, Vercel, awesome host. You can also do Node.js, you can use a static adapter if your entire app is a static site. You can even use community adapters to deploy to target platforms like Dino, for example. But alright, we're not done yet. So let me just go to the new tab so it's not distracting. I'm going to close this. So now Swellkid expects a HTML page template with placeholders that Swellkid uses and replaces for your pages. So inside of here I'm going to create a new file which is a nifty trick. So I'm going to say source in VS Code and then I'm going to say app.html. That's going to create a folder source with a file app.html inside. Let me just close the sidebar briefly. And now I'm going to commit a crime and write awful markup. but thanks to browsers understanding and being able to build proper HTML pages, this is going to work fine. So you can just say head, and now we can use SwellKit.head. So I can close it like this. And then we're also going to need a body. So we're also going to say SwellKit.body. And let me complete this. I'm going to save this. And this is almost it, but we need to do one more thing, and that's adding a route that's going to be the first page someone sees when they visit the site. So I'm going to open the sidebar again. Inside of source I going to again do new file going to create a folder routes and I going to create a special file plus page svelte so you can see here is the route folders and the file we created so i just going to use a h1 tag and i'm going to say hello i'm going to open the terminal now clear everything so now we can run development mode and everything should work so we can say pnpm run dev and awesome our port started on localhost 5173 and if you're curious why is it using this weird number and apparently the Vite developers are comedians because you might have noticed it but 5173 is let's speak for Vite or it can even spell outside so it's really hilarious in my opinion but basically that explains it and it's really interesting but okay enough talking let's just go to that port So you can say localhost 5173 and everything should work. And it does. Awesome. But we also get some one error, which is the favicon. So you can also include a static folder here. You can include the favicon, but I'm not going to do that. So let me just close the terminal. And one thing worth talking about is also that SvelteKit creates a special .svelte-kit folder that has all your generated files as you work on your project. So you can ignore or delete this folder because it's going to regenerate each time you run dev or build. And this is how, for example, the magic sauce works for generating types for your pages, which you can find in this folder. And this is usually going to be the output of your project. And you're going to see a types folder here. You can see the type generated right here. So basically, that's it for SwellKit from scratch. And in the next section, I'm going to show you how to use the SwellKit CLI, where I'm going to explain every file and folder. All right, so I deleted everything so we can start fresh, and here we're going to use the recommended way of scaffolding a SwellKit project, which is using the SwellKit CLI. So I'm going to open the terminal, and if you're following these steps along, and if you're new to this, you're going to need Node.js at least, so you can run this type of commands, and you can also get PNPM, or you can use NPM if you prefer. So how do we scaffold a Swell project? Well, it's really simple. So I can just say PNPM create in my case, and I can just say PNPM create Swellt, And this is going to start an installation wizard, so it's going to ask you where should we create your project, I just want to create it in the same folder, so I'm just going to press dot or leave it blank, which I'm going to do. And now it asks you what you want to do so you can get the demo app which has a lot of examples you can create a skeleton project that empty barely has anything And then you can create a project if you working on a library But I going to pick the skeleton project I'm going to pick TypeScript, but if you want, you can use JavaScript. So I'm going to pick the TypeScript syntax. We really want ESLint. We really want Prettier. And also going to say yes to everything, basically, so I can explain it. We want yes for Playwright. Vtest, let's just say yes. And then when this is all done, you have to install the packages, so you can say pnpmi, and that should take a second. Great, so now I'm going to clear the terminal, and now you can run your development server, and you should see that everything works fine. So we can go here, same as before, we can say localhost 5173, and this is basically it. I like how the bare bones project doesn't have a lot of things, so you have to delete a bunch of files and etc. But in this case, I'm just going to close the terminal, and let me just talk about first, about the things we selected. So first one was ESLint, right? And if you're not familiar, ESLint is like a spell checker for your code that gives you useful warnings in your editor from checking your code for problems like accessibility. So let me just see if I can quickly show this. If I go to routes, page, and for example, I'm just going to delete everything. Let me just do something that it doesn't like. So we can say whatever. And you can see here we get some warning and we can hover over it. So ESLint is saying accessibility pound is not a valid ref attribute. And this is how Svelke really leads you to the right way with accessibility and other useful warnings. But in this case, I can just delete this and close it. So whatever. And you're going to discover that ESLint and TypeScript make a great duo, ensuring you don't do something goofy. Next, let's talk about Prettier. So Prettier is an opinionated code formatter. You might find it does some things you don't like, but it's a great trade-off considering you don't have to think about formatting your code. and it's going to be consistent for everyone else working on the project. I also recommend you enable format and save, which you can look up how to do for your editor. But again, let me just open this file, so you can say h1, for example, hello world, and I can just press save, and this is going to get auto-formatted, and now you don't have to ever think about how to format your code and etc. Because Prettier just does it for you. Let me close this file, and let's talk about Playwright, which is interesting. So Playwright is used for end-to-end testing. And end testing might be like what is that so basically you can test how your user might use the site using a real browser And you can check for example if some content is showing or test your registration or checkout process Say for example, on JoyofCode, I have posts and I just want to test if those posts are visible on the page. So I can basically just click around and see if it works. And next, let's talk about another testing tool, which is VTest, which is a blazing fast unit testing framework. So VTest, as it says, is used for unit testing. And what does that mean? That means you're testing one unit of your code. So for example, you can use Playwright to test your site using a real browser and see if your content works like I gave you in that example, but you would use vTest to test the input and output of the function responsible for sorting the content in some order, right? So that's basically what a unit test is. And I also want to show you that in the examples. So for example, here is the test we talked about Playwright. So basically this is just going to open a browser in the background, which is going to run headless, but you can also specify so you can see the browser and what's going on on the page, and this just checks if index page has accepted h1, so that's basically awesome. And here is an example I believe in source index test test, here is an example using vtest, so this is a unit test, you can see it checks if sum works, so if the function sums up 1 and 2 to equal 3. But alright, let's look at the beautiful tree we inherited from scaffolding the SvelteKit project. Let me just close this, and I'm just going to close all these tabs so they're not distracting, and let me just close this too. So the first folder is the one created by SvelteKit, which is .svelteKit. We already talked about this, but it's a folder generated by SvelteKit, and it's safe to remove, so we can just ignore this for now. And if you're not familiar with the Node modules folder, here's basically where all your packages go, so here lives SvelteKit, Vite, and etc., your binaries. If you run something like pnpx, this is going to get stored here in your binaries, so you can run it without having to install the package globally, if you've ever done that. Let me close the Node modules and let's look at something more interesting, which is the source folder. So this is the heart of your project. So here we have routes, which SwellKit knows to map to a page. So whatever you create here, you're going to see in the browser. There's also going to be another folder here, which you're going to use to store shared components, which is going to be lib. So you can create that if you want, and this is also aliased in SwellKit as a special import, so you don't have to do that convoluted trailing where you do dot dot and then slash etc. You can just say $lib, and it's going to know.

 the path to it. And you can also specify your own aliases, so for example, you can have an alias to your styles, alias to your components, and etc. Okay, let me just cancel that out. Here are some files that are specific more to TypeScript, so if you don't use TypeScript, you can just ignore this. But if I open app.dts, this is used to add some type information for some special SvelteKit objects, which we're going to talk about in a later part, so you don't really have to think about this, and I can just close this. We already talked about app.html. It's a template used by SwellKit for your pages. And here, let me just show you. So here it uses the favicon, some meta tags, and this is really interesting. So it also has for you data preloading, which is on hover, so it starts fetching the data on your page in advance. It's SwellKit knows, thanks to code splitting, what the CSS and JavaScript is required for the next page. And here you might see something interesting. Why is this SwellKit body inside of this tag? And this is basically to avoid some problems with extensions that inject themselves into the body. This is just how SwellKit avoids that problem. All right, so we can close this file. And I already showed you the vtest one, so we can skip that. So here is the static folder, and here you would place your images or whatever you have, like favicon. So basically, it's nothing special. Here are your tests. So I already showed you this for Playwright. You can place your test whatever it is because VTest is going to scan your entire project. So you can put your test besides your component or in one folder. That's really up to you. Svelke really has no strict opinions on this. So we talked about ESLint and here is the ESLint config file. And it looks intimidating and you really don't have to care about anything inside here. What you do might want to know is that you can extend this so you can add your rules. You can disable rules and etc. Let me just close this. So I have a gitignore file. If you're not familiar with this, this is basically going to ignore files and folders you specify when you push your project to GitHub. For example, you might not want to leak your environment variables and et cetera, but yeah. Here is another interesting file, .npmrc. So this is a config file for npm, and it has this option here, engine strict true. And basically what this means is that it's going to refuse to install packages that aren't compatible with the version of Node.js you're using. But yeah, that's basically it. So we also have a prettier file here, so you can choose your preferences You can say use tabs For example I prefer not using semicolons so you can go here and you can say semi false and then you can also pick some other options Here are some good defaults in my opinion Another interesting thing is if you go to package.json, if you just go here, so it would be really annoying since you change this to not use semicolons. You have to open every file and press save and format, but instead of doing that, you can go here. you can just run the command to format your entire project, which is right here. So you would just run format and this would run prettier for you. Same for linting, so you can check your projects for errors. You can also run unit test and et cetera. Here are some really useful scripts for you to use. But yeah, let me just close these files. And you already might know about package.json, but basically this is where all your package information is being kept, scripts, and et cetera. And even if you wanted all of these gnarly .files here, which is unavoidable in doing modern JavaScript development, where you can have all of this inside your package JSON if you want, which would be kind of unmaintainable, but that also obviously depends on you. And then we have a Playwright config, which you would learn from reading the documentation because this really has nothing to do with SwellKit. They just really make this setup easy for you to configure Playwright. And that is really fascinating. So I can close this. So you have your lock file here. If you don't know what this is, you can lock your package versions to a specific file. Also, when someone else downloads the project, they're going to get the same version as you have, so that avoids issues. And of course, what we never do when we start a new project or whatever is actually read the readme, which explains almost everything. So this shows you creating the project, how to install the packages, how to start it, and how to build it. But yeah, basically read your readmes, right? So here we already looked at it, but here is the swell config that we did by hand previously, and it's exactly the same, nothing special. so we can also see the vidconfig here which is the same as before it also has some extra things for tests to include some files nothing special so you can just close this and here is the tsconfig file so basically this extends the swellkit typescript configuration file you can also change this however you want you can enable path aliases here it shows you some useful information but that's basically it. If you're newer to development you might be hearing some of these things for the first time but you can ignore most of them to be honest. And there's really a lot of junk in these files and it really can be avoided because that how mostly border web development is done and this is like nothing compared to a real project where you going to have even more files So for deployment you might have a Docker config and etc So that really gets out of hand quick. So there's really not the fault of SvelteKit, but just the general JavaScript ecosystem. So I hope this gave you a better understanding of these configuration files in general because you're going to see them in every JavaScript project, but now you're a certified SvelteKit connoisseur. If you're just starting learning SvelteKit and want to follow along, you're going to need Node.js, and I recommend using VS Code as the editor and using the Svelte VS Code extension. So you're going to go to the Node.js, download it. This is going to get NPM for you if you're new to this, so you're going to be able to install packages. And I also highly encourage you, despite me in the post using NPM because it's standard, I'm personally going to use PNPM. Please get PNPM, save your hard drive, because PNPM lets you reuse packages. So for example, when you start a new project, you're not going to install the same packages all over again, which is really going to destroy your hard drive. And pnpm is way faster because of this, so it just uses links to packages for every project, so it's really super fast, and it's really easy to set up. So I highly encourage you to look into that. So you're going to need VS Code for the editor, but you can use whatever you want. Of course, you're going to need to set up the Svelte syntax highlighting yourself. So you're going to need this extension, Svelte for VS Code. just grab this and you're going to be fine so for example if I press CTRL SHIFT X I'm going to get to my extensions and now I can type in Svelte and I should get the extension so here it is Svelte for VS Code you should install this and you should be good so let me just close this and here I just have a regular SvelteKit project here already know how to do this so you can scaffold this really it's not important what you select because you're going to be mostly talking about routing but I'm going to use TypeScript, but TypeScript is really optional. And if you're afraid of TypeScript, you can just ignore it. So for example, people really think that TypeScript is a spooky thing, but for example, if you just see something like, let's say variable, and you see something with a colon, number, if you're not familiar with TypeScript, you can just basically just ignore the type, remove it, right? And that's going to be valid JavaScript. So let me just close this. Another thing I'm going to set up is some styling, so I don't ruin my eyes. So I'm going to use PicoCSS. is just going to give us some nice default style. So I'm going to go to get started. I really going to use a CDN because I don want to install anything right now I just going to copy this over Control P in your editor your code open app HTML And here before the head ends we just going to copy this over ctrl in your editor code open app and here before the head ends we just going to paste this in and I already started the development server with pnpm run dev, so if I go to localhost here, if I refresh it, it's already updated, so you can see pico is in action here, which has some really nice default styles for us. Another thing you can do is use StackBlitz if you want to follow along and using something like a or whatever, you really don't have access to all of this, you can just go to sveltekit.new. This is just going to open a new Stagblitz project, and this honestly blows my mind because this uses Node.js in the browser, and it feels even faster than your local development. But yeah, I'm just going to set this up. You might have to enable cookies because Stagblitz is some special secret sauce behind the scenes that uses web containers, which is really fascinating, but yeah, you can do that. As you see in Brave, it tells me to enable web containers, So basically, I just have to go here and I can put down the shield or I can enable the cookies. So let me just go here and I'm going to say allow all cookies for this site and it should now work. It's going to restart. But yeah, this is a common problem with Stagglitz when it's embedded for code example in some other sites because it really needs you to access cookies. But basically, this is it. You get a SvelteKit app super fast and that's it. So let's talk about pages in SvelteKit. SwellKit uses file-based routing where routes of your app are defined by the directors in your project. So for example, here is this URL and all of these parts are URL segments. So example.com, this slash is going to map to routes, which has a page.swell file. So this is going to be your home. And then if you want to go, for example, to posts, you have a post directory, which has another plus page.swell file. As you can see, these routes are defined inside a source slash routes folder. each directory inside the routes folder can have one or more files using the plus prefix. To define a page in SwellKit, use a plus page.swell file, which becomes a route that maps to a URL. So let's create a default route. I'm going to open the sidebar here. I'm going to go to the source routes folder. You'll already have a plus page.swell file that comes default when you scaffold the project. I'm going to close the sidebar. So let's just make some navigation. So I can say nav autocomplete. This is just emit in your editor. or you can press tab to complete it. So let me just create a link. This is going to be our home. So I can just say home, and I'm just going to copy it over. And we're going to have posts. So I'm going to say posts here. I'm going to save it, and I'm going to go here. And you can see we already have

 this navigation that's home. It's really important to understand the mental model of what a page is in SwellKit. Because the page component gets rendered twice, once on the server for the initial request and once on the client because of hydration, which is just a fancy word that means adding JavaScript for interactivity to the page after the server returns their HTML document. Before I show you what I'm talking about, let's just give it a h1 so we can just say home page. And I'm just going to add a script here, this is just a quick snippet I have. So we can just add a script, and here we're going to console logout hello, so I'm going to say CL, which is another snippet I have. So we can just say hello. Alright, so now pay attention, I'm going to open the terminal, so Ctrl dot is a shortcut for me, but maybe something else for you, or you can use the menu in VS Code. And I'm also going to open the console here, and let me just adjust it. So now I'm going to save this, and first you're going to notice hello in the console here, which is on the client and you're like maybe thinking, okay, but where it is on the server? And because the client-side router already kicked in, but for example, let's say I'm the user, I'm visiting the page for the first time. So when I refresh, this page is going to run on the server and on the client. So let's see this in action. I'm going to refresh now and see hello on the server inside your terminal and in your browser. I want you to understand what a page is and that it matches your mental model because it's going to save you a lot of trouble in the future. A page itself is just a swell component, which you can see for yourself if you press Ctrl-Shift-I to open the developer tools and navigate to the network tab and look at the response for the page. So here we're already inside developer tools, so we can go to the network tab, and if we scroll up top, we can see if we, let me just clear everything, also make sure you disable cache. So you can see here is the document that server-side rendered from the server. if you go to the preview, here is actually the entire HTML document. But where is our page component? So here is just a lot of junk for development you can ignore. But here at the bottom is somewhere our page, so we can find it quickly. Go here, here it is, somewhere. Let me just scroll to the bottom. So here it is, somewhere. Yeah, so this is it. So basically, this might look weird to you because it doesn't look anything like Svelte. Well, at least the one you know about, because this is what it means that Svelte is a disappearing framework because SvelteKit at the end of the day compiles to JavaScript so it doesn even have to ship some runtime Of course there is some runtime because at the end of the day if you look here Svelte turns your component into a class classPage extends SvelteComponent so this is your component you really don't have to understand this, I just want to show you how this works. And basically here is some magic with hydration and etc. You really don't have to consider yourself about what it's really useful to know about. So remember, a page is just a component in SvelteKit. Let me just close this, and I also want to show you that if you look at the response of the page here, we can actually go to the page source. So here is actually your HTML generated. You can see here is the script that's really responsible for hydration and loading the client-side router, and enables client-side rendering once the page is loaded. Alright, but enough of this. Let me just close this, and I'm also going to close the terminal for now. Here's just complaining about the favicon, which you can ignore. but yeah let me just close the terminal and let's create another route and let me just do one quick thing so I'm going to go to Prettier and I'm going to disable semicolons because I prefer no semicolons so I can just close that and let me just save it and this should auto-format everything and awesome everything works. So I'm going to open the sidebar in our routes I'm going to press new file which is a neat trick in VS Code so we can start creating a folder that's named post, we can say slash, and then we can say page plus swelt, and now we can just go here, and we can copy what we already have. We don't even need this right now, let me just remove this, and just copy this entire part. We can go here, and instead of home page, we can just say post page. So here is our home and post, and it looks weird because of Pico, so what I have to do in this navigation, I'm just going to create a UL. I'm going to say Li. I'm going to place it like this. Let me just select all of this. I'm going to create another one. Let me just do this. I'm going to save it. And now this should be working. So you can see if you go to Home and Post, everything should work great. And let me just copy over this to Post. Yes, everything should work great. Awesome. So you might be wondering, what is the reason behind this weird plus symbol? And basically, it's just so SwellKit knows that this is a specific file to a route. So what this enables you to do is collocate code. So for example, if you had a post component, for example, or some utility here, you can just create a normal file here instead of having to use some weird names like underscore and etc. Because SwellKit is going to ignore everything that not a route So let me just close this sidebar I mentioned how pages are just components and just like regular components they mounted and destroyed on navigation So let's see if that is true. So I'm going to go to the homepage, and I'm going to add back the script. I'm going to use the onmount and ondestroy methods. I'm going to say onmount, and this should auto-import it for me if I press it like this. So here I'm going to give it a callback. I'm going to say console log. I'm going to say mounted homepage. And then I'm going to say on destroy. I'm going to give it also a callback. Console log unmounted homepage. I'm going to save this. And let me just copy this over. So I can go here to post. I'm going to copy this. And now we can just say mounted post. So I can press Ctrl D to select what's similar. Mounted and unmounted post page. Alright, so here we're going to go first to the console. Let me just clear everything here. And now I'm the user first time opening the page. So let me just do this. So you can see it says mounted home page. And now when you go to the post page you should say that it unmounted the home page and mounted the post page. Awesome. So it says unmounted home page, mounted post page. The same is true when you go back. Because your pages are just components, this also means that page transitions are really simple in SvelteKit, which is a topic for another time. But I also want to notice how the only thing that loads when navigating between the pages is the data for the page, because it's used in client-side rendering, but if you refresh the page it's going to use server-side rendering. So let me just show you what I mean. If I go to the Network tab, I'm going to clear everything again, and let me just refresh. So this is the first time when you visit the page, right? going to see that you get the entire document here so you can see here is everything you need but let me just clear everything and i'm going to show you something awesome so the first thing notice the data preloading when i'm going to hover over posts and it didn't load any html document right or did server-side rendering at least behind the scenes but for example you can see it just loaded the component that it requires you can see this looks very familiar and that's basically it but you can see here if we for example again do a hard refresh so we're revisiting the post page for the first time, it's going to load everything. Let me just clear this. I'm going to load everything. You can see now you have a document here which has everything again And if I clear this and again going to home it just going to load what it requires And don forget to enable disable caching if you doing this so you going to get consistent results But yeah basically this is how this works And you might be wondering is the data preloading some magic that SvelteKit does? And the answer is yes, it's some magic. But because SvelteKit knows the data required for your routes, it can load the CSS and JavaScript script in advance. And this is thanks to if I press ctrl p and go to app html you can see this attribute on the body that's data swellkit preload data on hover. So when you hover over a link it's going to start prefetching or preloading the data for the next page. So I kind of want to show you how this is awesome. If I go for example I'll go here and let me just create some styles. let me just say h1 color aqua and you won't see this in development but let's stop the development server inside pnpm run build and i'm also going to run preview so basically this is emulating like you're in production all right so let's build everything it's going to take one second now the url is different it's going to be 4173 so let's go to the home page so pay attention what happens now. How awesome is this? When we go to post, it's going to load the CSS and the JavaScript required for the page. Amazing. So you can see here is the CSS alone which is scoped to this component and here is just the JavaScript which is probably, oh it's not even minified interesting. Oh this is because I have this pretty print, but when you remove this it's minified. So yeah, you get the smallest bundle size. But how awesome is this? And another thing worth mentioning is that you can set preloading for the entire page like it is set in the app.html file, but you can also set it for individual links and override it if you want. Alright, so that was a brief and interesting tangent, and I'm back here in development mode, so let's talk about layouts. Our two pages, if you notice, share the same navigation, and we could create a navigation component, and then we can reuse it, so you might be familiar with this from other frameworks, we can probably make something like navigation, and then we can import navigation from whatever, right? But really, in SoilKit, this is solved using layouts. So first I'm going to remove these styles because we don't need them. And let's take the repeating styles. I'm also going to remove the script block. And let's just take this. We're just going to cut it. Let's just save this in our post. We're going to go to home. I'm also going to remove

 everything here. So how do you create a root layout? You create a root layout by going to source routes and then you can say new file and you can create layout plus svelte. Now we can just copy the navigation over and we should see the navigation is here and everything works but where's the content? And you need to do another thing which is pass a slot. So you can do it like this. You can save and now we can see the home page and the post page. And this is also a great spot to include your global style. So for example, if I go to source and I can just create app CSS, and just close it quickly. So we can create some global styles. We can say body. Let's give it some padding. And then I'm going to say for the title, I want the line height to be 1. And then I can say text transform capitalize. Let me just save it. I'm going to close this file and now inside our layout, let me just move it here, we can go to the top, we can create a script block, and now we can say import, so we just have to go one folder above, and we can say app.css, and now when you save it, you should see that things are going to get updated. Awesome, and just like your pages, the layout is going to run on the server and client, but first let me explain to you what a slot is, and basically if you're not familiar, this isn't something SvelteKid specific, but this comes from Svelte, which is a slot property which lets you pass anything you want. So here I have an example of that. Let me just go here. So here you can pretend this is our page. So this is the root layout. Here we have our navigation. We can obviously move the slot wherever we want and that's basically how that works. So basically everything that you pass here is going to be shown. So in Remix this is outlets and I don't know what it is in other frameworks but basically that's how it works. So you can include repeating content here like navigation, a sidebar, or a footer, and it's going to be repeated for every child route. So for example, if we have a post route, here is the root layout. So if we create a slash post, now we have a sidebar here and post, and basically this is going to be the slot that's just going to show the other content. So basically how this works behind the scenes in SwellKit, let's say for example, we have our homepage. Remember, a page is just a component. So when you add something like a layout, a new slot, it basically equivalent to something like this right So basically this is what it does And now we can just indent it And basically that how this works So everything else is going to get passed As I said a slot lets other content through. And as you navigate to a route, it mounts the component for the page and unmounts the old component. So one component is just going to be active for the route you're on. So for example, if you go to the post page, this is not going to be active. You're just going to show the post page right another interesting thing is that if there's an error it's just going to render the error for that page and nothing else so if you really want to see how the secret sauce works let me just exit this component so in your .svelkit folder this might look intimidating but don't worry about it so let me just see i think it's in the generated we can see here is the root .svel file for the pages so it really has some interesting things here that are foreshadowing but we can see here how it kind of works and you don't really have to understand. So basically this is exactly what I've shown you. So if it's just a single component without a layout then it's just going to render out the component but if it has a layout then it's just going to use the layout and then it's just going to render your component and if there's an error it's going to show the error component instead and basically that's how that works. So this is really fascinating what you're going to learn even more about layouts. So I'm just going to close this And let's talk about the power of nested routes. You can nest layouts as much as you want. So let's say for example I want a slash post, so if I go here I'm already at slash post, but for example I really want this kind of route where I have slash post and slug, so how I have it here, if I go to slash post, and this is another beautiful aspect of file-based routing because this is going to match the URL where your other content is. So we're on post, and this is going to be our new layout which you can create a nested layout for. So we're going to have a sidebar post, and when I click on a post it's going to load the post on the right side. And if I go here, this works by this, so we're going to go to posts and we're going to go to the slug and this is going to show the post here. But the true power of nested layouts or routing is we already mentioned how Svelki knows what data to load for the page, which is awesome, but another great aspect is that, let's say for example something goes wrong here when we load the post, instead of taking our entire app down, only this part is going to crash and you going to get a useful error message and nowhere to look to fix the problem So let have a look how that works I going to go back here and let me just close all these files we going to need this and now just collapse everything we're going to go to source routes post inside our post so this is the post page and let me just give some text here so you can say you can and let me just give a link so So let's say, for example, that we want the user to create a post. So we can say plus create. You can create or edit your post here. So basically, this is what we want to do. And now you need to create a layout. So we always have this sidebar here. And when we click on a post, it's going to load it here. And we already have a nested layout, so our navigation isn't going anywhere, right? And how awesome is that? So I can create another plus layout.svelte file inside source routes posts plus layout.svelte. So let's do that. I'm going to go here. So here where our posts are, we can say new file plus layout.svelte. Now I'm going to close the sidebar. And now let's add quickly some markup. So I can say posts using Emmet, really simple. Now I'm going to create an aside. I'm going to give it a H4. I'm going to say posts. And now I'm going to hard code some posts. So I can say nav. Let's give it a list. You can say li. Let's give it a link. So we can say posts one. Do it like that. And I'm just going to select this li. Control alt for me. And arrow down is going to just copy over the code in VS Code. So I'm going to say two. So right now nothing is dynamic here. But we're going to see how that works later. So we can just say two. And now remember we need to include a slot. because if we just save this, we can see our post is here. Say 1, 2, and it's not found because we need to do something which we're going to do in a second. So this is 1, 2, and remember how to include the slot. We can just say main, and let's just include the slot. So now we can see our post page create, and let's add some quick styles. So now we can go here, I can say style, post. Let's say display grid. I'm going to give it a gap of 2 RAM. let's say grid template column so we really want the column to be 200 pixels and then the post to be 60 characters wide but you can set it to whatever you want and let's just give it some margin top we can say 2rem i going to save this and now we should move this main so it part of our grid so we going to get this layout And how awesome is this Also this is hard to see Let me just zoom in a bit I'm going to do it like this. Let me just see. Yeah, let's just zoom in like this. So remember how I showed you here this log? So when I go here and I go to post 1, we somehow need to load this post. And we can do this using a parameter. so this can be dynamic like a variable and this is how we can get the post or whatever we want. So we can create a child routes for posts that's going to be named slash post slash create or we can even make something like post edit and it will inherit the root layout and the post layout. So first let's create that so we have that because when we go to create there's nothing here right. So we're going to go to the sidebar and where we have posts, we're going to create another child route. We're going to say create. And again, you just say plus page.svelte. Now we're going to close this. Let's give it a h1. Create new post. Let's give it a paragraph. Create a new post. We can save this. And now when we go to this route, now it's post create. Before we talk about dynamic routes, let me show you the real superpower of nested routes. And I already told you how Swellkit knows what data to fetch for a particular route, but I want to show you how when one part of your app fails, it's not going to take the entire thing down. First I'm going to create a file you don't have to know about what it does right now, so I'm going to go to Routes, Posts, remember, to create, and I'm going to create a special file so you don't have to be concerned what it does right now, but basically I just want to cause an error for the page. And when I create this file, I'm just going to use a SwellKit extension, make this function. And now let's talk about unexpected and expected errors. So in SwellKit, when you encounter an unexpected error, it can contain sensitive information so the error message and stack trace is not exposed to the user. So let's really see what this is. So basically unexpected error, when you get a really bad error like this, it's like yikes. and then let me just go here and I'm going to say import type page load just so it doesn't complain at us so let me just save this and you're going to notice something. So first our app crashed but it basically took everything down right so that's really not great it's not useful error message for a reason because as I said this is an unexpected

 the error so SwellKit hides the error message and the stack trace but you can see the logs for yourself it doesn't hide that but basically it is just to protect you so what can we do so for every route that you have you can create a plus error.swell file so it's just going to get contained to that area so if we go here to create we can just say new file we can say error and now you already see something interesting so if I say boom like this and go here again I'm going to go to post create and just going to say boom here and it's not going to take your entire app down so for example i can go here let me just say yikes and then maybe i can give it an emoji i can say explosion and then i can give it a description something went horribly wrong but the blast radius has been contained to this route. And I'm also going to show you something fun. So we can say script here and I can import a page store from app stores. And this is how you use this information in your arrow pages anyhow. So page store has some information. Here is some snippet I always use. So it's pre and you can just use JSON stringify. so it's really just going to output an object of everything that's available. So we can use a store by selling $page. You can see page has options like error message and etc. Let's really see what's inside this page. So if I do this, let me just zoom out so you can see what's going on. So you can see, yikes, something went horribly wrong. As you can see, here is the error message. You can see it's vague on purpose, even though we said here that it's yikes, right? So we can go here, we can see other params, routes, etc. And if you want to output this really, you have an example in your SvelteKit docs, you can go here, and then you can say page, and then you can say message, error, message, or whatever else you have. You can even output the status if you want. But let's really talk about, or expected errors, that is. And expected errors are created using the error helper, which sets the status and renders the error Svelte component and returns the status and error message. So this is something that you import from SvelteKit, so we can just comment this out. I'm going to go here and I can say throw error, and it should import this from CellKit. Now we can give it a status, and then let's say message. We can say yikes And let me just give it an emoji say speaker So let see when we save this ah okay so now that it expected it going to show the error message on the page so this goes back to what i showed you on this last diagram which when you're on the slug and if something goes wrong instead of it taking your entire app down this part is going to be down and you know where to look so you know where to start looking for the errors so let's talk about dynamic routes in and SvelteKit. Let's say that you had a lot of posts, and it would be really tedious to create a route with a slug for every post, so you would have to create slash posts one plus page Svelte, and then slash posts two slash page Svelte, and that would get really tedious. So instead of doing that, you can create a route with dynamic parameters that uses square brackets around a variable name. So instead of being one, two, and et cetera for every folder, you can basically just create this type of route where it's slug and it's going to catch everything here you can catch one two three four you can catch banana or whatever else you might have so let's see how we can create such a route so i'm going to go to the sidebar and here in routes posts we're going to create new file but we're creating a folder so we can say slug and let's just say slash of course we need the plus pages file so we can do it like this and now this is going to match our slug so inside of here i can just say post and let's just log out the params and remember how we have access to this great store from cell kit so we can say import page from see app stores and i'm going to use a snippet here and i'm just going to save page here i'm I'm going to save it, and now notice when we navigate to our post, it's going to catch this param, which is 1, so it says params here, slug, its name is 1, and then we have all other useful information, so if we go to 2 for example, it says 2, and of course this data is the same, but now I hope some gears are turning in your head, and you can imagine how if we have access to this slug here, we can just pass it to a database or whatever function we have that calls some piece of data so we can dynamically render content on the page. So right now if you navigate to any post the content is going to be the same but later when we get to loading data I going to show you how to use the dynamic parameter to show a post Let talk about more advanced routing in CellKit First let talk about multiple route parameters So what are multiple route parameters You can use multiple parameters as long as they are separated by at least one character. So for example let's say we have some image API so this is going to be I don't know for example image and then maybe you want 200 by 200 whatever, and basically how can we get this as parameters? So we can just put them again in square brackets, and we can create literally a route like that, and we can get the width and height and do whatever we need on the backend. So here in our project, this is starting to get unreadable, so I'm just going to collapse everything, and I'm going to go back to routes, and inside our routes, I'm just going to create a new file. I'm going to create an image folder, and that image folder is going to have a URL segment with X, we need a character, right? With height. And inside of it, since this is a folder, we need to create plus page swell. So you can see here, we created an image folder with height, which are going to be the params, and now we have access to them. So let me just close this. And again, I'm going to import the page from app stores and we're going to create a title dimensions and then let's just output it so we can say page so let me just save this so let's really use this how i said so we can go here and of course we don't need these brackets in the url so let's say for example a user wants an image of the dimension 200 by 200 now we can go to that route and we can see dimensions and here are the params so we get the width and height and now you can do whatever you want with this. Next let's talk about optional parameters. Let's say you're working on internationalization and you have a lang slash about route with a required lang parameter. So for example if I'm here let's say I have English about but I also want to match it by default that is just about which isn't going to work. So let me just show you that. I'm going to go to the sidebar inside our route so let me just close everything here. I'm going to say new file, so I'm going to create a dynamic parameter lang. This is going to be about, and we're going to have page swelt. And let's just say about. So now we going to go here and for example I going to say English about is going to work But for example what if you want just this default about is going to say not found so in this scenario this is where optional parameters are useful so to make a parameter optional we can wrap the square brackets in another pair of square brackets so if i go to the sidebar here where lang is i can say rename and let's just add another pair of square brackets i'm going to save this and now when i go here and refresh you can see that this matches i want to note that this is a simplified example because you haven't learned about some things yet to make change in the language work but at least you know about optional parameters in case you need it next i want to talk about rest parameters you might be familiar with rest from javascript and that's the same idea for routes in swellkit you might receive an unknown number of path segments in case which you use a rest parameter but be careful you do checks in your code because it could be anything so let me just really show you the idea behind this so here is a contrived example let's say we have some image api or whatever and then we have media and then we need path to file or whatever and then maybe this is some image api so the user can give a width and height but basically this is an unknown number of segments right so we can use a rest path so we can say it like this you can say file and now we can catch what the user entered here and do checks that we need and do whatever we need after that so let's see how we can do something like this if i go here and now in the source again routes i'm going to create new file so i'm going to create a media folder i'm going to say slash and now since we don't know the number of segments in advance we can just say file this can be anything you want this can be banana or whatever right so you can just say file and then let's also say slash and we're going to create another folder of course we're going to say width and we're going to say height because those are just parameters right and of course we also need to say slash page as well so this might really look complicated but just give it a second to think about it but yeah we can just go here so now we have media file which is going to catch everything and now we have width height and our which is going to be the page itself. So same as before, I'm going to import page from app stores and I can see here rest parameters and now let's just output. So I can just pre output the page. So now for example, the user

 navigates to media, and now they can say path to image, and they can also give the mention, so you can say 200 by 200, we should get a result. So you can see here it matches the params, so we get a file here, path to image, we get the width and height. How awesome is this? Lastly, let's talk about matching parameters. So if you go to the post route, for example, post, and you can say slash one, this is going to match it, but of course it's going to match everything else, like 1234, banana, etc. But let's say we have something invalid like a space. This should never be a slug, right? So how can we make this more strict and make sure the route matches a valid slug? We can do this using matching parameters. And to do that, you just have to create a source slash params folder. And you need to create a file that exports a match function. So let me show you quickly how you can do that. We can go here to source. And we can just create new file. So I'm going to create a params folder slash. and I'm going to create a slug.ts file and I'm just going to say export const match and say param matcher which is going to import the type so we're going to say param let me just do this and of course you need to spell this properly so we can say export and I'm just going to save this so okay now we need to return a boolean if this is true and false which is going to involve some regex but don't be afraid because instead of using stack overflow or whatever we can just ask our friend chat gpt so we can go to chat gpt which is my new best friend so you can just give it a prompt here for example we can say can you write a match function in javascript that just checks if the param is a slug. And it's going to say sure. And let's see what it's going to come up with. So yeah, basically almost, almost we're there. I just want something simpler, right? And it can even show you how we can use the function, which is amusing. And just give it a second, so it just ends. And then we can regenerate it, and we're going to see a much simpler answer. So let me just go here, and it's going to ask a new answer. and let's see what it comes up with. So it says match param and also that's basically everything we needed. And we can just go here We don even need to copy the function let just copy the regex So we can go here We can say return We can just use that regex And then we can use test And we can pass it the param All right. So while chat GPT is doing his thing over here. Let me just save this. Actually before I save it. Let me just go to one. All right. Go here. And if I refresh it. Everything works. So now we should give it something invalid. It should return a 404. Because it doesn't match the route. But it's not working. And why is that? we have to do one more thing. So for example, if I go here and then here in our routes where we use the slug, so this is going to be in post slug, you have to say rename, and then you need to use the matcher. So we can say equals slug or whatever else matcher you have. Let me just save this, and now we get a 404 not found. Let me just see if this is true. So we can go 1, 2, we can even pass it banana or write whatever, 1, 2, 3, 4, and this should be valid. But for example, something like a space. It's not a valid slot. It should just say 404 not found. Alright sweet. That's everything you need to know when it comes to routing in SwellKit. There's more advanced things to go over like group layout but first we need to learn about data loading in SwellKit which I'm excited about so look out for the next part. In this part of the SwellKit series we're going to be learning how to create API endpoints and loading data for pages in SwellKit. So here I have a simple SwellKit project which at this point you already should know how to make and I just have some default styles so you can go to your app.html and here I have included some PicoCSS styles which you can include yourself if you want and then I have some global styles which is apps.css and then I just have a root layout here where I'm importing the styles and I have some basic navigation here and that's basically it if you want to catch up and you don't have this project set up and here's nothing special, just say hello and then you can go and run the development server so I can say pnpm run dev, and now we can go to 5173, and everything should look great. Before I get started, I'm going to set up a database with Prisma, and Prisma is really awesome because it basically, instead of writing raw SQL, you're going to write something more that looks like TypeScript. And this is a schema in Prisma, which you can look at this example here. Here is how you define a table in your database, you can just say model post, and etc. And this is really simpler than writing raw SQL yourself. For a database I'm going to use SQLite which is really awesome because you don't have to set up anything it just a file on your system meaning you don have to figure out for an hour how to set up a database or sign up for things you really don care about And I also going to show you how to seed your database So we going to use some placeholder data from dummy So here it has 30 posts for us. By default, when you open the API, so we can look here, here are the posts. So we're going to input that into our database just so we have some data to work with. But yeah, let me close this and let's get started. So I can go here, I can press Ctrl-C to stop our development server, ctrl L to clear everything. Now let's start and initialize the Prisma database. So I can say pnpx prisma init. And this is mostly just going to be a speedrun how to set up Prisma. So we can use data source provider. This is really an awesome and quick way to set up SQLite with Prisma providing this flag. So we can just say enter. And this should take a second. And if you look here what happened, this created a Prisma folder with our schema. So you can really ignore this part at the top, we're going to write our schema here, and also created an env file, let me just close the sidebar so you can see what's going on. And here is the beautiful part about Prisma. So this connection string here, you can replace this with anything later. You can create a database on Supabase for free, right? You can just drop in the connection string here and you don't have to change anything else. Prisma supports many databases from PostgreSQL, SQL to even MongoDB I think. But before we get to writing our schema, we also need to install the Prisma client which is going to let us interface with the database so i'm going to say pnpmi we can say prisma client and i'll give it a second awesome so now let's create our schema so i'm going to close the terminal let's close this and how we can start creating our model here and model just means table model post and i'm going to give it an id and also if you want this auto completion you can get the prisma extension from vs code but you don't have to so we can just say int which is a built-in type id is also built-in and also you can see how we get this great auto completion thanks to typescript you can just say auto increment and of course it didn't make this up i just took this from the prisma example which also had this created at timestamp which is a built-in date type time we can say default now so that's how simple that is you also might want to know when it's updated Again, we can use the same thing, but here is a special updated at, and now we can create our own fields. So we can go here, and basically this is really intuitive. You're like, okay, title is text. What is text in Prisba? It string of course And now we can just say content or body string and if we give it a question mark it optional because you might want to create an empty post which is fine For the slug we want to be unique So we can just say string. And we can also make it unique using this. So we can look this up using Prisma, which is going to be really simple. And then we can also have a publish field. So this is going to be a Boolean. Simple as that. And we also can give it a default value, which is really awesome. So we can just say false. And now we don't really need to even think about this field. And now when I'm going to save, Prisma is going to format this file. But before we create the database, let's create a seed file. So we're not going to need this schema anymore. We can close this. Let's go to Prisma. I'm going to say new file, seed, ts. We can say import Prisma client. This should auto-complete for us. Very nice. We can say consdb, new Prisma client. And now we're going to create a type post, which is going to be matching the post from the dummy JSON response. So you can just say title string body string and we can open it here on the side so you can see. Here we open it which is awesome. So as you can see here it returns an object with a post array and this has for every post ID title body. We don't really care about ID. We're going to create this ourselves and these are things we don't care about and that's why I only created this type for title and body so you get great autocompletion. Alright, so now let's fetch this post. So we basically, let's copy this URL because we're going to need it. We can say async function getPost and now I can say const response await fetch and now I can just copy over this URL and now we can destructure post because this is what it returns on the object, right? const post from await response JSON and now we're going to return a post. And if I save this, you can see one problem here. It returns promise any, so we don't really get the type back. And that's why we created this type. So in TypeScript, we can say as post, but this is just a single post. So we have to say, hey, this is an array of post. Awesome. And now if you hover over this, you can see it returns a promise, which is of type post as an array. So that's really not complicated. And I'm also going to create another function and there's going to be Sluggify. So as you can see here, this is this long title, and I want to create slugs from our post title, which would be really convenient if the API had this, but it doesn't, so we have to do it ourselves. You don't really need to import any other library because it's really simple to create such

 function. So you can say function sluggify. It's going to take in some text, which is going to be a string. And it's going to return that text. Let me just make this easier to read. So we can just say text replace. And now we can give it some regex. And then we can also define what it needs to replace. So you do it like this. And you say global. So it's going to take into account everything. And now we need to target whitespace. So we can say this. So this is going to target every white space and now what we want to replace it with we can replace it with banana or whatever but let's just say we want a dash and next we want to remove any characters that are not letters numbers and etc so this can be punctuation some special symbols or whatever and you can change this so you can say replace and now we can also specify our regex and let's just say we want to replace it with nothing so let's start writing the regex here we can do this matching thing so we're going to match a lowercase to z a uppercase to uppercase z and then we also want to match any number but of course this really isn't what we want we want the opposite of this we want to match anything that isn't this so how do you do that you can specify it using a caret symbol you can do this and now this means hey i'm going to match anything that isn't here and also for the last part we're going to say to lowercase because we want to slug in lowercase and let me just show you how this works so I can get this part and I'm going to go here I'm just going to open the developer tools and let me just clear this and this is complaining because we don't really have the developer server so actually this is really annoying let's just go here and let's go to the console and now I'm going to copy over this code so of course let's give it some text so you can say it's a me Mario and now this should create a slug so you can see it should replace this and it should fill in the dashes here. So if I press enter and good thing that we don't do because we made a mistake and this is why regex is so tricky. So you can see here we need to preserve the dash right. So we also need to say dash here and this should work. So we can see it's a me Mario. Okay so let me just also give you another tip if you go to regexer you can actually learn how this thing works. So if I take in this regex let me just paste this in and let's also just give it an example, Samir Mario, and you can see it's going to not only match it what you want right so you know it works but it also going to give you a description so this is really a negated set and this is going to give you all the description here And maybe you can also ask a chat GPT which would be really interesting right But yeah, really, that's a hot tip. So we can just close this for now. And let me just clear this. I'm just going to close this. So basically, now we have the Sluggify. And now we're going to loop over the posts and add them to the database. So I'm going to create a function, async, function main. You can name this whatever you want because we're just going to run it. So before we forget, let's just invoke it. So when the script runs, it's going to run. So now we can get the post. We can say const post await get post. And we can see we're also going to get the types here, which is really awesome. So let me just briefly show you how simple it is to add a post in Prisma. So what we can do is we can say await db post. We can say create. You can see how awesome this auto-completion is. You don't really have to think about it or look at the documentation. And now when we pass it here, this, This is why TypeScript is so awesome because you can just say Control Spacebar and then we have our option. We can say, okay, select doesn't make sense here. I have only data, so I can do that. You can see here is an object. And now we can also go deeper. And I can press Control Spacebar again. And you can see here is the awesome auto-completion for Prisma. So you can see everything you can enter here. But basically, what we have to add is the title. Which is going to come from the post title. And don't worry, this is going to come from our loop. I just want to focus on this. So we can say content, post body, and remember we have to use our sluggify to create a slug, so we can just say sluggify, post title, and now we can create the loop, and when I'm dealing with async, things like this that need to loop over, I honestly don't like using map because the code looks really ugly, because you have to wrap it in promise all or whatever, and it looks really ugly, and for this reason I prefer something that's more readable, and that's a for off loop so you can just say for const post of post and now you can just do this and now we can move the code here just like that and now we can see here we have auto completion from post and you can even destructure this if you want since we have types you can see body title if you want to do that but I honestly prefer legibility when someone else is reading this code and basically that's everything it's not that bad right so you can just save it and now Now before we can run the seed script, we need to add a seed script. So we can just go to package.json, I press Ctrl P, and now we're just going to create a Prisma script. And again this isn some magic knowledge this is just from reading the Prisma documentation They have a nice section But one thing that isn nice is how they describe seeding which isn going to work in CellKit because we using type module which is using native JavaScript module And this is going to work with TSNode But here is a simple solution to that. So you can just say Prisma, following just like they have it in the documentation. Now we need a seed script. And here is the part that's just going to work like magic. So instead of using TSNode, how they recommend it, we're just going to say PNPX. We're going to use the vt note package which is going to transpile on the fly the title file so we can just say prisma we need to point it to the seed script cts and this is just going to work now we can run the migrate command which is going to create the database from the prisma schema and run the script if it finds it so now we can open the terminal and i'm going to press ctrl l to clear everything and now we can run pnpx prisma migrate so it's dev name and now we can give it any name one this can be banana but i'm just going to stick to init as they show in their example so this is going to create the database from the schema and it's going to run the seed script so let's press enter and it should take a second awesome so let's close the terminal so i can show you what happened and also close the seed file you won't ever have to look at it again so here it created the sqli database for us which is really awesome and you can see here it created a migrations folder so every time you make a change to your database you're going to have a migration here So here is an init and here is the magic sauce. So it creates the raw SQL code for you. This is how Prisma works and it's really awesome. So let me just close this. And another way how you can confirm that everything works, Prisma has a graphical user interface, which you can use to check out your database, which is called Prisma Studio. And it really gives me phpMyAdmin vibes, which is really awesome. So you can just say PNPX Prisma Studio and it's going to open it in your browser. And here are the posts, but what you're going to most likely see if you open it for the first time, you're going to see this view. Here are going to be older tables. You can see here we have post. And now when you view post, here is the timestamps. Updated at title. We have the content. And now we also have the slug. Oh, but of course I made a blunder. And I'm really glad this happened so I can show you how you can reset your database. So remember how we corrected the mistake, not package.json, in our seed script. I really forgot to enter the dash here, right? It's a literally small mistake, but I'm going to leave this in because it's going to be awesome. So let me just save this. So what you can do of course is you can delete everything but you can also say here PNPX Prisma You can say migrate reset Are you sure you want to delete this you can just say yes now we can delete the migration and i can press ctrl l to clear everything and let just do the migration again so we can say pnpx prisma migrate so it was dev name init let's do this again awesome so let's run pnpx prisma studio which would open it in another tab so let's just close this and let's see if this works this time and awesome now we have our slugs one last thing we have to do is actually export the database for use in our Svelkid application software now I'm just going to close Prisma Studio I'm going to close this API and let me just close this close the c file I'm going to collapse everything just so we know where we are right so we can go to source and here is a special folder we can create which is aliased in Svelkid we can just say lib and now we can create a database ts file and inside our database file we're just going to do the same thing with it in the seed script we can say prisma client from prisma client and now we can create the database again new prisma client and let's just default export it awesome now you can use this anywhere in our app let's talk about api endpoints you probably used an api like dummy JSON. So for example, if I go here and look at all the available endpoints, I can see here is the products, cards, users, and posts endpoint I'm interested in. And let's go to the post. And what really happens here, right? So to understand this, we need to open the developer tools. So we can say Ctrl-Shift-I. And let's go to the network tab. Also make sure you disable cache. And now when we reload the page, you're going to see some junk, which is not important, but here is the important part what is actually returned here is the document post so we can see here are the headers preview which is the json that got back so here are all the posts so this is basically what we can fetch and show or do whatever here is the raw response so if you go to the header here is the request url the request method which is get the status code 200 okay but how does it know right that this is like json and it should show it like this basically this is because of the response header. So we can see the content type on the response header is set to application.json. And also another thing is that you might not be seeing this like this. And the reason is because I'm using an extension. So if I go to extensions and this is true

 for all Chromium-based browsers, which is really surprising to me that in current year, Chrome doesn't have this and Firefox had this for years. So we can go to extensions. You can get an extension like JSON Viewer. So this is how it would look like for you if you don't have any extension. Let me just go here. I'm going to refresh the page. So you can see now that this matches the exact same raw response, but basically we can just get an extension, use JSON Viewer if you want, but you can use anything else. I'm just going to refresh it. And also, if you're curious, you can go to the settings here and I'm using this Panda syntax theme. So I can close this and this looks great. Alright, but where am I going with this? Basically what I'm trying to say is that SwellKit also makes creating API Endpoints simple. And you do that by creating a special plus.server.ts file that exports a function that corresponds to a HTTP verb, which is get, post, patch, put, delete, or whatever else. That function takes our request and returns a response. And if you don't know about HTTP request methods, where do you learn about it? Of course, on MDN. So you can say HTTP request methods. You can go here. You can open MDN. And now you can see the explanation for this. You can see each one. And this is how you learn. And this is a great thing about SwellKit because we're going to spend more time learning about web standards on MDN than actually reading the SwellKit documentation. All right, so let's create an endpoint. So to show this how this works, basically what I'm going to create if I close this. So remember we have our here development server which should be running and now I basically want to create this endpoint. I want API newsletter and right now it's not found but let's see how we can create it. So I'm going to open the sidebar and in source routes I'm going to create a special folder API slash newsletter. This isn't convention you can name it banana or whatever you want. In some frameworks this is convention that you have to have an API folder, but I just use it to know where this type of files are if this is some API that's used across the app. So here in Routes I can say new file so you can start creating some folders. I can say API newsletter and then you have to create this special plus server TS file. And now we we can close the sidebar, and now we can create the functions that match the HTTP request methods. So we going to create one that API newsletter this is going to be the get request and also we going to create a one It going to be newsletter post request And how do we create it Well we just say export const what we want, get right. And we're also going to use our request handler type. If you press enter, it should auto import it. Or we can do this. And now we can say async. We don't really have to. And here is an event which comes by default. So we're going to talk about this in a second. So we're going to do this, and let's just return some text, right? So remember how we said it returns a response, and we actually looked at the response in the network tools. So you can say return new response, and you can just return anything. You can also see this awesome type completion. You can see body and the options. You can just say hello, and now if I save this, it should return hello. And if we look at the network tab, you can go here, just refresh. here is the newsletter and this looks familiar right so we can see request method status code content type text so basically we can infer that the browser does this by default if you don't supply anything so you don't have to specify it yourself and the browser is actually smart enough to understand the content type in most cases i also want to talk about the response obviously you might be thinking about this you're seeing this for the first time okay i can probably learn about it in a silky doc wrong you're going to hear me talk about all this time about using web standards and response is a web standard so you can go mdn response you can open mdn you can see here the description and now we can go to the constructor right so here is what we're using actually right new response you can see okay here is the body options but of course if you're using timescript you already know about this because you get awesome auto completion but you can actually learn more about it here you can see what you can pass in so you can pass a blob array buffer I never use these things to be honest I use blobs. Array buffer, no idea what it is, etc. Readable streams, this is something cool, right? But yeah, this is really awesome and you can learn so much. Not just about Selkid, but the web in general which is transferable knowledge. Alright, but let's look at MDN as this option and let's create the options ourselves. So you can just create them here, like this that would be fine. I just want to create a separate one so it's more readable. So I can say const options, and this is of type response init, which should be available globally. This really isn't important. I just want this to have auto so if I press Ctrl I going to see header status and status text And how awesome is this So let create our own status right We can say 418 which is going to return the teapot status which is a hilarious meme in web development And then let also specify some headers so we can take the meme to the next level. And now we can give this whatever name you want, like, right? This is like the part about learning and playing around, like all of this looks serious, like, oh, like your life depends on it, right? But you can just play around it have fun so i can just name it x and what does x do of course x is gonna give it to you we can pass the options here let's just save it and now when we refresh the page you should see here oh here is our status code and what is that status code you can see 400 i'm a teapot you can learn more about this on mdn the origin of this joke and we can see something interesting here so here is our own header x and what does x do x is gonna give it to you all right so this is awesome but let's say for example you want to subscribe someone to your newsletter or you're using some other api so we can create a post request and let me just close this and now here we can just go to our post so basically we can use a phone we can use the method type post and this is going to ping this instead right because when we visit this page is going to trigger the get but we want to trigger the post which we can do using a fetch request which i'm going to show in a second. But yeah, let's just do that. So how do we do that? Export const post, and we can say request handler, which would be the same type. And let's just say event. I'm just including this so you know that this is what you get by default, even if we use it or not. But in this case, we're going to use it because we can get something interesting from the event, which is the request. So let me just show you that. So we can just say it's going to be the data from the form, right? because we're going to submit it. So you can just say data await event. And what is on the request? TypeScript help us out. So you can see here are some interesting things which we're going to talk about later. So we can just say event request to get the access to the request. And what is on the request? Form data, beautiful. So now we can get the data and now we can get the email from the data. So let me just move this up. So how do we get this? And basically this is also something you can look up on MDN, the form data and how you work with it. And you're going to find out that you get a value from form data by using the get methods. You can say get and you going to have a field which has a name email right And then here is some logic so you can subscribe you can subscribe the user to the newsletter but here we just going to console log out the email when we submit it all right so now here is the interesting thing so remember how we had new response so basically we want to return JSON and I'm just going to create a new line so this is more readable so basically we need to stringify first whatever we get So we have to say JSON stringify or some experts will say we need to serialize it. Okay, so we need to do that. And now we're also going to return a success true. So basically when we get this response, we can show a success message to the user, right? So we're going to return a success true because this isn't going to get returned if this fails, right? This is just going to explode. Okay, so now for the headers, this is important. And we can say headers. Let's do it like this. Actually, we need to rename it. And now you set headers like this. And again, you'll learn about this also on MDN, how you set headers. So you can say content type. This is the same thing we've seen in the network tab. And what do we want? Application JSON. And we also need to match it because this is another one. We need to do it like this. And when I save it, it's going to format it anyhow. So that all goes through the window, which is really awesome. So yeah, we can do it like this. And now we just need to use it. So how can we do this? Let me just go to the sidebar. And here in our routes, I'm just going to open the default page. So now let's pretend that we're trying to make a signup, right? So we can say h1 newsletter. We're going to have a form. We don't have to specify an action. This is by default get, actually not an action, this is the URL. The method we're going to have to specify, which is default get, but we're going to specify post. But actually, we're going to use JavaScript here, so we don't really need this. But you can also get this from the form even if you use JavaScript. But let's keep it simple. I'm just going to remove this. I'm going to have onSubmit, and I'm just going to use this handy thing from self. PreventDefault. And now we're just going to create a function subscribe. here instead of submit you say subscribe and default is going to be submit so we don't really need this let me just go here and now we just need an input that's going to be of type email

 and just say, yeah, type email. We can just give it a name. And this is really important. This is how we get the value from this thing. So we can just say email. You can even remove this. Of course, introduce some semantic markup in your HTML. And let's just create a script tag. And now here is the more tedious part because we actually have to do this tedious part where we have to fetch to the endpoint and et cetera. And that's why SwellKit has another more awesome way of working with reforms, which I'm going to save for another part. But for now, we're going to do this. I'm going to say async function subscribe and it's going to return an event which is of type event so now we can get the form itself remember we can say event target or you can use this but I really prefer this and after a piece TypeScript we just need to say hey this is a HTML form element so treat it as a form element and now we need to get the data and remember this is what we get here right when we pass it back okay so how do we do that Let's say const data new form data. Ah, that's interesting, right? So this is something also you can look up on MDN. And we pass it back to form and now this is going to return the form values, right? Which we can use. And remember, now we need to ping our endpoint. How do we do that? Well, we use fetch. I wait, fetch. What do we want to ping? API newsletter. And now we need to give it options, right? So here is an options object. And now we can say method post, how awesome is that? And now for the body, we return the data. Alright, so let me just save this and again, now we're going to return this data from the form whatever we passed in and you can also have values here that you can bind if you want. This is honestly way simpler and closer to the web. So this is what you're going to get here from the form data. Remember, we created this form data here, how awesome is this? And now we have our own endpoint because we have an actual server. And we don't really need an entire server. We can use serverless functions from the cell, which is actually perfectly suited for this because you can spin up one action at a time than having to have some server constantly running in the background. So now we can get the email and this is going to log out the email. And you're going to see in response, if it's successful, you're going to see a success message. All right, so let me go to localhost 5173. Here is our form. I'm just going to move it here. And now we should see this logged out on the server. if I open the terminal here So let just give it an email here say that I want to subscribe and actually let me just open the network tab here So I just going to press subscribe and you see ah here the email right Okay. And now you can see here is the fetch request. How awesome it is. So now when we go here, you can see it made a post request to API newsletter. And now we can see the payload, the preview, it returns the success and you can return whatever you want. And now, since you've done the fetch here, you can go even further. You can take this from the response and then you can update some state inside your app if this returns whatever you want, right? And then you can show whatever you want to the user. And how awesome is this? And you can use this in many different ways. So for example, if I go to even my site, you can see for example that all of these posts have view counters. And basically, that's done by having an API that just pings Supabase, so it just increments account in some database whenever someone visits a page and this is how you can use an api endpoint whenever you need to hit some endpoint or whatever an api endpoint is really useful and again i want to repeat that in swell kit which is going to be on another part we're going to explore a much better way with working with forms in cell kit all right so this was just an introduction to api endpoints but what i really want to make i want to make an api post endpoint so you can go to api post and this should return all the posts from our database so we can use it across our app and this is what i'm going to do next so let me just close this and let me just keep this open let's close the terminal so now i'm going to close this and we can close this so now we're going to create another route so i'm going to go to api and i'm going to say new file and this time i'm going to create a post folder i'm going to say plus server ts and now we're going to use prisma to fetch the posts from our database and return them as JSON so we can use them. It's going to be exactly the same as the dummy JSON API. And later we're going to even enhance it so I can show you how you can make your own API more interesting and special. Alright, so let's close this. And now if you use the Svelkit extension, you can just use kit and you can just say kit endpoint. This is going to give you a much quicker snippet so you don't have to type all of this out. So we can say export const get and again we can just import this request handler. You should import it here and let me just instead of returning this I'm going to show you something so we can go here and now we just need to use Prisma to get the post How do we do that Well first we going to import our database Remember we created this db from and this is aliased automatically for you Lib database See it already knows and this is by default in SwellKit. And you can also alias other folders if you want. Okay, so how do we get to post? And this couldn't be simpler. So we just say const post and now we need to use Prisma. So we can say await db post findMany and that's it. This is going to return all the posts. And now remember how we said that we need to return, so we can say return new response and remember how we had to stringify and etc to return a JSON response. Well, this is so common in fact that SvelteKit has a helper function for you so you don't have to do this. So you can say return JSON, if you press enter, it should auto import this from SwellKit. So I can place this at the top. So now you can say return JSON. Now you don't need to do any of that. Now you can just return the post. I can save it and now this should work. So now let's go here. We're going to refresh this and now we should get the post. Awesome. And it's the almost same exact thing like you get from dummy JSON. And here is our database. So remember we had a created at updated title. Now we get the slug also, also we get the published etc. if that's what you want. And here are all the posts that we had in our database. And now we can go here to Posts, we can see again same like that other API, right? We have a request method status code, here is of type JSON. We can go to the preview, exact same thing. Here is the raw response, right? And how awesome is this? So while I'm here, I want to explain the event object to you because it's very important. and you're going to see this across your entire SwellKit app when it comes to loading data and etc. So what I'm going to do, I'm just going to use an event here and then I'm going to console log it out. So I'm just going to say console log event and if you're using TypeScript, of course, you can destructure it here and you already see all the options here, cookies, fetch and etc. But let's just do this and just open the terminal. Let's save everything and now when we reload the page, we're going to see, oh here is some interesting things here. So you can see, so this is a method to get and set cookies in SwellKit. Then you also have fetch, which has superpowers, which we're going to see how it works in a second. So this is going to give you extra features like inheriting cookies and authorization headers for the page request. It can do relative and internal requests on the server. And it's also going to prevent additional requests because it inlines the response from the HTML which really doesn mean anything but we going to see how that works in a second We also of course have params of the current page So remember previously when we had slug or whatever it going to give you those params We already seen how the requests work, so it's going to give you the original request object. The root has the information about the route. So if you go here is the request. There's a lot. Here's the route, API post. Here's the URL, so you can get whatever you want from here. Same as you can from that store that we used previously, if you remember from the last part. And then you also have another interesting thing, which is a way to set headers. So this also returns set headers, which is right here. So you can set the headers for the endpoint or for the page. So let me actually show you an example of that. And this is going to be really cool. So we can go here. And again, we're in our post endpoint. And now remember how we said that this should find many. I'm just going to remove this. here I also want to get a random number of postage time so we can see that caching works so we can specify to prisma take and we just need to generate a random number between 0 and 30 so we can say math round because it's going to return a float or whatever so we can just say math random and now we need to multiply it by the number of post so this should always be random and we're going to fetch this post and I'm going to show you how this works and now here is how simple it is to set your own headers. So from the event, we have set headers, and now you can specify your headers. Again, cache control, and you also learn how to do this on MDN. So you can say maxH is going to be 60 seconds. So this is going to be fresh for 60 seconds, and whenever you make a request to this, it's going to cache it to your disk and show it to the user. So you can go to MDN, HTTP caching, and it should open the HTTP cache link, you can learn everything you need to know about caching of course. Alright but before I show you that let's first talk about how we can actually show the data on the page. Alright so let's see how we can show the data on the page and this might look familiar to you because we're going to use client-side rendering and this is how you've done it in the past in React, Vue, and Svelte before SvelteKit. First I'm going to remove all of this code because this was just an example so so we can just save it and then I'm going to add a script like this and now I'm going to create a function to get the post. So now we can say const response, I can say await fetch and remember here is a

 our API posts. So if I go here and just copy this over, if we go to API posts, it's really just like any other API. We can ping this and we can return some data. Nothing special here. So we can just go here. We can say const posts. And thankfully, Prisma generates a type for us, so we can get the posts like this. We can specify this as an array of posts. And then we can say await response JSON. And let me just clear it like here. and I'm just going to return posts. So now that we have this promise, we can use a special await block from Svelte to get the data and show it to the user. So I'm going to go here, I'm going to say h1 posts. So if we save this, we can see here the posts. And now we can start using the block. We can say await. We have to use the promise, get posts. And now here you can set the loading data. This is only going to show for a brief second because it's really fast. And now when you have the data, you can say then. You can name this whatever you want. I'm just going to name it post. And I'm also going to use my snippet that I used previously, just so we can see what's on the page. And now in case you have an error, you can say catch error. Like this. And now we also need to close the await block. You can do it like this. And now we need to say P. You can output the error message in case you have an error. Okay, let's save this. And you already seen this took a millisecond. And now, okay, one, two, three, four. So you can see we got a random amount of posts, even though there's 30 posts. And remember, this is because previously we used stake, and now we use mathrandom. So now remember, because we set the cache control header, this is going to be fresh for a minute. So no matter how much you refresh, you should see 25 posts. So here you can see here is 25 posts. And the way you can break this spell if you go to the network tab since we disabled cache, if I refresh this right now, this should refresh with a completely random set amount of posts. Let me just go here. So here you can see it returned 21. If I refresh it again, it returned 11. And of course you shouldn't rely this in production. You should use SMAXH so you get it cached on the CDN. So for example, if I go here to post, let me just see maxH 60. So you can see here it cached and it also going to say that it read from disk Of course let me just enable it like this so we can see the request And you can see here it says disk cache. So now when you open it, you can see 200 OK from disk cache. And when you're using a CDN in your headers, you're going to have a header here that's going to say hit for the cache. And you would set maxH to 0. Of course, if you're generating a completely static site generated site, you really don't have to think about this. When you upload it to something to Vercel, they're going to set the cache to forever until the next time you redeploy or whatever. So basically, you would set something if you're using server-side rendering. You would set this to public. You would set maxH to 0. And then you have xmaxH 60. So for example, if you have a deluge of traffic, you're not going to hammer of the servers is going to get cached by the first person it might take the initial response more time but the subsequent responses are going to be much quicker so this is how we set the cache control header if using server side rendering and want to cache something on a cdn but yeah i can just revert it to what i had before just as an example and that's basically it and also let's actually display the post so i'm going to close this and let's go here oops i'm just going to remove this and we can just use good old swell to loop over the data and you can also see the caching in play if we let's see do i get autocomplacent awesome we can just say showing so we can get the post length so showing amount of posts and then let's just loop over the data we just create space here so it's easier to read we can say each post as post and now we can close the each here and now we can just display so we can say ul li i'm just going to show a link so you can just say slash post this is what we're going to use in the future and now we can say post slug because remember this is why we created this log so we have here to visit the post and we can just say post title and of course if you want to be clever you can destructure it here since we have type completion you can see all of the things that are available to you so you can say post title and etc like this slug title and now we can even remove this and now when i save this showing 25 posts and this should be cached Showing 25 posts but remember we can always break the magic spell if we go here Disable caching. And now it should always return different data. How awesome is this? Alright friends, so we've seen how we can show data on the page using client-side rendering. But this comes with some problems. For example, here we have posts and really want great SEO. And now when Google visits us or the goat Bing, it's going to have problems parsing this JavaScript. Of course, search engines can parse JavaScript in theory, but that takes compute. And really, is Google going to waste resources on you? So really don't believe those fairy tales when people tell you that it's fine to just use JavaScript. It's not for many reasons, because if you want great SEO, you have to use server-side rendering. So let me show you what this means. If you go to view page source, Here you're going to see loading. Let me see if I can zoom in. Yeah, so this is the only markup you're going to see. And why is that? Well, because we're using client-side rendering. And if we go to the Network tab, I'm just going to refresh this. And let me just go to the document here. And this is the only thing that returns. So this really isn't server-side rendered. So basically, you're just getting an empty shell HTML file. And whatever has to load here after the fact, it uses JavaScript or Svelte in this case. which is why when a search engine comes here, unless you can execute a JavaScript on your page, and this is why you won't get great SEO, because this is what the search engine is going to see, unless it's able to execute JavaScript on your page. Downfall of this is that the JavaScript has to load first before it can even start fetching the data, so it does a round trip, right? If you're making a dashboard or whatever, like who cares, right? But for example, something like PostCare or etc. where you want great SEO, server-side rendering is a must almost. Using server-side rendering is just a much nicer user experience and is going to avoid loading spinners everywhere. So instead of using client-side rendering, I want to take advantage of server-side rendering in SvelteKit and fetch the data before the page loaded, which is going to result in a faster and more resilient app. Alright, so how can we do this? Let me just close the developer tools and also going to close this view source. So how we do this in SvelteKit, a page plus Svelte can have a sibling plus page.ts file that exports a load function which returns data for the page and nothing else. So let's create that file. I going to open the sidebar and here in source routes so remember here is the page Svelte at the root of routes You can create new file plus page And now we need to export a load function So we can say export const load. The type is going to be page load and it should auto import it for us which is nice. We can just say async. It also takes an event, right? So we're going to see this everywhere when it comes to data loading. And now we need to do something special. a fetch method from SwellKit so it understands the relative paths on the server. We talked about this before if you remember. So we can say const response await fetch and now we can just point it to our API. So we can say API post and now we're going to get the response. I'm going to use the post from Prisma which is going to auto import for us which is nice. Now we can say await response JSON. And now we just return the data. So you have to say return, return an object, and now we can return the posts. The posts are going to now become available to our page inside a data param. So we can see if we go here, I'm just going to remove everything here. And now we're going to start by creating a script again. And I'm just going to say export let data. And this is already typed for us, which is really awesome because SwellKit here generated the types, post here, and now we can use those. So now we can go here and we can say page data, and this is the only thing you have to import here. So now if we save this, and let me just hover this, you can see this is already typed, which is really awesome. Alright, so now we just need to use this data. So we can just say post, and again, we're going to do the same thing. I'm going to say showing post, actually, post length. It's dataPost, like my bad. DataPostLengthPost. Okay, sweet. So now we can loop over it. Again, I can say each dataPost, right? As post. And now we can close it here. And now let's just say ULLI. Again, we're going to use the link post. So we want a slug, if you remember. and we're going to use the post title. Alright, so let's save this and we should see our data, which should be server-site-rendered. Awesome. And again, we can just reset this.

 refresh it, we're just going to get a random amount of posts. So now when we go to the network tab, and let me just refresh this, you can see we actually get the entire document. So here you see 11 posts, here you see the same thing. So now when Google or the legend Bing comes around, he's going to say, oh, here are some posts, okay, better index, and boom, bam, thank you, ma'am, now you're number one ranked on Google or whatever, congrats. And also another thing I want you to note is that you can't find a single fetch request here. So if you try you couldn't because why? It happens on the server, right? And you would only see a fetch request if you navigate to some other link because CellKit at that point as you learn in another part becomes almost like a single page application. Because when you first visit the page there shouldn't be any links, right? So let's see if we go to Posts. So even if it says not found, now if we go and preload home, you should see here is the fetch request because this is basically client-side rendering. But if you go to home and your first time visiting the page is going to render on the server and that's why there is no fetch request here. And also another thing I want to show you how I mentioned, and this is one that gets me all the time. I use rarely fetch like this here because I'm using a database or whatever, but because of that, because you don't use it all the time, you're going to get into this issue. you're going to forget about this fetch because fetch works on the server because it's follow field so you're going to have an event and this all looks great right okay great this is going to work great and now you save this and you get an eternal error which is honestly not that helpful and now you're going to waste half an hour here trying to understand this cannot use relative url if you like know about what i talked about this should make sense but if you don't then you're like okay what does this even mean like why does this work and you're like just going to get confused. So remember, this is why this fetch is useful, because it comes with superpowers. So this is just going to work. Also remember how I also mentioned that fetch inlines the data, and what does that really mean? So for example, if we go to the page source here, you can see here is your actual HTML. Ah, but look at this. Here is the data itself. So SwellKit isn't going to have to do the same work again, because it's just going to inline this data, and if nothing has changed, it's just is going to show the data. So let me just close this. Another tip I want to show you when you go to Page the Swell. So this is great data post, but honestly you going to have a lot of things and it going to become a pain having to constantly use data dot whatever But we can use reactive declarations and we can destructure post So for example let say you do const I going to say post from data So this is fine, but this really wouldn't be reactive because when you update this, nothing is going to happen. So the next step you can do is use a reactive declaration, which is a dollar sign. But there's another problem. This is invalid syntax. So you can just group it like this. And now if you save it, everything should work. And this is now reactive and something changes. It's going to update data. So now we can go here and I'm going to say Control D. So everywhere where we use this, I'm just going to remove it. And let's also be a hotshot. We can say Slack title. Can remove it here. Save it. And let me just close this. And everything should work great. This is great, but sometimes you only want to run code on the server. The plus page.ts file is great for fetching data for the page, but also you have to keep in mind that it runs on the server and browser and it won't work if you need to use some secrets or want to use the file system or database. I'm going to show you this by creating a slug route that should get to post from the database using the slug parameter. So I'm going to open the sidebar and inside our routes, I'm going to create a new folder. So I'm going to say posts, I'm going to create another folder, slug, and I'm going to create page.svelte, and let's just give it a title, this should be post. So now, when we get the post here, and go, we should just see post, and you can see it's going to update, so this should always show the same, but we want to dynamically show post, and this is also why we created the slugs, which is really awesome. So now what we have to do is fetch the data on the page like we've done before. So here in post, we can go to slug, and remember, we can create a page.ts file, and we're going to see why this won't work in a minute. But first, let's just create the code. So we can export the load function. We can say export const load, page load. Let's import it. And now we can say async. We're going to need params from the event, because we're going to take the slug, and we're going to fetch it from the database. So now we can get the post. we can say const post await. If we start typing db and press enter it should also auto import. This is why TypeScript is really awesome because it's really smart about these things in your redditor So we can say db post find unique remember because we specified that the slug should be unique so this is really easy find unique and now if we get auto completion what are the options where right and now we can just give it a slug it also knows this slug the unique identifier how do you get the slug from the param slug if you go here for example and you do console params you should see the slug bag which we already learned in the previous part. So now let's do some error handling. So for example, if there is no post, we're going to throw an expected error. If you also remember that from a previous part, we're going to say throw error. So this is going to be expected. Let's auto import error from cell kit. So we can say throw error. Let's give it a 404 and we can say post not found. And now we can return the post if everything is all right. And basically that should be it. So now if you look at the terminal, remember how we console log this out here. Let me just refresh it so you can see this is the slug. So this is how we can fetch data as we've seen in the previous part when I teased this. And now we're going to see why this doesn't work. You already see we have an internal error. So if you go here to our console, you can see error. Prisma Client is unable to be run in the browser. Okay, so how do we solve this? Like is this all code for nothing? We're going to throw this away? Nope. it's really simple as renaming plus page ts to plus page dot server dot ts so it's only going to be run on the server so if i go here i'm going to close this so inside your sidebar inside the slug folder we're going to rename page ts dot server ts and now if we go here we need to change some things instead of page load this becomes page server load so we can remove this type here let me just save this and i'm going to refresh and everything should work when you're accessing secret environment variables talking to a file system or a database you have to use dot server but by default just use plus page ts for everything else all right so let's dynamically render the post and show it to the user. So we can go to page Svelte where we have the slug so now we can actually get the data, right? So let me just remove this Let add a script and now we can say export let data Nothing changes here You receiving the data We can auto import page data like this And I also going to create a helper function that going to format the date because we also returned it from the database I going to say formatDate It's going to accept the date. It's going to be of type date. And we're going to return this useful JavaScript feature. We're going to say Intel dateTimeFormat, which is a really nice way how we can format dates. We can say English. and for the date style we can use long and then we also have to say format and we need to pass it the date and that's going to be great. So now we can show it in our template. So I'm going to create a heading group. I'm going to say H1 and I'm not going to use the fancy destructuring because I really want to focus on this concept. So I can say data post title. As you can see we already have great auto-completion from TypeScript, which is really awesome. And if you're not using TypeScript, of course, you can use JS doc. So, if you just copy-paste the JS doc comment here, you're going to get the same awesome type completion. So, this is going to be the title, and I'm going to add a subtitle, and here's going to be the date. So, let's just do date post created at. Now, if we say we should see this, and this really doesn't look pretty, right? But we can already see our post is working, and I'm also going to have some content here and if we had some HTML or whatever in our post which we usually do right even when it's marked down we can just use HTML from Svelte we can say data post content and this will show you for this page all right so now when you go to home his mother has always taught him you can see this is going to work the other post is going to work and all the other posts are going to work and now you're dynamically rendering data but let's also format the date. So here we can use our utility function. You can save this in a utility folder or whatever. So let's just see how this is useful. Really simple to format it this way. Ah, you can see January 10th. And you also have other short, I think. You can use auto-completion. This is, again, white-iscript is so awesome. You don't need to open the docs. Just see all the available options to you. January 10th. That's a full. This is going to give you the full. But yeah, we're using long, so you can just keep it So not a lot has changed besides the filename and the types for the load function becoming page server load instead of page server. In general, whenever you need to create an API or make a HTTP request, use plusserver.ts

 data for the page, use plus page.ts or plus page.server.ts. In this section, we're also going to talk about how your layout files can also load data. Your plus layout.swealth files can also load data using a plus layout.ts or plus layout.server.ts file the same as your plus page.swealth files. And you might be wondering why would you do that? Well, the superpower of doing that is that the data return from layout load function is not only available to that layout, but it's also available to all the child routes, meaning you can pass data like a hot potato for your routes. Let me just quickly show you how that looks like. So here in source, routes, you can see how we have the root layout here. So if you want to load the data, you can just create a new file layout.ts here. And now if you have the SwellKit extension, you can just do this, but instead of page load, the type is layout load so this is going to get import from you you also get the event the same as before and now we're just going to return a message and nothing else let's say return message hello and now this data is going to become available to the layout page but also to your other child routes i'm going to press ctrl p and i'm going to find the layout in source routes and here if you say export let data and we can give it a type layout data you can see this is imported for you and if you hover over it you're going to see that you're going to get the message which is awesome so now when you output it like here you need a snippet you're going to see message hello so let's take this same block of code and now we don't really need this here let's just remove it so now you can go to any child routes and you're going to be able to use that data So we can go to Posts, where you have the slug, for example, to Page Svelte, and now if you hover over this, you should already see, ah, here it is, the message. And now if we put it here, now when you go to a post, you should see not only the post that returned for the page, but also the message from the loader function from the layout. This is really powerful when you have some data that you want to reuse, so I'm going to show you how we can take advantage of that. Here in the post, since we don't have a page yet, we're going to create it, but basically what I want here, I want a sidebar that's going to give us a couple of posts, and on the right, I want to show the posts that we seen so far but also I want to recommend posts that are going to be the same as in this sidebar and we going to use a layout to achieve that So you don have to create a special file just to fetch the data for posts or whatever But first I going to remove this because we don need it And I can just save this. And we don't even really need this file. So I'm going to find it here. And I'm just going to delete it. So first thing, I'm just going to... So I'm not blinded. I'm going to go here. Let me just collapse everything just so we know our footing. We have source, routes, here is our post. So remember when we use it post, nothing here. So I'm going to create a page.svelte file just to get started. So we can just say post and we're also going to include a paragraph. We can say you can browse post here. And now we're also going to create a new layout. So again under post plus layout.svelte and let's just name it layout or whatever. It's really not important for now because first we're going to fetch the data here. And you can also see if we just give it a slot, we should see everything else. But we're going to get back to this. First, let's create a plus layout.server.ts file under post. So you can say plus layout server.ts. And why server.ts? Because we're going to talk to Prisma, of course. So let me just collab this. And we need to export a load function. Export const load. the type is layout server load so this is going to get imported we can say async and again you get the event here if you need it just like before and we can just say const post so we can use Prisma if you press enter DB it should import it for us so we can just do it like this and we can get post find many because we want everything and now I'm going to specify the fields I want. Let me just do it like this. So I can say select. I don't want anything else. I just want the title and I want the slide. I'm going to say true and I'm going to take four results, nothing else and now we just need to return the post. So I can say return post and basically that's it. Awesome. So since we use this, now this data is going to be available through our entire slash post route. so we can go to layout svelte and I'm just going to remove everything here I'm just going to add a script export let data so we can get the data the type is going to be layout data which should be imported like this Awesome Now I going to create a layout like this We going to have some basic styling Let me just make space so it's more readable. I'm going to create an aside. Here's going to be a nav inside. H4. We're going to have posts. And now here is going to be some list. And now we're going to loop over each of those posts. So you can say each data, we have types here, data posts, right? Data posts as slug title. So sometimes this might be tricky here, we have some posts, but in that case you can press Ctrl P, you can use the pointy boy and then restart language server, or worse, you can restart your development server and the type should be generated. TypeScript is sometimes slow, and that's how it is, because this is really complicated when you think about what it does under the hood, right? So if you ever have problems, maybe it's not you first, maybe it's typing, so I recommend you check that. So we can say each here, and then say li, we're going to have a link here, post, it's going to be slug, and this is going to be title since we destructured it. So awesome, here you can see we have the sidebar, everything is good. We have our type here. Alright, so now let's show everything else. Remember, we need to use slot here. This is going to show our post. Okay, so now we just need some basic styling. That's how simple this is. How awesome is this, right? So I can say display grid, grid, template columns. So I'm going to say the sidebar should be 200 pixel, not responsive. 60 characters for the post and I want a gap of for rem and then I want to some spacing to rem. Let's save it and awesome. This is a great layout. So we can see here we have it on the side and now since we created this layout when we load the post in it's going to load in on the side. How awesome is this? And of course this is not the most responsive thing. You can make it more responsive but yeah. And I'm also zoomed in so that's why that is. But yeah, let's just keep it zoomed in for now. So let me just give you a summary. We created a new layout for the post route just so we have some posts here in the sidebar on the left and just so we can load posts here This post is coming from this file which is slash post page So we can do whatever here And now when we load a post because we using this layout where we have this slot here, now every post that we pick here is going to get loaded on the right. And this is how that works. How awesome is this. Okay, let me just zoom in just so we see everything. Okay. Hope this is visible. But yeah, basically that's it. But now I also want to have recommended posts here that are going to be the same as they are here. And in our sidebar if I go here to Routes, Posts, we can see here is a child route of Posts, Slug, Page.svelth. If we go here and hover over data, hmm, what is this? Oh, here we have the post, right? And the post itself. And here is everything that we need, right? So we don't really need to create a special file just for this PlusPage.svelth file where we can already reuse the data we have. So let's show the post. So we can go here, I'm going to create posts, give it a h3, post, we're going to loop over it again, ul, and then I'm going to use the snippet I have, so you can say data posts as slug title, and now inside here we can do the same thing, li, We're going to give it a link. This is going to be post slug. Give it a title. Awesome. Now we just need some styles. If we save it, it should already work. But now let's give it some spacing here. So if I go create a style, just say post margin top to rem. Awesome. And now we reuse this data. So now let's try if everything works. So this is going to load the post And we're going to get the same recommended post. And now when we use this, it's also going to change the post. But this isn't going to change, of course. And how awesome and simple was that? Alright, friends, before we get started with this next part, first let's fix this issue so it'll get cancelled. So this was in our layout post, right? So you can just say min max. We can say actually auto and max 60 characters. And this should fix it. Alright, that fixed my OCD. And I feel already a lot better. So let's close this and let's talk about how your data is available everywhere. So, so far we've seen how data flows in one direction, but the dollar sign page store makes your data available everywhere. So let's see how that works. If I press control P, I'm going to go to the root layout, which is going to be source routes.

 And now here I can import the store from SvelteKit, which we've already seen in previous parts how useful this is. So I can say import page from $app stores. And I'm just going to output everything here. Use a store by prefixing with the $. This is just syntactic sugar, so you don't have to subscribe and unsubscribe to stores yourself. so now I can save this and you can see it's going to output it for every request. So here we're going to have these params and we also have some data so we get post and remember here are the posts from data that we return from our loaders and here is a post. So interesting things happen when we go to a post. So you get here post and here is a post with the id. You have created that and etc. So why is this useful? You might be confused and basically this is really useful instead of repeating something like SEO on every page, you can use this page store to use it for your titles and whatever else you need. And you can overwrite it for individual pages if you want. So let's see how this can be useful. So I'm just going to remove this and I'm just going to create Svelte head here. And here is where you put whatever you need that goes in the head of the document. So we can say title. and now remember we get it from the page store and the beautiful thing is that it's also typed so we can say data post and let's give it also a question mark because the post might not exist and you're going to see we're going to update the title here when I save so awesome this now updates the title of the post but of course when you go to other parts of your site this is going to be undefined so you can set a default here if you want or you can override it just for those individual pages but now you don't need to do other complicated things to make this work. So if you see when I go to any other post, it updates the title and this is really an awesome use case for this. Another real world example I want to show you is when you're using an off library or doing off yourself, you need to somehow authenticate that user. So let me just scroll down here. So remember how we said that you can return data from your load function, from your layout that is, and it's going to be available for your entire app, and here is the perfect use case for that. So of course this is more involved you going to first authenticate the user using hooks in CellKit and then through this event you going to get the session or the user data whatever it is from event locals So you going to get the session here and now you can use this from your anywhere in your app. So in this case for off.js it's returning this session and now you can check it in your template. So here you have some file, whatever, and now you have access to the page store and now Now you can make a check here. If page.data session, so remember, this is the same session that you returned from here. Okay, then you know the user is authenticated. And now you can display any data you want from that. You can show the user image or whatever else you need. And this is really what this is useful for. So I'm just chilling here in our API endpoint and I'm thinking to myself, hmm, how can I make this API more flexible? When you first created this API, I honestly wouldn't have blamed you if you thought that We just did the same thing that the dummy JSON API did, but not only do we own this API, now we can make it more flexible. So let's talk about how we can use the data from the URL. First I'm going to remove this limit here and the cache control header since we don't need this anymore. And basically if you think about it, the URL was the first staked manager before any of these fancy JavaScript frameworks existed. A staked for URL means you can use query parameters from the URL for providing options like filtering and sorting data. And SwellKit makes it easy to work with the URL and that's why the load function has some useful things. So we can get the URL from here which is an instance of URL which you can learn more about on MDN and it has properties like origin, hostname and pathname and also the search params which are going to be really useful in a second. You also get the route which has the name of the current directory relative to source slash routes. And you also have params which is derived from url.pathname and route.id. And if you go here, you can console log it out. So you can say url route params. Let's open the terminal. I'm going to save this. Let's rerun this. So now we can see all these options on the URL. Here is the route which you can get the id, and your params have other info if you have those. But what I want to do is to improve the existing posts API so I'm able to specify the amount of posts I want and set the order. So I want something like this. I want to go to posts, I want to be able to set a limit and I also want to be able to set an order that descending or ascending And basically now when we look here we get the search params and we don really have to do any crazy regex or whatever to get this It already parsed for us. We get the limit, we get the order, and this is all thanks to the web platform. Again, I know, you're already tired of me mentioning the web platform, all right? So if you go to MDN, you can learn more about this here. It's the same thing, URL search params. You're like, okay, how do I get anything from this? Okay, has, get all, okay, et cetera. Or you can be a true chat and just use TypeScript in your project. So you can just go here, and now since we have access to this, we can create a more flexible API. So let me just close the terminal. I'm going to remove this. So we won't need params route. We're just going to need the URL. And now we just need a way to get our limit and order. So I'm going to say limit, and this is going to be URL. URL, search params, and now we say get what we want to get, the limit. It's already parsed for us, right? Which is really awesome. And now we can set a default. If there's no limit, just return all the posts. And now we can set the order. We're going to say search params again, get, order, or we can set the default here. We can set ascending. And this is going to return a string, but we want a number so we can cast it here to a number. You can go to the end and you can just save it like this. So in our query here let's just make some space. We're going to add some more options. Prisma has this order by options and you can select what you want to order it by the ID and of course it already has options since we have great auto-completion it's ascending and descending and of course this is why I intentionally designed the API that way because Prisma expects ascending or descending. And now instead of using a literal string, we can just say order, and it's going to complain about some things, really, it's not important. We also need to specify the limit, so we can just say take, which is going to be the limit, not order. So yeah, that should work. So now if I go here, I'm going to save this, and right now nothing is happening, we also need to refresh. So we should get back four posts, and it should be in the reverse order. It should start from 30. So let's do this, and awesome. Now we get back 30, 29, 28, 27. And the beautiful thing is that the order here doesn't really matter. So we can for example remove this We can just say limit or if we don provide anything it should work the same And now let just say order So we can say descending So this should give us all the polls but in reverse order And everything works great. So honestly, that's it for this session, but I actually want to include some bonus, which is more food for thought. So using the URL for state management is not a unique concept and something we just started rediscovering because frameworks like SwellKit make working with the URL great again. So you're used for example to having component states for something like search but you can't share the link with someone else. So here is an example of this. If I told you to make a search like this you would probably do something similar like this but you would use some state in your component like the search query and that's how you would do it. But in SwellKit and these other frameworks what you can do is update the search params and the search params when they get updated they can rerun your load function and this can update the data on your page. So as you can see here is an example where you don't need any client state or state in your component. This is basically just has a form and is going to trigger the search and in the search get updated, the data is going to get updated for the page. Of course, you don't have to understand this everything. This is, as I said, just bonus content and something I honestly think even the swelky dog should include because this is really almost an old way but new way of thinking for people. So, for example, if I go here and let's look for Angelo and we get Angelo back and we really had no state. Let me just also show you how this works in practice. I'm going to zoom out because this UI is honestly mind-boggling sometimes. So, here's what I want. I want to open this in the new tab. So, let's just go to the end. I guess I'm going to copy the URL. It doesn't matter. So, you can see what's going to happen here. Okay, I just clicked on accident on someone. But let's say, let's search for Angelo again. and now as we typed if you go back to url you can see this was updated real time so for example imagine if you're working on a dashboard or something how useful this would be and now if this was a real site which it is of course i can just share this url with anyone like i can just copy this i close the tab right proof look at that confidence now i can just go here leave i guess it's going to close that but yeah you can see how this works and now you can preserve your state in the URL. And I also want to give a shout out to this library, which is Sveltee Search Params. This what I showed you right now looks a bit boilerplate-y, right? But here is a great library that someone made, which makes this really easy.

 how simple this is compared to what I showed. This is even simpler. And here you can just import the query param from SwellKit search params and you can just update the query param like this. And there is another great example. So you can just bind the value and update it easily like this. So I think this is something really exciting and something that we just started rediscovering again if you're in the JavaScript landscape because probably everyone else that works in PHP and those other environments are probably laughing at me right now. Next one is going to be a bit brain twisty. We're going to talk about using parent layout data. So far you learned how data returned from a parent load function becomes available to plus page svelte and plus.layout svelte components over the data prop. That's great but what if you need the parent layout data inside the child load function, in that case you can await the data using parent. I want to emphasize that it only works if you return the data from a layout. To show this I'm going to go to the deepest route which is our post so I can open the sidebar, I can go to source routes posts slug and I'm going to open the plus page.server.ts file and now here we have access to something interesting, we have the parent method. So let me just make space, I'm going to say const parent data, I have to await it, I can say parent and now let's log it out, parent data. When I run this code, what do you expect to see in the output? Let me just open the terminal and now I'm going to navigate to a post. It already preloaded the data so we can see something interesting. It returned the posts. And if you guessed that those are the four posts from routes-post-layout.server.ts, you would be right. Because that's the only parent layout load function that returns data so far. So we can go to post-layout like this. And here it is. you return the data from the load function in the layout. So I'm just going to close the terminal. Another thing you have to keep in mind is that you have to be careful to not introduce a waterfall if your data doesn't depend on the result of the parent because load functions run in parallel. If you never heard about this, when people say waterfall they usually mean a traffic jam in your network tab. So for example, if you request something from another load function, now that load function has to stop rendering because it has to wait for that parent data to get the data for the current load function and then you basically get into what looks like a waterfall in the network tab so i just going to close this file and open a new one just so i can show you an example so you can pretend that for example this is some page server ts file and now we export a load function like before so we can say const load which would be page load for example and now Now we can say async and now we can destructure the parent. So let's do it like that. And now let me show you what I mean. So first, we would want to get the data from the parent first. In this case, you obviously can't avoid it. This is why you're using it because you depend on the data. Now you can say parent data and say await parent. And now we have the second step because you need the parent data. And say data. And now you have some function, a call to a database or whatever. Get data. Now we can pass it the parent data. And this is fine if you have to do it. But what the SvelteKit documentation says is that you shouldn't do this and you should await the parent last so you don't block the rendering. So basically what happens here, parent load function runs first, we can even give it a hourglass, and then you have here, this load function is now blocked because it has to wait for the results of the first one. So you can just say stop. So now you have a better idea how this can stop rendering. So here is the ideal that you should do if you don't depend on that data. So if you go here, so again, the first step, this load function fires off. So we can even give it a nice running emoji like this. We also copy this over. so you can just say const data await get data not this get data and then you can say second the parent load function fires off const parent data await parent and now you won run into any blocking issues this is going to fire off then this is going to fire off and now the load functions can run in parallel as long as you keep this in mind you should be fine i hope you're not tired because there's one more thing we have to talk about and that is the secret life of load functions you should understand how load functions work because you're going to need to rerun a load function for the page which swill kid already does for you behind the scenes in most cases, but in some cases you might want to do it yourself. And how this works is that SvelteKit tracks the dependencies of each load function to avoid having to do the same work during navigation. So for example, let's take a look at the load function for the slug which shows our post. So if we type in slug, we're going to go here. The dependency here would be the params, so each time params.slug changes, SvelteKit is going to rerun the load function. Let's look at another example. So we can open page.ts in our routes and what is the dependency here? The dependency here is the URL inside the fetch, so api.post. If Swellkit sees that the post data hasn't changed, it's not going to rerun this function when you navigate to other pages. And remember from the start how this goes full circle. This is why this special fetch is going to inline the response in the HTML, so it's just going to reuse it. Also a load function that awaits the parent data from another load function will rerun if the parent load function reruns. If you need to manually rerun the load function, Svelke provides you some useful functions like invalidate, which you can pass a URL, or you can use invalidate all, which is going to rerun every load function. So be careful with that one. So let's look at an example here. I'm going to close this, and you can also create your own identifier. So for example, we already mentioned how this is an identifier, but you can create your own using the pens, so we can use the pens here, and you can name this whatever you want, you can go here, and you can say the pens, and you can name this banana if you want, or whatever, but I'm going to call it post, or the doc show you this really neat naming convention, you can use app, or whatever, I'm just going to keep it simple, and name it post, I'm going to save, so I'm going to change the API slightly here because I want to show you how this affects refetching the data on the page. So what I'm going to do here is return a random number of posts. I'm just going to get a random number here. We have to say math round and then you have to say math random times 30 because that the amount of posts And now here in the posts I going to use backticks like this And now I'm going to say limit, because remember, we enhanced our API. How cool is this? And now we can say random, so this should return a random number of posts when we validate this load function. And we can save it. Nothing changed, of course, beside the API. Now we get a random number of posts when you refresh the page, but we don't want to refresh the page, we just want to do it manually ourselves, invalidate the load function and rerun the data for the page. Alright, so now we have to go to the page which is going to be here, so source routes page. Remember here we have our posts and we're going to move it here. So what I'm now going to do below posts, I'm going to create a button and we can say rerun And this is just going to have a function onClick. We're going to name it rerunLoadFunction. We're going to create this function right now. Function rerunLoadFunction. It's not going to have any parameters. So now I'm going to show you all the ways that you can revalidate. So the first A method, I'm going to call it, is going to use the invalidate from CellKit. So we need to import invalidate from app.navigation. and now the first is using as we defined it here that depends this is going to be that let's also define a b option which is going to be invalidate again and now we can say api post and quote from this isn't going to work in this case because we created a unique url so we really can't account for that, but in case we have a stable URL, it's going to work. Alright, so let's introduce option number C, which is going to also use invalidate, but we're going to pass it a callback that takes a URL, and we can say URL ref, if it includes anything relating to post, it's going to rerun it, and let's also include the last option, which is going to be invalidate all. You should treat this as a nuclear option, so avoid this at all costs if you can. But let me just comment all of this out. Let me just save it. So when I press this button now, this should invalidate the data on the page and

 Refresh it. So let's see if this works. Awesome. And even if you open your network tab, let's get to the network tab, you're going to see it's going to make a fetch request. You can see it does a random one each time. So now let's look at all the others. Of course, this one won't work in this case because we have a unique URL. So if I clear this out, try it, it won't work. But it would work if you had a stable URL. So let's see the C1. So I'm going to clear it and I'm going to refetch post. Now I'm going to use the nuclear option invalidate all so I can also rerun it. Let's repeat what makes a load function rerun. If any reference to a property of params or URL changes, if the load function calls a wait parent and the parent reran, if you declared a dependency with fetch or depends and marked the URL invalid with invalidate URL, or if you use the nuclear option invalidate all to force every load function to rerun. Another thing worth noting is that this doesn't cause the component to be recreated, but it just updates the data prop for the page inside your plusPage.svelte or plusLayout.svelte component. But if you want to reset the component, you can use AfterNavigate or wrap your component in a key block. In the last part, we talked about data loading in SvelteKit, but in this part, we're going to learn how to work with forms in SvelteKit. So let's talk about the project setup first. Here I'm going to open the sidebar, and this is just a regular Skeleton SvelteKit project with TypeScript. So you can go to source, and really there isn't anything special here, I just have a root layout here. Let me just close the sidebar. So I include the PicoCSS. Someone asked me last time, hey, can I write global styles in the layout? And of course you can, you do it like this, so you can import whatever you want here globally. Then you can define some styles here, I want some padding for the body, and I want some rounded corners for the inputs and buttons. And this is how you can easily do it in SvelteKit. That's basically the setup and nothing special here. In the plus page 12 file, I just have a title here and nothing special. And of course, I'm running a development server. So if I go here, I have these default styles using Pico and here I just have a title. So if you want, feel free to catch up. All right, before we get started, I'm going to keep it simple and I'm going to create a fake database. And we're also going to learn something neat, which is server-only modules. So remember how we said that if you type for a file it going to be only available on the server And same for your data loading this works for any other file So for example here is how I going to do it I'm going to go to source, and I'm going to create new file. I'm going to create the lib folder, which as you already learned, is the default alias in SwellKit. And now inside, I can create either a file that's going to be called database server.ts, or I can create a folder, which I'm going to do here. I'm going to just say server, and now I can say database TS which is honestly even calling it generous a fake database because this is just going to be an array of to-dos. So let me just press enter and here I'm going to start by defining our type to-do. So it's going to have an ID which is going to be number. It's going to have a text which is going to be a string and completed which is going to be a boolean. So now I'm going to create our fancy database which is just going to be to-dos and this is going to use the to-do type which is going to be an array right and the first time I did it I over-engineered it completely I used the map or whatever and I was like okay it's time to stop just keep it simple an array is fine for me right and we don't need anything else right so let me just give one default example here so we can see that it works and of course I'm going to give it a date now for the id because I really don't care and now for the first one we're going to say learn how forms work and then we can say completed false. All right so let's just define a couple of functions and then we're done. So we can say export function get todos or whatever else you have and we're just going to return the todos and really need to do this because really can't just export this because it's going to be referenced forever so we always have to run some other function that's going to return the new updated todos and then let's keep it simple. I'm just going to scroll here. We can say export function add to do. This is going to accept the text, which is string. And we're going to create a to do, which should satisfy this type, right? So we're going to say ID date now. Let's just give it a text that we pass to the function. And we're going to say completed false. And now we just need to update the to do. So we can say to do this push. Oh dear, we're mutating data, oh no. Okay, let's save this and I can now define our remove to do function. I can say export function remove to do. It's going to take in an ID which is going to be number and this is going to be really simple We just going to reassign the value We can say todos Filter is going to take in a todo and we just have to say hey, does this todo not match the one we passed in? And it's just going to filter out the todos. And the last function I'm going to define, export function, clear todos. So you can clear the todos. And I'm just going to initialize the todos back to an empty array. All right, so that's it. In the next part, we're going to start to talk about forms. This part is going to be a reintroduction to forms. And why do I say a reintroduction? Because we kind of know how forms work, but we really don't. From years of using JavaScript frameworks and avoiding forms like the plague, so we used our event handlers on buttons and etc. And we kind of know what happens when we submit a form, but how does a form actually work? So I'm going to talk about that in this section. So let's start first by defining what a form is. A form is a way to exchange information between the browser and the server, and it's just a container for form controls, or also called widgets, believe it or not, as said on MDN, with some optional attributes to configure how the form behaves. So let's have a look at that. Alright, so inside the editor I'm going to go to Routes and I'm going to open the plus page svelte file and I'm going to start by defining a form. So we can say form, which is interesting, so what is this method? Yeah, that's interesting, right? And now we can define an action, and say login, and now we can close the form, and now we can specify some input fields, or as we just learned, they're called form controls. So we can say input type, which is really important, just tells the browser what type of input this is, you can have a button, you can have checkboxes, and et cetera, and this is the most important part. You have to specify a name, because this is used on the server to get the data, right? and we can also say input type password. So the browser now knows that input field is a password and knows to treat it as such and to hide the user input. And now we can also give it a name. We can say password. You don't really have to even finish closing this tag like this because these elements are also called void elements, which means they don't need a closing tag. But honestly, this is just habit. And now for the button, we can optionally say type submit, which is the default. and now you can say login, let's just save it and now we should get a beautiful form. So here in the form the action attribute defines the location URL where the forms collect data should be sent and the method attribute defines which HTTP method to send the data with And the form attributes are optional If you exclude for example the action it's just going to get or post to itself. So first, let's see how get works. The get method requests a resource from the server and appends the form data at the end of the URL. So what do you expect is going to happen when I type something in? So we can say test, one, two, three, four, and we're doing a get request so I can say login oh interesting so now it redirected us to the action which is slash login and now we can see it appended the login which is the user query params test and password 1234 so this is great to request a resource or maybe play around with query params but in case of this form this is actually insecure because you're showing the password in the url right it's also not great for sending a large amount of data over the wire because the body is empty and that's why this gets appended to the end of the URL. So let's change this method to post and save it. And I'm also going to go back like this. And basically the post method is similar to get, but it can return a resource depending on the data sent in the request body. And no data is going to be appended to the URL and the data is going to be included in the body instead. So let's see how this works. I'm going to open the network tab. and pay attention to what's going to happen. Of course, we get redirected again, and we can see here we get a response. So we can see here is the payload, user test and the password 1234. And we can also view the source. So again, instead of being appended to the end of the URL, it's going to be sent in the body to the server as a list of key value pairs. And this is why the name attribute is so important because if we didn't have the name attribute, then it wouldn't know what to assign to these values, right? And now on the server side we can just say, okay, give me the form data, whatever you have, and then we can just pluck the values from it. I'm going to show you how you can use API endpoints to work with forms. And this part is important for understanding how forms work because it's going to give you more appreciation when you learn how simple Svelkin makes working with forms in the next section. And this is also going to help us understand how that actually works under the hood. So next I'm going to create a to-do folder with some route files. So I'm going to go to our editor, I'm going to open the sidebar and if you have the SwellKit extension you can right click anywhere in your project or use the command palette in VS Code and we can say SwellKit files and you can create a route. So you can give it a name, we want to name the folder to do's and now you can

 select the files you want. So using spacebar I can say page swelt. We also want server ts. This is going to be the data for the page and we also want the endpoint for the form. So I'm going to press enter and now it's going to create it. So it's going to create the folder to do's. So now we have here the page.swelt file. We have our data for the page which we're going to fetch in a second and here is our endpoint. So let me just close the sidebar and first what we're going to do is fetch the data for the page which in our case is going to be the to do's. And you You might see this if you're using TypeScript, this satisfy page server load. I'm honestly not a huge fan of this because it makes the code harder to read for no actual benefit. So we can just remove this and I can just use it like this. We can say page server load and that's it. It works the same. Of course, satisfy is useful in other areas, but in this case, it really doesn't do anything. Alright, so because we're using TypeScript in our editor is super smart. So I can just say const todos, and now we're gonna start typing get todos. Aha, it's going to know that we should import this. So we can go here, and of course it's aliased, and we can just go here. So I'm going to say dollar sign. You would see what you would have to do if it wasn't aliased. So you would have to do all of this nonsense, which is really awesome because it's aliased by default. And if it's confused about this, you should restart your development server and it's going to work. So right now we can just return the todos inside of an object. Let me just save this and we can go here. And I love using pre, so we can say data. And now we should see the to-dos on the page if we go to slash to-dos. And actually, it's just going to show the one to-do. All right, so we have the page data and I'm just going to make a to-do. So we're going to create two functions. We're going to need a function to add a to-do, which is going to take the event of type event. And let's also make another to-do. I'm going to say function remove todo, and simple like that. So now we can go inside our template and we can loop over the todos. So let's go here, and I'm just going to say ul, and I have this each snippet, and now we can get the todos, we can say data todos is todo, and now we can put it inside an li, and we can use a span, so now we can say todo text, and now we're just going to use a form. And this might be weird to you if you used to JavaScript because you might be thinking okay in the past I just might have used the button here have an event handler so it really going to feel weird that you using forms in quotes for these small things, but don't be afraid, just use forms whenever you can, because that's the right way to do it. So I can say form, and then I can say on submit, so we're just going to use JavaScript in this case, we can say prevent default, which is provided by Svelte, and now we can say remove to do and the method is going to be post so let me just close the form and now I can define a button which is going to be type submit which is optional of course and I'm also going to give it a class delete which we're going to create in a second I'm going to do this and let's give it an emoji so we can say cross of course you should make this more accessible but the question is for example how are we going to send the id to the server right so you know what to do to remove it and And the answer is quite simple. We can just create a hidden input field which is going to send the ID to the server. So I can say input type hidden and now I can give it a name which we can grab on the server and for the value I can even say to do ID so we can grab the value. Alright, sweet. So now we can save it and we should see here is the first to do and we're going to include some styles in a second to make this better but we also need another form now. So this was the form for our to-do and to delete them. So we can go here, let's create another form, onSubmit, so we can say prevent default, and now we can use the to-do function, we can say method post, let's close the form, and this is straightforward, we can just say type text, I'm going to give it a name to-do, and then button, type submit, and we can just say add to do. And now let's add some styles. Oh, let me just do this. I can create a style tag. So now I'm going to say UL padding zero. Let's just give some styles for the LI. You can say justify content space between, align items center. And I'm also going to say for the span, text reform should be capitalized. And we just need to specify the delete and error classes. So I can say delete, margin zero. This is just some styling because of pickup So we can say background zero and border none Actually background is going to be none and border is going to be none also And now for the last error class we're going to be using in a minute, we can just say color tomato. All right, so let's save this and everything should look a lot nicer. So you can see here it's still complaining. It says, okay, I have no idea what this is. And usually you can restart the development server. So you can go here, say pinpm run dev, and this should resolve it. And I was going to generate whatever it needs, and you can see it's happy now. And as we learned previously, you can see how we didn't specify the action attribute for the forms because we're going to submit it to the same page. So now inside the server TS file, we're going to create the post and delete functions. So let me just scroll up here, and we already have the data here, so we really don't need this. I can just close this, I can go here. So let me just remove this response, And the first thing I'm going to do is actually declare a type data. And this is just going to be responsible for returning success and errors for the page. And this can be whatever you want. This is just the shape I decided on. So we can do things based on what is returned from this. So this is going to have a property success, which is a Boolean. And it's going to have an object of errors. And how we type errors in TypeScript, you can use record. And then we say, hey, the key is a string. And then we can also maybe say unknown for the value. but we can also give it string and this really isn't important. And now instead of using get because this is going to be a post submit we're actually going to use post and we need a request so we can get the form data right so we can go here and now we can say const form data so we can get the form data await request and type we can help us out so we can say request okay what is here form data nice and then we can get the to do so we can say form data get to do and this is the name of the field on the form, right? And now we need to make sure that this is a string because if you hover over this it's going to be formDataEntryValue. TypeScript really doesn't like this so you can just say string and that's it. So now I'm going to create the data object. I can say const data, actually let's give it the type data, this is why we created it. So I can say by default false and we can say errors which is going to be empty and now we can say if there is no to-do we can say data errors to do and we can say required which really isn important and then we should probably throw this and catch it on the front end but really this isn important so we can just return json we can use the helper from cell kit let's say json data and we can also give it a status which is going to be 400 and now if everything works i'm just going to go here and i'm going to say add to do this is going to auto import it from our file so you can see here it works everything nicely in the background. So let me just sort these things. Awesome. So we can say add to do and we can just pass it a text, right? And then we can say data success true. And we can also return the JSON with that data. Let's do it like this. I can save it. And now this is the post done. And the delete is also going to be simple. So we can go export const. you want to use delete going to be the same type request handler async you're going to the structure request let's say again form data again you're going to get the form everybody thinking yourself this is tedious and you can just abstract this inside the function or whatever so you can say form data and now we can say const to do id and we can say form data get and we call it id, right? So if I go here, let me just see. Yeah, we gave it a name id and this is going to give us the to-do id. So we can go back here and we need to cast it to a number because it's going to be a string. So we can do it like this and then we can just import remove to-do. So again, it's going to import it because TypeScript is smart like that. And now we can say remove to-do. We can pass it the to-do id and that's it. And let's return some JSON and we can even say success true and we can save this and that's basically it so now on our front end we can fill in the function so if I go here here is the attitude so let's fill that in but first we're going to need the same type so I can even scroll up here let's just copy paste it you can already see how this is starting to be tedious now we need to copy over that part data right and now I also need to keep track of whatever we're going to return so I can create this variable. This is going to hold data right. And now we can fill in the add to do. So we can say const form element event target we need to say as html form element.

 So TypeScript is happy. And then we can say data, new form data. And we can pass in the form element. And I'm also going to console.log it out. Like this. And we're going to see that in a second. But first I'm going to ping the endpoint. So I can say const response. And now you have to say await fetch. What we want to ping. We actually don't need to specify here. Because we have a reference to the form element. So we can say form element action. How awesome is that? And now we can give it some options. We can say method post and we can pass the data. So now before I continue, let me just show you how that works. So I can open the developer tools. Let me go to the console and now we can submit it or whatever. And we can see the form element is here. And now we have everything which has to do with that form. So we got the action. You can also get the method, but this can only be a post like this. So we type post. And you can also see the data. So instead of the form, let's log out data. So now if I type whatever, you can see form data. And let me see if I say log. And we can see the form data object and all the properties available on it. So we can get the value and etc. But I'm just going to remove this. And let's just continue. So now that we get the response, we really need to populate this form. This is why we did this data thing here. So now we can for example say const response data and now we can just await the JSON that we returned. So let me just console log it out so you can see what's going on. Response data. I'm going to clear this so let's not submit anything. We can see success false and now we get back the errors which is required. So we can use this in our template. But let's see what happens if we submit something so we can say test and now success is true and errors should be empty. So now basically what we need to say, we need to set the form variable. You can say form is equal to the response data. Another thing you can see is that this persists when you submit the form. And how do you reset the form? Well, you have access to the form, right? It's simple as saying form element reset. As you can see, you get great autocompletion. So now if I type test and submit it, it should disappear. There's one more thing we have to do. So you can see how nothing updated on the page. Let me see. if I refresh the page you should see ah here are the to that we typed in Okay so how can we fix this Let me just close this so we have space to work with And you can see here are the to And basically this is happening because we have to invalidate the page data and we have to rerun the load function. So in the data loading part, we learned that we can use invalidate, which we can use right here. So you can say await invalidate. Let's just use the nuclear option. You can say invalidate all. And I'm just going to save this. And now if you see, if I type in test and add it, it should update immediately. And awesome, it works. So you can see, let's just say banana, you can see it added banana. Alright so sweet, this wasn't that bad, right? So let's do the one for removing the to-do. And also I can just remove this placeholder. And let's do it. And now again I can say const form element, event target as html form element, I can say const data, new form data, so we just pass in the form. And now, again we can just say const response, we can say await fetch, use form element, action, and let's pass it some options. So an interesting thing is that a form can only do a post and get, so even if you do a delete, it's going to do a post to the server. And that's basically to the way the HTTP standard is made, and that's really a story for itself. But basically, Felcut is going to know what to do, because we created a function delete. So if we say here method delete, this should work without a problem. And now we can also pass it the form, we can say body data. And remember, we have to invalidate the data, so we can say await invalidate all, which is already imported here at the top for us. Alright, so now that's basically it. So we can just save this and now let's see if it works. So let me just start deleting things. Okay, awesome. And we can see how this works. Alright, but for example, how do we show the feedback to the user? So right now there's nothing, right? But remember, we returned this data thing, so it has a success and errors and this also gets updated, right? So now we can use this in the template. So here it is with the to-do. So let me just make space. I can just say if, and now we can say form. And because the next value might not exist, we can use this nifty trick, we can say errors, and because the to-do might not exist, we can also use a question mark. And now we can create the p tag which is going to have that class of error that we made and now we can say this field is required or whatever else you want and let also do one for success so here we can say if and now we can say form if there's success we can also give it a paragraph add it to do and let's give it some emoji we can say party so right now if i submit the form the user should see the feedback, which is me. So the field is required. Awesome. So now let's add something. We can say banana, edit, edit to do. And how awesome is this? And you can of course see everything in the network tab. So let's see how this works. If I go here and submit nothing, you should see 400 to do is empty. And if we submit something else, we should see new to do's, which is going to be test. And you can see in the preview and the response is the data which return. So this is the raw response. And here you can see errors, success. And for the other one that failed, we can go here, you get the errors back. And yeah, that's basically it. So this was basically just an exercise. So I can show you that it really doesn't matter what you return. It's basically up to you how you want to handle the error validation, which leads us to the next part. So this taught us a lot about forms and endpoints, but this is not a great user and developer experience. And why is that? Because, for example, this only works with JavaScript. So you can see here, for example, how we had to prevent the default form behavior. Now we had to go here. Even if we have a server right here, we had to implement all of this ourselves. We had to use fetch, which is really tedious. So imagine how it would look like with a more complicated form. We had to invent our own wonky validation like this thing isn't not ideal. I wouldn't use this, right? We also had to use fetch and invalidate all, which is the nuclear option, right? And really the framework should do more for you. And this is why you should use SvelteKit form actions and in the next section I'm going to show you why they're so awesome. So finally let's talk about SwellKit form actions. So remember how inside a standalone plus.server.ts endpoint you can use functions that map to HTTP verbs like get, post, and delete like we've done it here so you can see delete, post, and whatever else you want. But form actions take this idea a step further and you can define methods that map to an action inside a plus.server.ts file. So you can go here and you can export an Actions object which is going to map to the Actions in your form. I going to convert the previous example to use Form Actions First I going to delete this endpoint file because we not going to need it anymore So I can close it and I can go to the sidebar and let me just press delete and we can move it to trash because we don't need it. And now inside of here we can define the form actions. Nothing else changes about this file. You still use it to fetch the data for the page but now you can also define form actions. So let's start with creating actions for adding, removing, and clearing that to do items. So this is how you do it. You can say export const actions, and it uses the type actions, which is going to be imported for you. So let's put it at the top. And now you can give it an object. So this is going to use default if you don't have any actions on your form like this. But if you define a named action, which you're going to use, then you can't use default anymore. So now let's just define the actions we have. And this is really simple and awesome. Because also remember when we use post, right? So if I go here and where is it in our template, let me just go here. So for example, here it was for adding a to do, but now what if you want to clear the to do's or do something else or have three, four actions or have different forms? Now this starts to get hairy because every method is going to be post. So now you probably need to include some query params or have some hidden fields so you know on the server what you should do based on what it gets, right? And this is really tedious and annoying and form actions are amazing because of this. So let's just define our form actions. So we're going to have one that's going to be add to do. We can say async and also remember this takes in an event object like we've seen. Everywhere where you have something with data loading you're going to have this object. We already learned about this so you can have cookies, fetch, locals, params or whatever else. And we're going to take in our request from here and let's also add remove to do. So we're going to say remove. This is also going to be async and it's going to take the request. And we can also say clear to do's. And you can honestly keep it like this because this is just going to be the function that we created. But let's just be more clear what this is. So I can and just give it an empty function. I can just say clear to do's and this should auto import it for us. And let me just save everything and everything works. All right, sweet. So now we're going to see how much less code we're going to write.

 First, let's fill in add to do. I'm going to go here. So I can say const form data await request. It has form data on it. And now we can say const to do. And now we can use form data. We can say get to do. Let's turn this into a string. And now we're going to do some error validation, which is going to be way easier than what we did before. So now we're going to say if there is no to do, SwellKid has a handy fail function that we can return a status and whatever else we want. So we can say return import fail, which is going to import the function if we go here. So here it is, fail. And now let's see the argument. So we can give it a status. We can say 400. And now again, this is up to you. You can return whatever you want. So in our case, let's actually return the value so we can use it in case the form gets reset, then we can just repopulate it. So we can return the same value. We can say to do, and now we can say missing true or whatever. And this is going to be available on the same form prop that we've seen, but now it's official by SwellKit. All right, so that handles the error case. And let's just import a to do, and same as before, we pass it a to do. And now we can just return success true. And basically, let me save this. And now let's also fill in the remove to do. again we can say form data request form data let's say const do id and let's just say number because we already know and we can actually let's just get the id sometimes typescript is overzealous and this is because we need to also include await requests all right so now it's happy see how typescript saves your bacon i would notice this and i would waste minutes of my life Alright, sweet, so now let me just scroll up here and now I can say remove to do. Again I'm going to press enter, this is going to import it, let's just pass to do ID, everything should work great and we can return success. Alright, let me save this and this is it basically, you can already see how much less code this is. Alright, so now let's update our template. So if I go here and now I can remove all of this nonsense. I can remove these functions. Let me remove this. I'm going to remove this type. Ah, deleting code feels better than writing code, to be honest. We don need invalidate Alright sweet So now we have export let data This won change at all Ah now we have another thing from CellKit export let form which is going to be of the type action data And let me just instead of data I going to say form And right now there nothing, but we're going to see how we can update our template. So now we want to use JavaScript here. So we can remove on submit for the post. So this is just going to stay post. and now we can define the action, right? So how do we do it? And this might look like magic first. Okay, so check this out. So we say action question mark and we can say remove to do, but that wouldn't work, right? Because this is a query param and SwellKit won't know that this is an action or you're trying to invoke an action. So how do you do it in SwellKit? Well, you just add a slash here and now SwellKit knows that you want to call this function. All right, awesome. So now let's update the other form. How good does this feel, right? So we can delete this code and now we can say action. What was it? Question mark slash add to do and now we can update this. So we return form missing and now we can keep this as this field is required. And also let me show you something else what is cool. So we want to clear the to do's, right? So if I add this button, we can say clear. Okay, but how do we do it? So let me first add a class which is going to be secondary and this is of course optional but I like having it. Let me just save it so you can see here we have cleared. Okay but how can we invoke other functions right because we specified here that this form should invoke add to do. Well simple this isn't a SwillKit API or anything this is using web standards. So on the button you can use this property form action. If specified it overrides the action attribute of the button's form owner. Okay so this is going to override it. Awesome. So let's see. Form action. And now we can again say question mark slash clear to do's and save it. How awesome is this? And here nothing changed. We again return success. So this should work. One downside though is that this type generation is sometimes wonky like here. For example, here you can see it's form missing, but you're going to see that this should work. So when I go here, let's first see the error handling. So I can say add to do. This field is required. Also notice how our browser refresh because we're not using JavaScript. And this is why your app is going to be more resilient because it's going to work before JavaScript. So you can see how we get back the to do and missing So basically the editor doesn know about this But what you can do you can press control Ctrl type the pointy boy you can say restart language server and sometimes that going to do it sometimes you need to restart the development server and really if continuous erroring like this just ignore it, because you can see everything works just fine. Alright, so let's see, we can say test, we can submit it, ah, how awesome is this, alright, let's see if we can delete it, ah, awesome. Awesome. So now let's add it back again. Let's add more things. And now let's see if clear is going to work, right? Ah, awesome. How beautiful is this? So let's also look at the network type, right? Let's see what's going on. I'm always curious about that, you know me. So for example, we can just add a banana. So we can see all this junk here and we can see how this is parsed. So in the headers, it did slash deduce. You can see this is a query parameter but because it uses a slash, Svelkin knows it should invoke this function. And you can see the payload here. So it parses the query string here. And you also get the form data, which is really awesome. So you can see the preview and the response here, which is going to be the HTML document, of course. So let's try removing this. And this should also update. Of course, it does a complete refresh. You can see here is the ID and the parse query string parameters. And again, actions might look like magic, but they're just a URL that invokes a function. As you've seen, SvelteKit makes it special by including a slash that lets SvelteKit know, hey, I should execute this method. So you can see how this is really an awesome mental model. You can have as many actions as you want and forms and etc. You can just go here to your actions object. You can just add a new one. Let's talk about progressive form enhancement. So we've seen how already this is really awesome. So we can add our to do's or whatever else. But the page refresh is really not a big deal. But what if you want to preserve that awesome single page application experience. And this is what progressive form enhancement is for. Let's pretend that in this case the user doesn't have JavaScript because it can fail for whatever reason, right? Your form is still going to work and etc. But if the JavaScript is available on the page, we can enhance the user experience. So we can do client-side validation or whatever else you want. And let's see how simple this is to do. And remember, the point is not that your site should work without JavaScript, but before it. Because JavaScript can fail and this is what makes your app more resilient. So remember in the first example how we had to do everything by hand? Well basically Svelte does that for you and wraps everything in a pretty bow in a neat use and hands Svelte action This is unrelated to Form action This is Svelte actions which let you hook into lifecycle methods of elements So how do we do this This might sound like super complicated but believe me, it's one line of code if you count the import. All right, so how do we make this work? We can go here to the form, and now we can start using a svelte action. We can say use enhance, and as you start typing enhance, you can import it. So you can see here at the top, imported and hence from app forms ah awesome so now let me just copy this over that's it that's all trust me so now we can go here to the other form we can say use and hence ah interesting so what happens now you can see now if you look here the page isn't going to refresh ah awesome how awesome is this say test or whatever and now we can also remove the deduce and notice now we get that awesome experience but let's see what's going on in the network tab right So let me just do delete like this. And now instead of refreshing the page, right, it's going to use JavaScript and client-side rendering because the JavaScript is available on the page. So you can see fetch request. And here it is. You can see preview. It returns the data status and the type which you're going to look into. Here is the raw response. And let me just close this. So when you submit the form using the use enhance action, it's going to update the form. So right here, it's going to update this. It's going to update the $page.formStore and it's going to update the $page.status property. It's also going to reset the form and rerun the load function for the page so you don't have to use invalidate all yourself. And in a case of a redirect, it's going to use goto. So you can see if we go here and add whatever, it's going to work just great. And also the error handling, so you can see here it updates live. And this is why I wanted to show you previously how you can work with forms using an API endpoint so you can understand actually what Svelky does under the hood. Otherwise, you would just use this and treat it as black magic, which I honestly don't like. I love magic, but I also love understanding how things work. And let's look at the implementation, which really isn't spooky. I honestly maybe don't understand half of this, but if you can at least understand the general idea of what it's doing, and this is going to look really familiar. Okay, so when I look at something like this, I'm like, okay, junk, junk, I really don't care about this series. Oh, here it is. Here is the magic sauce. Here is the Svelte actions. I already know about Svelte actions, right? So I can see, okay, export, enhance. It accepts a form, write and a submit value. And we can already start seeing something

 familiar things here. We can ignore this. Here it has a handle submit. So it really does the equivalent to what we've done before. It prevents the default behavior of the form. Here it specifies an action. Then it does again that things with the form data, right? Oh, how familiar is this, right? You really don't need to understand these things, but get a high level concept of how it understands. And this is going to give you more confidence in working with these things, right? And here's the abort controller so you can prevent requests and et cetera. And really here is the response so it's trying a response ah this looks really familiar right look await fetch action method post here is some special sauce headers right really not important and you can see some other things which you can dive into and basically that's it and here is a cleanup if you know what swell actions are all right friends how cool is this but now i want to show you how you can customize the enhance action and we're going to use it to show a loading ui so how can you customize the behavior of the use enhance action and you can do it by providing a submit function that runs before the form is submitted so here you can do your validation or whatever and then you can also return a callback that has access to the result so let's see how this looks like so here for example where i have add to do we won't add it for the removing of the to do so we can just go here and where it use enhance is now we can specify a function so you can just say add to do you can name this whatever you want, whatever flows your boat like banana, right? So we can go here and now we can define a function and I'm going to do it using an arrow function because I want to use the type, which wouldn't be possible using a regular function. So I'm going to say const add to do and this is of type submit function. So this should import it from app forms. All right. So now here we have the first argument, which is going to be the input. and now let me just look like this and now inside of here you can do something before the form submits so now maybe you can here do validation of the inputs or whatever because we're going to see what you have access to here and this is maybe you don't really want to submit the form to the server right for no reason if you can already validate the data for example let me say that i'm typing my name here and it's really a frustrating user experience if you find out your name is taken once you submit the form. I want to know immediately if my name is taken. You know what I'm talking about. How many annoying sites do this, right? So this is something you can do here. And then you can provide a return function So you can say return async and this has options so you can do it like this and this is do something after the form submits and you can see because we using our custom callback functions the form isn't going to work using the use enhance method and we're going to see how to make that work again so let's just see what do we get so we can say console.log input and now we can also go here options let me save this and now I'm going to open the developer tools let's just go to the console and now let's just type something in so this is really interesting so for the input we get this object we get an action which is a URL you can get cancel methods you can cancel the request this is the abort controller which you can also use for canceling requests here is the form data itself right how awesome and you have access also to the form element and here is very similar for options. It has an action, it has the form data, the form itself, but it also has a result which we're going to learn about in the next section. How awesome is that? And here we have something which we can use. So we can do whatever we want here and we can call this update. And this update function is basically going to run the logic it would do otherwise if you didn't specify a custom callback. Otherwise you would have to re-implement all that fetch nonsense yourself and etc. but SwellKit really makes this easy. So let's look at the real use case for this. You can't always rely on a fast response from the server, in which case the user might leave your site because it looks completely broken. So what I'm going to do next, let me just close this, I'm going to go inside pageServer TS and I'm going to define a sleep function which is going to simulate a slow response. So right after the load function we can define it here. we can say async function sleep is going to take in milliseconds and then we can just say return new promise like this we can use resolve and we can say set timeout and we can just resolve it in whatever time we pass in so i can save this and now that we have this nice helper you can put this in your utils or whatever let's just go here and before we add that you do we're going to simulate a slow network. You can also do it from your developer tools or whatever. But I can just say await sleep and we can say two seconds. So now if I go here and add a beautiful banana, you should see oh there's no feedback and the user is already starting to be frustrated. They're like okay, what is happening? And in this case nothing is happening because we lost the default behavior So if I go here let me just The structure update And now we can say await update And we can also remove this output because we don't really need it here. Just remove this. I'm going to save it. So now, again, let's try adding something. Again, nothing is happening. It's going to take two seconds. And, ah, you see. And we already submitted the old one. So now we get two bananas, which is awesome. Two bananas is better than one. Okay, so how can we give the user something useful, right? So let's first define some state in our components. So we can say let loading false. All right, so now you know that here you can do something before the form submits, and here you can do something after it's done. So do you already know the solution? So of course, we can go here. We can just say loading automatically to true. And let me just bump this up. So we can say loading false when it's done, right? We can say false, and it's going to update. And now also let me update the template. So if I go to adding our to-do, Pico has this awesome thing, which is ARIA busy. So if ARIA busy is true, it's going to show a loading spinner, which is really awesome. So you can say ARIA busy. And we already have a boolean, right? It's the loading. How awesome is this? And we can also give it a conditional class. We can do it like this, class secondary. What is the boolean? Loading. Let me just save this. How awesome is this, friends? So now if we go here and I can say one, two, three, four, whatever. Now this should show a loading spinner here because it's going to take two seconds. All right, see how awesome. And we can also even make this better. So here where the text is, let me just like this. And now we can just do if it's not loading, show the text. So you can just say add to do. Let me just save this. And we can put this on one line, but who really cares? Okay, so now let's go here and we can start adding something. Alright, so now it's going to take two seconds and awesome. And you can also disable the input or whatever you want. Alright, so how awesome is this? So now for example, if you get an error or success state, you can show a toast notification to the user, which is really awesome, but I'm going to leave that to you as an exercise. Alright friends, let's learn how we can do form validation in SvelteKit. And first I'm going to show you the hard way and then I'm going to show you how we can use a popular schema validation library like Zod and show you a couple of tricks along the way. And I going to create a login route using this first example So this is from pluspage We can just copy over this form and now I going to close it and let go to the routes We can say SvelteKit files create route we going to create a login route we going to need plus page.svelte and we're going to need plus page server ts for the form actions. So let's press enter and now you should have a login folder. So here is our page and here is our endpoints, so we can just remove everything here, we're going to need it and here let me just copy this form over so we really don't need to specify an action here because it's going to point to itself which is already slash login but i'm going to import using hands like this which is awesome and i can even specify they should use style script all right so let's save it all right so let me go to that route we can say slash login and now Now, if I submit it, nothing is going to happen, right? So we can say required, which is natively supported in the browser. So now if I try to submit, it's going to say, hey, please fill out this field. But there's a problem with this. Any hacker man can come along and they can inspect this and they can say, okay, required, not today. Type password. I really feel like you should submit an email today. And this is going to cause chaos, okay? And this is why you should always do server-side validation. Alright, so I'm going to close this and I'm going to remove required for now because it's going to get in the way. And now I can go to the page.server.ts file and we can say export const actions. It has the type actions, which should be imported. So we can use the default method and we can just structure request like this and awesome. Alright, so let's get started. First, we need to get the form data, of course, const form data. and say await request form data and now we need to get the input value so we can say user and we can say form data get user and then I can just copy this over and we can say password and of course we need to turn this into a string and you can already see how this is starting to feel tedious because imagine if you had something more complicated and yeah I'm just painting a picture here So alright, so here is something else we need to do. Now we need to invent our own way again how to handle errors. You can do this many ways, but I'm just going to have an errors object. And if the error object has anything in it, we're just going to return the errors. So I can say const errors, going to be an object. Let's just give it a type like this. So remember record.

 and we can say the key should be a string and unknown. And this really isn't important. So this should be empty. And now let's do the validation, right? So let me just make space here. So it's readable. And now again, now you have to do your own validation and you might not be even thinking about this thing. So for example, you might be thinking, okay, if the user doesn't exist, maybe that's it. But you also need to check that they're not screwing with you. So you have to say type of user. So if this is a string, right? and then if this fails we can say errors user required but really doesn't matter what you say here okay so now we have to do the same thing for the password so now you just have to say password or type of password is it equal string and i'm already falling asleep i don't know about you and now we can say errors password required and all right this is how everything is going to work So now we can say if, so now we need to get the length. We can say object keys and we can pass errors. And now we can say, hey, is there any errors here? And then we can do something. And also here I can just fix this. It's not free assets. So you can just do it like this. Awesome. That is resolved. And now we can do this validation. So now we can return fail. So if I press enter, it's going to import it. Let's see at the top. All right, that worked fine. and now we can give it status and we're going to return some data and let's just make this more readable so I'm going to define it like this I can say const data okay so the first thing I want to return is some data right and then I'm also going to return the errors all right but how do I return this data and basically I just want to turn the form data into some object we can get so we can say object from entries and we can pass it form data and this is going to return an object instead of form data and we can just return the errors and that's basically it it really doesn't look complicated but again it's really tedious right and for the last part we can say if everything was successful let's learn about a new thing okay so how can we redirect okay swelkit also has a useful method for this so we can throw a redirect you can auto import it so it's going to import redirect, okay now awesome. Let's see what are the options. You can specify a status, let's say 303, and where do we want to redirect? Well let pretend the user is logged in and now they can go to the to So now we really didn use the validation in the template but let say if we type test1234 it should redirect to todo Alright, awesome. Alright, so now we can go to the template, and again, we need the form data, so we can say export let form, which is going to be action data. Let me just do my snippet here, so you can see what's going on. Alright, so this is really cool. So for example, if we don't specify anything, we're going to get this shape. So you're going to get data, user, password, empty, and the errors, right? Which is really awesome. And then let's say we specify the username or whatever. You can see here is the user. So now because the form resets, we can use this value here. So let me just show you. And let me just go here. I'm just going to make space here. We can go to the user. And now here we can say value. And now we can say form data. If user is on here, we can use that value. otherwise we can say hey just leave it empty and then let's do some validation we can say form errors user let's also not forget the question mark and we can also give it a paragraph let's see paragraph class error and now we can say name is required all right so let's copy this over we're going to do the same for password. You can already see this is easy. So we can say password and you can say password is required. All right. So let's save everything and let's specify some style. So you can say style error color tomato. So now we can see here password is required. Let me just remove this so you can see we get both name is required. So if we input our password. Name is required, but if we do this, everything should work great, and it should redirect us. Awesome. Let me just refresh for good measure, and now we can see what's going on. Again, here, password required, and that's how we can output this in the template. All right, this is really cool, but again, as I said, this is really tedious. Imagine if you had something more complicated, now we have to do all of these if statements. You need to get the data from the form, and this is where Zod comes in, and Zod is basically going to validate the schema, which you can set up yourself, so we don't really need to do this if or whatever. And the template is actually going to stay the same, which is really awesome. So I'm going to open the terminal, let's stop the development server, and now I can say pnpmi zod and I going to use another package which is zod form data which is really awesome because we can just pass the form data or URL search params which we can parse and it can validate that So let me just do that quickly And another awesome thing about Zod form data is a great example of using web standards because that package was made for Remix, but because Remix and SwellKit use the web platform, it works flawlessly. All right, so let's start the development server again. Let's close this. So now let's change this example to use Zod for validation. And I'm just going to remove everything here just so we can see how that works. All right, so let's make some space. And now again, we just need the form data. So we can say await request form data. So now we can define the schema. And how do you do that? And we can say login schema. And we're going to use Zod form data. So we can say ZFD and this should be auto imported. Awesome. And then we can say form data. And now you can define your schema instead of doing all those if conditionals, right? And what are the fields? We can say user. So we can say ZFD type of text, or we can even use ZOD, which also has validation methods. And we also have password on it, which would be ZFD text. And this is really awesome. All right, so we need to parse it. So we can say const result and we can say login schema and on the login schema we can invoke save parse and we're going to pass it the form data and this is why this library is so awesome. So let me just scroll up and I'm just going to put it like this and now we need to check if there was an error so you can do it by saying hey if the result wasn't a success and now we can do the same thing that we did before. So I can say return fail. We can give it 400 and we can return the data. You can see what is going on. So you can say data and this is awesome. All right. So how do we return back the data? I can just say object from entries and let's pass form data back in. And now for the errors, which is more interesting. You can learn more about this by reading the ZOD documentation. from the result you get error and we can flatten it and now we can also return the field errors so let's return the field errors and lastly let's also do our redirect so we can say throw redirect if everything is fine 303 slash deduce all right let save everything and you can see already how this is so much nicer and easier and now you can store these schemas in a separate file You can abstract this validation logic in another file And you can pass it form data and the schema. And you can return back the data and errors if you want and make it reusable. And as I said before, you shouldn't have to change anything here. And now when you go here, let's see if this works. You can see data, user password, and the errors. And of course, I don't know how to type because you can see here we're using two R's. And here, let me just see errors. Yeah, left. We can just do this. And let's see. Okay, now name is required, password is required. So I can say test. Awesome. So now if we just do this and let's submit. Okay, so now let's do both. And this should redirect us to deduce. Awesome. How awesome is this, right? Of course, this isn't the only way to do validation with Zod. and you can read more about error handling in Zotron and documentation, but form validation honestly deserves its own video. Alright friends, in the last part I want to show you some advanced enhanced action customization. For example, I mentioned how actions can be invoked from other pages, and in this example I want to reuse this login form, so I just want to copy it over, let me just close it, and here in the page svelte, which is our homepage or root, we can just replace it, and let me just save it. So now if you go here, and you would maybe expect that this would work, and if we go here, of course it wouldn't. It's undefined because the form didn't get updated because it has no idea. Even if we, let me just, we have to say action. It should go to login, right? Because we're inside our root, and we're going to basically target the slash login. So now we go here. Again, nothing is happening. The redirect should only work. So now if we type anything here, it should redirect to deduce. but how do we make this work and we can make this work customizing the use enhance action so for example i can go here let me just say login and now we can go here and i can say cons login which is type submit function so it's going to get auto imported for us and let's just do this and now we can return the callback which is going to be async so previously we learned about update right and You might be thinking, okay, maybe if I try update, but you're going to see this isn't going to work, right? Because this isn't going to update the form data for other routes but only for itself. Alright, so here is something else we can do.

 Besides update, you get this awesome result. So let me just console.logout result. And let's open the developer tools. And now when we submit it, you can see we return from the action type failure status and even the data with the data and errors. And how awesome is this? So you can see right now it's not even going to redirect because again, we provided a custom callback. So now when I say test, one, two, three, four, this should be a redirect. So you can see redirect, status, and the type. How awesome is this? So now you can use the applyAction method, which unlike update, can update this form property and the store for the form from anywhere. So you can first get the result like we did it now. But now let me just say await and we can import applyAction. So it even tells you what it does. The action updates the form property of the current page with the given data and update the store. And in case of an error, it's going to redirect to the nearest error page. You're going to see how this works in a second. So you can say apply action. And now you can pass this result, right? So look at this. So now when we, let me just close this. So now when we press login, it's going to return the data, which can be reused anywhere. How awesome is this? So now name is required. And now if you say test1234, now we should redirect to deduce. And how awesome is this because now you can reuse this anywhere and you don't have to again specify the same actions and return the same data. All right but let's have a closer look at apply action. So let's just console out the result which we already did but what does apply action really do and really it depends on the result.type. So if we go here let me just remove this so we can make space and say result type and now we have everything here from success to whatever else so you have error, failure, redirect so let's say for example that we only want to do something when it's a success otherwise it won't do anything we can just go here then you can do whatever you feel like doing here and then you can say await apply action and you can pass it back the result and this is only going to do what this logic does in the case the result type is a success and nothing else So for example in this case this is only going to redirect us on success or if there a redirect So for example let change this to redirect but this really isn going to return data for validation, et cetera. So if I press login here, we shouldn't get validation back because this is only going to apply the logic related to this type of result type. So if you press login, ah, you can see it doesn't work, but it's only going to do this if the type is redirect. So now it gets back to redirect and that's how that works. And this might be really confusing at first, the difference between update and apply action, but just so you're aware of it and when you run into that situation where you need it, then you can be like, okay, maybe I should go back and rewatch this or I should read the documentation. So based on the result type, if you get success and failure, it's going to update the form, the $page.form and $page.status, regardless where you're submitting form. This is the difference between apply action and update. And if it catches a redirect, it's going to invoke goto and use result.location, and if it gets an error, it's going to render the nearest plus error.svelte page. This way you can customize the behavior of the useEnhance action and dip in and out of the regular behavior when you need it. In this part of the SvelteKit series, we're going to learn about using advanced layouts in SvelteKit and why they're so useful. So if you want to get started, I have this project here I set up in advance, so in the post if you want to follow along the easiest way is to open the project on stack blitz so you can see it's easy as opening a link which is really awesome or if you prefer your local development i have instructions in the post so you can clone the project install the dependencies and run it and then you're going to have this development environment here okay so let me just close this and let's continue all right friends before we get started let's first talk about the problem i'm working on this million dollar idea which is plume a site for discovering and sharing inspiring quotes. Don't ask me about the business model, first we need to focus on growth and then we can talk about it in 10 years. And also by the way, hot tip, if you need to come up with a cool sounding name, just use a word and translate one of those cool Latin languages like French, Italian or whatever else. Or you can spice it up with some German or Japanese. Alright friends, so what is the problem? Before I can ship the Yacht to C, I need to ship this code to production, but I have some problems here. And let me turn on some hacks, so I'm going to go to my developer tools here, Let me just enable layouts so we can visualize how these layouts work. And really this project isn't really anything complicated. I just running a basic SwellKit development server So here in source we have routes and here we have admin and quotes and really nothing special So here are the ID and tags And if you look at here, here is the root layout, and then we have quotes. So now we can see here is the nested layout because quotes inherits the root layout as we learned previously in layouts. So now this all works as expected, but what is the problem here? For example, I have this admin folder here and really want to use a separate layout for that. So for example, investors are tech savvy and I'm going to look like a clown because if you go to the dashboard, which is the admin section, now it shares the root layout and the admin layout when I want a separate layout for this. So that's not a great look, right? And also another problem I have, let's say we go to quotes. This looks all great, right? So we can go by tags or go to the quote itself. So let's see, we can go here. And that really looks great. So you can see how we share the same layout for quotes, ID, and all the children. This is exactly what I want. I just want to show more quotes in all of the child. That's why I'm using this quotes layout. But here's a problem. If I, for example, go to the tags, now because tags shares the same layout as slash quotes, lives under slash quotes, right? It's going to inherit that quotes layout when I just want to show the tags and the root layout, so I want to keep the navigation, right? This is another problem that you're going to need to solve. To solve this problem, we can use group layouts. All right, so what are group layouts? Group layouts basically let you group related routes inside a directory which is wrapped in parentheses, but they don't create a new route. So if you remember this embarrassing admin section, we really want to create a separate admin layout for this and let's say that the plume side, all of this code stack which is user facing, we can say that this is going to be an app layout. So again, everything here that's user facing is going to be the app layout and then let's say pretend when we log in into admin, this would use a separate admin layout. Alright, so let's see how this works. I'm going to open the sidebar. I'm going to go to routes, and I'm going to start creating some folders, which you can name whatever, but I'm going to name it app, and I'm going to name it dashboard. And now it's easy as dragging folders around. So just ask yourself the question, alright, so what belongs in these folders? And the admin one is going to be the simplest. It already has a layout here, which is going to apply to the children, and let's just drag it into dashboard. Let's say move and you might have this prompt to update imports, but just say no, unless you have to of course. And that's basically it for the dashboard section. So ok let look at the rest of our application We have quotes ok let just move this into app because that where it belongs right But this really isn going to work yet because we need to update or in fact we need to add a layout to the app because right now we're using the root layout. So if we open the root layout, I'm just going to select everything and copy it over and here I'm going to just leave what's necessary like the global styles and etc. So let's see what we don't need here anymore. We don't need this navigation anymore because we're going to define that in the app layout, And I'm also going to remove these tiles here. Let's leave this. Also, don't forget to use slot. And now I don't need this anymore. And I can leave everything else. And awesome. That looks great, right? Let's just go to here inside the wrap. And let's go new file plus layout. So we can create a new layout for the app layout, right? Our admin layout is now working beautifully, which is great. and now we can remove things that we don't need here so i don't need this we want the navigation of course i don't need my dev tools anymore here we don't think of global styles in app and we can just remove this import let's just save and now when we navigate you would expect it to work right but there's going to be one problem so let's first navigate to our site and all right okay what is going on like this is confusing where is the navigation right and basically if you remember let me just close this layout and i'm going to collapse everything just so we know where we are. If you remember in routes, we have this root layout here and this homepage is right here, right? But it doesn't have anything in this root layout anymore. It doesn't have the navigation, etc. So if I close this, if you want this page to be the root of one of your group layouts, you can just drag it in the group layout. So I'm just going to take this plus page.sale file and I'm going to drag it into app and that's simple as that. Okay, so let's move it. And now everything works. Let me just close everything. and how awesome is this? So we can go to quotes, everything works just like before and now we can go to the dashboard. Ah, great. Okay, so let's go back. So next let's fix the tags layout. If you remember the problem I had, if we go, let me turn on my hacks and also let's recap. So here we have root and let me just rename if I go here to routes app because this should be named app instead of root. Awesome. Let me just close this. So as you can see, here is the app layout. When you go to quote, same as before, quote layout. But remember, when I go to a quote, this is great. But if I go to tags, I just want to show the

 tags and not use these quotes layouts, so I don't want other quotes and etc. So how can we fix this? If I go here, I'm just going to collapse it just so we know where we are, because it's really confusing having to navigate all of these things. It's in a CIDAR app, quotes, and now we already explained what this problem is, so we can create two separate group layouts in quotes, which is going to be one for the ID and the tags. So I'm going to do this by creating a new folder and I'm going to name this quote and I'm going to name the other one tags. And that's it. So same as before, we just need to start dragging things around. Alright, so we have the ID, where does that go? That's related to the quote, right? So we can just move this inside quote, let's say no, and the tags go to the tags group layout. Awesome. And when we refresh, it's not done yet because we need to move this plus layout server ts and plus layout svelte because this is related to the tags, right? So this is going to show more quotes and we just need to move it to its corresponding group layout which is going to be quote. So let's just select those two and we can move it to quote. And let me just close this. This is going to error for a second. And if you refresh, ah, it works, right? And now, for example, we're going to see a problem when you go to quotes. we're going to see nothing because again remember here it is this plus page.svelte file which we need to move into quote right so if we see it here here is this cover and share inspiring quotes actually this is the starting one as i already told you this like gets confusing really fast so this here is the plus page so i really wish in vs code it would be so much easier to parse this folder structure it would give you line spacing or whatever but that's besides this point so as As you can see, here it is. Here is where it picks a random quote and whatever. And we just need to move this file inside our quote. So let's just move it here. And everything should work great. Even though it says error, don't trust it. Okay, so now we can see. Let me just close everything here. Let's see. Don't save. Just close everything here. And let me turn on the hex. Okay, so now we're going to go see here is our homepage. So now we're going to quotes. Everything works great. we can go and share it if we want. So let's see if we go to text, oh, how awesome is this? So this really isn going to inherit that layout And this is really awesome And now even if we go to quotes and again let find this quote and if we go to the inspirational one we not going to see more quotes here and now we change the layout successfully so as you already seen group layouts aren that bad but i think what makes them confusing or difficult is when you start nesting layouts like this because you can think of group layouts as a bucket to put things into but if you're not confident in using layouts yet this is going to be hard to wrap your head around so if you're not sure when to use a layout ask yourself if the child routes of a given route have some repeating content. In that case, a layout makes perfect sense. And also remember that we previously learned that data return from a layout's load function is available to child routes in your application, which is really useful. And of course, you don't have to use group layouts, so put this away in your pocket in case when you need it and focus on the fundamentals instead. Alright, if you thought this was mind bending, in the next section I'm going to show you that individual pages and layouts can also change layouts. Alright, so if you thought that group layouts aren't mind-wending enough, let's talk about how we can break out of layouts. So we learned that group layouts are nice for related routes, but what if you want to use a different layout for a specific page or layout? And you can do that. So for example, if we go to the quotes, let's find a beautiful quote. So we can go to that quote, and let's say for example that we don't want these other quotes and we want to use some other layout like the app layout. Let's first find where it is in our quote. So you can go to routes, app, quotes, going to be quote ID and quote ID. So you can see here is the file plus page.svelte that inherits the parent layout. So inherits the quotes layout and quote layout inherits the app layout. All right. So how can we use this app layout? We can just rename plus page.svelte. We can use the add symbol. And if you leave it blank, it's going to use the root layout since this is an empty string. But we want to just use another layout. So you can specify the layout you want to use, which should be a parent. In this case it's app. So now when we save this, let's see what happens. How beautiful it is. And we can even turn our hacks back on. So now you can see it only uses the app layout. And how awesome is this. And you probably looked up how to reset a layout in SwellKit and were confused when you read that you need to use a blank root layout, which doesn't make any sense until you learn about group layouts and how to break out of layouts. So if you want to reset a layout, you have to have a blank root layout. So if you remember, let me just collapse all of this. If you remember, we have this blank layout right here. And here is what Celci is going to reference when you leave a blank layout and it going to use the root layout And this is how you reset to a root layout So I going to close it and let see that in action So for example if I go to tags maybe I don't want this navigation. Maybe I just want a separate page that just shows tags and doesn't use any layout and I want to reset it to the root layout. So let's see how we can do this. So let's first find where our tags are. That's in app quotes tags right here. So let me just create a new layout for tags. I'm going to say plus layout svelte. I'm going to just define an empty script tag and let me see if it auto imports visualize awesome because I just want to show it to you. And now we can give it a name. Let's say tags or whatever I had. And then let's just say main. I have this class space so it looks great. And then don't forget about the slot. Let's save and it works same as before but now we have a new layout and how can we reset this layout right so if i open the sidebar again and remember if i collapse this so it's easier to see here is our layout svelte which is this file so now we can change this layout for the layout itself okay so now when we go to rename we can just say at this is an empty string and this is going to use the root layout all right so now when i do this oh how awesome is this so now you reset this layout the tags layout to the root layout. And now even if we turn on the hacks, you can see this is the tags layout. And how awesome is this? Alright, so now you know how to break out of layouts if you have to. Today I'm going to show you something cool and that is what are SwellKit hooks and how to use them for example. So what are even hooks? Hooks can mean different things depending where you come from, but in the case of SwellKit, you can think of hooks as middleware. But they're more special because hooks can attach themselves to some other events and trigger behavior based on that. So if you look at this example I made here, here is the client and the server, and usually you just send a request to the server and get the response. But in case of middleware or hooks, we can basically hook into the request, right? We can change the request, which is going to change the response. And you can do a lot of things. We can use this for authentication, modifying the response. We can use it for error and performance logging, and even creating automatic routes. So it uses a special hooks file that can be run on the client or server, and it provides you with some server hooks like handle, handle fetch, and some shared hooks like handle error. But instead of boring you with theory and exploring every API of hooks I going to show you examples to spark your imagination because you really might not use hooks ever You definitely going to encounter them if you use something like authentication but even in that case the library you using is just going to give you the hook you just going to include in the hooks file. So let's really understand what are hooks and how to use them. All right, so I'm inside a regular Sveltec project and I'm running a development server. If you want to follow along, you can scaffold your own project or you can just open StackBlitz and get up and running quickly. So let's write your first hook. And the most used and powerful hook you're going to use is the handle hook, which runs each time the SwellKit server receives a request and it determines the response. So inside of our project, let's go to source. And in your source folder, you need to create the hooks file. So I can say new file, and then I can say hooks. Let's create a server hook. So we're going to say hooks.server.ts. Let's close the sidebar. And now we need to create a handle function that we're also going to export so i'm going to say export const handle and the type for handle is candle which should be auto imported from circuit and then we can also say async let's give it a function body like this and that's it so let's say that you didn't add this hooks file what is the default behavior and basically the handle function takes an input object so this is going to be an input like this and this has some interesting things so if we look at it we can say input it has an event and resolve function so we can destructure this in the function here you can just do it like this and this is how you're going to see it in most examples we can get event resolve and what is the default behavior in a swelked application so basically it returns the event which is resolved so this is the function resolve and we're just going to say event and if we save this you don't have to restart your development server or anything like that it should just work. So if we see this is just the default behavior, because otherwise if you didn't include this, your editor would complain and now we get a nasty error. So let's get this back how it was. You can just refresh and everything should work fine. All right, so let's change the default behavior. And let's say that for every page, I want to instead return a banana. So instead of the default behavior, I can just remove this and I can say return. And what are we going to return? We're just going to return the response, right? Which is the web standard as we already learned. So if we go to responseMDN, and we can go here, and you can see the response interface of the Fetch API, etc. And these are just web standards, right? So this isn't something that SvelteKit invented and etc. And this is the beautiful thing about this. So you can just say return, new response, and of course we can say it like this.

 this, and we're just going to get a text back which is banana, but let's do something more fun so we can add an emoji. Let's go banana, let's save this, and now if you refresh this, let's also go to the network tab so you can see what's going on. I'm going to refresh everything, and we're just going to see that we get back a response banana, preview banana, right? And here in the headers we can see this is just plain text. But also notice something interesting. What would be the default behavior when you go to a route that doesn't exist? return a 404 writer not found but basically here we're overriding this and we're just returning a banana for everything so if we for example go to a route that doesn't exist like banana we're just going to get the banana back nope we get back the banana right so this is really interesting so let's say that we want to be more precise and how would we do this so basically we can just look at the path name and then if it starts with some route then we can just change that route and return the default behavior. So how can we do this here? We can just go here, and we can just, let me just make space. We can say if, now we can from the event, get URL, which is really interesting. So remember, we previously in SvelteKit seen this event object, which has everything like cookies fetch, and et cetera, and you always come back to this object. So this was really something that we dove into in the earlier parts. So we can just take the URL. We can get the path name. So we can say, hey, does this start with some URL? We can say banana. And now in that case, we just want to return a banana, right? Otherwise, we're just going to return the default. So we can say return resolve event. And now if you refresh this, everything looks the same as before, right? But now when we go to our specific route, banana, then we're going to get back the banana. And this really might not seem like a lot, but you just created a route through code, which can be useful if you're making some library and don't want to make the user create a new route. Let's look at an example how hooks are used for authentication in SwellKick. And usually the authentication flow is that you have some route like slash login or whatever, the user fills in the form, then you authenticate them and set the cookie. So now you can get the cookie here from the event. So for example, you can have something like this, session, event, cookies, get, you can get the session. and now you can ping your database, so you can say await get user, you can pass the session but this really is just an example and this really isn important I just want to focus on something way cooler which is for example now that you make a request inside your endpoint like for example slash admin and you want this user information So how can we get this data inside of our endpoints? And for this, you can populate the event.locals object, which is going to pass extra data to a request. So you can do it like this. You can say event, not event counts, you can just say event.locals And you can name this whatever you want, pass whatever information or data you want. But in this case I just want a user, so I can name it test. And now, if this user is authenticated, we can just populate this information for our entire application. So let me show you how this is really awesome. Alright, so in the sidebar I'm going to go through routes. I'm just going to create a new file and let's create a user route. And this is going to be a standalone endpoint. So you can say server ts. And because I'm using the SvelteKit extension, we have some snippets. So I'm going to say kit endpoint, and I'm just going to hover over the slide wall. We can see add import from types, and it's just going to import it for us. And here we can see, here is something interesting, right? Again, so here is this event object, but if we destructure it, we're going to see it has everything including locals. So as you can see, it contains custom data that was added to the request from the handle hook. And now we can do this. And I'm just curious, it's going to work if we just say locals. So remember on the locals we have user, so you can just do it like this. And now we can save this. Actually, let me just rename this locals. And now if we go to slash user, we can just get back the user, or you can log it out or whatever else you want. All right, and this is cool, but let me show you actually what you do most of the time when you do authentication in SwellKit. So if I go back here, I'm just going to close this. I'm just going to create a plus layout.server.ts file because remember in a previous part, we learned the data sent from a layout load function gets merged with data in child routes. And this also becomes available in the page.data store. So how does this really work? And we can really ignore this. So it's not confusing. We can just delete this, gone. So now inside the routes, we can just say plus layout server.ts and then we can just say kit load like this. And the load function is going to be layout server load. Layout server load. So this is going to actually what is going on Let me just do layout server load Okay this is going to import this for us which is really awesome And now again here this is the same event object right So let me just destructure this locals And now what we can do here is we can return this data for all the child routes. And this is how this works. This is why when you try to use any off library or etc., they're going to make you do this. They're going to make you get the locals from the layout server TS file. and now you can say return user so we can say locals user and now you save this and this becomes available in your child routes through the data prop and also becomes available on the page.data store so let's see how something like this is really useful so when i go to the sidebar i'm just going to go to the plus page self and now i'm going to create a script this is a snippet i have and now we can say import we're going to import the page store from app stores and now inside of here we're going to get access to the information inside so we can say if page data user and we can just say welcome page data user and since we have the user here is going to say hey welcome test. And how awesome is this? And this is basically because inside of our layout, whatever you return here gets merged in the data object in your child routes, but this also becomes available in the page.data store in SwellKit. And because this runs on every request, we can authenticate the user, so we make sure nothing is wrong, and this is going to get updated, and this is going to get updated in your file. So basically, that's really the most simplest authentication flow in SvelteKit. Let's look at how we can use hooks to transfer HTML. And why would you want to transfer HTML? One real world example I can immediately think of is internationalization. So for example, in your app, you have different languages and you can change between them, right? But that's really not enough because if I press Ctrl P, app.html, so this is the default template in SvelteKit, you also need to somehow replace this in your HTML markup, so the language attribute, which really isn't great to always leave it on English right so in this case you're going to see this if you use an internationalization library so you don't really have to worry about it you have to do this yourself but let's do something cheeky here so we can just say percent and then let's just give it a placeholder right so this is something that we can target ourselves and now we going to save this and now we can go back to the hook and we can do something really special here so i going to remove this line So inside your hook you can get the locale from your cookie or whatever So this is going to be something like locale and you going to be like event cookies get locale or however you set it up. Again you don't really have to worry about this if you use an internationalization library they're just going to give you the instructions. But let's say for example that I want to use Croatian and now since I picked that language Again, remember, now we can also pass it for our entire app, so we can say event locals locale. Yeah, this is a mouthful. Try saying that a couple of times. Now we can say locale, right? And this is really warning us because we also need to specify the type inside app.dts if you're using TypeScript, but this really isn't important, so I'm just going to ignore it. And let me just put it here. And now, here is the fun part. so when we return resolve event same as before but now we can pass some extra options here so you can pass it an object but what we want to use is the transform page chunk which is a really funny name if you ask me so we can just do this and this is basically just a function which is going to return something and inside of here we have access to a couple of things like done and html but basically this is going to give us the HTML of the request as a string. So you really have to be careful in this case that you don't mess up the HTML because it might not be properly formatted. But in this case what we can do is a simple replace. So you can say HTML replace and now remember we have our percent lang which we're going to target and we're going to replace it with locale that we got from the cookie or whatever. And now you can see already it kicked in. It really thinks we're using creation right? So now when I open the developer tools, let me just zoom in, and if you go to the elements here, you can see the language is set to creation. And how awesome is this? All right, friends, so let's look how we can use hooks to measure page load speed. So hooks are really useful for something like measuring performance and error logging, which we're going to look in another example. But for now, I have this problematic page, which you probably wouldn't know about in development. It takes two seconds to load, right? So it would be really useful if we can log out a console log message only during development. So here is this problematic page. I just have a slip function. It takes two seconds. But let's see how we can measure this using hooks. So the first thing I want to know what page is slow, right? So let's just remove this and I'm going to say const route, or you can get the route using event URL.

 And now we can start the performance measuring, which is really simple. So we can just say let start. And we can use this useful function. We can say performance now. And now we can do whatever. So we can say response. So we're going to measure how long it takes for the response. And we're going to resolve it right here. And now we can say let end. And we can say performance now again. And now this is going to give us back our performance. But to have the response time, we can just say let response time. So we're going to take the end and we're going to say minus start. Or we're going to subtract the start from the end. All right, cool. And that's it, basically. So we can just say something like if response time is bigger than 2000 milliseconds or two seconds, right? We can just say console log. And now we can give it backticks. Let's say turtle because emojis are fun. and now we can say route took and now we can say response time just like this response time and we can say milliseconds and i'm also going to use two fakes so it's not a large number it's going to round it to two decimals and this is really awesome so let's just copy this over just going to do it like this and now we can say if response time is below one second. We're going to use a rocket. And that's basically it. And also, since we already have this response right here, right? We just have to say return response. And before I save, let me just open our terminal. And here we have it here. Now this should log turtle if I save this. So let's see, this is going to take two seconds. Awesome. And now we get back our turtle. And now it says the route and how long it took. So if I go back here and if I just remove this to just give us back a rocket and how awesome is this? As you can see it only took 24 milliseconds. Let's look at how we can use hooks for error handling. In this case I'm throwing this error and as you can see because this is an unexpected error in SvelteKit, SvelteKit is going to strip this message and is going to strip the stack trace. So we're only going to get this internal error message. You might have some gremlins in your code and want to send error reporting to a service like Sentry or LogRocket and this is a perfect use case for the handleError hook which is a shared function meaning it's the only hook that works inside hooks and hooks And the handleError function is going to run if an unexpected error is from during loading or rendering So let see how that works Here in our hook, we have the default handle hook. We can just delete everything and we're going to export the handleError hook. So we can say export cons handleError. We can use handleServerError. This is just going to import it. and now we can say async like this and now we can destructure the error and the event not event which is really interesting event like this and now you can do whatever you want basically this is it so you can say console log error and now if we open the terminal it's going to say error but we can actually log out the actual error we can say error let's save it you can see here is the error so it doesn't hide the stack trace and etc but if you want you can also change what is returned. So you can say return and you can specify whatever you want, message, id, whatever. You can say yikes exclamation mark, let's give it a nice emoji. And now instead of internal error you're going to get back yikes and this also becomes a part of your page data store so you get access to this inside your error page so you can customize this even further. Let's see how you can use hooks to modify a fetch response. For example, let's say that I want to use HTTP or HTTPS for every request, so we can use the handleFetch hook, which is a hook to modify a fetch request inside the load or action function which runs on the server. So here I can just remove all of this code. I can say export const handleFetch, which has the handleFetch type. And now from here we can destructure request and fetch. Let's give it a function body, and now we can just listen to the URL. So we can say request URL. If it starts with HTTP, then let's change the request. So we can first replace the URL. So we can say request URL replace, and now let's replace HTTP with HTTPS. And now we can reassign the request. So we can say request, again just using web standards. We can pass in the URL and the original request object. And now I can even console.logout request URL. And before I save it we also need to resolve it so we have to return fetch request And let me just open the terminal so here we use HTTP and now we change the request and this should log out HTTPS. So let me just save everything and you should see everything works as expected. And how awesome is this? Let's look at an awesome use case for hooks which is parsing form data. You already know that working with forms is a pain even if you're using SwellKit and it makes everything easy for you. How this works is basically you just submit what you have right and then you have some form actions here, but now you need to get the form data, you need to validate or loop over each field before you can pass it to something like Zod and this is very tedious. So what if you could just make a hook that parses that form data for you and just gives you the parsed form data and you can. Let's look at how we can achieve that. So first I'm going to go here to hooks and I already have a handle hook here but I'm also going to use another library which is parse form data and this is going to take care of the parsing for us so we don't really have to even think about it. We can import it from parse nested form data. So let's see how we can make this work. So I'm just going to remove this so we know what's going on and now we can just listen to the request and if the method is post right which is from our form then we know it's a form request and we can parse the form data. So we can say if event request method is equal post and now we can get the form data from the request so we can say const formData await event from the request formData and now we can parse the formData into a JSON object using this package we imported. So I can say const data parse formData and I can pass formData. And also let's not forget to include async here. And before, we're not done yet. So how do we make it available inside our actions here? So remember, we already learned about locals and we can do the same trick here to pass the form data to the request. So here I can go and just say event locals form data and we can just pass it the same data. How beautiful is this? And now don't forget we need to resolve the event like this. Let me just save it and now here, let me just logout locals. So now we don't have to parse the form data and how awesome it is. So let me just save this I going to open the terminal Let say for the username test password 1234 and let say remember me and now this should parse the form data for us And how beautiful is this So we get the form data object, username test, password, and this is really a weird thing when you submit forms, since everything is a string, it's not a boolean so the value is on going to be for a checkbox. And we can even just say form data here, let me just do it again, test 1234, remember me, And now you can pass this to Zod or whatever. Let me show you another beautiful thing about this library parse form data. For example, you can do different things with it and if you want to pass some values to null or boolean for example, you can go to the value, in this case remember, and now for this library you can use ampersand and now look what's going to happen when I say for example test1234 remember me is going to convert it to a boolean. So you can see username test, password1234 remember true. How awesome is this? And also if you're using TypeScript right here inside your app.dts you're going to have an error here because you haven't typed locals, but let's go to app.dts and now here where your interface is, previously we had user, I can just remove this, but now you can specify this type form data which is a record string of type unknown and now you won't get an error anymore. Alright friends, in the last example let's look at how we can use multiple hooks together. So you're going to see this when you're using a library that gives you a hook, it's going have a different name. Of course, you don't have to use event for the name, right? But what if you have multiple hooks then? So for example, here I have an off hook which is going to deal with authentication. Here I have an internationalization hook that's going to deal with the internationalization. And basically, to use multiple hooks together, you can use the sequence helper function from SwellKit and everything is going to work great. So let's see how we can do that. And we can just say OK, export const handle, we can import sequence from SwellKit, and now we can pass it all the hooks you have. And that's simple as that. OK, so now if we open the terminal before I save it, so you can see here it is imported from SwellKit, and now we included all of our hooks so you can save your hooks for later and reuse them, and now when we save it, we can see our off hook ran and our internalization hook ran. Alright, so that's it. Svelkit hooks are very powerful and I hope you now understand how they work and when to reach for them if you have to. Welcome to the last part of the Svelkit series which is going to be about deploying a full stack Svelkit app. We're going to learn a lot about it.

 in this one from web hosting types, or if you don't care about it, you can just skip to the end, and I'm going to show you how to deploy a SwellKit project. But at the end of this, we're going to deploy a full stack SwellKit blog project that's going to use Prisma, PostgreSQL as the database, which is going to be hosted on Supabase, and we're going to host the app on Vercel. I wanted a real world example because applications are more complicated than deploying your typical static blog, right? In this project, we're going to have blogs, a dashboard, which is just a mini content management system, so we're going to use server-side rendering, it's going to be great. But before that, let's talk about web hosting types. The reason why I want to cover all of this web hosting lore is because I want you to actually understand why I picked these solutions instead of going for some other solutions, and we're going to briefly speedrun the history of hosting and what led us to where we are today. But of course, we can skip this and just go to the hosting part, which is going to take you five minutes probably. Let's talk about cloud hosting. Basically, all of hosting is cloud hosting. So you might be familiar with these traditional hosting providers like DigitalOcean, Node, or Vulture, but I call them specialized cloud providers because they're actually focused on the consumer. So if you go here, you can see they have a really nice site, so they're focused on individual developers, businesses, and etc. So you can see it's very clear when you go to products, droplets, Kubernetes, and etc. You can pick a virtual private server or shared hosting, so you're going to share CPU, RAM, and etc. with others. You can see managed databases, so basically you know what you get. You also have solutions here like managed WordPress, Magento, WooCommerce, and etc. So they really aim at making this as user-friendly as possible. And then you have the second category, which are the titans of infrastructure. They're basically like DigitalOcean, Linode, and these others, but AVS, our Google Cloud Provider on Azure, are basically the titans of infrastructure. So look at this. You basically, the main difference is they offer thousand more services. They have insanely larger infrastructure, etc. And you need a degree to understand any of it. So if you go, for example, to products, you can scroll for days. So how can you make sense of this, right? And basically this isn't for mere mortals, but this is for enterprise and etc. And this sounds boring, true, but this is important to understand how we got to the next year of web hosting, which is going to be serverless. So here you have the most popular ones for most people I think are new developers it going to be serverless or Jamstack And these are your Vercels Netlify Cloudflare pages If you go here immediately here is advertising as a Jamstack platform And Jamstack platform means a lot to many people but basically it just means an architecture where you use third-party APIs to stitch together a site instead of hosting everything on a single server. And you have Vercels and etc. And basically, how do you make a Vercel? So let's go back to AWS, right? So AWS has many offerings. and let's say for example you want to make this super easy, you make a nice CLI, you make a nice frontend around some of their offerings like AVS Lambda, which is serverless, and what you get? You get oversell, that's it. And they also offer you a lot of more beneficial features like continuous integrations, for example, when you push your code up to GitHub, it's automatically going to redeploy and etc. You get nice previews and etc. And that's really the greatest developer experience out of all of them. And then you have this other category that I didn't know the name off, so I named it Full Stack Platform. So basically you might be familiar with Heroku, and Heroku is like Vercel, but for the entire stack, right? And it makes it easy, one click deploys for your back and front and etc. But Heroku has fallen out of favor due to recent pricing structure changes, right? But there's other amazing solutions now in this space. You have Railway, which is really easy if you want to just provision a database where you can host full stack. You have Render.com, which is also awesome. You have Fly.io, which is also becoming it lets you deploy your app across the globe. So as you can see here, you can deploy not just your app, but your data and etc. So this is blazingly fast. And this means that in a lot of cases, that server-side rendering can actually beat the speed of static. And this is really awesome if this is something that you're interested in. So you might be asking, all right, if this is really so awesome, then why didn't you pick Flyo or any other? And this is another great selling point of serverless, because serverless is so cheap because you don't have this server that you manage, right? Like think of a traditional server is just a long running process in your test manager or whatever you can imagine. But serverless are just functions which get invoked by some action, right? So for example, if you have an entire server and you only send one newsletter a week, that's really a waste of electricity. But if you're using serverless, it's only going to spin up when you need to send that newsletter, which is really awesome and cheap. This is why they have a lot of these free generous tiers, because they don't actually give you a real server where you can wreak havoc, right? because the thing is with these sort of sites RenderFly they actually give you a real server and this is really dangerous if you make it a free tier for everyone because people are going to do nefarious things with it So basically this is just all me rambling about just to say that these type of services require you mostly to use a credit card just to prevent that abuse. And that's why I've really chosen something like Vercel to host the app, and I've chosen Supabase for the database. And of course this is the next tier I want to talk about, because serverless has its own unique set of challenges. You have all of these amazing, great serverless databases, you have Supabase, Firebase, Fauna and Hasura, which I haven't tried, but they seem like they're all into GraphQL, if that's something you're interested in. SATA sounds really interesting, you have Upstash for Redis, so you can use that. You have Planetscale, and then you have MongoDB, if you like using MongoDB. I'm really not a fan of Firebase, because Firebase is proprietary and locks you in. What is the benefit of something like Supabase? It's that it uses PostgreSQL. So if Supabase buys the dust or whatever, they change the pricing tiers, it really doesn't matter, you can switch to PlanetScale or whatever else, you can provision another type of SQL database, because we're also going to use Prisma that has many database adapters. So your schema stays the same, because the schema looks more something that looks like TypeScript, instead of writing raw SQL or MongoDB even yourself. Alright friends, I'm super excited to show you how simple this is. The only thing you're going to need is a GitHub account, which I have a secret Smurf account here, so you can use GitHub to log in to Supabase and to Vercel, and Vercel is going to ask you for permission to your GitHub anyhow, because it has a tight integration with it. So first we're going to create a database, because that takes a minute, and again we're going to use Supabase to provision a PostgreSQL database. We don't really care about any other Supabase features, we're using Prisma and not their JavaScript library. But of course if you want to use other Supabase features, you don't have to use Prisma. So let's go and create a new project. If you go to app.superbase.com, create a new project, I'm going to name it blog, you can name it whatever you want, and this is the important part, we need to generate this password, then we need to copy it, I'm just going to create a new tab here, copy the password, don't leak it to anyone, and here you can choose a region close to you, I'm going to pick this, and then you can press free, simple as that, let's create a new project, and this is going to take a second, and then it's going to take a minute to provision the database itself. So you can see the project is created, but it's setting up the project. it. This is a perfect time to set up the project, so here is the example project with some simple instructions, you don't really need to go here, I'm just going to tell you what to do if you're following along, which I hope you're doing. So here inside of an empty project you basically going to create a new GitHub repository and you going to push this up so you can host it yourself and try it right So I going to use this command pnpx which is just going to copy over a GitHub project without the history and it really super simple So I'm going to complete joysofcode.com slash Svelte Deploy, this is the name of the repository, and this dot at the end just means, okay, put it in this exact folder, don't create a new folder, and I'm just going to press enter, and awesome, it's fast like that. Let's install the dependencies, And of course you can use any package manager you want, but I highly encourage you to use PNPM. So this is great, and now if I close the terminal, you should see here is the project. So we need to rename this environment file to environment, and be careful to not leak this to anyone. This is very important, and this is only required for local development, because later when you host it somewhere on Vercel, you need to enter your environment variable in their dashboard. So here I can open the ENV, and I already have some example here. and by now this should be done so our database is provisioned awesome so if we go to project settings database and you can see here's the connection string so you can get this but we want the connection string for the pooling because it's going to fix the problem when it comes to using a serverless database you don't really have to think about it just copy this string over we can copy it right here i hope you have your password because we're going to take the password copy it let's close this because we don't need it anymore. And now, including brackets, replace this, and this is it. Boom. You're done. So let me just really show you inside the Prisma schema. I set it up to use PostgreSQL. You can use any other adapter you want, right? The schema stays the same. It looks like TypeScript. Beautiful. Chef's kiss. And you can see here we have something for authentication. Really, it's not important. Here is the post schema itself. So let me just close this. And now I can anyway close this. And now if you go to your terminal, I'm going to press Ctrl L to clear everything. So now we just want to create the tables from our Prisma schema and you can run migrate if you're in production, but if you're just prototyping and trying things out, you can say PNPX Prisma DB push and now this is going to create the table on Superbase. Alright, so let's give it a try and let's see what happens. And now when you go to the table editor, you're going to see here you populated the tables and here your posts are going to be you can even add it now. Superbase error out, which is hilarious. But yeah, okay, this is it. You can see here is the database. Also, I want to mention that you can also set up row level security because right now anyone with the anonymous Prisma key can edit this, but you can look into this if you want.

 thing is that you can run the development server, so you can say ppm run dev, everything should work great. So first time running, now we can go to localhost 5173, you should see everything working, give it a minute to build everything, you see everything working, we only see the title because we don't have any posts, but yeah, this is just the full stack blog app. So you can see here is the blog, where it's going to be the search, here is the dashboard, right now there is nothing here, so we get an error, maybe I should have done some better error handling, right? But yeah, It's really not important. About. And this is awesome. And you can even just go here. And you can see here where the dashboard was, right? You can register here because you already have the access to the database. But this is boring. Let's host our app on Vercel. And first, let me just close this. I'm going to close everything. And on GitHub, first we need to create a new project. So we're going to create a new repository. I'm just going to name it blog. Let's name it SwellKit blog. Nothing else you need to do. So you can just go here. create your repository, don't do anything here I'm going to press ctrl shift g to enter this git mode and I can say initialize repository so you don't even have to use your terminal if that's spooky to you so the only thing we have to do here is add everything and let's just say feature add project, nothing special we're going to use this, sometimes I mix the GUI and terminal however I feel and this is what I love to do so I can go here, I can just copy everything I can just say paste Let's just do this, and everything is fine because we're going to push on already existing repository, and congrats, now you have your own repository you can host, it's clean, and now we can use Vercel. But let me tell you one thing before we do that, which you should do. We're going to talk about adapters. Let's talk about that first. So how do you host a Sveltec project, right? Sveltec has this concept of adapters. By default, if you don't have any adapters specified in the Sveltec config, you're going to see, let me just close this, you're going to see here it uses adapter auto, and this basically means when you deploy it to a supported platform like Cloudflare, Worker's, Netlify, Node, Static or Vercel, it's going to know what the platform is and it's going to use the right adapter. But you can of course do it yourself, you can go here, which Vercel recommends, so let's do that, pnpnid development, swelljs adapter Vercel, let's do that, and we just need to replace that and that's it. Okay so now we can go here Vercel Here is a good tip I have for you So before you deploy to Vercel just run ppm run build This is going to expose any potential errors like TypeScript errors because those are going to error out when you deploy your project. So if you catch anything here, it's going to save you so much time for having to redeploy constantly your app because of some silly errors, right? And you can see everything looks great. This is the same output that's going to be on Vercel, but it's not really the same. and then when you're done with this, you can say pnpm run preview, and if you're really wondering how do I know all these commands, just go to your package.json, you can always find the scripts here for testing and etc, they are all here, so this is going to open it on port 4173 instead of 5, you can go here, you can see, alright, not brave search, nice one, you can just go here, 5173, and okay, you see everything works, okay, this is internal error, but it's because we output it using build. This is not a development server. So don't freak out, okay? So now let me show you how easy this is. Let me just stop all of this. I'm just going to exit. And now, inside of the Vercel dashboard, you just have to go create new project. And this is going to load your repository. If you're doing this for the first time, it's going to ask you for the permission to your GitHub. Just say yes. And then we can just select the repository. Because I'm on my legendary Smurf account, I only have one repository, so I can say import blog. And now here it already knows this is SwellKit because it's already pre-configured for you. Now the only thing you have to do is populate the environment variable here. So let me just see. I need to open the sidebar. You can see build and output settings. You don't really have to change anything here because you have the preset here. So it's with build public and you don't have to care about this. Okay, so now we care about this. So now we just need to give it a name. is going to be database URL, and now we just need to copy this connection string. Let me do this. Press add before you click deploy on accident, but you can add it after, right? Because you can use this dashboard or whatever. So now it's added, and that's basically it. So let me just collapse this, and now I can press deploy. And let me also close this tab. And now this is going to take under a minute. And another thing I want to mention is that if this is the first time you're doing this, never be afraid of the built out. This might look spooky, but this is the same thing we did here in the terminal, right? Same thing as you run pnpm or npm run build. This is the same output, but it's using someone else's computer, right? So if you ever get an error don freak out it just running the command Just stay calm read the error maybe google it maybe it something obvious you doing something crazy right If you remember this is like exactly the same like we did here Everything looks great and it just doing its thing closing to the end Let's see, it's already done. Okay, so this is it. No errors. Great, this is how simple that was. Let me just scroll up. There's a lot. Oh, it's actually not done, but yeah, it's going to be soon, and the next time it's going to be even faster. All right, so now we get congratulations, But let's continue to the dashboard. So also our cell gives you a nice name for a preview, but you can also look at our deployment. So here we see our site is live. So we can go to the deployment right here, or you can change other settings like your node version if you want. All right, so let's see. Oh, I clicked the deployment on accident. I want to click on domains. Okay, let's go to the domain. So let's see what's going on. So we have latest posts. And now when we go to the dashboard, since you don't have an account, right, we can go register. I'm going to say test 1234 and it should create a new account on Supabase, right? And we already have a page host set. And if you want to enter your domain, you can go here and somewhere under settings, there is an option for domains and etc. All right, so let's see what it's complaining about. And if you ever get an error, you can go to your deployments and you can go here, I think, and then you can see logs, but you can also check it for functions. you can see if something is wrong here but i don't think anything should be wrong here so let me just check what is going on here okay i don't know what happened now but we are already logged in and as we can go to supabase let's see user you can see here is the user and then we can go here we can create a new post and let's say bob ross ipsum of course let's go here and let's add some happy little trees like a post and then we can say happy little trees or whatever else title you want to give it happy little trees happy little trees and then we'll just paste this text i'm going to select as published let's submit it this is going to be added to our database you can see despite this being server-side rendered, this is really fast. And if we go here, let me just see, this should work. Actually, I'm really curious. Interesting. Must be something going on with Wurselle because I actually did not experience this Basically this is going to work 100 You go to the blog dashboard you can see here are all your posts You can search happy little trees We only have one post And let me just see about blog. And here it is. So basically, maybe this is just so new that things need to settle down. Just give it a minute. Don't panic, right? Things are going to work. And now you can share this with your friends or whoever you want. And you can log out. And basically, this is it. Now we've learned how to host a full stack project using SwellKit, we use Supabase to provision the PostgreSQL database, and of course then we deploy the entire project on Vercel. In the next section I'm going to show you how we can optimize your site further using cache headers. Alright friends, so how do we make our site even more awesome? I'm not sure if you noticed it, I probably mentioned it, but we're using server site rendering. That means none of this is static, but you can see our site is blazingly fast. So how is that possible? Well basically that server-side rendering is slow is a misconception. What is expensive with server-side rendering isn't the creation of the HTML page or whatever, but it's the data you're trying to fetch, because fetching is expensive if the data is further away from you. But how a static site works, for example, if I go here, it uses a CDN or a content delivery network which are just servers across the globe that literally just take the assets from where you're hosting this, so HTML, video, images, etc., and they put it closer to you. So for example, if you're here and you request some image from my blog, then you're going to get this from this CDN instead of here, and this is why static sites are so fast. But then imagine that if you have some data, like here, in this case, we're using Supabase, right? And this is here in Frankfurt, somewhere in Germany, right? And this is fast for me, but it might be not fast for you over here or here. What people are trying to solve this problem with is edge computing, which is basically the same concept as CDN, but it's using the edge to move the data closer to the user. We're not going to use edge today, but we're going to use some simple HTTP caching. Basically, we can just set cache control headers for a certain duration, which means if a thousand people visit your page, you're not going to create a thousand requests doing the same work on the server but the CDN is going to be like, ah, I have this cached already, I can just serve you this resource. And then for example, if an hour passed, then it's going to get it from the server again. And this is really simple but powerful. And really, cache control headers aren't anything spooky, so if I go here in the post, here

 have this section where I show you how you can set cache control headers. And another thing I like about this is that you have to think about the content on your site. So you can optimize it and you can do whatever you want. Basically, it gives you a lot more power, freedom, and flexibility. And if you want to learn more about cache control headers, you can go to MDN. Here you have some descriptions. They aren't very useful, to be honest, but you learn a couple of these things and then you're set. So for example, if we set max age, this just means, okay, I don't want you to cache this to the disk. Then you have this directive as max h, and this tells a shared cache, which is a CDN, a content delivery network, it tells it how much to cache this resource. And this is 60 times 60, so this is going to be one hour, because 60 seconds times 60 minutes. So if I go to the blog here, let's see, we have the latest post, right? And then we're thinking, okay, how often do I want to refresh this, right? And maybe you can put an hour, because this really isn't that important. And then we have an RSS here, which you can also cache for an hour because why would you need to ask the server every second for this, right? This is like, it's a waste of electricity. And then you have some other things. If you go to the block here, you have a search, and this just grabs the post, and here I have some client JavaScript that just filters through them, so this is nothing special. And just ask yourself, like, how important is this, right? Maybe we can also cache this for an hour because it's not important. And then for the dashboard, of course, that gives us this internal error for whatever reason. I don't know what's going on, but we can just ignore it for now. In here, you can be like, okay, I don't want to cache anything that's dynamic, that's not the same, right? Because I want the freshest data always, and it's not really often used or public-facing. And then we have an interesting thing like an about, which we can pre-render using page options in CellKit, and we can even disable JavaScript by disabling client-side routing, which I'm going to show you how, and this is really awesome. All right, so now that we discussed this strategy, Another thing probably I should mention is that newsletter, I don't really have any logic here, but you might be thinking if you look at this newsletter, okay this isn't changing we can just pre-render it, but you can't because pre-rendering isn't going to work if you use SvelteKit form actions because they require a server. So we're just going to leave this alone, we really don't care about this. Alright, so let me just use this post so I don't mistype anything and have some silly errors. So, we just discussed this strategy, what we want to do, and I'm just going to use this to set the cache control headers. So now we going to go to source routes and now we can set the cache control header inside the plus page of server file So here is one for the route and here it is So here is where we get the published post and really we just need to destructure set headers from here and that how simple this is So now we can say set headers, and you can set any header you want. You can say x, and you can say go and give it to you, and then you can specify cache control headers if you want, which is the thing we want so you can say cache control and again i also prefer to use this format like this so we actually know the time so we can say max h zero that's never going to change and then you can say s max h which this is really sometimes easy to get wrong and then let's just use this and i like to use this format but you can use an hour or the relation but you can just Let's use JavaScript for some easy maths. So we can save this and then we have the blog route, so we can go to the blog route as we discussed it and let's also cache this for an hour and let's just copy this part over so we don't have to repeat ourselves. So we can go to the blog, so we have the blog. So here is the search for the site, right? If we go here, see blog. It's not cooperating today with me. Let me just see what's going on. I'm just going to log in again, see what's going on. But yeah, I hope this works much better for you because, yeah, apparently there are some difficulties. But yeah, we can just ignore it for now. But we can just go here to the page server. And let me just go here. I'm just going to close this. And let me just close the sidebar. I'm going to copy over. We don't really need this. We just need to get the headers. So you can say set headers. and now we can do this like i have it in the post right if you look at here here is the same thing so this is going to be an hour this is going to be an hour so for the post itself we want that to always be fresh so when we fix a typo or something we just want it to be immediately reflected so we can set this to one minute so let's go here to the blog slug you can go here again same thing you can copy this over, you can just go here, you can say set headers, and then go here, and just set it to 60 seconds. You don't even have to do anything special here. And I also going to need cparams Yeah so let not mess that up And then another one I think is the RSS So let me just see Yeah, it's the RSS. And this is interesting because this is at a root. So if I go here, where is the RSS? Here it is. So here is something different because I'm using a standalone endpoint. I'm already returning a new response, which is content type. And then we just need to do the same thing. So we can just go here. you can say hey cache this also on the cdn you can say max age 0 smax age and then you can set it to an hour or you can set it to whatever you want and also you don't have to just use these values you have access to javascript right so you can make this conditional if you have a post that's older than seven days you can look at the publish time you can say okay if this post is older than seven days i'm probably not going to edit it often so cache it forever and then to bust the cache you can just redeploy to Vercel or you can use a webhook. So let me just look at the about page when we're here. Here we're going to use SwellKit page options. So let's say for example I'm going to collapse everything just so you know where we are. So for example in routes about I can just create page server ts file see what I created here. So you can say export cons. And now if you say pre-render, this is just going to build a HTML page in advance. And we can also disable the client router. So this is not going to have any JavaScript at all because we don't need it for an about page. And it's going to get rarely viewed anyhow. So we can say client-side rendering false. All right. Awesome. So basically now we're done and now we can push the changes press ctrl shift g i can go here and we can just add this just add this we can say feature and versell adapter or actually it's not a feature we can say build it doesn't matter just commit and then we can say feature cache let's add all of these say commit and then you can say sync so now you're going to see something beautiful if i refresh this you're going to see here is going to push something in your commits and now for sale since it's hooked into this if you go to our sale dashboard is going to automatically redeploy so this is going to also take under a minute i going to close all of this and now our cache is going to work So give this a second All right and this time it a lot faster so you can go here and you even have a new URL for that if you want and I hope this time we have more luck and less errors. Unlucky I know but it is how it is. So this is another great thing that even if you have a branch in your repository you can push that up before you push it to main and you can get a preview deploy to make sure you didn't mess something up on Vercel, which you should always do. And then we can just open the link, which is the link for this preview deploy. And let's see, things are already looking a lot better. So let's see, just log in, it should take a second, and you can see it here. So let's see our caching in play. So when we open the network tab, so the first thing I'm expecting is we're going to get a cache miss because what I've done right now is I've just used client side navigation, right? And your data can also get cached this way, but it doesn't really matter. How someone is going to open your link, they're going to go directly to that link, right? So first time we're going to get a miss because it didn't prime the cache. So let's reset it. And actually, maybe I'm also unlucky. Let me just see. It's going to do this. And then let's just open this and we can see age zero. So it just started and when we go here to these headers we can see it's a miss and now when we refresh this instead of asking the server is going to pull this from the CDN. So let's refresh this and you already seen how fast this was and how awesome is this and this even isn't using static side generation, we're using server side rendering with some clever caching. You can see h14 and now when a minute passes this is going to reset so let me just try my luck if I can go to the dashboard. Let me just make some changes here if I can. I'm just going to give it exclamation marks. Let's save it. Submit it. Let's go to the blog. And now you can see 44. And now, no matter how many times a refresh is going to be cached. How awesome is this? Beautiful. It's just using web standards, right? So here we say it's 54. We set it to 60 seconds, right one minute. So let's see, are we close? Of course it's giving us this error, but now, let me just go here, and you can see this is updated. So now again this timer is going to start running, and beautiful, this is it. Alright, so that concludes the Selkid series.

 I hope you learned a lot about SvelteKit and now you should have more confidence to start working on your app. If you enjoyed my content and want to support my work, you can like and subscribe or become a Patreon starting in low as $1 a month and if you need help or looking for a friendly community, you can join the Joy of Code Discord server. As always, thank you for watching and catch you in the next one. Peace. Thank you.