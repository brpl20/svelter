 Hi, I'm Benjamin Schachter, and this is my talk called Lawrence Felt Using React. And it's a little bit misleading because we're also going to use React to Lawrence Felt. And let's just jump right in. Um, this talk by a fellow named, um, Mr. Richard Hamming, um, had a really profound impact on what I think about, how I learn, and kind of my thoughts around where to spend my time. and this video is on YouTube as well, and the text is also great, but I kind of just wanted to point out this one particular line that really stuck, and Mr. Hamming says, another trait, while it took me a while to notice, I noticed the following facts about people who work with the door open or the door closed. I noticed that if you have the door to your office closed, you get more work done today and tomorrow, and you're more productive than most. But 10 years later, somehow, you don't quite know what problems are worth working on. All the hard work you do is sort of tangential in importance. He who works with the door open gets all kinds of interruptions, but he also occasionally gets clues as to what the world is and what might be important. And this just rung a bell, and it kind of changed my perception of the world. And I only learned about this talk through the Recurse Center, which is a free programming retreat. And basically that's just what happens there. There's other people who are all trying to become dramatically better programmers and who have different interests And you keep that door open and they expose you to things that you never would have thought of and vice versa And it's a really worthwhile experience and I encourage everyone to apply if they're able to. but that concept of keeping the door open also keeps me really engaged on twitter and i like to look at folks who are able to be really productive and learn deeply and this guy kent c dodds had a tweet that I thought was a great interruption. And he said, a few years ago, this book totally changed how I teach and learn. I just listened to it again, and I'm still convinced it's the best. I strongly recommend it for students and teachers, and y'all make it stick. And he also writes a blog post about it too. And he goes into detail, and he talks about a couple different points here. So desirable difficulty in learning, right? You want to have a challenge. Interleave practice, mix up what you're learning. Elaboration, discuss what you learned, which we're going to do here. Active retrieval, go back and make your brain try to remember what it's naturally forgetting, which I just got to do by making this talk and going back to some old code that I hadn't looked at in a while. And I took Kent's words to heart and got the book. So there's one other thing that the book talks about here, and that's using mental models that you've already acquired to learn new things. And on that note, I want to talk about Svelte and I want to talk about, well, I think Rich Harris does a really good job explaining reactive programming with something that we're all very familiar with, which is an Excel sheet. Programming. And you've all experienced this, but I'm going to show you anyway. I have a spreadsheet here that tracks my fruit purchasing habits and in columns B and C I have some values I got some prices and I got some quantities In column D I got something more interesting I got formulas The values of these cells are derived from the values of other cells which means that if I buy another cantaloupe, the spreadsheet updates automatically. The subtotal and the total update to reflect the new inputs. And the way that this works is the spreadsheet maintains a dependency graph internally, and we can visualize that. We can click around and we can see the inputs and the outputs for each of these cells. And we can even change a dependency graph by adding a new formula. All of a sudden, these cells now have two outputs. Now, this was important back in 1969 because computers weren't very fast. And it's a lot more... So, we just learned what reactive programming is. It knows what every dependency is, and it derives new values from those dependencies. And it automatically changes those values. and this is a really important concept to nail down and being able to reference that idea to an excel sheet helps us understand this new concept and that's powerful so let's take this idea of extending a model that we already understand to a new context so that we can use our old learning to influence our new learning. And there's a great example here in this Svelte tutorial, and it's about key values. And key values, when I read this tutorial, it made no sense to me. Absolutely none. And I'm going and I'm trying to figure out what the hell is going on here and why does it work this way? And by default, when you modify a value of an each block, it will add or remove items at the end of the block and update any values that have changed, that might not be what you want. It's easier to show than explain. So I agree. It is much easier to show than to explain but I broke it down a little bit more and I thought about well I see these different colors but I don really understand exactly how they relate to the problem But we do have numbers And maybe if I can see the number changing, I'll understand what's going on. And I just added a number here. So initial and current, and we have our initial ID and our current ID. And we're able to see, okay, here's our initial, here's our current. The initial value is fixed upon initialization. And look, one list is going one, two, three, and the other is going three, four, five. And then we look at the logic of what's going on here. Things.slice. What does things.slice do? It takes off the first value of the array or the string, and it gives you the substring. and we can see our initial is taking values off the bottom and our current is taking values off the top, right? So this makes sense. The default value, because it's holding on to the initial value and doesn't know it changed, it's going to take items off the bottom. And values that it knows have changed, it's going to take values off of the top. And there's a solution here. And the solution was just write our thing at ID. And it blew my mind because it took me so long to understand what was going on. And I said, you know what, this is a great, this is a prime candidate to write and react. Because if I can understand it and react and I can build something that I don't understand and svelte, I bet I'll understand what's going on a little better if I have to force myself to dig through to challenge what I know about this subject. So that's what we do. That's exactly what we do. So here's the exact same thing in React. And we have a problem. we have a solution. So we have the same problem, right? Our initial, our current, and the initial is pulling from the bottom, the current is pulling from the top.

 We're using things at slice. We're using set things from the use state API. And we get this error. Everyone gets this error because for some reason you forget to throw on the key and React screams at you and you just put it in and you forget about it. But you dig down a little more. and then there's like another there's another article somewhere in here about reconciliation how this thing works and people have written in depth about how React updates these unique values and they basically perform in a similar fashion between Svelte and React and if we just add our key here, our thing ID, and then we try it again, we solve the problem. So it's this idea of letting the system know what's changed, that we're able to fix this bug. And we can also look back on the Svelte example and say, hey, we actually want to fix a value upon a initialization. How would we do that in React? Well, you're going to do it with a ref. and you're going to use a use effect because with this use effect hook, it only runs on instantiation and then we hold its current value and it doesn't change. So now we've kind of unlocked another piece of functionality that maybe we didn't know about before of how to hold a value through multiple re-renders and a React component. And when we toggle between React and Svelte, it feels almost magical because there's so few APIs that you need to know. You're just assigning values and things are magically changing. And it's hard to understand for me what was going on because there wasn another API to compare it to I was just assigning variables So yeah I was able to transfer these contexts over to each other and learn a little bit from each one and solidify that base knowledge that I can extend maybe to Vue or maybe to Preact or whatever. And additionally, I made a small change to the documentation. If anyone here is a core member and thinks this is valuable, it helped me. And thinking about React keys and Svelte keys made this much easier to understand. So then we move to this next subject that Rich talks about, which reactive programming, right? Like we have a dependency and the compiler knows what's going on. And it's only changing values that change, thinking about that Excel sheet. So then we think a little more and we try to say to ourselves, well, how is React not reactive then? If Svelte can do this, what are things that React can't do? And what are solutions to those problems? And it took a while to think about, but React has all of these APIs, these use callbacks. and these use memos. And if we look at the documentation here, it tells us, right? It says pass an inline function with an array of dependencies. Use callback will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimize child components that they rely on reference equality to prevent unnecessary renders. Examples should component update, right? So React doesn't know when something needs to update. You have to tell it when something should update. When should a component update, you need to tell it. Same holds true for use callback. So I think that the solution but maybe let talk to some other folks and reference some other people And I searched around and I found this great article from Thoughtbot. And Thoughtbot talks about this exact problem. We don't have to go through it too much, but what we can look at right here is this chart and this interaction. And look, you see all these renders right here. They're changing all the time on every single update. And we look through here and there are lifecycle components and shoot component update. Essentially what they do here is they optimize. They use these APIs and now look, you only have four re-renders. And it's because React is not reactive. You need to tell it when it should and when it shouldn't re-render. So moving forward, I watched a video from this guy, Ken Wheeler. And Ken talks about these problems. And he shows us with the perf flame graph tool. So let's see what's going on here. So here, right, we have this handle click business here. You have your onClick prop that gets past these rascals right here. here. So one thing that we can do is in here and say, you know, const click handler equals and use callback. And so this will memoize this callback here. All right. Wait. Yeah. Yeah, I think we're good. All right. So I'm going to fast forward this a little bit. See if that fixed it. but he's using the same thing, right? He's using these perf hooks. All right. Not fixed yet. Wait, unclick change? Well that BS That is BS Ken Oh sorry I'm dumb. We want to do it here because it's coming down from the top. So here I can say, well, we better update that or we're going to have a problem. We want to do it down here. So here we'll say click handler. Right? and that's getting passed in. That calls that. All right. Go back. Eating up the clock here. All right. Still changed, didn't it? Hmm? What? What's the second argument? We're going to do this, aren't we? We're doing it. Gotta love those hooks, am I right? Yes. So now we take Ken's example. I kind of just did a little copy-paste, and this is the before state. So you have none of these hooks. And you can really see, look, it re-renders each time, right? You have every single time it's re-rendering everything. You can see it, even just without this flame graph. If you click one of these things, all of them change because one thing changes that got passed down, and Direct doesn't know what should happen. And then we can try again with some of Ken's solutions here, these use memos here. and we have a use callback. And look, you see it. Seven, seven, four, four. So they work. And there are solutions to this problem where React doesn't know what changed and you need to tell it what changed. So the next thing I did was, well, how can I apply this to Svelte, right? Like Svelte is all about not having to do this stuff. Svelte doesn't have that.

 these APIs. So let's write this in Svelte. Where did I put it? That's the question. I had it in a REPL. Oh, here it is. So here's the same example that Ken has. And we can see, look, initial render, and then we move this guy here. You can see, look, only renders 10, only renders 6, only renders 4. And we're using Svelte's little dollar sign label here, which which makes our goals reactive. And we iterate through. We have the same tile. There's a lot less code, right? There's Svelte just through this one line of code is handling all of these things that we would have to do in React. And we don't have a set state, right? We just reassign it like good old-fashioned JavaScript. And Svelte works a little differently and I learned something new which is we couldn call back our function that was firing this event And if there is a way to pass down callback functions please let me know But I found this solution here, which we use the create event dispatcher. And looking at the documentation of create event dispatcher, we learned about the custom event. and that's how this thing works under the hood. So naturally, start looking, right? What is a custom event and what is this dispatcher? And I didn't really understand from this article, but the idea was from looking into it a little farther, a custom event is an event that you get to trigger, an event that the developer can trigger instead of the browser. So instead of an onload, you can make your own event. Or instead of a resize event, you can make your own custom event. And this was valuable to me because I now got to learn something about the browser API and the platform itself, and not just Svelte. And this knowledge will be valuable anywhere that I writing for a browser It great And yeah, now I have my little Svelte app. and this dispatch is firing an event with an index here. And we're able to grab that event here for the event detail index that we are listening for on this handle click. We're calling on handle click and we're looking for this fired event. And now we have it. And then we're able to toggle based on the event. And it works. We don't have all these extra APIs that we need to program to tell Svelte what to do. We've kind of gone full circle from this Excel sheet that Rich was telling us about initially to implementing it ourselves and to understanding how Svelte does its own kind of Excel sheet. Yeah So that everything And kind of just wrapping up here when we're able to challenge ourselves and try to maybe answer a question before we know the answer, when we try to use mental models that we already have to learn new things and extend what we already learn and when we can compare different contexts different problems we can understand how things work at a deeper level so I encourage everyone to maybe grab one of these Svelte tutorial samples and write it in React and see how far you get and try to push yourself to learn how Svelte is different than React and how it's different from what you know and you can kind of compare and contrast and think about the programming model for yourself. I'm Benjamin Schachter. I'm looking for a new job. Please reach out to me on Twitter if you know anyone who's hiring. Have a great day. Bye.