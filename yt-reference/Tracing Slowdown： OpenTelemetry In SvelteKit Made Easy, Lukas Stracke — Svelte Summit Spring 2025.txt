 Well, good morning, everyone. It's really nice to be here today at Svart Summit. Really nice venue, really nice conference. Yeah, super happy to kick off the second day of this conference. My name is Lukas. I'm a software engineer at Sentry. And yeah, a couple of fun facts about me. I'm kind of a massive aviation nerd. I've spent way too much time in flight simulators or following some aviation news. Maybe I get a license someday, who knows. And more recently, I also got into archery, which for me is really kind of a fun activity for the weekends to get outdoors. And yeah, at Sentry, I maintain our JavaScript SDKs. And specifically, around two years ago, I started adding Svelte support. So I added a Svelte and SvelteKit SDK. And I'm kind of the core maintainer of the Svelte stuff at Sentry. And therefore, I also got into the Svelte ecosystem, And yeah, it's a really nice community. Yeah, I'm super happy to be here today. Cool. You might have seen I'm not alone here. There's a couple of other people from Century. We have a table today in here because it rained a little bit. And yeah, we're somewhat sponsoring this conference. So there's always going to be some stuff we have to take care of, some things we need to figure out beforehand. And therefore, like every naive software engineer out there, I decided to write my own task tracker to make sure sure we don't forget anything we have to do for that conference. So, well, here it is. Let's see if we manage to do everything in time. If it would load. That's kind of weird. Why is this taking so long? Well, OK, here we are. But let's try this again. This is a bit slow. I don't know why. Yeah, doesn't look like it's a one off. Something is off of the performance here. So let's find out how we can, well, see what's going on. And that's the, well, a little bit crafted segue into my talk, Tracing the Slowdown, or the alternative title being Open Telemetry in SvelteKit made easy, or as easy as possible. So today, we'll talk about tracing. And before I get into it, can I maybe get a show of hands who of you has heard or used tracing before? Oh wow, that's quite a few people. That amazing But maybe for everyone who hasn yet I will give a quick primer basically on what it all about And then we see how we can add tracing with OpenTelemetry to a typical SvelteKit application Then I'll go a little bit onto kind of a tangent on why observability or tracing in ESM-based applications is a little bit, let's say, cumbersome or could be improved. And ultimately I'll make some proposals or some ideas on how I think that SvelteKit could do a little bit of a better job in supporting instrumentation and observability and tracing. Cool. So let's get into it. When we talk about tracing, we can kind of break it down from a bottom-up perspective. And the smallest unit of a trace is a span. So let's say we have kind of that typical load function here. I think most of us are familiar with that. We just fetch some to-dos from an API and then return the tracing. So nothing really special going on here. but let's say we want to track the time how long this actually takes so what we can do is we can just basically wrap a span starting helper around it these methods are available in kind of a couple of tracing SDKs and really what they do is they just basically measure the time of how long that callback insight takes to execute and then they will take care of sending off that span, that timing data to your tracing tool or back end of choice So chances are we're not going to just start one span, but actually multiple. And then we're going to end up with this nice hierarchical visualization of how long certain operation takes within, for example, a request. So this here kind of depicts the typical server lifetime of a request. We have this top-level span that kind of measures the entire duration, and then that again is made off of a couple of child operations. So a couple of middlewares. We obviously go into our actual handler that takes care of loading these to-dos. And then we can even take a look at some query spans, some cache lookups. And ultimately, of course, we also have to transform and send off that response. Now, the really cool part of tracing is that this isn't just tied to one service or one part of your ecosystem. You can really split that up into and trace it across multiple of your services. so for example if we're still talking about a SvelteKit app, chances are we have some kind of universal load function on the client that makes a fetch call to exactly that backend that we saw before and maybe we also have a third service in here It could be an authentication service or some kind of other microservice And we can really trace that entire duration of like how long the fetch call takes on the client side and really see what is going on across our entire service stack. So that's pretty nice and very helpful to the backstuff, like some performance issues. And we'll see that in a minute. and now I'll just quickly talk also about open telemetry because that's also quite important so a couple of years ago the kind of the big players in the observability space but also generally the big tech companies they decided to kind of start a common standard or kind of terminology or understanding of observability and for example also of tracing so this basically ended up being called open telemetry and it kind of defines a common terminology of how we think and talk about tracing and some other observability stuff. But they don't just stop there with theoretical stuff. They also provide completely vendor-neutral and agnostic SDKs, so like small libraries that you can add to your application and also a set of standardized APIs and most importantly, instrumentation. So when I talk about instrumentation, it really just means that there's a piece of code that watches what another piece of code does and kind of takes some learnings or some data from that. And that sounds a little bit abstract, but in the case of tracing, it's really all about basically being able for instrumentation to start those spans manually for us. So we as users, we don't have to write start span all the time. We just let that handle the instrumentation for us. Alright, so now we're all experts in tracing here, so let's add OpenTelemetry and tracing, or OTel in short, to our Sleptit application. Step one is already a bit interesting, I would say, because OpenTelemetry, as I said, is basically an attempt to make tracing and observability vendor neutral. And as a result, their architecture is very pluggable and very modular. So unfortunately, we have to install a bunch of NPM packages to make that kind of work in our application. And since SvelteKit typically has a back and a front we have to basically install some core packages first that are available everywhere And then some web packages specifically for the frontend part and some server packages in this case the node SDK for the backend part Right. So I'm not going to bore you too much with the details of how we then can initialize the SDK. All of what I'm showing here is available as well on my GitHub. I will have a QR code at the end. Let's just go over a couple of important things here. So first off, we're of course going to import some stuff. And the cool part of Otel is that you really can plug everything in and out as you wish, so you can really customize your setup and make it work for your use case or the tools you're using. But yeah, it comes with a little bit of a configuration overhead. So here, we're going to take care of setting up the client part. So I just basically added an instrument.client.ts file. And then I'm going to initialize the web trace provider. That's this class here. Which essentially is kind of the top level SDK for the browser side of instrumentation and of the tracing SDK. Then maybe something that's worth calling out here. Registering the OTLP trace exporter. Which is just essentially a fancy term of saying take those spans we saw before, convert them to a standardized JSON format, and then send them off to whatever tracing tool or backend you're using. In my case here today, I'm using Jaeger, which is an open source, vendor-neutral tracing tool. It could be really anything that you want to plug into. Dynotrace, New Relics, Datadog, they all support this. And then, as a last step, we're going to register some instrumentation. So, in our case, we are going to take the document instrumentation, which takes care of tracing the initial page load. And then also, we're going to plug in the fetch instrumentation which takes care of tracking and adding spans for all the fetch calls we make later on. Right, and now we just have to add this file to our SvelteKit application. So one way how you can do this is you can just essentially import it on the top of your hooks.client.ts file because this ensures that the SDK is loaded very early in the client-side lifecycle of SvelteKit and it means that we essentially have an overview of everything that's going on just right from the start. All right, so we kind of set up the client side. Now let's take a look at the server side. It looks kind of similar.

 then have to import some stuff, and then we can initialize the node SDK in this case, and that really is very similar to what we saw before in the browser. And one notable difference here is that we don't have to specify which instrumentation exactly we want to use, because we just can't let OpenTelemetry figure this out on the fly, so this will essentially listen to the imports you make later on in your code, and just add instrumentation to whatever you're importing. So in my case, with that TodoApp we saw before, I'm using Postgres as a database and PG as the library to interact with it, so that instrumentation is going to kick in. One thing here, I'm going to also register the import in the middle hook. Let's not worry too much about this, I will come back to this in two minutes, but let's just remember it's kind of important. Alright, that's already it in terms of setup, then we just have to build our application, and then we can actually already start it. And for my app, I was using the node adapter, so I'm just using the standard node start command, but I have to add the dash dash import flag to preload basically my instrumentation.server.js file. And again, let's not worry about it too much. Why do you have to do this? I will come back to this in a second. Cool. Then let's see. Our application is up and running again. So we can see if we still need so much time to load those to-dos. Yeah, it still takes long. I think I wrote some bad queries here. We'll see. Because now we can go to step five, which is to analyze what's actually going on. For this, I quickly switch into Jaeger, which is the tool I said before. That's kind of my tracing tool of choice today. And we can now take a look at the traces within the last five minutes. And we luckily have some. So let's take a look at such a trace. And as you can see, as you saw before, basically, we now have this hierarchical structure of spans on the request lifecycle. And let's maybe break this down a little bit. So right at the top, I can see that the entire request that we see here took 8.5 seconds to handle. And that's obviously way too long for just loading a couple of to-do threads. That shouldn't take longer than a couple of milliseconds, actually. So let's see why that's happening. So here we have the first spam, which is kind of the root spam of the trace. And we can see here that this was basically made with fetch It happened on the client and it was caught by OpenTelemetry fetch instrumentation So that was probably a fetch call within the load function of my client code And now here we see kind of the counterpart, which is the server side. So we can see here this was, this ban was made on the server. It was a get request, and you can also see basically this took almost as long as the client side. So really the bottleneck here is the server side. And then let's take a look at some more spans here. So as you can see, we have this get all user spans here. Kind of, it's pretty fast, right? 12 milliseconds. That seems nice. But then here, it's getting interesting because I'm loading a couple of things here. It says get to do's for user. And here again. And here again. And it seems like this is happening a lot and it's taking a lot of time. So something seems off here. And maybe let's also quickly take a look at a query spam because it's also quite interesting. Because OpenTelemetry instrumentation really gives us also a lot of metadata around the spam. So I can even take a look at, for example, the SQL query that I was writing. And well, here I think we can maybe see already the problem. I'm fetching some to-dos for a specific user, right? So initially we saw that get all user span and now we're seeing, well, these get all user spans. So what I think is happening is we have some kind of n plus one query situation, which, well, obviously you shouldn't have. But, yeah, that kind of might be a crafted example. But in reality, a lot of the times stuff like this just slips into large code bases. So at Century, for example, we also definitely have some n plus one queries we still should fix. But yeah, this just happens and it's good that we at least have some data and some insights that is actually happening. And you can manually inspect this just like we did now, but some tools out there also provide some kind of data analysis on top of spans. So then they can actually tell you for you or just look at your trace and then tell you, hey, you have a M plus one query issue here. Fix that. that. And yeah, that's kind of the idea of tracing. And at least we saw now how I can fix my problem All right So I previously said let not worry too much about this thing called import in the middle that we previously showed or about this dash dash import command you have to add to your run command of the application Let's talk about that. Why do we have to do this? And the answer here is, well, our module standard ESM, which has a little bit of a complicated background with instrumentation and tracing tools, and we'll just see why that is today and how we can maybe fix it a little bit. So when we talk about instrumentation, there are two fundamental approaches in how instrumentation libraries like OpenTelemetry can actually get their data. The first one is what I call kind of the listening approach, which really means just that the instrumentation can listen to some signal that's the library or the framework or whatever we want to observe, basically, that it emits. So in the case of, for example, the server-side node-fetch library, OpenTelemetry can listen to diagnostics channel messages, which is just basically kind of a nice way for libraries to emit certain signals, and then whatever is listening to it can pick up those signals and extract some data out of it. So this is a very simple example here, but essentially that's what the OpenTelemetry instrumentation for node-fetch is doing. The big thing here is the library or the package we want to instrument actually has to emit these signals. And unfortunately, not a lot of libraries do this nowadays. So we have this other fundamental approach, which is called patching, monkey patching. It has a couple of different names, but it really boils down to kind of hooking yourself as an instrumentation into the code path of certain operations or function within a library. We can see here, it's kind of a simple example, but it's not far off from what OpenTelemetry is actually doing with the PG library for Postgres. So it basically, sorry, it basically, well, requires the pull class, for example, from PG, and then you can just kind of store the initial original function pointer and actually like re-overwrite the, for example, the query method, add your start-ban calls, extract some metadata like the query we saw before and then just invoke the original code. This is really the approach that most open telemetry instrumentation nowadays uses. But unfortunately there is no problem with that This doesn really work in ESM anymore At least not how it used to work in common JS with the require statement we saw before So if I would just basically switch out the require statement to an import statement I would actually end up with a runtime error. Because ES modules, by default, when you import them, are immutable. So I cannot just basically overwrite the query function here. Because then I would get this cannot redefine property runtime error. And, well, I would break my user's application. So that's definitely not what I want to do. So, and even if I could do that, there's a timing issue as well. Because ESM modules are not loaded synchronously like the require modules we had before. But they're actually loaded beforehand before the actual code underneath gets executed. So even if I was able to patch this, I would come in too late. Because all the other places had already imported my original module without my patch being applied. All right. So that's obviously not great and luckily there is an answer to this as well. And it's a concept by Node which is module customization hooks. And essentially the idea is that Node actually provides us a specific point in kind of the application lifecycle where we can go in and inject or modify or, well, customize a module. And we don't really have to worry about this as users because OpenTelemetry or nowadays actually the Node folks, actually the node folks themselves, they maintain a library called import in the middle, which well, as the name suggests, kind of hooks into this import process and later on enables instrumentation to add their behavior to whatever library basically is getting imported. So that's kind of the official solution and the official answer by node on how instrumentation with patching can work. But it has a couple of fundamental drawbacks. But for this to work, as we saw, it has to be added at import time, and that happens before our entire user code is executed. And that's the reason why I have to dash dash import my instrument.server file where I register this hook, because only if I do it then, afterwards the rest of my actual application is loaded, and I can in time listen for all the imports. And yeah, as we saw, this has to happen basically before we start the app. And you can do this with dash dash import. You could also alternatively add your node options environment variable and add this flag there. But unfortunately, today this isn't really possible on all platforms because sometimes

 I just cannot modify the run command of my application. Could be due to some fundamental technical limitations, could be to some permission limitations within a larger company, for example. But it's really kind of painful to get this going. And on some platforms, we just don't have the possibility to actually go in and add this flag. So I wish I had a better answer for everybody who is deploying to some cloud providers here. But today, we're really limited by this, and we're kind of hitting this problem not just in SvelteKit, but also in a bunch of other meta frameworks. But I think there is something that SvelteKit could do a little bit better with first class support for instrumentation. And I have two concrete suggestions. I also basically posted the same thing on the SvelteKit repo yesterday and opened a discussion. And yeah, I would be really happy to kind of kick this off with anybody who is interested in that. But yeah, let's maybe talk about this quickly. So the first thing that I think SvelteKit should do is add first-class instrumentation support. And what I mean by this is that, well, users can just basically specify whatever kind of instrumentation and SDK they want to use in a dedicated instrumentation.server.ts file. Kind of similar to how you can nowadays set up server and client hooks And then SvelteKit would basically just pick up this file and in the first step transpile it for us And in the second step we need to adjust the adapters of SvelteKit to take that file and modify a little bit how they're going to start the server side of SvelteKit. So before we saw this dash dash input thing, but there's one other thing that you could do to also get instrumentation in place just in time. And And that is to kind of delay the actual start of the server, but basically not preload the instrumentation, but first dynamically import it. And once that is loaded and all these hooks are set up, you can dynamically import your server code. And that basically also solves the timing issue. And the nice thing for users is they don't really have to worry about this because the framework already took care of it and instrumentation will essentially just work out of the box. So that would be the first idea. And then I also have a second idea about how we can actually make SvelteKit a little bit more observable. And that is that SvelteKit could, for example, emit diagnostic channel messages. So basically, some of these signals that I showed before for NodeFetch, they could come directly from SvelteKit. And they could emit, for example, some messages when it starts handling a request and when it finishes handling this Or the same thing basically for load functions or server route handlers or for server actions as well maybe even for page SSR rendering Because this will kind of give us the possibility for open telemetry instrumentation anybody can actually write one of these, to then really go in and provide a specific SvelteKit instrumentation, and just get users some spans, like basically out of the box, so that they don't have to manually wrap their load functions in star span calls, for example. And yeah, talking about this is obviously always easier than doing stuff. So I took the liberty to already open a PR to SvelteKit as well. That basically adds... That kind of adds this to this first step, this first class instrumentation. I'm going to admit this is just a proof of concept I think I'm definitely missing some edge cases but yeah, I would really be happy to kind of start a conversation about instrumentation and see if there's something we could do actually in SvelteKit to make it a little bit better and I would be more than happy to collaborate with whoever is interested in doing that as a second step we can definitely also take a look at diagnostics channels but yeah, I haven't done this yet but who knows I can give it a try as well Alright so let make a quick recap here Tracing is a really nice way to understand the performance of our application and to find and diagnose some performance issues like this M plus 1 query we saw beforehand And OpenTelemetry is probably the thing you want to use. You can use it directly like I did today, or chances are you're already using it. already using it. For example, using SDKs from, well, Sentry, from Honeycomb, or any other of the popular tracing providers. Most of them use OpenTelemetry nowadays under the hood. And yeah, we saw fortunately today there are some limitations, but as we saw also, SvelteKit, I think, can do a little bit more to help overcome them, at least to a certain extent. And yeah, that's already it. That's everything I got. Thanks, Lucas. Thank you. I just have a super quick shout-out. We're doing a giveaway at the Sentry table. We're giving away some nice goodies, so if you want to sign up for that, there's the QR code on your left. And feel free to drop by at the Sentry table anytime you want. Thanks. you