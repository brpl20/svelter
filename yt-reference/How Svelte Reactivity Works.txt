 Hey friends, today I want to talk about Svelte's reactivity. Every now and then I see this post about Svelte being magic, so for example here where we have this derived and we pass in this function, how is this reactive, right, this must be some magic, or this effect, how do we have automatic dependency tracking in Svelte? And this is something that even Svelte fans get wrong because I often hear on podcasts this is because of the Svelte compiler and etc, when that is not the case. So if you look at this example we can see we have a beautiful counter here, we can increment it no problem we log the value in the console and this works because of signals so today we're not only going to learn how Svelte reactivity works but we're also going to implement signals from scratch and maybe we'll also look at the Svelte source code later. Alright so I hope you're excited as I am and before we get started don't forget to like share and subscribe. Alright so let's talk about framework Andy's so this is the type of discord I see online all the time here we have the React Andy, who says about everything, it's magic, but uses the React compiler and obeys the rules of hooks at the same time, doesn't understand the layers of abstraction, says React is just JavaScript unironically, and molds when you say the JSX is a DSL. And DSL means domain-specific language, like a templating language in Svelte. But of course, we need to make fun of everyone, so here is also the Svelte Andy. He says, excuse me, it's not magic, it's magical. He uses the Svelte compiler, doesn't understand the layers of abstraction, says Svelte is just vibes, unironically, and he molds when JSX is even mentioned. And of course, then we have the chat developer. To him, it's just code. He solves problems, isn't afraid of being replaced by AI, and doesn't self-report by complaining about learning. And of course, he dreams about being a farmer. Of course, I'm joking, but this isn't far from the truth. Alright, so let's talk about signals and fine-grained reactivity. So here we have the creator of Svelte, Rich Harris. Yes, this is a pizza cone, I had to point that out because everyone gets it wrong. And not only is he the Svelte creator, he made Degit, Rollup, MagicString, and so on. So he's really prolific. And in 2019, he made one of the best talks about rethinking reactivity, where he introduced Svelte 3, the version of Svelte that became mainstream. And at that point, Svelte wasn't really widely used. And people still look at Svelte as this underdog, but it's really a mainstream framework today used by trillion dollar companies. And over the years, as more people use the framework, they ran into some limitations. So before Svelte 5, Svelte would statically analyze your code to see what had to change, and then it would create a function for updating the value. But this reactivity only worked inside of Svelte components. So to have reactivity outside of Svelte components, we had to use something like stores. But during that time, as React was gaining more popularity, we had the CEO of Signals, Ryan Carniato, the guy who made Solid, evangelizing Signals. So he didn't invent Signals, but he made them popular. And in fact, he made them so popular that almost every JavaScript framework today uses them. There's even a proposal to add Signals to JavaScript itself. And then in 2023, Svelte decided to switch to Signals. So we have Dominic Ganoewe join Vercel to work on Svelte full-time. So Dominic is basically a wizard at JavaScript and compilers. So he worked on React, Lexical, and Svelte. So he worked on Svelte for around two years to work on the compiler. And since then, you have a lot of salty people that say kind of crazy things like, oh, Svelte is just following trends, they're using signals because they're trendy. If I remember correctly, Rich Harris mentioned that they tried like 50 solutions before they used signals. Usually how this works is that the best ideas cross-pollinate around frameworks, and at some point everyone converges at the same idea. So it might look like everyone is following trends, but in reality they discover the best approach to solving a problem. And signals are the perfect reactive primitive for building user interfaces. Alright, so what are signals? Signals are basically observables with automatic subscriptions. So first we have to look at the observer pattern. So this is your PubSub pattern. So here for example we have count, which is an observable, and then we have observers which can subscribe to count. And then when count updates, we can send an update. As you can see, in this example, we have to do manual subscriptions. And this might look familiar if you ever use Swell stores because they use the same pattern. And you have this pattern in other places. For example, event listeners. So here we have a button where we add a click event listener and then we get the event. Alright, but how do signals compare to the observer pattern? So here we have signals and they have different names like observables atoms subjects refs and so on So here we have a count signal And signals on their own don do anything so they need effects to react to them changing So for example, in this example, we're changing the inner text of the element, and we have this count text node. And the same is true for the write values. Under the hood, the write values are just effects that return a signal. And again, we have this effect that's going to update the inner text of the element with a double count. And as you can see in this example, instead of using a virtual DOM, you have a constantly updating dependency graph. So each time a value updates, all of this reruns and the dependency graph updates. But of course, this isn't true for all frameworks. For example, Vue uses some form of signals, but they still use the virtual DOM from what I understand. And here is a quote from Ryan Carniato himself. Signals alone are not very interesting without their partner in crime reactions. Reactions, also called effects, autoruns, watches, or computates observe our signals and rerun them every time their value updates. Alright, so after that history lesson, let's understand how Svelte actually compiles code. Alright, so if you have the Svelte extension, you can say show compiled code, and that is going to open the compiled Svelte code. Unlike some other frameworks, Svelte doesn't pretend that it's something that is not. Svelte is a language that extends HTML. So let's say for example that we want to create a piece of state called count you're going to see is just a regular variable so it's not even reactive until we actually change the value and if we create this paragraph tag you can see that svelte is going to create the dom elements required so we can also say count here and if you look at the compile code it's really that simple it's actually human readable javascript and of course the first thing that we learn about reactivity in svelte is that reassignments update values so for example we can say count plus equals one or we can say count plus plus it doesn't matter as you can see now the cell compiler notice that you're actually changing this value so it's going to turn it into a signal and let me actually scroll this code so you can see it better as you can see here we have this count which is now a signal and as you can see an assignment is really nothing special it's just a function call using this set method so we pass the signal in and we get the latest value of count and then we increment it by one but that's not reactive the actually reactive part is this template effect in the code itself generated as you can see this template effect has this set text method which is going to update the text and because this signal gets read inside of this effect it gets updated reactively because count is read inside of an effect is going to add it to its subscribers you're going to understand how this works completely when we implement signals from scratch all right so let me show you the next piece of magic so when we use derives for example let's say let double and then we use derived and let's say count times two as you can see the compiler turns this into a function and because derives are also effects they have their own tracking context so for example if we create a function double count and we can just join this code let's return it so now if we go inside of here and say double count and invoke this function you can see that it really doesn't matter because how effects work the only important thing here is that we read the signal so it's going to know who called it and it's going to add it to its dependencies so when double updates it runs this double count function and that is why it doesn't matter if you pass a value or not because count is not some magic reactive container. We can pass it if you want but as you can see it doesn't matter. The only thing that matters is that this function is going to rerun when double updates because it's inside of a tracking context and here we have this effect. This is also what's called a tracking context. And speaking of tracking context you can create your own user effects. Of course for that we can use the effect rune. and then we can say console.log, and we can track count and double. And as you can see, this works the same way. Because these values are going to be read inside of this effect, and this function is going to be added to their dependencies. So when they update, this function is going to run. And that is the beauty of signals. This is runtime reactivity. This happens live as values update. These dependencies change, and then the dependency graph gets updated And if this is confusing don worry because next you going to implement signals from scratch so you going to understand how everything works all right so let delete everything and i have this special signals file so let start here all right so let's create a simple signals implementation well first we need to create state so we can say function state then we can pass in a value and then we can create a signal and basically a signal is just an object. It has this value and it has subscribers. So we're going to say new set so they're unique and then we're going to pass an array by default. And then we need to return the signal and that's basically it. As you can see, signals really don't do anything on their own. That is why they need effects to react to them. So let's create an effect. So this accepts a callback function and now we need to track the active effects so we know who called it. So we can say let activeEffect, let's say null by default, and then we can say activeEffect equals this function. And then of course, we're going to run the effect. So let me explain it so it makes more sense. So for example, if we have an effect, where we say, for example, console.log, and then we have to say getCount, for example. So what's going to happen, we're going to push this function to be the currently active effect. and now when this value inside of an effect gets read it can check hey if there's an active effect like who called me then it's going to add the effect to the subscribers and then later when we update the value we can notify the subscribers all right so in this case we can say function get so we're going to get the value of the signal and then we can say hey if there's an active effect then we're going to say signal subscribers add active effect and then we can return the signal value awesome now we just need to update the effect so we can say function set we can pass the signal and the new value so here is what's going to happen so we can just say signal value equals the new value and now we just need to notify the subscribers so we can say signal subscribers for each and you can say effect and we can invoke the effect and that's it the only thing that we have to do is export these functions and that's it all right so let's go back to app.svelte so let's pretend that this is just regular javascript so let's create a script block let's also create our app here but of course this is still swell so we have to use on mount so let's do that all right so just like swell first we need to target the app element so we can say const app equals document get element by id and then we can pass app and of course now we need to create the paragraph element so we can add it to our app so we can say const p equals document create element and then we can add the paragraph to the app so we can say app append p that's it so now we can create our piece of state so we can say let count equals state so this is going to be imported from lib signals so let's give it a default value of zero so now we can create the effect so we can import the effect and then we can say p text content equals now we just need to read the signal by importing get and then we can pass count so now the function is going to be added as an active effect and then when we read the signal is going to ask itself all right who called me right and then it's going to add this function to its subscribers all right so the only thing that we have to do is update the signal and I'm going to be lazy and use a set interval so let's say one second and here we can import set so we can pass the count signal and the new value which is going to be using get count and then we can say plus one. Alright, so let's save and go to the page and as you can see, it works as expected. And this is the power of signals. Instead of doing manual subscriptions, dependencies get automatically tracked. As you can see, Svelte doesn't do some crazy compiler magic under the hood. Svelte mostly optimizes for developer experience. As the React bros love to say, it's just JavaScript. Alright, and we can even implement our derived. So we can go back to our code here and under an effect, we going to create a new function export function derive And derives are basically just like effects and they return a signal so we can accept a callback function and now here we need to create a signal so we can say value equals state and then we're going to invoke this function here so we get the value and we need to use an effect inside of here so we can use an effect and now we need to update the signal so we can use set we can pass the signal and we can invoke the function to get the latest value and then we just need to return the signal and that's it so now we can go back to f.svelte under let count we can create a derived double so let's say derived imported from lib signals and then we can pass a callback function we can say get count times two and the only thing that you have to do is update the paragraph with the double count instead. And that's it. So now if you go back to our example, you can see it works as expected. Alright friends, that's it. And if you want to learn Svelte, check out my free Svelte 5 course on YouTube. But before I go, I'm going to leave you with a clip from Rich Harris' talk on Svelte reactivity. And as always, don't forget to like and subscribe and I'll catch you in the next one. Peace! So when people talk about signals, they're generally talking about three things. Sources, derivations and effects. Sources contain values. Effects are things that react to changes to those values. Derivations are both values and reactions. They update when their dependencies change, but effects and derivations can also depend on them. So you end up with a dependency graph with sources at the top and effects at the bottom and derivations potentially in the middle. A source might be something like count equals state zero. Derivation might be something like double equals derived count times two, and an effect might be a function that updates the text content of an element, or it could be an effect that you define yourself with the effect rune. In a real app, this graph will obviously look much more complicated, but the essence of it is just this. Now, when count changes, we don't rerun effects immediately. Instead, we follow the edges of this dependency graph and mark reactions as dirty, or in the case of a derivation, sometimes maybe dirty, because it could reevaluate to the same value. And then we wait a beat. enough time for any other sources to update, but before the browser repaints, and then we run the effects. Sometimes if an effect depends on a maybe dirty derivation, we'll skip it if it turns out that nothing actually changed. It's not quite that simple. We don't just want to run these effects immediately because this text update, for example, could be inside an if block, and if the if block is destroyed, we don't want to have run that code and updated that DOM. In some cases, it could even cause an error if you did that because you could be accessing a property of undefined or something like that. So instead we put all of the effects in another graph where your root component is mounted at the top and other effects are recursively nested inside it. And when an effect is marked as dirty, like this one, we mark all the edges between it and the root as dirty so that we can traverse the effect graph from top to bottom efficiently by skipping over any branches that we know are clean and preserving the sibling order of effects. Through the effects that you create with the effect rune or effect dot pre. There are the effects that update text nodes and DOM attributes. We call these template effects. Things like if blocks and each blocks and key blocks are called block effects. And the things immediately inside those blocks are called branch effects. And if you have an await expression inside a derived or in the template, then that creates something called an async effect. So in the async world, when we process the effect graph, we do it a little bit differently, because we don't want anything to update in the DOM while async work is still pending. We still traverse the effect graph from top to bottom, but instead of running template effects or user effects created within the effectorine, we put these into an array. And we do the same thing for async effects. And when we run block effects, instead of putting the newly created DOM, creating the newly created branch into the DOM, or taking an old branch out of the DOM, we create elements in an off-screen fragment and stash the append or remove operation away in a callback. At the end of that process, nothing has actually changed. But we have an array of async effects, and an array of template effects, and user effects, and an array of callbacks. So if you're not waiting for any async work to happen, then we run the template effects and the block callbacks, which brings the DOM up to date. But if we are waiting for async work, then we run those effects and stash all of the other effects away for later. And so when those newly created promises resolve, We mark the stashed effects as dirty, and we do this, repeat the process, and just do this as many times as it takes for all of the async work to settle.