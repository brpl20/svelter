哈囉大家好,我是凱開歡迎收看凱開寫程式今天是IT田仁賽的第11天了也是我們介紹Svelte基本功能介紹的最後一天從明天開始我們就會講一些關於Svelte如何應用在前端的UI互動當中所以今天就是這個Svelte功能介紹的最後一天有沒有很開心我們花了11天把Svelte的功能全部講解完了好 那麼今天要講的是什麼呢今天呢我們會講一些Svelte裡頭內建的一些Elements跟Surfer-side rendering的簡介那我們就馬上開始吧在Svelte當中有一些內建的Element類型那這邊是全部的列表第一個是Svelte 冒號self這個Element可以讓你遞回使用的原件我們等一下會看一下雖然說我目前還想不到有哪些地方可以遞回來使用原件不過Svelte有提供這樣的功能再來是Svelte 冒號Window它提供一個簡便的方式讓你可以直接對Window的物件做一些操作還有Svelte的Body那它跟Window也很類似只是剛剛我們看到Window是操作Window那Body當然就是操作Body再來還有svelte-head那它可以讓你操作head裡頭的內容那這個東西也蠻方便的我們等一下也會一併介紹再來是svelte.component我們可以動態的引入svelte原件再來是svelte-options那這個是你可以針對每個原件本身分別指定你要的編譯器選項我們等一下會一起看那我們就先講第一個這個svelte 冒號self基本上它的使用情境應該還蠻少的那如果你要用的話大概就會長這樣子比如說let's count我們這邊就直接用官方的範例然後呢假設if count 0在做遞回的時候有一個非常重要的地方就是你一定要設定你的條件是確保你的遞回不會掉入無限迴圈最後卡死,最後瀏覽器卡死所以我們這邊就一定讓它是count 0而且每次做動作的時候我們都要確保count這個數字是有變化的好pcountdown然後你在這邊就可以使用這樣子countsself然後你現在可以看到他說maximum cost that size existed對 對不對那他這就是說因為你的count一直都是3所以呢就爆表啦所以我們在這邊要做一個操作counts-1你可以發現這樣子就出現了三個列表三個這個countdown那每一次渲染都是遞回的去呼叫這個元件好,那麼如果沒有的話呢如果有的話呢else好 所以它的使用方式大概就像這樣子基本上應該是蠻少見的好 所以如果大家有任何關於遞回如果有想到什麼適合應用的情節的話歡迎留言讓我知道好的 那我們回到簡報當中接下來我們看一下svelte.windowsvelte.window提供一個方式讓你可以很方便的去加入事件簡介體或者是綁定一些window裡面的屬性給變數那我們實際來看一下這邊的程式我就直接拿掉比如說我今天有一個svelte.window然後呢我可以直接比如說我想要假設inner width你可以直接這樣寫grind inner width給你想要的變數這我們之前有講過嘛對不對inner width你可以直接這樣寫Wide Inner Width 給你想要的變數這我們之前有講過Inner Width然後呢我們在每一次有變化的時候把Inner Width給印出來你會發現剛開始它是On Define沒有綁定 然後綁定之後呢 它會是384然後 神奇的地方來了喔當我改變了WindowsWindows的寬度的時候 你會發現Spelt竟然重新幫你列印出來這個意思是說 當你在呼叫這個這個Bind Inner Width的時候Spelt就會假設說 每一次当我的尺寸改变的时候我都要重新去修改inner width这个变数也是说svelte本身会帮你处理当onresize事件发生的时候我要重新绑定这个变数第二个就是当我的事件被销毁当我的元件被销毁的时候我也要顺便的去销毁这样我也要顺便去销毁这个监听器所以如果没有这个功能的话他大概的施作方式會像是這個樣子比如說我在amount的時候在window加入一個listeneraddEventListener然後假設resize好了但有可能不只resize嘛有可能當我的手機從portrait變成Horizontal 的時候可能也要做類似的操作等等所以Spells 幫你省掉了你要自己去註射監聽器然後在適當時機銷毀監聽器的麻煩比如說 當我如果要用 Resize 試做的話我可能要這樣寫 InnerWeaveInnerWeave等於 Window.InnerWeave然後呢我要在他amount的時候去remove eventListener大概就長得像這樣子所以你會發現透過這個FindInnerWidth的語法看起來會比較簡潔一些那body也是一樣body也是類似的概念你可以在body當中比如說你想要放一個mouseenter之類的或者是mouseleaf之類的那你就可以把這個事件監聽器綁定在body當中並且在這個原件被掛載上去的時候順便註冊這個監聽器然後在這個原件被銷毀的時候一起刪除事件監聽器我們就不用再另外寫程式碼去控制這些東西了那這大概就是Felds的Window還有Body想要提供的效果再來第二點的好處是說你不需要去擔心SurfaceRendering的問題什麼意思?我們來看一下範例假設我今天這樣寫好了然後inner weave假設我今天沒有這個功能然後我現在隨便亂寫inner weave等於inner weave假設每一次做更新的時候我都想要重新去綁定這個值假設我今天是有一個功能想要這樣做好了在spell當中 我們等一下會提到我們的spells 不是我們的spellsspell當中有提供server-side-rendering的機制不過呢 在做server-side-rendering的時候你要記住啊 在server也就是在node.js當中 是沒有window這個物件的或者是叫做gobblewindow那如果沒有會怎樣當然這個東西就會直接噴錯了 對不對也就是說在SurferSiteRender的時候你這樣寫整個App就會壞掉然後你可能Render出來就是錯的東西或者是你在SurferSite裡頭就要做額外的處理等等

那麼,Spelt提供的這個方式呢第一個,因為Spelt知道他現在是在做Surfer-side rendering還是在做Client-side rendering所以呢,他知道說,如果我現在是Surfer-side的話那我這個東西就先不要看等到我的JavaScript load,JavaScript載入之後呢我再去做同樣的,綁定事件監聽器,假設onclick也是一樣,我們在Server-side rendering當中我們的HTML都一定是一個純的自創所以你不可能執行這些東西你也不會有什麼Document, AddEvent,Listener之類的東西所以透過這樣的方式,Spelt就不會在SurferSightRenderer的時候它就不會幫你去註冊試鏡監聽器好所以這算是一個蠻不錯的功能就是我們可以少寫很多這種要額外特別做處理的程式好那這大概就是Window跟Body想要做到的事情再來我們看一下Spell裡面的Hat這個東西也是我覺得蠻好用的一個功能好,我們就直接來看一下吧在前端當中我們常常會有一個需求是比如說欸,我現在在看文章好了Article好,就沒關係,我們就隨便寫ProveHello WorldSpellsShe's awesome好那我們訂好article之後呢假設這個有一個需求是說哎請你幫我做seo那請你幫我的這個description跟我的article一樣好了假設假設一樣然後呢同時我想要設定那個open graph的image對不對所以我們可能會有image url然後這邊可能是某一個好 我們又要出動unsplash就這張好了然後我有一個image URL然後呢請你幫我在這個文章載入的時候第一個請幫我把description跟image URL的這個head的標籤的部分呢塞到我們的meta當中來做SEO第二個我們想要做到的是title的部分我們想要變成文章的名字好了假設這個文章的名字叫做spellsgood good一時想不到好名字那這時候你可以怎麼實作呢你可以用spells head的功能來實作所以假设我这边的metaproperty等于ogImage然后呢content会等于imageURL再来我的descriptiondescription等于description還有什麼呢我要把我的title改掉了對不對所以可以直接這樣寫title等於title好所以當這個文章也就是說這個原件被載入的時候呢這邊的head都會自動幫你加上去我們來看一下是不是真的是這樣子我們順便把文章內容一起印出來好我們來看一下是不是真的是這個樣子確定這邊看不看得到它會不會真的渲染會會,它會真的渲染出來我會這樣講的原因是我怕IPL它可能害怕一些這個安全性的機制所以它不會幫你渲染不過從這邊看起來它是會幫你渲染的沒錯所以你可以看到title的確變成我想要的svelte good good然後meta也變了然後Property也變了好那麼關於這一點它不僅可以在Client-side做使用另外一點很棒的事情就是它也可以在surface-side rendering达到同样的效果也就是说你定义了这个head之后呢Spouse会去帮你收集这个资讯它会去侦测说我现在是render这个componentrender这个原件所以我要这个原件的head的资讯然后它会帮你把全部的原件收集起来之后统一吐给你一个这个你這個頁面當中需要渲染的head裡頭的資訊有哪一些好那這樣子就很方便了就是我們可以透過原件來管理我們的head而不是把head這個標籤統一塞在一個很大的地方或者是比如說在re-ed當中我們可能要用re-ed helmet來實作類似的功能然後如果你要做Service I Render的話你可能又要再做一些其他的事情看起來就比較沒有那麼直覺比較麻煩一點點好當然這邊不是說React不好只是跟大家描述一下差異在哪裡而已對理性 理性 理性誤展好的那我們等一下呢會實際透過這個操作Server-side rendering 一起來看這個機制是怎麼達成的好的,那我們現在來介紹一下Svelte當中這個option element的使用方式首先最常見的應該就是Immutable假設我給他true的話,代表說我的data always都會是靜態的,這時候呢,編譯器就會讓簡單的只需比較它的reference check是不是相同的這邊要寫所以呢當你宣告了immutable等於true的話呢這個編譯器可能就不會做一些太複雜的檢查等等好,那另外一個呢比較常用的就是這個tag等於你要的名稱,比如說myapp好了假設長這個樣子那宣告這個是說你現在要使用spell當中的CustomEelement的功能也就是說我的這個原件可以被當作一個custom element來使用也就是說我可以在外面或者是在external直接這樣子寫那spell就會幫你處理各種比如說define element然後生命週期等等它就會幫你包裝成一個custom element好實際使用上呢第一個你在這邊加了這個之後呢你要在你的rollout當中加入一個custom element的一處那這個意思是說請你幫我的原件,就把我的原件打包成custom element好,打包完之後呢假設你要在你的這邊做渲染你就不需要再做這個了因為我們現在用的方式是走ConstantElements所以這邊就不需要再呼叫了然後呢,我們在這邊直接宣告MyApp所以你會發現效果是一樣它一樣會出現Hello World好,那我們想測試一下我們的Countdown是不是還是可以用的喔 他說他找不到因為他發現他噴錯誤了這是因為我們在countdown裡頭也要去宣告它的tag的名字是什麼好 那我們在這邊再加一個spellsoptions那一樣我們這邊tag給它就假設叫countdown好了countdown好 你會發現的確這樣子就可以成功然後的確它也是用我們的Custom Element的方式不過你會發現為什麼我沒有辦法去定義我的Style那這是因為呢這個Custom Element當中你只能去修改

修改shadow root的style而不能去動到它裡面的style也就是說這裡面的style我們是沒辦法修改的或者是你就是想要想辦法在這邊去做修改好那這邊的是一個比較麻煩的部分所以未來如果大家是想要透過sphert來製作自己的custom elements然後可能把這些CustomElement因為它們是HTML定義的所以它也可以去挪到比如說react或者是移到Field去做使用不過這邊就會因為畢竟CustomElement還不是一個主流的方式所以我們這邊也不會深入談太多那關於這個CustomElement以及SpellsOption的部分我們就介紹到這邊那我們就直接跳到這個Spell當中的SurfaceRendering好的那我們回到這個不知道大家還記不記得我們之前寫的Countdown的程式碼當中好那我們先把之前的build刪掉好了以防萬一然後我們再跑一次看看看一下功能是不是還好好的看一下沒有問題,它是有成功跑出來的好再來呢,我們要做的事情是我們想要幫我們的這個Countdown的功能加入Surface Irendering,現在聽起來好像有點怪怪的,不過沒關係好的,那首先我們先安裝一下Express,方便這個等一下加Server使用然後我們在這邊新增一個新的檔案叫做server.js如果你要在Svelte当中如果你没有透过任何Bubble或者是任何预编器来做的话如果你要在最原始最原生的Node.js当中让你的Node.js可以顺利跑Svelte原件的话呢你要这样子写首先你要这样Svelte然后Register你要呼叫这一个你要Require它你才可以顺利的去使用这个Svelte裡頭的原件不過在這邊還是建議大家如果你的應用比較大一點,或者是你在做比較大一點的專案的時候呢還是透過bubble或者是rollup等等的方式來做server塞回比較好第一個原因是你可以用ES6的語法第二個原因是,比如說你要用這種import的stemin用起來會比較順對,好那不過我們這邊為了簡潔我們就直接就先使用這個最原生的Node.js的這個ServiceRender的方式好,那在這邊呢你可以require你的app.spells所以你會發現原本我們只能引入JavaScript的檔案嘛,對不對,我們可能只能引入JS不過呢,你只要呼叫它之後呢,你就可以使用require的方式呢直接require as felt好那這邊呼叫之後呢它會回傳一個app的這個原件然後呢它裡頭會有一個這個render的方法你再呼叫它之後呢它會回傳你三個東西第一個是htmlcss跟hat好那我們就先來觀察一下是不是真的是這個樣子那我們這邊就先不要把server就先不用開server啦,就直接拋起來看一下就好你會發現,這邊真的是我們的這個HTML嘛,對不對,它就是一個字串然後CSS會回傳一個物件,然後裡頭會是是css的字串還有head那因為head我們沒有定義嘛所以它就沒有回傳任何東西不過如果我們這邊有定義svelte head的話呢假設我這邊給了一個title講做myapp假設叫做myapp好了那我們再跑一次看看看一下svelte是不是真的會回傳你會發現真的有回傳head給我們好那到這邊我們就可以透過這種方式來實作一個非常簡單的Server-side rendering的頁面首先我們先把我們的Express呼叫進來呃require express然後呢呼叫一個假設我用MyAppexpress那麼首先我要做的事情是打listen假設我們開3333port好了然後呢myapp.get我們讓任何的不管是任何的路徑我們都回傳同一的頁面那我們在這邊為了方便就直接寫html的字串在裡面不過通常來講你可能都想要把html字串額外放到另外一個檔案當中我們等一下會來試試看應該會來試試看不過這邊為了方便就直接寫死在這邊好head然後我們就直接把head放進來然後bodybody這邊可能看大家是要怎麼實作不過我們就直接把html給塞進來或者是你可能還想再用另外一個這個div包起來之類的都可以就是看大家實作等等好然後再來呢還有css嘛那一般來說啦css可能你也會想用Bundle CSS的方式就是額外的去載入檔案不過這邊我們一樣為了方便我們就直接把它放在Stell當中一樣然後我們剛剛發現它是回傳一個物件所以我們這邊用CSS打扣好,這樣子就是一個最簡單的靜態的Server-side Rendering的頁面我們來試試看是不是真的可以跑起來src好然後呢我們到3333port你會發現哇 我的這個倒數計時器成功渲染了不過你會發現我的倒數計時器怎麼沒有在動這是正常的因為我們在這邊做的事情只是把html跟css還有head傳進來而已我們並沒有去載入動態時期的javascript所以我們等一下想要做到這件事情那要做到這件事情要怎麼做呢就是你一定要去載入一個Java Scrum所以大概長的會像這樣子public build fondo.js好,那我們重新載入一次重新整理你會發現奇怪怎麼沒辦法載入呢然後他這邊還跳錯這是因為呢Express 這個 Server 他並不知道 Public 在哪裡所以如果你要額外引入的話呢我們需要用 Express 當中的 Static 功能Static 它本身會回傳一個 Middleware所以我們要用 use 來做myapp useuse express.static一樣重新開一次server之後回到我們的頁面我直接把它這樣子寫好了把它放在一起 這樣大家看得比較清楚好 重新整理怎麼還是不行我們這邊是public嘛 對不對然後一樣是public所以這邊就不用public了是這樣子欸?還是不行build然後...我們先直接從這邊測試看看

我們的靜態檔案是不是有正確被設定所以你會發現現在這樣好像是還沒有被正確設定我看一下喔啊 有了所以不能加斜線喔 對 不能加斜線加斜線如果要加斜線的話要這樣子寫才對再試一次看看對好的那這樣子應該就可以成功引入了吧有!它有成功嗯?沒有耶它沒有成功引入因為我的JavaScript寫在這邊所以它在這邊應該要有一個script才對欸...這是為什麼呢?啊想到了 因為Express裡頭啊 它會我們這個是在前面宣告的所以他會先用這個然後當我去請求這個路徑的時候呢他就會先去看這邊的東西那他找找找找找找找找找他找到一個index.html當你的路徑沒有指定的時候呢他就會去找index.html所以呢它就會用這一個index.html 來做回傳為了證明這件事情我們在這邊放一個吧啦吧啦吧啦你會發現它用的是這一個 index.html而不是我們在這裡定義的那我們要怎麼改這件事情呢首先我們加一個public來確保說每一次呢他都是從這裡開始找當我的路徑加上public之後呢他才會去找這一邊的資料夾好那知道這件事情之後呢我們就再重新弄一次啊不過這邊呢也要同時改成public好那我們再重新渲染一次你會發現成功了耶不過呢這好像不是我們想要的我們想要的是這個渲染過的頁面之後直接載入JavaScript而不是再重新冒出一個這樣就是完全錯的嘛對不對那我在想應該是因為我們這邊多加一個結構好,那我們再跑一次試試看你會發現怎麼還是一樣那從這邊呢我們要做幾件事情第一個,這邊要用一個 high draft去告訴 spelt 說我的app請你不要重新渲染而是做一個脫水的動作可是他現在又跳一個新的錯誤了他說options.hydrate only works if the component was compiled with hydratable true所以在svelte當中如果你要做server-side rendering的話你要再做一件事情你要在這邊加上一個hydra-table-tree這樣嗎你才可以做server-side rendering好的我在想在加這個option之後呢Svelte会帮你做一些標記來標記說哪些地方是svelte原件渲染出來的這樣他才知道要怎麼去做脫水然後怎麼把JavaScript載入到正確的地方好這樣子我們就實作出來了一個第一個它可以成功的支援Service Site Rendering同時呢在我的頁面載入完成之後我的JavaScript也会一起载入然后呢同时有动作那从这边呢你也可以直接看到如果我直接用CURL去打这个网址的话呢你会发现它渲染的就会是一个HTML而不是一个空空的HTML文件这样子对SEO也是有帮助的好,不知道大家对Svelte的功能是不是有更深一层的了解呢之后呢我们会搭配Spelt来实作各种UI在前端上的应用还有透过Spelt来做各式各样的互动所以还请大家敬请期待啰我是凯凯我们下次再见啰拜拜