哈囉大家好,我是凱開歡迎收看凱開寫程式今天是IT田的賽的第三十天也就是最後一天啦最後一天我們會把之前寫的解析器然後昨天寫的JavaScript解析器把它整合起來生成一個Svelte的原件的程式好,那我們就馬上開始吧我們今天的目標會是用JS跟HTML語法整合成Svelte編譯過的語法雖然所有的功能都比如說像Transition,Animation或者是動態追蹤生命週期等等這些東西可能都沒辦法完成不可能在這麼短的時間內完成不過呢我們會盡量的去用比較容易懂的實作來讓大家明白說內部當中大概是怎麼樣運作的好那我們就馬上開始吧好那这是我们之前写的程式嘛对不对你可以发现这边我们是用动态然后用自串生成的方式把它生成像这样子的程式不过在实际上如果你的应用比较复杂一点的话呢光是用自串的方式其实还蛮难维护的所以一般在实用上实际应用上来说我们会用语法术来帮我们实作因为语法术里头它涵盖的资讯比较多那么作者本人他自己也有写过一个叫做Core-Red的Library那Svelte里头的这个程式码生成主要就是用Core-Red所以呢我们今天的实作也会利用Core-Red来帮我们生成程式码好那它主要的功用是说你可以直接用這種寫程式碼的方式它會幫你編譯成對應的這個語法數的節點然後呢你再透過printprint這個你再透過print這個函數呢它會把它變成原來的樣子OK那它這裡面有幾個好用的功能第一個是說它會幫你去這個偵測變數也就是說如果今天變數有撞名它會幫你做這個後綴的動作所以你就不用怕撞名好,那大概是這樣子然後再來就是你可以把它做組合也就是說你在這邊這個i會變成一個這個一個i的identifier然後j的話也是identifier然後呢expression你可以這樣子把它組合起來好 那我們就實際來操作看看吧那麼首先呢 我們會需要幾個呃東西來幫我們做一些簡化 第一個是我們會需要一個component那component就是記載著這個spells component裡頭我們所想要的資訊好那這個component裡頭我們想要做的事情有幾個第一個它會接受一個astast就是有涵蓋html跟js的語法數那就是我們昨天有寫的嘛就是用parse然後content得到的結果會有js跟html好 所以我們把它複製然後呢他會有一個fragmentfragment就是我們等一下會實作的HTML的語法對應的語法生成出來的程式所以我們這邊一樣再加入一個新的class叫做fragmentnew fragment然後呢在fragment裡頭我們會想要丟丟什麼呢丟list然後把HTML的語法語一起丟進去好 這樣子最後呢 我們在這邊會有一個Generate那Generate的函數呢 是讓就生成最後的程式碼最後的程式碼Final Code好OK 這樣我們就可以來實作了好,那在這邊我還想要儲存一些資訊是它有存放的變數是什麼然後跟一個容易去找變數的一個map好,那我們現在先來實作一下fragment的部分fragment的部分呢我會接受一個listlist的話就是component然後這邊的話我們把它叫做information再svelte原始碼當初也是這樣命名的好所以在這之前我們再宣告一個node那這個node 記載的資訊是就是一個方便使用的nodeparent 跟跟info然後list.parent等於parentlist.component等於component好這邊的info可以做什麼用呢我想一下喔info.我們可能會需要知道它的type是什麼好這樣子做一個小小的組裝然後呢fragment我們就直接去繼承node然後在這邊我們去呼叫supercomponent然後fragment的部分的話他沒有parent所以我們這邊給node然後info的部分的話我們就一樣把它塞進來然後會有一個childrenChildren 的部分的話,我這邊想要寫一個函數叫 mapChildren那它做的事情是mapChildren然後 list這個是 component 嘛然後這個是 parent然後這邊的話我想要畫 info.children所以这边的话一样嘛component parent跟children好然后我想要return我想要把每一个children都去map一次现在这个children它会是一个这个我们的抽象语法术的那个节点嘛对不对那我想要把这些节點再新增一些資訊然後真正的去做Render好那可能現在看還不太明顯我們繼續實作大家會越來越有感覺好那這邊Map過來會有一個Trial然後呢在這邊我們會想要多做幾個呃我們先實作兩個就好事實上我們能做的大概也只有這兩個Element跟TestElement就是一般的tag像div,p,section等等好,那我們一樣constructor過來component parent跟info然後一樣去呼叫super那一樣我們讓它去繼承node這邊parent然後info就照著塞進去是打type它是一個element然後呢我們想要給它一個name也是一樣是從info打name過來的好,那之後呢我們會有一個render那render的方法就是說去render程式嘛,也就是說這個element它去轉換成JavaScript的時候它的code應該要長什麼樣子好,那我們這邊等一下會實作然後一樣text的部分也是記成node parent info然後這邊我們就直接給data就好了然後list.type.textok好那一樣render我們等一下會實作這個方法好那在這邊我想要做的事情就是嗯想一下喔我们这要把它变成一个node然后呢如果trial.type等于element的话我们就回传我们最后再回传好了new element然后element里面要接收什么component parent跟infocomponent的话就是上面传来的component然后parent的话就是parent然后这边的话info我们就给trial然后else if trial.type.text也就是说如果它是text的话我们就要用这个classno.menu.text一样我们就直接把它塞进去ok

在最後這邊我們就return喔不用return在這邊return null好這樣一來我們就可以把我們的fragment把它map成children了ok然後呢在fragment這邊我們也想要有一個這個render的方法那這個render的方法就是我會去遞回的我會把每個children的render都跑一遍打forEach.child然後呢child.render好 這邊的參數我們等一下再給我們先繼續實作好 那在Element的部分也有可能會有Children嘛 對不對所以我們一樣去實作它那它這邊的Children要怎麼做呢 也是一樣mapChildren 然後一樣這邊component然後這邊給parent然後這邊給info.childrenOK好 這樣子應該就沒有問題了所以我們先寫一個測試看看看一下我們要的語法數是不是有長出來好 compiler.test.js然後首先我們把我們的parse function給引入進來再来我们把component也引入进来compile component我们describe component它这边应该要做什么事情compile我們先看一看結果就好這邊我就st 等於 parsescript console.logscript這邊寫 html 的 tag然後呢 把它放到component 當中new componentast這邊還沒有把它 export 出去所以我們這邊把它 export 出去component好,那我們來看一下我們比較在意的是fragment的部分沒關係我們先看一下snapshot長什麼樣子好他fail了oh most code super所以我有些地方忘記code super了這邊?這邊忘記call super欸不對啊component不是node哪邊忘記call?欸?都有call啊都有call,啊這邊沒有call好,把它補回來super,component,然後parent,然後info寫進來了,我們看一下長什麼樣子HTML這個是AST的部分所以對 我們不要這樣寫好了打Fragment 這樣應該會比較好看一點安心嗯? 等一下怎麼感覺還是舊的我現在每次去呼叫他的時候他裡面都會參照到component所以他現在有一個可以看到這邊有一個circular reference所以這樣看其實有點難看想一下怎樣用會比較好不然這樣好了我們把它變成這樣好像有沒有比較好對他現在冒出說Comfort Circular Structure沒關係那想一下這邊怎麼做會比較好打Fragment然後打children打fragment 打children所以感覺起來它是有成功被map過去的你看到這邊type是text然後parent是一個fragment這個門ok然後element的部分我想觀察一下他沒有放進來有 你看這邊是element嘛 對不對然後name的話是p所以我的程式碼是有動作的 雖然這樣檢查的方式不太好我們換個檢查方式好了0 第0個Children是p所以我們期待它的type會是一個element這樣子比較好然後呢Children裡面這邊有一個html的text所以我們再給一個children.type應該會是一個text好 雖然這樣比較寫起來比較沒有那麼直覺一點 不過這樣寫會比較正確啦好 所以我們可以知道說 欸 他有幫我們把這些轉換成正確的節點 這樣就OK了接下來呢 我們就要試著開始生成程式碼了 有點刺激了首先 在spill當中啊你可以觀察到它會幫你產生出一個CreateFragment的功能然後裡頭會有C,N,P,I,O,D那我們這邊只關注C跟En就好好那我們就試著來寫寫看吧首先呢,我們一樣,我們在這邊先加入一個新的class叫做block那block這邊是一個方便我去組裝程式碼的一個工具在這邊我想要放的是一樣是component跟parent然後我想要在這邊放幾個東西一個是variables就是等一下我們要做的變數宣告有哪一些還有chunks那chunks裡頭分幾個mount跟create那實際上還有更多像什麼update啊 或者是intro啊等等那這些我們就不另外實作了好然後呢 這個block本身我們就直接這樣放著好了好 那接下來我們要來開始實作這個render的方法好 首先我們先看fragment的部分fragment的部分我是想讓它對全部的child去做 去call一次render的動作所以呢在在這邊我們先新增一個block等於new blockcomponent是list然後parent是其實感覺不需要放對啊我們就直接這樣好了然後這邊就不要寫這樣子好因為我們現在只要實作當作範例而已所以不需要那麼複雜OK 接下來我們現在這邊有block了對不對然後在我們在這邊去呼叫list.fragment.render然後裡頭放block跟null

在fragment裡頭呢第一個參數是block第二個參數我們放parent然後這邊也一樣就parentblock parent所以這邊也一樣block跟什麼 parent好那這邊就可以開始寫了首先呢我想要讓它這個text也要有一個變數名稱嘛所以我先給它一個id叫做t好了因為一個HTML當中可能會有很多text所以我們可能要去放一個map來表示說這個變數現在用過了所以我們先這邊宣告一個useFault然後想一下喔這樣的話感覺在在block當中去放入component應該會比較好阿不用沒關係我們這邊已經有component資訊了沒關係好那這邊的話id我給一個t好我們這邊宣告一個這個判斷式喔那這邊的判斷式是說我想要知道說欸這個t現在到多少了這樣我的變數才不會有衝突嘛好所以我們這邊先新增一個這個component.usedFor.st那如果有的話代表已經有了所以我們這邊set然後get t 然後加1那如果沒有的話呢我們就去欸如果有的話加1如果沒有的話就是set 1那這邊的話我們就可以這樣寫加get好,那在這邊我們就可以這樣寫囉首先呢,我們在 block.create.push然後我們在變數裡頭也要新增一個好,那在這邊我們就要引入這個correct然後有它有兩個x跟b然後還有print這三個函數好那在這邊的話我們要用要用b應該是用b吧我也不確定是不是用b好那我們首先要放一個變數進來所以我們先在這邊先放一個變數list.id等於等於什麼還不需要還不需要給值我們只要先get variable就好然後在create的時候我們再去宣告這個值list.id會等於什麼document.createTextNode然後這裡面放list.data然後在mouse的時候就是真的被mouse上去之後我們要放一個是說欸?把它放到把這個list.id放到哪裡放到parent當中放到parent.id當中OK好那在element這邊呢我們一樣第一個我們先給一個id那這邊我就直接把這邊的邏輯全部都複製過來因為我們一樣要去避免比如說div這個tag好了那他可能會有很多div嘛所以我們一樣要去做這個衝突的判斷全部改成list.namerendering的部分一樣有block跟parender 部分一樣會有 block 跟 parent然後我們這邊一樣block.chunks剛剛都忘記加 chunks這邊不用,fairable 是這樣子chunks好,這樣子就沒問題了對,上面打push一樣我們要把變數也放進來variable.push一樣lets.id等一樣還不用等然後這邊的話一樣chance.create然後這邊一樣list.id 等於document.哎喲document.createElementok然後裡面的話是放list.name好那Mounts的部分的話呢Mounts的部分喔,Mounts的部分的話Mounts的部分就是append這邊我們是不是寫錯啊?喔沒有寫錯,append沒錯我們要把這個 div 或者是這個 element 塞到 parent 當中ok所以這邊一樣放 list.id這邊一樣 parent.id那如果沒有 parent 怎麼辦呢我們就直接塞 fragment好等一下我們再想一下這邊要怎麼寫會比較好ok 那這兩個都實作好了之後呢其實就可以開始Render程式然後Element裡面也有可能會有Children所以一樣這邊我們會去呼叫list.children欸?那這個是 text這邊一樣我們去 list.children.forEachchild.render那一樣我們把 block 跟 parent 放進來等一下喔這邊的pattern應該要放這個element本身吧對嗯好好接下來我們已經把所有render要做的事情做好了嘛這樣我們就可以開始生成我們要的程式這邊的話我們就先宣告一個body好了然後 body.pushbxfunction.createFragmentFragment裡頭要做的事情是我們會去Return然後同時這邊我們會去放List.Block.Ferrables然後Return的部分我們會有詞做兩個一個是C那我們把它寫清楚叫做Create跟Mount這邊的話我們就放 list.block.chunks.create這邊的話我們就放 mountpush 完之後呢 我們要做的事情是這邊我們會呼叫 print然後最剛開始的type就會叫program然後body的話就放body這樣子應該就ok了然後打扣好哇完成了

我們來試試看事不宜遲有可能會有出錯expect component.generateto beoh它說什麼block is not defined好我們來debug囉它說block is not defined list.fragment在generate的部分我們少加一個list好然後慢慢來這邊有一個list.id它說unexpected token failed to parseok 所以我們來看一下list.id他說在哪裡啊 我看一下在element.render的部分 也就是這邊啦他說這個是沒辦法解析的我想一下喔Element的部分所以是這裡喔我這邊是不是多打一個掛號好接下來呢它說 cannot read id of nullok 所以這邊的話有parallel我們再給parallel打ID不然就給一個fragment嗯?喔這樣子好了!喔!有沒有看到?有沒有看到?程式碼生出來了這樣子,這邊就有一個createFragment然後createElementP,然後HTML然後這邊appendP1到fragmentappend t1 of u那我們等一下會再去定義fragment是什麼啦是什麼啦好 這樣子我們至少邁出一大步了 然後我們看一下這個嘲諷的是有沒有辦法成功spam然後再一個spamnestedok,他說T is not defined所以,嗯?等一下,T is not defined好,沒關係,我們看一下在第幾行在56行,這裡,啊ok,T1T2,都有可是現在感覺這樣順序是反過來的那我們乾脆就讓他做reverse好了reverse看起來比較順好這樣子他就會先你看喔他就會先去把span放他會把T2先放到span當中然後把span放到P1然後把T1放到P1然後再把P1放到fragment這樣子應該OK好 這樣是我們就生成我們的component最基本的component了接下來呢我們要做的事情是我們要把JavaScript一起塞進去對不對好 所以呢我們這邊可以這樣寫young body.push然後xfunction instance好 那在這邊我想要做的事情是我想要做的事情是list.st.js我想要做的事情是把除了变数宣告的东西的程式码都放到这里面好所以我们n.type那我们看一下变数宣告的这个接点叫什么变速宣告的话它叫做所以我们把它复制起来不等于好這樣子應該就會有嗯?他說list.ist.js啊.body這樣嗎ok,欸你看你看這邊有塞進來了然後你看這邊有塞進來好 所以這邊的那我們要確定一下是不是真的它不會去吃這個變數的部分所以 let a 等於 1嗯 你看 它還是不會把變數放進來那這個變數要放哪裡呢這個變數呢 我們是希望它等一下可以跟我們的 template 一起共用跟我們的 HTML 的程式一起共用所以我想要把它放到最外層所以呢 在這邊我想要先做一件事情是我們先去走訪所有的Jazz然後呢這兩個就可以用到了好我們去啊不對,我們直接用walk這個ES3 walker我們直接用walk這個函數呢去走訪整個語法樹HTML打...呃...list.st.js然後它在裡面可以定義兩個function,那我們這邊只要enter就好它可以給enter跟leave也就是當你進入節點跟離開節點的時候要做什麼好,那我們這邊想要做的事情是如果它是一個fairabledecoration的話,就幫我把它放到我們看一下decoration裡面會有一個fairable decoration裡面會有很多decoration 因為你可以這樣寫b等於2這樣寫no.decorationsok.foreachDecoration好,那我們想要做的事情是把它加進來Farce.push那push的話我這邊type.fairable那其實真正的實作它會更複雜因為你這個變數你要做的事情是你在你的原件去宣告變數的時候然後你在template也有用到的話你要做的事情是你要去依賴追蹤這個變數那這個邏輯就會變得非常複雜所以我們這邊呢不會實作我們只是把它放進來而已kind他是不是可以寫的writable判斷writable的話就是看kind等於decoration.kind等於const如果是的話就代表他是可以寫的然後idid他會有個identifieridentifier 跟所以可以這樣寫然後init好 然後呢等一下 然後我們再把farlookup 放進來key的話我想要給的是等一下喔我想要給的是decoration.id.name然後對應到Node但我這邊是不是沒有寫好我這邊好像有地方沒有寫好少一個好,那把它放進來之後我們就先放進來就好然後等一下我們再去做處理

好然後這邊的話我想要另外宣告一個叫做global variableglobal variable的部分就是我們剛剛說的這個放到fars裡面的東西所以我們可以這樣寫fars.map不行fars是關鍵字我們叫fa好了偷懶然後然後我們就去return一個b這邊的話我們就寫va.哇 等一下我們這邊再加一個kind好了va.kind 然後va.nameVA.id VA.init然後我想要把它放在最前面所以我可以這樣寫print b global files.code加等於空行這樣寫有點醜看一下是不是有放在最前面好像被吃掉了等一下喔因為我們沒有去walk,還沒有去呼叫他walk.js喔,他這邊說unexpected token所以我這邊應該要給aqus才對嗎還是我們直接這樣寫啊然後這邊一樣叫b好了他還是說unexpected這個函式庫的文件很少所以我們只能猜好看來用b然後直接宣告let是可以的不過這樣有個問題如果原本是用常數的話這邊就會有問題好 沒關係我們就直接這樣子寫吧好所以這樣寫之後呢它會幫我把所有把我們宣告的變數呢放在最外層這樣我們在create fragment裡頭就可以去呼叫它那這有什麼好處呢我們就可以去我們再加一個class叫做mostpack的這個標籤就是用這個大括號包起來的好,那一樣parent,然後info然後呼叫super我們很快速的來實作一下list.name等於info.name其實這樣就好了然後render的部分也一樣render的部分會有block跟parent那其實它的幾乎跟text的實作是一樣的所以你可以把它其實可以統整起來也沒關係不過我們這邊就另外再寫就好就好這樣子 然後list.data 我們這邊就不需要包起來因為它是一個變數list.name好那在這邊其實你可以做一件事情是你可以去找找看componentlist.component.varlookup.hasList.name因為我們之前實作的時候只限制它可以打變數我們沒有限制我們就是它沒辦法去輸入表達式那這樣做的好處就是比較好找因為一般來說spell是可以這樣寫的比如說我的變數叫做list然後我可能想要map一下這樣子他可以接受表達式可是我們在實作的時候我們只讓他是一個變數名稱原因就是因為我們不想要再去裡面再去做解析的動作好所以我們去看一下有沒有這個name然後如果沒有的話就可以像spells一樣跳出一個警告說欸?this.name is not defined好那這邊也一樣喔push這邊的話我們其實不需要再另外宣告變數create的部分create的部分create的部分create的部分create的部分要所以這個要放著我想一下喔當我們在去呼叫當我們在去呼叫其實你可以直接把其實你可以不用在create的時候這樣寫你可以在這邊append list.idlist.id是什麼不行 我們還是要create一個node想一下喔其實不用 我們可以直接這樣寫text然後list.name也是变数名称然后塞到parent的ID当中好,然后这边多一个那这边也有可能会有parent不在的情况所以我们一样parent.id或者是fragmentfragment好,然后一样写一个测试看一下好我們就直接偷懶to snapshot然後這邊一樣to snapshot然後這邊一樣toSnapshot然後這邊呢issue.compile.jstagst等於parse所以我們先在這邊宣告有宣告變數然後在底頭也可以用了我們試試看 啊等一下這樣子不過我們在這邊還沒有實作這在component當中在fragment當中啊在這邊啦 在element當中else if trial type等於我們看一下它會長怎樣子最後一個,它也是有渲染成功的你看喔這邊 text Aappend text A 到 span 1append text A 到 span 1 沒錯那我們如果再加一個 123append text A 到 123等一下喔順序好像怪怪的嗯順序好像這樣順序好像反了所以好像不能 reverse 對不對把A塞進來,然後再把T2塞到SPAN1當中那這樣的話就會變成,T2塞到A的後面所以我們這邊還是改過來好了我們原本有呼叫REFERSE不要,拿掉看一下,這樣子的順序對不對把P1塞到Fragment,也就是最外層,然後再把T1,也就是HTML塞到P1

把span塞到p1當中把t2塞到span1當中然後再把textA其實我們不需要呼叫text我們就假設這個A會是一個字串或者是可以被自串化的東西這樣子一來我們就有Create Fragment跟Instance的部分所以我們其實已經做好了幾乎所有的準備可以去生成一個這個svelte的原件接下來我們會開始寫一些runtile程式碼來做但確定可以做得好那我們先把測試也是一樣偷來喔to match snapshotssnapshots好然後生出來的這個component等一下attr還沒實作attribute沒關係實作很快 所以我們馬上來做一下等一下 怎麼壞掉了tocompoundertomatchsnapshot2這邊沒有打好tomatchsnapshotMatchSnapshot欸?好,這樣就沒問題了我們忘記實作attribute的部分了沒關係,我們來馬上實作一下element的話蠻快的呃,attribute這邊我們就給attributes.info.attrs然後再嗯,我們因為我們現在的attribute現在還是都只能是純靜態嘛雖然說這樣子很雞肋因為一般來說我們想要它的動態不過沒關係我們這邊只是示範這個何操作,所以我們就只在這邊mount這邊做一個這個iflist.attribute.length大於0的話呢,我們就去做forEach那forEach裡面要做什麼呢,我們就去呼叫mult.chunks.mult.pushb.append不要了,就直接list.id.setattrib然後呢,這邊這邊要怎麼寫attr打name然后这边是attr打value嗯?他怎么一直等下我是没有写写正确to match snapshotto match snapshot复制接上to match snapshot好 没事了好 再来我们来测试一下tab attribute然後我們這邊隨便加一個attributerule等於status好啦我們來看一下產出來的程式嘛有了,在這邊然後這邊有一個setAttribute所以是沒有問題這邊要是字串所以我們回到component當中把它用字串包起來好,它有用字串包起來了這樣就沒有問題了之後呢,我們可能會希望它可以接收變數因為它有一個我們可能會希望它可以接收變數不過時間有點不夠我們就先跳過首先呢在這邊我想要這邊大家會希望留著嗎?還是就直接刪掉我們在Generate這邊Generate這個是我們手寫的直接用String寫的程式沒關係,我們這邊就再寫一個GenerateTo.js這個是比較正統的寫法好,我們去呼叫我們先updaterequire componentcompile component然後parse那一樣我們去呼叫filesystem然後filesystem.writefilesync等於app.svelte然後呢new不對我們要先去readconreadfilesynccontent然後呢A...RifleSync我們就把它叫做 name.js然後new componentparseparse什麼? parse content好 這樣子接下來呢 我們去呼叫node然後 generateto然後它他說沒有app.spells所以我們新增一個然後一樣我們再寫一個scriptlet a 等於 e然後pap喔 好 然後產出來之後等一下喔這邊有個object我們要去code generate的方法這樣子他說Can I read ID of no好因為想一下喔我們這兩邊沒有做條件的判斷式parent id這邊這邊要做一個判斷式fragmentsok 我們再編譯一次喔 好像成功了等一下 為什麼這個text-node長那麼奇怪它會跟我的結果完全不一樣啊 我知道為什麼了有可能是我知道為什麼啦這邊我們要把它變成toString好這樣就合理了對 看來我想得沒有錯好所以我們把它剛剛會錯的原因是因為read file sync它回傳會是一個buffer那我们要去呼叫toString把它变成这个正确的自传因为我们现在的poster它只能解析自传好那这样的话我们就有一个createFragment跟instance接下来我们想要写一些wrong type的程式嘛其实我这边做的事情会变得比较简单一些第一个是我们去实作append这个function跟fragment跟宣告global的fragment的變數我想一下喔我們就直接偷懶好了叫做run time.js然後我們這邊宣告一個appendno target所以append child no這樣就ok了然後functionFragmentWindow我们就偷懒把它变成一个Global的变数Window Fragment等于Document.body我们就直接把它塞到body里头好然后我去呼叫Create Fragment所以

打mount然後create fragment打createOK 這樣子我就只要跑wrong type就好了接下來我們再新增一个index.html2首先我们先去引入runtime的程式然后我们再引入一个刚刚写出来的热腾腾的man.js的程式好終於到了最後決戰的時刻登登跑錯誤了沒關係他說createFragment is not defined啊 因為我們先跑runtime我們應該先跑man.js然後呢他這邊現在寫說什麼setAttribute of undefined好等一下喔我們是不是寫錯Create然後再mouse所以應該是對的好我們把wrong time拿掉啊!component等於create fragment這樣才對啊component.create跟component.mult這樣子好,然後它說 rule is not defined我是不是忘記啊, rule 的部分也要用那個把它包起來就是用 quotes 把它包起來我忘記把它包起來了所以這邊包起來好,然後我們再重新 run 一次哇,出來了,有沒有看到非常感動的時刻啊接下來我們再稍微測試一下div然後article這邊我們寫一個article等於hello world this is karenwe built mini spelt好 我們終於快要把它完成了雖然說離真正的可以用的階段還蠻遠的好 再產生一次 再打開來欸等一下喔 它說append child的部分哇 我們不能打article 因為有可能會撞名不過撞名是一回事啊,A1,我們假設叫A1好了我們看一下錯誤是什麼,然後把它解決掉Fail to execute append trial on node. Parameter 1 is not of time.你的child一定要是一個這個note才行所以對所以我們還是應該要用text把它包起來好text所以我們這邊就return一個document.createTextNote然後text好然後呢在component裡面我們回到attribute的地方到mostAttack的地方然後這邊我們用text把它包起來好有沒有看到這邊終於跑出來了太開心了雖然他現在並沒有辦法做很多事情就是当你的变数变了它还不会变这样子然后也没有依赖追踪也没有神明周期也没有事件检听器不过呢我想从这次的范例当中大家应该可以开始清楚的知道说SFILT它是透过怎么样的概念呢去帮你产生出这样的程式吗然后实际上如果你要再實作更多功能的話可能你要考慮的東西也會越來越多就算是現在這樣我們也寫得有點辛苦了更何況這已經是超級簡化過後的版本好,那麼以上就是這個Svelte大概是怎麼樣運作然後我們透過這幾天的練習自己動手寫出了一個非常迷你的版本的Svelte好 那麼鐵人賽到今天也算是告了一個段落啦希望大家從這個系列的影片當中或多或少有學到一些東西那不管你在工作上是不是會真的使用到Svelte也好可能你是用Re-Edit 可能你是用Fuel那麼我在之前有說過嘛多样性会是前端不管是前端也好或者是软体开发工程也好甚至延伸到整个社会也好都会是一个很棒的存在所以希望Svelte大家看了这系列的Svelte教学可以对整个不管是前端也好Svelte也好整个前端框架的生态圈也好有一个更详细的了解好那么如果你有任何问题的话都欢迎在影片或者是铁人赛文章下方留言或者是直接追踪我的Twitter也可以好那么终于到最后一天了也是说再见的时候了好了我是凯凯我们下次再见咯拜拜