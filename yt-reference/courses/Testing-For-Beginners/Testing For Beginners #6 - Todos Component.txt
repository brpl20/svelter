 So if I could only test one thing about our to-do's component, it would be the to-do's well component. Because the to-do's well is our entire app, and by testing it, we're doing integration testing because of multiple components working together. And we only care about our tests, so we're not interested in what type of testing it is, even if someone pointed it out with, say, I guess, I'm just confident it works. And if you look at it, we can see why it's an integration test, in theory, right? Because if I scroll down here, we can see how it's multiple components working together. and for example it would be difficult to test inside the to-do component itself if it's working etc because the logic for that is outside of it and of course it depends on your project structure etc because if you look at here we really only care about can we add a to-do can we edit it can we complete it and can we remove it so yeah that's the only thing we care about so we should be able to add a to-do item edit a to-do item remove a to-do item filter the to-do items and clear the completed to do items and if our business depended on it this is everything we would care about so once you identify what you need to test you can start from there and explore how to achieve it and also where you add your tests inside your project is an important to jest so that being said it's easier if you place them near your components so let me just close this and if i show you here so we place the test folder near our components but you also have scenarios where you can add different folders and if it has more files then you can collocate your tests with your components there but it would just be unnecessary folder drilling so I want to avoid that and that's why we're going to write tests like a single folder but you do there are like no wrong or right way to do it so another thing I want to emphasize is how you can get help writing tests or help in general so if you need help join a discord server of the framework you're using because everyone speaks the same language even if it's testing the same for every framework like someone is going to have experience how you test x or y for the specific test you want so you can ask how to test what you want but please i always see this mistake with people provide a reproduction with your problem so it's easier to help you so use something like code sandbox make a test there it works in the browser and then just send the link to someone and they can help you out since you're simulating the browser environment we need to clear the local storage because our app uses the local storage because if you look here, if you open the developer tools, you might not see these menus, but just go to applications local storage and then we have local storage So if I add that to do it going to be here And this is an easy part to remember when you testing that it actually simulating a browser environment So you also have to account for local storage and you need to clear that between tests if you're doing a kind of testing that can affect that. And I was stumped for a while on this and then it dawned on me that I have to do that. So yeah, I'm going to save you time and pain, right? So this is how we're going to do it. so we don't need this example test js let me just quickly remove it and then for our test we can add to do's it's useful when you give it the same name right so you know what you're testing and then we can give it a type extension even if it's not required in fact giving it the type extension is detrimental because it's going to double the amount of time it takes for the test to run basically because it has to go for type script but this is the hill i'm going to die on it seems so yeah let's go let's add this and it's already failing because we don't have any tests and you can see how just watch works beautifully so the first thing we're going to do is import to do's from to do's well because it's in the folder above so we're in a test folder and we just move one up and then we have access to our components yeah so we can do that and then just expose these global methods after each test and etc so you don't have to be worried if you need to import them or not so you can say after each and then we give it a function and then you can look on mdn but you can just trust me that to clear the local storage we have to say local storage clear and you see this completion that you get like this is typescript if you know it or not this is what powers the auto completion in your editor so the joke's on you because you're already using typescript okay i'm just joking i'm not a zealot i promise so yeah so we're going to have an error because we don't have any tests but let's remedy this first i want to talk about how it might feel weird thinking about how to write a test but it helps if you think about it from the perspective of the user so let's say i'm the user and let me just clear everything here so how do i use this app so i just come here and i notice a text placeholder what needs to be done And I'm like, okay, let me click into this. And then I submit it and it just works like that. And we don't need to test implementation details if our frameworks work as expected right We just care how the user is using the app So if I go back to the post so from the perspective of your user you find the input element with the placeholder what needs to be done. You change the value of the input and you submit it. And this is really a fun way to write tests because it's just JavaScript, right? So if you look here, we're going to write our first test. So everything is the same, but let us just import what we're going to need from testing library. So you're going to need fire event, which comes from testing library to simulate what the user clicks. Right. And then you have render screen from testing library. I think it's well, right. Testing library is well. Let me just make sure. Yeah. Testing library is well. And then we can add our test here so we can add our first test and we can say able to add to do item. And it's going to be async. because we're using FireEvent. And this is another reason why it's important to read documentation. Because from what I remember, I'm foggy on this, but FireEvent, for example, isn't async in React, but it's async in Svelte. And why that is? Really simple. If we look at it, we can go here to the API. So if we go here, we can see all the different libraries and Svelte testing library, we can go to the API. And it shows you everything we just used. So you have render, cleanup, act, FireEvent. so if we go under fire event it says async and then it says it calls the fire event and this is the most important part it is an async method due to calling tick which tells swell to flush all pending state changes basically it updates the DOM to reflect the new changes and that's how you learn the most you just read documentation trial and error reiterate and that's it yeah so we can go back here and I hope that made more sense to you. So the next step is to render our markup, right? Or our component. So we can do assertions on it. So we can say render and it's the component that we imported, right? And then, so we don't make mistakes in the future, we can say the value should be to do item and then we have to query it, right? So we'd say, we say to do input element, then we say screen and we can access the method to query the element. You can say get by placeholder text And then if I just come here we can use a regex but you can also use text really depends on you you can say what needs to be done and we just say it case insensitive so by this point we should have the element if I just come over here and now we need to say await fire event we need to give it an input on what element we say to do input element and to change the value we just say the target is equal to value which is another object because we named it value we don't have to say value value but we just say value so at this point it should be changed and then we need to submit it so we can say fire event submit on what element to input element and we could use submit because we're using a form but click would also work if you submit your form that way and then we need to assert if it works so we can say expect screen get by text value yeah so we just grabbed it like this we can also place it in a variable font and we can say to be in the document and we can save it and let's see but we also have to change the path because remember previously we specified the path with p so we can say p again we can say source components tests to do test ts but yeah it works so congrats this is your first test but let's take a minute to understand what just happened so we rendered the to do's component so we can query its elements same like in javascript when you use document query selector but these are way easier methods to do so we query the to do input element by its placeholder text and we fired an input to change the contents of the input and submit it and then we asserted that the value we just entered exists and then we have our first passing test so if you scroll down here another thing i want to point out is that when testing is desirable to first make the test fail so you know it works when it passes to avoid false positive another hot tip i want to share with you is how to debug your test because we really don't have a browser or anything so we don't know what are we doing right but we can use the screen debug method which is equal to console.log so you can see the state of the DOM before and after you made the change. And here's an example of how that works. So for example, if we're here and we have no idea what we're doing right, so we can say screen debug and this should output the entire DOM.

 and we're going to see it in our terminal. So yeah, give it a second. And then if you scroll up, it should display the entire thing in rendered. And you can also see why it's irrelevant what framework you're using because at the end, it's all going to be transpiled into regular HTML, right? So we can do assertions on it. And if you want to focus on a specific element, you can just pass that specific element inside and then it should work. So yeah, here is our input element. So all right, so we're on fire. So how would we test adding multiple to-do items? So whenever something is new to you, like a library or framework, it's easy to forget to adjust JavaScript, but you already know how to use loops, right? So let's add a new test. So here I'm just going to remove the screen. Now let's just add a new test. We can say test able to add multiple to-do items, which is also going to be async. we want to render the to-dos, and then we can just copy what we have previously, as we're just querying. And here is where it's really interesting writing tests, because you're kind of thinking out of the box, right? So we're just pretending we're the user, but we somehow need to simulate, we like enter multiple items. So we can just say to-do item 2, say to-do item 3, to-do item 4. now we have a list and now we can do the same thing we did here but loop over those items so you can say let value of values and we can just use the same code we wrote we can paste it here and then we can assert each time so you can say screen get by text value you want to say to be in the document and if we save let's see if it works so jess should pick it up and awesome we have a passing test so you can see how this is just javascript and the more you write tests you're going to find these reusable scenarios and you can abstract that logic inside the functions and do whatever you want right because the test is passing so how do we test editing a to do we know the user has to double click the to do text if we go here if we double click it we're going to get into the editing state so we need to test this and And we also need to make sure it saved when you press enter on the keyboard But there one problem and is that the ready thing to do input markup isn that great for querying and we could refactor it but you might encounter a case where you can so we have to resort to using a data test attribute So inside the to do Svelte, we need to include a data test ID attribute, and if you remember from the recommendations from testing library, this is the last one you should use as a last resort, right? So if we go to to do Svelte, we can find our input here, which is for editing, You go down here. Here it is. So we can see this is an input, but it lacks a label. So we can't really query it. And it's really an awkward situation. So because of that, we need to say data test ID is edit. And then we can save it. And then we can update the test. Or in this case, we're just going to add a new test. So we can close the to do right now. And then let's add a test. able to edit a to-do item, which should be async. We render the to-dos like before, and we have a value. And I'm putting these things in variables so we don't get into a mistake, so we don't have to repeat what we wrote, right? It's always consistent that way more. So the change value is going to be edited, to-do item, and then we can copy the same thing you had before yeah we can do this and we can see we can copy these two lines yeah and that's it so this is how we can submit it so we need to select the current to do text get by text oops it's always the same text value let me just use screen debug so we can see what's going on so we added a value to do item and we should see that inside let's see here it is a span of to do item so awesome so we're selecting that and then we can await fire event double click because remember we need to double click current to do text. So we're in the editing state, and now we need to check if the input for the editing has appeared, right? And then we need to query. So we can say let to do input screen get by test ID going to be edit which we added a minute ago right and then we can just do the same thing so we can wait fire event change on what element to do input and then again we say target and the value this time is going to be to be what we change right so it's going to be the changed value and if I see here it's the same thing right and then we just need to simulate the user pressing a key we can say await fire event key down new to do input and then we just say key and we say enter and then let's assert if this is working let me just comment out the debug and say expect current to do text to have text content and it's like really intuitive you can just auto complete things until you make something work right and you're constantly going to be screen debugging and checking the values out so let's see if this passes which should and also another test is passing so i just want to mention that we're using fire event but testing library encourages and also has a user event library that simulates more closely how the user navigates and clicks around your application so you might want to look into that but fire event is really simple to use and enough for our use case so i'm not sure about you but i already feel more confidence so here's the thing that might stump you if you tried it whenever you're using animations you have to wait for them to finish otherwise if you make an assertion is going to fail because the dom isn't updated so in this case this happens when removing a to do because if we look at the to do swell titan on the list item we have an animation which happens when the component enters and it's destroyed later so we need to wait for this to happen let me close this so to remedy this we need to use the wait for method and query to assert it's removed so unfortunately Actually our markup is also poor here, so we need to add a data test to the button for removing the to-do inside to-do Svelte. So yeah, so let's just open it again. Yeah and we can find where it removed to do with the area label right And then we need to say data test ID remove And we can change the marker but as I said sometimes you might not have a choice and this is all you have And as long as the test works, it's fine. So we can see here a new test. And I just included the more imports we're going to be using here, but we can just auto import it as we're writing our test. So we can remove this. And then we can say test able to remove a to-do item, which is async. And then we need to get the container from the render, which is documented in the API, right? And why we need the container is because we need to pass it to the query method, and you're going to see later why. So it still renders the component, but we can just pull more methods out of it, right? And then we can say let value to do item. And then we're doing the same thing. So let me just copy this over. And then our first assertion is spec screen get by text the value to be in the document. So we can query the remove button. remove to do button screen get by test id remove and then we're just going to click it so fire event click remove to do button and this is the part where you need to wait for the animation to finish because nothing is going to happen so we need to say await wait for and then we just give a function and we can do our insertion inside here so we have to say query by text because if we use the regular method it's going to return an error because it's not going to find it but query tries to find it until it doesn't so here's where we pass our container and the value and we just want to say not to be in the document and it's complaining because we haven't imported it so Pro tip, if you just type it out, query by text, it should offer an import and you just have to press it. If we do look at the top, here are imports. So that should pass. Let's see. And that's right. Awesome, right?

 So if we scroll down here, I have a challenge for you. So if you're up for a challenge at the end, you can refactor repeating code if you wish, like rendering the to-do and querying the to-do input so it's reusable. And you can do this inside the render to-do function, and later I'm going to show you how we can do this in our other test. But you can do this on your own, and don't forget that you have to return the render so you can use the methods. So you can use this as a great opportunity to learn more. So testing filtering the to-dos isn't going to be harder, but more verbose. As before, we're going to add to-do items, but this time when we change the filter, we're looking for if the DOM is updated properly. So to be able to query the to-do items, we need to add a data test ID for each one. So let me show you what I mean. So it has to be dynamic. So for example, if we have a to-do item and then we have a to-do item too, we need the data test ID to reflect that. So we need to go back to the to-do svelte once again. and we can even find it by where it says class toggle. You can see here is our to-do. And since this is all dynamic, we can just say data test ID. You can say to-do text and that's going to use the to-do text so we can query it easily. And then we can add a test for filtering the to-do items. So we can close this now and then we can say test. able to filter to do items and it's async and then again we're going to need the container let's render the to-dos and let's just repeat what we had before because we're doing the same thing right and you can see how we constantly repeat things so you can abstract this into functions if you want and here the interesting part and why we use the test id so we can go here we can say fire event click screen get by test ID We can use a regex matching pattern so we can say to do item one which is case insensitive, and then we can copy it over, and we can say the second one. So going back to how we're testing how the user uses replication, so here are the filters, which are just buttons, and the user is going to click on each of them, so we need to query them. And to do that, we just need to create all filter button screen get by role, which is a button. And then it has a name. That's all. And then we can just copy these two times more. We can rename this active filter button. So you can see it's not hard, it's just repetitive. And that might be more boring and harder to you. So you can say active and this one is going to be completed. Let me just make sure. Yeah, active, completed. Then when we go back, we just need to make sure they change it. So we have all filter button, active filter button, and then we have completed filter button. And then we just start testing like a user. So for example, if we're here, we can just add more items. Yeah, and if you press active, it should just show the uncompleted to-dos. And this is basically what we're doing here. So we're pretending we're the user. We say fire event, click, active filter button. And then because it's also using animations, we need to wait for the animations to complete, even if it has a duration of zero. And then we can query for the elements. So we can say expect query by text. We need to pass the container, the regex. and we want to check if it not in document to be in the document and then we can copy it over we can change that to do and so far our test should be passing if we run it and definitely to make sure you're logging out and using the screen debugging but it would take a lot of time here so yeah so it's already passing our test isn't burning which is a great indicator so you can say fire event click and now the user is clicking the completed filter button right so we're moving from active to completed and it should return this so we can just paste this entire section and we can say this should be three four let's make sure this is right now test should still be passing awesome so we can copy this and so for the last one we're just returning so we say all filter buttons so if you look here we want to complete it but we want to make sure that all works and then we can just copy this and then I have in this example the last one so we just need to say one two and we need to confirm these are in the document so we can just copy two more say three four and our test should pass awesome congrats so it wasn't that bad this was just verbose but it really wasn't that awful we're going to test if we're able to clear the completed to do items so we should be able to select all items and just say clear completed and for this we're just going to add a bunch of to do items and then we're going to clear them yeah so let's say test able to clear completed to do items which is going to be async again we're going to use the container render rtdos and we're going to have the same thing as before So let's copy that over. And I think we can also copy this right Yeah it the same Yeah so we just adding to the items as before And we're just simulating here, completing all the to-do items. So let's just copy over this part because it's really redundant, right? We're just making sure we click or we can even test if we click. So for example, if we have this, we can even test if we click on this. This is going to complete all the items and then we can see if clear completed works. and that's also a valid option so really testing is about your imagination mostly so we really need to get the clear complete button so we need to say let clear completed button screen get by role button and then we can say the name clear completed case insensitive and then we're going to fire event so we say await fire event click clear completed button and then we just need to test the same thing so we're testing like if it's not in the element after it's being removed so we can paste this because it's literally the same what we've done before and so let me iterate once before but let me say first so it should be passing so literally testing we're adding one two three four and then we're actually doing this click click click click and then we're saying clear completed and that's it so if we go back here all our tests should be passing as we see here and having some test is better than having no test so next time someone asks to add a feature and the tests are passing we can avoid manual test checking and have confidence our code works as expected so now we can focus on testing individual components because we couldn't test the logic inside to do swell for example because it requires more components working together unless you have global state, which is another thing also. So for the two-svel components itself, we can test does it have the right class when a new item is completed or does it handle keyboard events as expected. So see you in the next one.