 Hey, welcome back! In this section we're going to learn how to fetch data using the SwellKit endpoints and how to get tweets from the database you showed them in the feed. But before we start, I want to give you an introduction to SwellKit endpoints. What are SwellKit endpoints? SwellKit endpoints are just files that export request handler functions that correspond to HTTP methods such as get, post, patch, and delete. If you go to MDN, you can look at the HTTP request methods, you might be familiar with get for fetching data, and if you have a form and you're posting some data you use post always but the interesting thing is that get and post are the only ones that are part of the http specification so we're going to see later how we can use something like delete and that's going to be interesting and also i want to encourage you to read up on forms because over the years we really forgot how basic things of the web work like forms so this is really an educational read and i encourage you to go for it so yeah so if i go back here i can start showing you inputs So I'm going to create an API folder, and I don't want you to think this is something special to SvelteKit. It's just going to be an example, because in frameworks like Next.js, you do have to create an API folder where you have your endpoints, right? But not in SvelteKit. This is just an example, right? So we can go to source. We can go to routes, and let me just create an API folder, and we're going to create index Svelte like any other normal route. Yeah, so we can just give it a title. We can say API, and then let's just go to the API, and we can see it displayed here. so let's create our first get endpoint so we can go to the api folder and we can create item ts you also might see json ts which is also valid so you don't have to specify the return type to be json but this is kind of confusing to me to be honest so i really prefer to just use the ts extension or whatever and just specify the return type but you don't even have to do that i'm going to show you what i mean in a second so yeah so as i said you get access to the verbs so you can say export function get and you have other functions like that you have post you have delete but delete is a reserved keyword in javascript so it's del yeah and then i can remove this so we can create this function and if you look at the documentation for swell kit you can see get here and accepts params so you can pass it parameters from the url which you're going to see later but before i do this let's create an item you can just say banana and this would usually be your database or whatever but we're going to use the in-memory value, right? Yeah so we always have to return something and let say status 200 and then we can say headers which is optional you can say the content type is application json and this is also really interesting to read upon on mdn and this is why svelte makes a better web developer because you start to learn and understand these things let me just close the sidebar because as it's distracting. And we can just send the body. It's going to be type JSON. And we can just say item. That's the same as saying item, item in JavaScript, right? So this is our endpoint. We can save it. And this is really similar to something like Express where you create your endpoints. So this is the full stack part of SvelteKit. And for example, if we go here, so remember we created the folder API and here is our endpoint item. So we can say API item and we should see a JSON response. and sure enough we do and that's really awesome so you can go back to the api but now i have another question how do we use it in our component right so if i hide the sidebar i can go back to index well so we have to somehow get it from the server so we can use a script with a tag module and this really means context module to run before the component but in swell kit's case this also means this is running on the server and now we can use a load function which you can read upon here in the swell documentation here's the load function and get params fetch session and stuff and fetch is really important to note because swell kit polyfills fetch for you because fetch isn't supported yet in node but that's going to change in the future so this might change this is why we always read documentation to make sure things are always up to date so yeah we're going to use the load function and just say export async function load and don't forget fetch i always forget this and then I'm debugging for five minutes why things aren't working. So we can just get the content like using any other fetch method. So we can say const response. We can say await fetch. And what is our endpoint? API item, right? And we can just say const item response. Same with any other fetch. We can say respond JSON. Don't forget to await. This is another thing I always forget. So this should log in the terminal because it's on the server and it should also log in the client. So let's see what happens. Just refresh the page and we get an error, which is lovely Let me just say must return a value Ah yes I also forget another thing So this is really a tutorial on how I forget about things So I think we can just return anything from here And here it is So we get on the client the item banana and on the server the item banana. So we can even destructure it like this. And we can return it. So let me just comment this out. And we have to return it like this. Let me just show you in the documentation. Are you loading it? So when you return it, you can return a status if you want. and then you return it as props that your component can consume. So you can say props and then we can just say item because again, this means item, item. So the next thing is we need to use it on the client. So remember this part, we're on the server, right? So think this is the server and then we can use a regular script and then we can define the prop here. So we can say export let item and then we can remove the API text and replace it with item and this should work. Let me just go to the example. It says undefined. Let us refresh. And we get the value from our server. How awesome is this? So let me just show you how we'd use a post, for example. So let's create a basic form. And it's going to have an action. So where should it go? Again, it's API item. And the method is going to be post. Let's do this. We're going to have an input text. And this is really important. We have to give it a name. so the name is going to be item and we can grab this value and then we're going to have a button that has by default a type of submit type this out so we can press submit and let me just use a button class because i have that from before so it's not that ugly so yeah so this is going to post to our server and we can get the value from the form we can update it right so we can create the post endpoint. So I can go here and I can create export function post and we can destructure the request. As we said, SwellKit is based on web fundamentals. So we talked about requesting response earlier. So we can first get the form and this is just the web APIs, what you learn from MDN. You don't even need the SwellKit docs for this. So we can say await. So let's make this async before I forget. And then we can say, form await request, and request has form data on it. And if we were using TypeScript here, we will get this auto-completion. So this is like hard mode right now. So we can get the value the new item from form We can use get and then we use the name of the input right so that was item and then we can say that item is new item but because how forms works it going to redirect so we going to return a status of 304 so nothing change and then we can say headers location and then we can say it should just stay on the api or in this case it's just going to refresh let's see if that's going to change so for the next example we're going to just input when we input something like coffee here and press submit this should change banana to coffee so yeah let us try if this works coffee and sure it does and you can see the page reloaded and that's it so if I go back to the index page this is like old school way of doing things but Before this, you would do for years in current JavaScript frameworks, you would do on submit prevent default, and then you would do handle submit. And inside, you would do function handle submit. So yeah, this would be some nonsense like fetch, and we would re-implement what forms already do for us. I really love this approach because if JavaScript fails, we can fall back on the forms and use that. And if JavaScript is available on the page, we can use progressive enhancement, and I'm to show you how to do that later. I also want to show you another awesome thing but for that let me just remove this event handler so it doesn't get in the way. Let's just remove the function. So up here we're basically repeating this code right because we already have it on the server so why do it twice and we can avoid doing that by using a newer feature SvelteKit called Shadow Endpoints. So if you look at our file if we rename the file from item to the same name as the component we can automatically pass the props from the endpoint to the component, in this case, item. So let me just close the sidebar, and we can just remove this entire code, and it's going to work. So yeah, we can remove this, so we get the item from the endpoint, and we just need to change the API to reflect our change. We can save it, and then let's reload it. We have banana, but if we type coffee again, banana should change to coffee, and sure enough, it works. And shadow endpoints are really awesome in what you're going to use across the series because it's way simpler to write code. And another thing I want to point out is the importance of reading documentation. For example, here we have the post request and then we're parsing the data. So if you read the documentation, you can find for endpoints the body parsing and you can see how to process

 this data so you can get the form data you can get json text or whatever and of course this is just the request object from the mdn you can read up on that if you want and yeah that's it so i hope you got the general idea of what swell kit endpoints are but let's now work on adding the tweets to the page so we can scroll down here and here's the same example i just showed you so we can go to the prisma client part because we need to initialize the prisma client so we don't have to do this in every file we can create it inside the lib folder prisma and then import it and use it in our end points so we can go to source let's create a lib folder and let's name this prisma ts so we can import the prisma client so we can create the prisma client now prisma client and then let's just export it so we can use it export default prisma save it and that's it so i'm also going to have some utility functions like the time posted so for example if you post a tweet a minute ago it's going to say one min or if it was four hours ago it's going to say four hours and we do that by getting the date where it was created at and then we have the posted from the new date that's created at and we get the time because typescript would matter to be like oh this is a date not a string please string okay typescript calm down and then we can get the current time and then we can get the difference and from that difference we can get seconds minutes hours and I only want to show it if it's below an hour, then it's going to be minutes. And if it's over 24 hours, which is a day, I just want to return a normal date because I'm lazy. So yeah, so that's basically it. So let's copy that part and then inside the lib folder, we can create a date.ts file and then just paste this over, save it. And we don't have to think about this. So let's close this tabs. So we're going to create an endpoint inside home because if you remember shadow endpoint is the component and the endpoint has the same name. So since we're using the server and our user doesn't have to incur the cost of it on the client, we can do whatever we want on the server, right? So we're going to get the data from the server. We're going to get the tweets. Find many because the Prisma API is awesome. And then we can also include the user and we can order it. And then we can get the like tweets. But we just want to get the tweets that are liked by the ID. So we're going to do it like that. And then we can shape the data or massage it if you want, however we want. so we can loop over the tweets and then we can return the shape we want and this would be really expensive to do on the client and this is why things like GraphQL etc became popular even though if there are libraries that are like huge over 100 kilobytes and you don even need GraphQL when you using an endpoint like this Of course you can use GraphQL and etc there are other use cases but yeah So we just going to return 400 if there are no tweets and otherwise we're going to return header content type which is optional. We're going to create status 200 okay and then we're just going to return the tweets we can consume on the front end and that's it. Nothing complicated. Let's create the endpoints so we can close this. We can go routes home and then we're going to create the same name it's going to be index ts and then we don't have to type the imports because we're going to auto import them because we're lazy right so we can say cons get and then we can get type which is request handler i only use anonymous functions like this because this is the only way to type a function like this in typescript right now so that's the only time i use anonymous functions because i prefer regular functions So yeah, we have the get, it's mad. So just, let's just return nothing right now. And we can just ignore it. So we can get the data, cones data, await. And now pay attention that you import the right Prisma because if you import the client, it's different. So we want the one we created from root lib Prisma, right? And sometimes your laziness can come back to bite you, right? So this is the correct one. Prisma knows our schema. So we can type dot and knows we have a table tweet. You can get the tweet. And we can say find many. If we look here, our awesome TypeScript. It gives you an example. And this is really awesome. You don't even have to read the docs. But of course, always read docs, right? So you can say include user. Again, TypeScript. Let me just show you this again. You can say include. And then if you ever lose completion, right? Press control space bar. And then you get the option. So this is optional user. And then we say true. now we get ordered by again typescript doing work and then we get posted option and we can say ascending or descending and again look how insane this typescript support is so yeah this is really awesome so we can say descending so we now need to get the like to it so we can say const liked we can await prisma again in other schema liked we can find many and then we get an example or we can say where user ID is equal one. And again, this is hard coded to the user with the ID one, but if you had a session you can get this from your session So we can select tweet ID So we can say const like tweets and we do this by object keys We get the like keys and we can map over each one. We can say key like key tweet ID, right? So now we can shape the data however we want. So the user doesn't have to pay the cost for it. So we can say const tweets data map tweet and then we're going to return whatever shape we want right this is only limited by your imagination say content tweet content again amazing types of completion tweet likes and then we're going to use time posted so here it is and that's awesome so time posted we're going to pass it tweet posted because in our schema we're creating the new time right and we're going to say tweet URL we're going to get the user avatar tweet user avatar and even with auto completion I'm failing so it can save you always tweet user handle get the name from tweet user name and then liked we're going to take the like tweets going to look over them. I'm going to say, hey, does this include the tweet ID? If so, return a boolean, right? And that's it. We can just say, if there are no tweets, return an oopsie. So you can say status 400, and we can now fill this return. Say header. I wish it would auto-complete this type because this is really easy to mistype, but yeah, open MDN, I guess. And you can say status 200, and then we're going to return the body tweets, which is same as saying tweets, tweets, but we can do a shortcut like this. So we can save this. We can add some types for a tweet type. So let's just go and add the types. So we're going to go in source. We're going to create types, types folder, we're to create index.ts types. And this is going to be the same thing we did here, right? Because we created something unique, we really don't have types for this from anywhere, so we can create it ourselves. And that's what we're saying here, tweet type ID content et cetera So you can just save it and close it So back in index we can use the tweets prop now from our endpoint So let just close this So here we have our feed. Since we're using a shadow endpoint we don't have to do all that nonsense. Let's say language typescript and then we're going to say import tweet from root components tweet which we're going to create in a minute and we're going to say import type tweet type from root types. Then I'm going to grab the tweets we exported from the endpoint export let tweets. We can use the type we created. So this means one but if you use the brackets this means an array and then let's initialize it in case it's empty. So yeah. So let me just show you this awesome trick. So for example we can add here a pre tag and then we can say JSON stringify, you can get the tweets, pass it null, and just for formatting, pass it too. And if you go to our page after typing so much, we can see it displayed. Let me see components tweet. Oh, it's complaining because we didn't add the component. So let me just refresh this, and we can see this here. Sometimes it's harder to read things when they're in the console, and you can keep this up on your screen for reference, so you know what you're doing, right? And this is really cool. So you can see our data here, but yeah, we're going to use a tweet component. So let me just uncomment this back. And instead of using this, I'm going to loop over each tweet. So we can say each tweets as tweet, and we can give it a unique ID, not like this. And then we can end the each and we can pass a tweet to the tweet component. So we're going to create this right now. If I scroll down here, here is the Tweet component. So inside Components, let's add Tweet Svelte. And then we can add a script tag. Say Language Tag Script. And we can just import paid fly from Svelte transition. let's import the icon component, from root, components, as well. And let's import the type we type, from root, types.

 And I'm only typing it out because we have a lot of code here to type. So let's not get distracted by figuring out if our auto imports are correct. Right. So this is what we're passing. Right. So each tweet, we have a loop here and we're passing a tweet and we can get the values from it, which is awesome. So let's get the tweet type. And this is a single one. So we don't specify this is an array. Right. So I'm going to have an article as a class of tweet container. I'm going to add a simple transition when we add and remove a tweet. Transition fade. If I can type. Awesome. Good job me. So you can say class avatar. And again, the link is going to be home profile. And we're going to get that from the tweet name. So let's also add avatar, which is going to have, let me just remove this. It's easier to see. Let's have a bit 400, 140. Hide 140 for the source. It's going to use tweet avatar. See how we get this nice auto-completion. Yeah. I also want to point out TSLint. It's helping us right now. Let me just do this. So for example, if I exclude the alt, it's going to complain. It's like, you should be more accessible. So yeah, this is really awesome. So just bring this back. So now let's add the tweet details. Let me just scroll up here. I'm going to add a div. Tweet details. Then I'm going to have another div and a link. I'm going to go to home, profile, tweet name. I'm going to have a class of user. with a tweet name value on the past tweet, right? This is the link Then we going to have a span of handle That going to be the tweet handle So we can create another span posted Another interesting thing, this dot is called an interpunct, if you didn't know. Today you learned, right? That's why you watch this high quality tutorials. Yeah, so this is the div. So now we can have our tweet. tweet and we're going to have class of content. It's going to be the tweet content. So let's see what's going on here. Here are actions. So there's going to be liking, removing the tweet, et cetera. So we can go actions. Let's add a form action is going to be home like which we're going to add later. The method is going to be post. Then we're going to have an input type hidden so we can pass the tweet ID to our backend. So it's important to name it ID and it's going to have a value of tweet ID and then we're going to add a button it has a class button like have a title when you hover over it type is going to be submit even though it's optional and then we can use an icon inside it so it has a circle add an icon close here and give it a width 24 height is going to be 24 name like and then we're going to pass it a class we can't use the cell directory because of this component works so we can do it the old-fashioned way using a ternary if it's liked we're going to pass a liked class name otherwise we not going to pass anything so yeah here is the icon and after the icon let see it should be in the class circle right Yes we going to have class count So we're going to use a key that's going to destroy and add the component again when we change the like. So that's how that animation is going to work. So let me just end the key here. And let's add an if statement. If likes, we're going to add a div here. Let's tweet the number of likes and then we can just add the transition here. So you can say in fly, the Y should be 40. Let's copy this over. When it gets unmounted, it's going to do the opposite. This should be a span, my bad. Change this to a span. And so we have, here's the key, span, button, and we have the form here. So we just make space here. We have a link that's going to go to home, profile, tweet name, status, tweet URL, with the class permalink, title permalink. So inside of the link, we're going to have a circle again. Let's pass an icon with 24, I24, name permalink. Say form action is going to be at home. And we're going to see later how we can use this method delete because it's not part of the HTTP specification. And we use a method post. So let give it an input hidden Name ID value tweet ID Set a button that going to have let's just add the circle. Circle, and then we're going to have an icon with 24, high 24, name, remove. So we can get it on the server. And let's not forget the classes for the button. First we're going to add an area label, remove tweet, class button remove, title remove, and the optional type submit. So let's see if this is all, always make sure your markup is complete. So if we look here, here is a div, and then it's a button form followed by two divs, write div and article. That's how I keep tracks when I'm following something along. And then let's copy over the styles because we already typed for five hours. So there's a lot of styles here, but they aren't important. Yeah. So I see a warning here for some classes that aren't being used, which shouldn't be because I think, where's the button? Let me see. I think I misspelled this. So it should be button remove. And then if I save this and go here, we should see everything is working properly. Another thing I want to mention is if you're pre-rendering pages, you don't have to think about the caching because they're static so if you're hosting it somewhere like on Vercel it has a CDN in front of it it just caches it for you until you rebuild and redeploy the site but if you're using server-side rendering it's good to set cache control HTTP headers in your endpoint and specify when the page should rebuild so let's pretend this blog post you're reading a server-side rendering so we would set the cache control header and we would say max h0 so we're saying hey the browser please don't cache this and then for the shared cache we can set an S max age header to 60 seconds so we're saying this page is fresh for 60 seconds or one minute and then after that passes is going to rebuild it again so yeah I hope you learned a lot in this one