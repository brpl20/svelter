 Yo friends, what's up? I thought today I'd make a shorter video and show you why using asyncfx is bad. And the same is true for on mount so that's not going to save you. Alright, but before I get started, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support. all right here i have a simple counter and let's say that we want to log the count value whenever it updates we can actually use an effect for this so effect replaces on mount and it's really great for any side effect right you can fetch inside of here you can do whatever you want please let on mount die you don't need it anymore and to track a dependency we can just use it inside of here so we can actually say count and we can also if we want to return a cleanup so we can return a function and this is going to rerun every time the effects updates so you can say log cleanup all right so now that i save this we can actually go here and now i'm going to increment this value and we're going to see the output so it increments the count and it outputs cleanup all right but things get a little bit more interesting once you start using async functions so for example you might be tempted to make this async so we can go here let's make this async and maybe you read this warning and you're like okay i don't know what this is saying it's saying that it doesn't expect this type signature i don't care right maybe you go here you throw in a nice ts ignore and you go on your merry way all right but the first thing you're going to run into is that your cleanup now no longer is going to run so for example if i go back here refresh let me increment this and now you can see you've incremented the count but the cleanup isn't going to run and the reason is very simple is because you're using an async callback that returns a promise right so for example if i I go back here and I say cones banana and I make this async and let's just return a banana. All right so here I have this beautiful banana. So I can say banana and then we can see that this is a promise. And Swell doesn't expect a promise so that is why your function is never going to run. All right so another thing I've read people say okay don't use effect use on mount for this you're not going to run into the same problem. And that is actually wrong because it works actually the same. So for example, if we use on mount here, you're going to see we get the same warning. Of course, in this case, we would actually have to unmount the component first, but you're going to have to trust me on this one that it's not going to work. And of course, you don't have to provide a callback here. You can use on destroy from Svelte if you want, but actually wouldn't use these APIs because they're legacy now, right? So at some point they're going to be removed. So we're going to have to rewrite this to use effects anyhow All right but today we talking about effects so let me actually just quickly remove this So now we are back to where we started Alright, so we can see that passing an async function is discouraged because it can cause all sorts of problems. You can get the function out of it back, it might cause race conditions and etc. But before I show you the solution, let me actually show you something else about FX that's really interesting. So let's read this paragraph from the Swell docs. values that are read asynchronously inside the fix after an await or inside a set timeout will not be tracked and this is also true when you use dot then for example which the dogs don't say so let me actually show you how this looks like so for example here if we say await sleep let's sleep for one second and then as the dogs say this isn't going to be tracked so even if i save this and now i'm going to refresh for good measure and now we can increment this count so it can go up to four and then we're going to see it's going to be zero, right? But if we actually use this before await, it's actually going to be tracked, but our cleanup is not going to run. So if I go back here, I'm going to refresh and then I'm going to increment this count and you're going to see actually it's going to work, but our cleanup isn't going to run. All right, so maybe thinking, okay, forget about this async nonsense. I'm just going to use .then and I can go here and I can just say .then. Let's pass a callback. But you're also going to see that this isn't going to work. So let's refresh, and then we can just increment the count. And you're going to see it's not going to work the same as before. But of course, we can actually specify count inside the fact, and it's going to rerun. So this is kind of a poor man's dependency array, which is kind of funny, to be honest. And of course, you can make this more readable, so people understand what this is doing. You can say if, and then you can put it inside if you want, or not, whatever you want, right? But let me actually show you another thing. So for example, if we forget about this, let's just use setTimeout. So I'm going to pass a callback to setTimeout. Let's also give it one second. We're also going to see that count is not going to be tracked inside setTimeout the same as before, right? So now we can increment the count and we're going to see the result is going to be the same. Of course, unless we pass in count as a dependency. So now this is going to be tracked and it's going to rerun things. All right, so if I save this, refresh again, and now we can just increment the count and we're going to see because we're using setTimeout, it's going to output like this, right? So that is something really interesting. All right what are the alternatives As we already seen we can just use so we can say sleep let sleep for one second and then you can do whatever work you need to do inside of here right And of course I was using reactivity for example but most of the time you just want to use some async function fetch something and etc I don know whatever you doing right So you can actually just say console log and you can log the count If I save this right now if I go back here after a second it going to log one so it actually just refresh you going to see after one second is going to log the value of count right all right but let say that you want to use async how can you do that well the only important thing is that you don't make this callback async otherwise you can do whatever you want you can for example make a function async function log count you can say await sleep you can pass one second and then you can say console log count or something whatever you're doing right you're not important and then instead of making this callback async you can just go here and then you can say log count right so if i save this and go back here is going to log count after one second same as before right all right another thing you can do is you can use an immediately invoked function expression and these always look mind-bending but they're actually kind of simple. So you're basically just creating an anonymous function, you're returning something, and then you just need to wrap this bad boy like this, okay? So now you actually need to invoke this function, that's basically how an ife works, right? And now you can do whatever you want inside of here, of course this has to be async, so this depends on you what you want to do, right? So let me actually save this, and now if I go back here, let me refresh, and we're going to see after a second, it's going to log the count. But yeah, that's basically it, and how effects work is also really interesting. So I can just remove this, for example. Let me just say hi for no particular reason. I'm just going to go here. And if I refresh the developer tools, I want to go to sources and we can go to source routes. And for example, if we open page.swell, so this is the call that we offer. This is our nice effect. But at the end of the day, this is the compiled output. So Swell is going to create this user effect and whatever this is, right? It's really not important to understand everything, but we can actually just look at what's going on to understand how this works. so we can go here for example let's slap a debugger i'm going to refresh this so we hit the breakpoint and now we can step into this so this is what was in the compiled output the user effect we're going to get back this function it has some interesting thing we can see that it's called from page.zelt right so that looks right so the first thing is going to do is going to validate this effect and this is just going to pass this rune right effect so now if there are some errors here is going to put it on this eating right so this is some object it has effect orphan if it's unknown teardown and etc it's really not important to understand this basically it's just validating this effect and this is something more interesting so non-nested effect in a component should be deferred so this is actually the part that happens when you use an effect right it's only going to run when the component is mounted so this is checking hey if this is a non-nested effect so a regular effect that you use then this should be deferred and this just does a bunch of checks to make sure that it true right so you can actually step through this so you can see defer is true based on these things right and then if we in development mode it going to set this property name with the value effect on this function that we passed in right so for example if we step through this we're going to see that after this is done now this is going to have a name effect you know this is the cool part so now it has to defer this so if it doesn't defer it it's just going to return a signal so a new thing that we can learn, effects are basically just signals, right? But the cool thing here is that, for example, this nullish coalescing assignment, so for example, if this E doesn't exist on context, which probably stands for effect, right? So if this doesn't exist, it's going to create an array on it, and then it's going to push the function, the effect, and the reaction. And we can actually see that the current component context, for example, is this function that it invoked, right? So we can actually see that this is source routes plus page.cell, because pages in SvelteKit are just regular Svelte components. Alright, and that's basically it. So now we step through this, and now we understand why we can just pass an async function, because Svelte really just doesn't handle it. I mean, in theory, you can check if this is an async function or whatever here, and then you can maybe assign it to a variable, but again, you're going to run it to race conditions and etc. So I think you need async effects or whatever else, right? And another interesting thing about effects is that they run on the microtest queue. So an effect is going to run when everything else is done. Of course, unless you're using effect.pre and etc. And I think how it works is, for example, let me just search in this folder. So, for example, we can actually search for microtask queue in the Swell codebase, or it's queue microtask. Queue microtask. And you can see it has some things that might not be related to it. We, of course, don't care about the DOM, so it's unlikely that it's here. It's not events. This looks more interesting, the runtime itself. So, basically, this is probably where this gets queued. so if we open this for example and let me close this we can actually see that this is where it schedules this effect so it's going to schedule an effect it passes a signal and then it's going to check hey if this is already queued then it's going to say okay this is queued and now it's going to process this microtest queue so it's going to pass in this function process deferred and if we actually just search for this what is this let's see process deferred we can actually see it's right here so this is going to happen on the next microtest queue right and now it's going to again set this value back to false, it's going to check against if this is an infinite loop, and then it's going to invoke this function with a weird name like flush queued effects, and basically what this does is it's going to run the effects and then it's going to get rid of them, it's going to do a cleanup and whatever else. But yeah, that's basically it. If you like what you've seen, don't forget to like and subscribe, and I'll catch you in the next one. Peace!