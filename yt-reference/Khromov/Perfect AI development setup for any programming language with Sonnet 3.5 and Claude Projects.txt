 Hello and welcome to this video. So in this video I want to share a really cool programming workflow for Cloud projects with you. We've all seen Cloud build cool small things like Tetris or Flappy Bird or Snake but what if you want to use it like for real not only for making it do like small scripts or small things but also actually to work in your existing big projects. So that's what I'm going to be talking about today and showing you how you can do that. So first, let's talk about the different layers of AI prompting that you can do. So in the beginning, so we started out with just the basic prompting. So what you are relying on then is the model's pre-existing knowledge of the world. So it's basically just asking it, can you do this? Can you do that for me? The problem with that is that the internet changes fast, frameworks get new versions, new features get added, new functions, and there are many different libraries that might not be fully documented in the model's knowledge. So you end up with kind of like a mix of sometimes you get good code, sometimes you get bad code, and usually it's somewhere in the middle and you have to do a lot of corrections and keep prompting the model. So the second level is RAG, the Retrieval Augmented Generation. and that is basically when you upload some knowledge that you want the model to have on top of the pre-existing knowledge so maybe some documentation or some parts of your code and that is put into a database and before the model asks your question it kind of checks with the database first to see if it can find any related pieces that it can include to the model so you're not getting like everything that you uploaded you're getting just like a small part of what the model thinks that you might want to answer this query. And that is already a lot better than just basic prompting. But the problem with that is that you never know which chunks you're going to get, which parts of the information you're going to get. So sometimes you get good parts of the information and sometimes you get bad. So the performance can be very hit and miss. The third layer is something that just now come out It the large context models With large context models you can actually put everything into the context So not only the small chunks like with RAG or the pre knowledge you can actually include all of your code all of your documentation for libraries you're using. And this is just now started to be possible. So there are a couple of long context models now we have on the OpenAI side, we have GPT-4-0, which has 128k, 128,000 tokens. We have Cloud 3.5 Sonnet, which does 200,000 tokens. And we even have some Google models that are doing 1 million tokens. So how do we tap into that right now? So what we can actually do is use the Cloud Projects feature, because unlike ChatGPT, which I think uses rag if you upload documents to it. The Cloud Projects actually puts your entire knowledge base into the context, which means you have incredible recall and you can basically ask about anything in that knowledge that you upload. But there's some challenges. So like how do you upload your entire code base and all the documentation you need in a simple way? and that's what I'm going to show today. I'm going to show a tool that I made that simplifies the preparation of a file that basically contains all the documentation you need and all the code you need. So let's get into the demo where I will show you how I'm actually working with this day-to-day in a large project and how it can implement pretty complex features in an existing a big project. Okay, so I just opened up this project that I've been working on. It's this app where couples can write appreciations to each other. So the app is very basic. You just press write an appreciation, you write something that you appreciate about your partner, and that gets posted on the timeline and as a user you can like it. Pretty simple but since it's an app and it's available on the App Store there's a little bit of complexity involved to getting all of it to run. So now let's look at the code for this. So here's the project. You can see that there quite a lot of different source files that make up the project different routes I using a Celtkit for this project and I just going to show you now what I do to prepare this project to be used with Cloud AI I using this tool that I developed called AI Digest. So you type mpxai digest and what this tool is going to do, it's going to run on your whole code base, and it's going to package it all up into a big markdown file. And this is just so that we don't have to upload a lot of files, hundreds or even thousands of files that can make up your project. So now that we ran this script, we can take a look at this file called codebase.md. I got it git ignored. And what we can see here is that this is just a list of all of our different files in the project. The file right now is almost half a megabyte. So that's a lot of text. So keeping that in mind. And so aside from, so that's the first preparation. So what this tool needs to do the best job it can is for you to create this file called .aiDigestIgnore. and this file is kind of like a gitignore file and it will basically not include certain parts of your project that shouldn't be uploaded to cloud which may be like some build artifacts, a build folder some unrelated files that you don't really care about temporary files, stuff like that so I got that set up and that means that if you look at the output we are ignoring some files here that won't be included and this tool also gives you the estimated token count it's using the gpt4 tokenizer for this so not exactly like a one-to-one to to clod but it's going to give you like a rough estimate of how many tokens it is so for example this code base is 130 000 gpt4 tokens the second thing except for this ai digest ignore file that i've done is that i've created this docs folder and in this docs folder I have put basically the documentation for all the different libraries I'm using. So I using this library called Postgres Migrations and I basically just taken the readme from their repo and pasted it in here I have the SvelteKit documentation because as I mentioned this SvelteKit is a framework that has a lot of changes going on constantly with it. And it's great to be able to reference the most up-to-date version of it. That's basically it. So let's now see how we can integrate this with the cloud projects. To do that, I'm just going to go to the cloud projects UI. I'm going to create a project. I'm going to call it appreciation jar development. I'm going to create it. and then I'm going to drag the generated codebase.md file into the project knowledge. And as we see, because the SvelteKit documentation is quite large, this uses up a lot of knowledge of the knowledge we have. But, you know, I think with time, this is just going to increase. So if you have a medium-sized code base, this is going to fit just fine if you don't include a bunch of documentation. So now that I've done that, what I usually like to do to start is I actually like to have Claude write the prompt that I'm going to set as the custom instructions. So I'm going to go ahead and just ask it to write me one. It analyzed the whole project and it provided a custom instruction set for me here. So what I can do now is to just paste this in to the custom instructions. So basically doing like this. I have already kind of like worked on a prompt that I use instead. that is basically the same but I have tweaked it a little bit, asking it to use artifacts and never to write partial files, stuff like that. So I'm going to use that instead but you can see that you can easily get a good prompt to start with and then you can refine it yourself or ask Claude to refine it for

 you. All right, so now we're ready to do some actual development. So let's start with thinking of a feature that we want to implement, something that is not extremely difficult, but something that is a kind of common everyday task that you might do as part of application development. So the thing I've been thinking of doing for this video is to ask it to basically have a little banner at the top of the app that asks people to review the app if they like it. So let's start the application again. Let's have a look here. So basically I want it to be up here somewhere. So let's go ahead and ask Claude to basically do this job for me. So I'm gonna start a new chat and I got the latest codebase uploaded and I'm gonna say I'm gonna write a prompt for it. All right, so now I've written a prompt that I think it's going to hopefully do a good job with. I've asked it to use the specific package that I've been looking at that makes the native part of the thing work. So when you press the review button, it's actually going to open the Google Play or Apple interface to leave a review. And I've also downloaded this documentation for this package and put it in the docs folder already. so let's see what it does with this prompt okay so let's see what it came up with so because i asked it to use artifacts it gave me this nice these nice boxes that i can press on to get the code first it gave me the actual banner itself so i already know that i'm gonna have to install this package so let's go ahead and do that first I'm just gonna install it here and then let me copy the contents of this file and did it tell me where to put it Let see Yeah it asking me to put it in lib component so let go ahead and do that We have the review banner.self file. I'm just pasting it in. It's using, it's decided to use this file that I have called spiky star. Good choice. It's an asset I already had included in the app and because it was available through the codebase markdown file it knows where to find it. Seems to not have done a good job with this method. Let's see. Let's have a look here at the readme here. So it's using this function called isAvailable which I kind of feel like yeah it invented. So as you see it's not perfect here. I think I see what's going on here. It kind of like tries to infer when it should show the banner and actually I actually have some ideas about this actually wanted to happen after the user has posted a certain number of appreciations so let's just go ahead and always show it for now there we go and then let's go back to here and it started writing out this the code for this jar page, but it kind of gave up after some time, which it does if the code is really, really big. So this sort of workflow works best if each individual file you have is not that huge, because otherwise it's going to get lazy and it's not actually going to print the whole file because it's going to be afraid that it's going to run out of tokens. But what I'm guessing it's doing here is that obviously we need to import this review banner. I could ask it to just tell me the changes if I wanted, but I think I know what needs to be done. So let's go to the jar page here. You see it's a big file, so asking the AI to write it all out is quite a lot of work for it. So it added the review banner, and then at some point it is going to, of course, show it on the page. and it did this in this content. So I'm just gonna go ahead and do that there and then it asked me to install the package and then it told me to update the capacitor configuration which I actually do not think Oh it just told me that I could configure it But I don't think any configuration should be necessary. Okay, so let's just save this and see what turns out. All right, so pretty cool, I think. that we got something. It is definitely not perfect here. Let's see how it did with the actual functionality. So if we check the how it handles the review app, it does call this request review function and if we check the dismiss button it will hide it but then it will come back. So this is actually something that we've done in other places in the app so we could actually save this as a local preference so when the user clicks the button we can hide it for them permanently. So let's go ahead and try to ask it to do that. All right, so here we go. So what I kind of did is I used my knowledge of the project to guide it in the correct direction by telling it about other places where we store local settings, for example, to be able to dismiss a notification or something like that. And I've asked it to update the code based on that. So what I actually usually do, the kind of workflow I usually have for this is that between each prompt, I sort of like commit into a test branch because it kind of helps to be able to see the changes on each step. So this was the first step, so I'm just gonna go ahead and commit this. And now it's giving me some more changes. First, it's changing in this local settings file where I asked it to add the new dismiss functionality. And I'm just pasting the whole file in and then it gave me the whole review banner again and I gonna also just overwrite the existing code here And I can check the diff And I can see that it did do something with that It reverted this change I did for is available. Which, that is my fault. I should have told it that I made that change. Because otherwise, how would it know? Here we go. and now let's take a look. All right we see the banner, we dismiss it, we reload and we no longer see it because it's saved and I believe it's saved in local storage so we can have a look here. Review banner dismissed true, sorry it's a little bit small. Here we go, review banner dismissed true. So that works just fine too. All right so now I can commit this and just go ahead and go on with the next step. So as you see, this is pretty cool, I think, personally, because we're not really having to correct it a lot. We're just kind of asking it, and since it has all of this context behind it already, we can also do things a lot quicker than having to constantly keep it asking it to iterate on the changes. Okay, so now I wanted to fix the design up a little bit. So since I did some changes to this local file I'm going to paste it in and ask it to like internalize these changes. I made some changes to this file and I'm just gonna paste the file in and and then I'm gonna say and now it's going to remember my old changes that I did hopefully and it's going to give me the file again and I'm just gonna paste it in again and I briefly look at the diff here it does look like it did a lot of stuff to the code which is okay we can have a look at how it looks now obviously it's still dismissed because I have dismissed it but I'm gonna delete this local storage key so we can bring the banner back. Ah look it already looks a lot better. I'm actually also gonna try this review app function even though it's not gonna work because we're on we're on web right now.

 So we click it and we see error not implemented on web, which is exactly what we expect, because this is how Capacitor works. It will use the OS-dependent function. So on iOS, it's going to use the iOS function. On Android, it's going to use the Android function. And on web, it doesn't work. So actually, that is the next thing that I would like it to fix, which is to not show this on the web. So I'll say... And again, I guided it just a little bit. I said that we have this function called isWeb. I didn't tell it where the function is because I kind of assumed that it's going to find it based on the fact that we've put in all of our code. Let's see if it's going to be able to handle that. so I can already see that yes it did figure out which file that function was in even though I didn't ask it and even though I didn't tell it I should say and it it looks like it made some good changes so again let's paste it in have a look and now I would actually expect yeah I would expect it to not show up because we are on on web and I'm gonna comment this out for now because we're gonna keep iterating but we obviously want to be able to see it locally so it's still insisting on this is available function so that I think that's the next thing I'm gonna have to ask it to do which is to like rewrite the file but without the is available function I don't know where it got it from. Obviously, sometimes it can still hallucinate. It's not perfect. Okay, there we go. I actually had to go back into the readme and just double check whether that function was available or not and it is not So let see what changes it did So I did very little If we checked it it might be a little bit small for you Sorry about that But all it really did was remove the usage of that non-existing is available function. And now we're going to take it up a notch and actually ask it to do something a little bit more complicated. and that is to actually only show this for people who have posted more than 10 appreciations. Now we're really going to test how good it does because this is going to have to touch the obviously the backend parts. It's going to have to add new data to the data loading that we have and it's going to have to integrate that and pass it all the way to through to the model to be able to show it properly. So let me try to craft a prompt for this. all right so here we can see the capabilities of Claude Sonnet like it effortlessly managed to write basically a bunch of changes in a bunch of different files for us so let's just start and implement all these changes. So first it changed the query or rather added a query. So here we go. Here are all the different queries and I'm going to paste in this new query it added. Let's just see that to see if it's actually makes sense or not. Select count from messages where some specific appreciation jar ID. That seems to make total sense. Now let's look at the the back-end part. So here it actually did something that doesn't really work in our environment because long story short we can use page server files so I gonna correct it by asking it to use the file we already have So this changes that it first proposed there was really nothing wrong with them it was actually according to the best practices it's just that because we are have an app which is compiled static HTML we can't use the server load functions but that's okay we just pushed it into the right direction and now it gave us what looks very promising all right so change the api route there and gonna change the data loader as well here we go and yeah that's it according to the to Claude let's have a look here doesn't oh yeah of course I actually I forgot one thing this is like tricky when you start prompting it to fix things is that it doesn't always include every change you need to make because of course you also need to pass the data through to the model itself. Here again it got a little bit lazy. Let's see here I have to decode what it wants to do but I can actually just ask it to write out the whole file. If you get lost you can in a separate prompt ask it to write out the whole file. All right, and there you saw a shortcoming of Claude, which is also why it doesn't write out the whole files. You see it just stopped and I got this error that the length limit was reached. But that's okay because it stopped kind of at the styles already so I can just take the actual code part and paste that in All right so let see here Yes we also forgot to update the review banner itself of course Let go ahead and do that Alright so that looking very promising. We don't see the review banner and that's because we haven't posted 10 appreciations. I'm gonna have a look at the I'm going to have a look at the data we get back. And I see it correctly gave us back that we have one appreciation. It is a string rather than an integer. That might be a problem. But let's make 10 appreciations and see if something shows up. All right. I made 10 appreciations. It's not showing up. But I do think that is because it incorrectly cast the appreciation count variable. let's just double check that all right so I just briefly looked at the code I cast the string that came back from the database on integer and then it basically just worked now to just test this let's see if we delete an appreciation that it actually will disappear yeah there we go so and I write another one and now it's back. So that's great. So we basically did everything we set out to do. And now if I dismiss it, then it's not going to come back. Perfect. All right. I hope you liked that walkthrough to just be able to see what Claude can do once you preload your whole code base into it. And I hope that I managed to show you that you can use it in your existing projects by using the CLI tool that I showed and that you can do even pretty complex features with just Cloud. So thanks so much for watching. If you have any thoughts or comments, please leave them below and I'll see you in the next video.