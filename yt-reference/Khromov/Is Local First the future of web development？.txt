 If you're working on web applications today then I'm sure you've heard about some of these new front-end buzzwords like React Server Components or Islands Architecture. Fundamentally what all these new technologies are trying to do is to simplify the front-end development experience for us devs and make sites on web apps faster for users. In this video I want to take a step back from specific technologies and talk about the broader picture of where front-end development is actually moving in 2025 and in the future because we have a very interesting shift happening and we're potentially moving in two different directions. To understand where we're going we first have to take a look way way back So let's start with an abridged history of the web We'll start by going back all the way to 1993 with the invention of the HTML specifications by Tim Berners-Lee Back then the web was envisioned as a collection of documents that could be linked together But pretty soon people wanted to implement dynamic behavior on their sites Guestbook, those charming stats counters, forums and more Since browsers were barely a thing at this point and any sort of client-side scripting didn't even exist, we naturally started on the backend with the common gateway interface that allowed existing programming languages to dynamically build HTML pages. Although it wouldn't take long for JavaScript to be created in 1995 by Brandon Eich, the first era of the web would come to be a backend-heavy experience. So let's say it's 1995 and you're creating a guestbook for your users. You would most likely be using HTML to build a form element and send that to the browser. Once the user submits the form, your server would process the request and return the updated HTML with the new guestbook post you added. At the time this was all very cool and with these new capabilities the World Wide Web created a flurry of new companies, some of which are still around to this day. Fast forwarding all the way to 2013, Jordan Walk, working at then Facebook now Meta, created the first version of React. With its at the time new approach to data binding and a component-based architecture, React introduced a paradigm shift in how we build web interfaces. This led to an era where we are still in over 10 years later, the era of JavaScript-focused frameworks. React was, especially at the beginning, very front-end centric. One of its core features was the ability to run all the interactivity on the front-end. This caused a shift in how we think about building building web services, because now if you wanted to build a guestbook, you would need an API to connect to, to make new requests. The front end application built with reactor or similar frameworks would no longer receive fully formed HTML from the server Instead it would request data via APIs and render the UI client side People started using a lot more so REST APIs which used HTTP verbs to denote different kinds of operations on database resources for writing, reading, or deleting data. The pendulum had clearly shifted towards frontend at this point, but it was about to shift even further due to the conception of GraphQL. GraphQL pushed the boundaries of frontend-centric development even further by allowing front-end developers to choose which data they wanted to fetch and write, rather than splitting that task up into a front-end and a back-end part, as was common before then. As developers started building more and more complex apps and pushing all the interactivity to the client, web apps started getting a little bit of a bad reputation for being slow, flaky and buggy. So what we're starting to see now is a pendulum swing back to the back-end. Although back-end continued to be popular all this time in languages like PHP, Ruby and Python. What really set the movement off in the front-end space was the advent of React server components which again placed the logic back on the server and also a movement back towards many web 1.0 paradigms like forms making their entrance back into React frameworks like Next.js and other frameworks like Sveltecube. But fundamentally this shift hadn't fixed some of the old problems with server focused approaches. Now let's say it's 20 years later and you're building your same guestbook again and this time you're doing it with React, with React server components. So you still have the problem where you're submitting data to the server and you need to wait for the data to come back. But we've gained something in these 20 years. We've gained the ability to easily, for example, show a loading indicator using React's front-end functionality. So we definitely gained a little bit of flexibility but that has also come at some cost. One of the complaints with client-focused approaches were how much JavaScript you would have to ship to your users to make new applications work. Unfortunately even with the move to React Server Components with Next.js, the front-end bundle size is still quite big even for a simple Hello World app. For example, when creating a new Next.js project you're forcing your users to download and execute over 300 kilobytes of JavaScript. That's the equivalent of over 100 pages of text to essentially show a hello world page. What I just described was the first direction which is this pendulum swing where we're currently moving back from a client-focused approach to a server-focused one. But what is the second direction? Well this second direction is something that kind of come out of left field and that is Local First To briefly explain the design philosophy of Local First it about creating an app that is fast without spinners an app that can be used on multiple devices and synchronized between them an app that works with intermittent connectivity and even completely offline an app that has support for real collaboration where it makes sense of course and lastly an app where you are in control of your own data, having the option to export it or delete it whenever you want. So what does this all mean in practice? And how is this different from the back-end approach? Local first is about having everything on the client and actually syncing all the data onto the client. For example, let's say we're rewriting our guestbook with a local first approach. In this approach, you synchronize all the guestbook entries into a local copy on your own machine. And when submitting a new entry, you write it to your local copy of the data, and a synchronization engine would upload this data to the central server, where it would be fanned out to all the other people's copies of the guestbook. Now, this is a very interesting approach because this pretty much solves a lot of the problems with backend-centric approaches, where we would have to have a loading state while submitting the form, and we would have to wait for the data to come back from the server to tell us whether we succeeded or failed in creating this guestbook entry. So now we actually just write the data locally, we let it sync in the background, and we can immediately show the user the new state, even while we're still pending. This doesn't of course mean that we can't do server-side stuff. For example, let's say that you don't have access to write a particular guestbook. You would commit that into your local database, you'd send it off, the server would then reject it and send you back the previous state of the database basically saying you can't do that and then you would be able to handle and show an error message to the user. Now I think both of these approaches are very very interesting and I don't think necessarily that there's a right or a wrong way to build an application so applications can be very different but I can't tell you about the different classes of applications that I think were better in one approach or the other. So for example if you're building something like an informational blog or a news website something that is content focused on when the user is where the user is mainly reading content and not writing very much uh actually they might write a comment or or on a blog post or something but maybe like 90 or even 99 percent of all the accesses are actually just people wanting to read content so in this case i think server focused uh is a fantastic approach right because the less javascript you have the faster the page loads and the faster the user sees the content So it actually great Now instead if you look at a more interactive app like perhaps a chat app where users frequently write data and might be on like a flaky internet connection, you really want to have this ability to write changes to a local database first, which will never fail, that is then synchronized when possible to other users. And once these new entries are confirmed by the server, you can show that little tick mark, you know, to let the user know that the message has actually been sent and confirmed by the server. I will say though that there is a challenge with local first app when it comes to handling permissions, especially when multiple users are kind of coexisting in the same space like a single chat, because if you have a chat app and you have all the messages in the local database, nothing is really stopping any user from rewriting or even deleting someone else's messages, right? So then you have to write logic in the synchronization layer to say what a particular user can and cannot do. And I think this can be actually more work to try to figure out than just a standard backend type of permission handling, because if you've worked with something like Firebase security rules or Superbase row level security, you'll probably know that this different way of thinking can be sort of hard to wrap your head around, especially if you haven't done it before. And so for Local First apps that need collaboration between different people and giving different people different access levels within the same kind of space, it's probably the toughest type of app to solve in Local First. But it can be done even with the tools we have today. But if you instead have an app where you just have your own data, for example a to-do app without any collaboration features, then things do get a lot easier because you don't really have to handle permissions at all. You can just read and write anything. So as we've seen in this video, the web development landscape is constantly evolving and it has a pendulum swings between the server and client-centric approaches. It's hard at this point to say if the pendulum swing back to the backend is going to persist for the next several years or if this local first approach actually represents a swing back to the client already. Regardless, I think it's important to understand both these approaches because as we've seen there is no like one-size-fits-all approach that works for all the different kinds of apps. But one thing is clear though, like the future of web development will continue to be shaped by the pursuit of both better performance for end users and simplified developer experience. What do you think? Have you tried local first development yet? Do you disagree with me on something in the video? Leave a comment and a like below and I'll see you in the next video.