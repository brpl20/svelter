 SvelteKit is already one of the most flexible full-stack frameworks out there, not only for building dynamic serverful apps, but also for building single-page applications that don't require a running server. All these use cases are enabled by the flexible adapter system, allowing you to run your apps basically anywhere. I've been building static single-page apps using Adapter Static for a while now. For those of you who are unfamiliar with this adapter, it compiles down your app to a folder of HTML, CSS, and JavaScript files. This adapter is a have a back-end. Everything, including your load functions, run in the user's browser. It also makes it possible to deploy your SvelteKit site basically anywhere you have a traditional web server, even places like GitHub Pages. So a couple of months ago the maintainers added two new features to SvelteKit that really improve how you can build these static apps. With these new features you can make your project more flexible, for example deploying it to a microcontroller, and you can even make your project run without any web server at all, meaning you can send your whole app, your whole SvelteKit app to someone as a single HTML file, have them double click it and have it all work out of the box. Today I'll go through the new hash-based router and inline bundle strategy and show you how I apply them to an existing SvelteKit project to make it more portable. Let's get into the video. Now what's funny about these two features that we're going to talk about today is that they were actually both part of advent of Svelte in 2024. So first we have the bundle strategy feature. So before we had this there was really no way to tell SvelteKit how we wanted it to split the JavaScript bundles for our project. And now we have three different options to choose from. So if we read the docs here on bundle strategy, this is a config that you set in the svelte.config.js file. We now have split, single, and inline. Now split is the previous strategy. So as it says here in the docs, it splits the app up into multiple JavaScript and CSS files so that they are loaded lazily as the user navigates around your app. This is by default the best option because you typically don't want a user to load, let's say, every component in your app just because they loaded like one page that may only contain a few components, right? So you usually want SvelteKit to do its thing and split the bundles in a smart way. Then we have single, which is a new option. And what Single does is creates just one JavaScript bundle and one CSS file. Now, if you're like me and you've been looking into different ways of doing bundle splitting in SvelteKit before these options arrived, you might have come across this issue. This is a giant issue with tons of posts in it. And basically, yeah, you see here 49 remaining items. So it's just a giant thread where people explain why it is important to be able to build only one JavaScript bundle. And some of the use cases were stuff like, I need to put my app on a microcontroller, and you know, I can't just put a bunch of files. I need everything to be put into one file so that I can easily upload it to the microcontroller and then load the app up. Some other use cases might be that you're building capacitor apps, which traditionally hasn't been able to use the HTTPS multiplexing, meaning that they load basically one JavaScript file at a time, making them slower than they have to be. So there are many reasons why you would want to do this, but there's also many reasons why you'd like to maybe leave it at the defaults. Going back, you have the single mode, and we also have as a bonus, which I think is amazing, the inline mode. And the inline mode, I think, is really cool. And I didn't see many people asking for it, but I love this because what it does is it takes the JavaScript and it actually inlines it into the generated HTML. Again, this is not something you might want to use all the time. There are some very specific use cases that this enables that I really excited about and I going to show you how this enables you to do really cool things later in the video The second cool addition was the hash router configuration So before we had this there was basically only one way to route things in SvelteKit. It was using the default router, right, which uses slashes and then like the path that you selected and that you configured in your app. But now we additionally have the hash router config and this is again something you configure in your SvelteConfig.js file. Now there's a lot to read here. What's important to know is that the hash router does mean like quite a lot of things. It's quite a big change to your cell kit projects. For example, you can see here that if you enable the hash router, server-side rendering and pre-rendering are disabled. And in fact, you can no longer even have any server files in your project. And the reason for that is that unlike paths, so normal paths like slash something, which are sent to the server, a hash parameter, which is like hash slash, that one is client only. So the server doesn't even see it. That means that you basically cannot have any sort of server logic in your app. But again, I'm going to show you one case where that actually works really well. And the project that we're going to use these new techniques on is a project that I built called Derivault. It's a deterministic password manager, meaning it's a password manager that doesn't actually require any connection to the internet to use. And while I will go through this project a little bit more in a future video, today we're going to look at the new capabilities that SvelteKit gives this project. Now this project is a little bit special, right? It's really cool that you can run this project anywhere, but it would be even cooler if we could, for example, have SvelteKit build the project into a single HTML file, and then we could even just save it on a USB drive or something or have it on our computer and use it completely offline. Well this is sort of possible now because this project has a service worker implemented so once you have loaded it once it will actually work offline. It would be even cooler if it could be a single self-contained HTML file. So let's go ahead and see how we can do that. So I have the project loaded up in VS Code right now and we can see that it is a fairly standard SvelteKit project. We have the routes folder here where we have a few different route groups. For this onboarding group, we have a slightly different layout. It looks like this. This is just kind of like an onboarding to the project. And then in here, we have all these different features. So you can add a password, you can check the settings, and you can see your vault of saved passwords. Let's see how that works. So I will first enter my master password, which is very secret. And now I am able to add new passwords. So let's say I'm adding the password for cell.dev and I'm going to use my username here and that password is for cell.dev. And now this deterministic password manager is going to generate a password for me for this site. and then I press add site and now I have it here. So now you see kind of what the sort of features are. Then there's a setting screen and so on. So but that's not so important because we want to see how we can use these new cell kit features on it. So this project is of course built with adapter static. Now let's see how it looks when we build this project right now. I'm going to go ahead and run the build command and because we're using adapter static that's going to generate a build folder and inside here we're going to find the index.html which is the starting point of the app and then we have this underscore app folder and immutable and here you have all these different chunks, these different JavaScript files that are generated. We can see it's quite a lot and we can I think also see here in the output we see if we scroll up to the client here, here are all the different JavaScript files that are being generated. Now let's try these different bundle strategy options Let first start with setting the bundle strategy to single and see how that affects the output So first we configure the output object here on the SvelteKit config and then we have bundle strategy and we gonna do single. Now I'm gonna build the site again and let's see what the difference practically is. All right now back in the build folder it's built again we still have that indexed HTML and a bunch static files, I'll go to app and then I go to... ah, there we go. So now instead of having all these different JavaScript files we have only the one bundle.js. Now there are some CSS files added here. I'm not sure if the CSS is also kind of single but as you can see there's only one JavaScript file being generated. Now let's try the option we're really interested in, the inline one. Well first let's look at the index of HTML that was generated. So here we kind of have the standard SvelteKit stuff, and then we have this import that starts off, or the whole app that imports the whole bundle that we now have, and that's about it, right? So that's basically because this is a single page application. Now let's switch to inline. We build again, and now let's see what happens. Now we built it with the inline option, so we go in here and we still have an app folder, we still have this immutable folder and we still generate like a CSS file in a JavaScript file, but if we look at this index.html file it looks quite a bit different because if you recall just now when we were looking at it, it just basically contained like a shell that would load the JavaScript for our site. But now we actually see all of the CSS that we have is being inlined here into the app and then a little bit further down we have the script tag and all of the scripts that are associated with this side. So all the whole SvelteKit app is being embedded here into the HTML file. If we kind of take a look at how that looks, we see here it might be a little bit small, but we see here that the index.html file is 246 kilobytes. That's quite a big HTML file, is not something you typically would want, but as we will see this can be a good trade-off sometimes. Now we did the first thing which is to set the bundle to inline. Now let's try the hash router and see how that works. So with the hash router it's also configured here, so we're going to go ahead and configure the router and then we're going to say type hash. Now when we do this there are quite a few conditions that occur. Like for example, when I tried to run the dev server now, it says cannot use server only files and app with router type hash. And that is because that is exactly what it says. You cannot have any server functionality anymore when you enable this. So what I'm going to do is I'm going to refactor this a little bit. I think it's just the one server usage I have in this project. Let's see what happens when we actually can use the hash router. Now I've removed the few remaining server parts of this project. So now let's have a look can see what actually shows up. What we can see here is that for example when I enter my super secret password and I press enter vault I get a not found error and the reason for that is that now we're navigating to slash vault and that is not a hash path so let's see how we can refactor this to use hash routing instead. So I'm gonna go ahead is to look for where we actually do this this redirect which is I think a go to. There we go and I think I found it here and so before when we didn't have hash routing we would also import this base from app paths which is because you can configure like a subfolder that the project runs from but we don need that anymore so to refactor this I just gonna go ahead and remove this base and then instead of doing a slash vault I gonna do hashtag slash vault and now let see if that works any better. I'm gonna enter the password again. So what I should do next is basically to refactor all of the usages we'll go to but there's one more thing that we need to do to make this project compatible with the hash router, and that has to do with the load functions. One super cool thing that you might have noticed is that, first of all, we can maintain our existing kind of app structure when we're using hash routing. I didn't have to change anything here. Another cool thing is that we can still use universal load functions. So for example, we have this plus layout.ts function, and that still works exactly as before. But I know that in this app we have another special thing, which is that, for example, when we edit the site, we in the query parameters, pass the site that we're editing. So for example, something like edit equals one, where one is the id of the site we're editing. This doesn't really work with hash routing either because those parameters aren't technically any longer part of the query parameters. To kind of visualize this, if we before would have something like this, so we had slash add, and then the query parameter, edit equals one. Now we will have slash hashtag. And this part is technically not part of the query parameters. So maybe there is some smart way to do it, but what I ended up doing was to write a sort of little wrapper function that will try to parse out the query parameters that exist in the hash. And so that function looks like this. So we check the incoming URL, which is going to be our URL object, and then we basically find the hash parameters and and the parse them as if there were normal query parameters. Now you don't have to do this, you can use route segments instead, but this just shows you how easy it is. So basically I didn't really have to do any changes to my logic. The other thing I needed to do was to get the query parameters in a new way and then I could reuse my existing code. So now I've refactored the the usages of goto and links and I have refactored the load functions. Now let's see how the application looks locally. So let's log in, let's edit a password here and that works just fine. All the routes work correctly and now for the final cool piece let's build this and try to run it not from our local web server but from just the HTML file. I'm gonna go ahead and build the project. I have the output here. I'm going to delete everything except for this index.html file just so that you know we're not we're not cheating. This is it. This is the whole project in a single file. Now double click it and it loads right up. Let's see if it still works. Yeah, it still works. Now we don't get the the sites that we had saved before, but that's because they're saved in local storage and the local storage isn't obviously not the same in our local dev server as in the file version. So that is expected, but we can see here that we can add a site and that works just fine and it is correctly saved. So now we have an entire SvelteKit project in a single file that we could send to our front, put in a USB stick, whatever. These are some I think really really cool improvements in the SvelteKit and it makes building static apps an absolute breeze. So I hope you liked this video, I hope you liked the demonstration. If you have any questions or any ideas please leave them in the comments. If you liked the video please like and subscribe it really helps a lot and I'll see you in the next video.