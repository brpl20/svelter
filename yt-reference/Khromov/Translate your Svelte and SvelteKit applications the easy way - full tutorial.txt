 Let's say you're putting the finishing touches on your brand new Svelte app, and you're thinking about translating it into more languages. Or maybe you've had an upriding for a while, and you want to capture a larger global market. There's no shortage of solutions for localizing Svelte apps. For example, you have libraries like SvelteKit Internationalization, Svelte Internationalization Lingui, or Paraglide to choose from. I've been following along with these different libraries for a while, and I've also implemented some of them in my own apps. But one thing that has always irked me is how invasive these libraries are. Using any internationalization library out there today basically boils down to you having to modify every instance of text in your existing Svelte components. Some libraries make it enough to just wrap your existing text with a function or store call, while others force you to come up with placeholder values for every single string. So a text like welcome to my application would have to have a key like welcome underscore message, so that the internationalization library can keep track of it. The downside is that both these approaches require large changes to your existing application. This has always felt off to me. The last thing I want to do when adding internationalization to my app is to modify hundreds or thousands of strings. That's why I'm excited to share with you a brand new internationalization library called Wookale. Wookale? Wookale? Don't quote me on the pronunciation. I've been using this library to translate the recent app I'm working on, and it really feels like the endgame for internationalizing Svelte and SvelteKit applications. Wookale takes a completely different approach than other libraries. Instead of you having to modify your existing application, Wookale works as a weak plugin. It parses all your Svelte components and JavaScript files and then extracts all the text strings from them. It then saves the translation strings as PO files, which is a very old standard for translation files called GNU GetText. You can then use existing free tools like POEdit to translate your application. Since PO files are also just normal text files, it's also very easy to hook AI into the process, and later on in this video I will show you how you can create an initial AI-assisted translation for your entire application. And it doesn't end there as WooKale supports both SvelteKit and Vanilla Svelte, React, SolidJS, and JavaScript apps that don't use the framework as well. How cool is that? So what I thought we'd do in this video is to translate one of my existing SvelteKit apps and show you how easy it is to add this library to an existing application. Let's get into it. All right, so we've got the project we're going to be working on up and running. And the project that I'm going to try to internationalize is a password manager that I've been working on called Derivault. We're not gonna go too deep into what this password manager does as I have a separate video coming about that But suffice to say is that it is a password manager and it does password manager things You can enter your secret passphrase you can enter your vault where you have your saved passwords Let go ahead and add some some passwords here. There we go and then you can of course edit your entries, you can copy the password to clipboard so that you can paste it into the site and so on. So what I wanted to do was I wanted to add Wookail to this app and translate it into my other native language, other in English, Swedish. And to do that, we're going to just start off in their documentation. So we're going to start here. We're going to pick Svelte, of course, but as mentioned, it does work for React, SolidJS, or even Vanilla applications, Vanilla JavaScript applications. I'm going to go ahead and install it into my app. So I'm going to run MPM install. Since Svelte bundles things a little bit differently. The change I'm going to do here is I'm going to add the development flag because this is a SvelteKit app, so I want this to be bundled with the rest of the app. Now that's done, so that's step one. And then the second step is to configure Vite. As mentioned, this is a Vite plugin, so this is showing an example of a Svelte Vite file. So since we're using SvelteKit, it's going to look a little bit different, but let's see if we can do this anyway. So I'm going to open the Vite file here. Here instead of Svelte I have SvelteKit but that's okay we're just going to go ahead and import the Wookale Vite plugin and I'm going to add it here in front of SvelteKit instead. Next step is to create a Wookale configuration and this is suggesting that we create a file called Wookale.config.js. I'm going to go ahead and do that. there we go and I'm going to copy the exact code here and if you look at what is configurable in this file so we have a few things one thing that we definitely want to configure is the locales because by default we're going to have English as our base language and then I also want to add Swedish so I'm going to add the Swedish language code here then it's telling us to run this npx command so let's go ahead and do that and kind of see what happens when we run this npx command Alright, so what it's saying here is it's asking me what loader I want to use and it has SvelteKit and SvelteKit. So I'm just gonna go ahead and pick SvelteKit because that's what we're using here. Let see what happened when we ran this command I mean it did a lot of stuff here It says it extracted a bunch of strings and then it makes an initialization complete So let see what actually happened here in the Git diff view All right, let's have a look. So we have, of course, our package. Package was added. We have the vt.config where we added the VUKL vt.plugin. We have the config file, which we also added ourselves when we added the locale. And then we have these EN and SVPO files. These are the text files that I was talking about before. And this is going to be an extraction of all the strings in the applications. So it has gone through and you can kind of see here which file the different strings come from. And then it has basically put them in here. And then in English, it's just the strings. And if I go to the Swedish one, then you have the original string. And then the translation string is going to be empty because we haven't translated it. So we see here that Wookiel also support things like dynamic strings. So if part of the string is dynamic, then it's going to be this kind of, you're going to see this kind of placeholder inside of the string that's going to be replaced dynamically by the library without us having to do anything. Aside from these PO files, there was also these loader files. And these loader files, you don't really like touch them that much, but these are required to basically keep track of the catalog. But for now, let's just continue with the guide. And then it says setup in your app here, and there's a Svelte and a SvelteKit guide. And of course, we're going to pick SvelteKit. And so one of the challenging things with SvelteKit and translation in general is that you have to have a correlation between the server and the client. So you have the initial kind of server-side rendering that SvelteKit creates for you. And then after that's been sent to the browser and SvelteKit, the client-side framework kicks in, then you kind of need the strings to stay consistent. So you don't want things to jump around or that something change when the app has finished loading. So for that reason, Vukail has this dual setup where you set up the server-side rendering part of it, which is a hook in hooks.server.js. And we can kind of see here how it works. So in the default implementation, what it does is it implements a handle hook. And of course, if you already have handle hooks, you can use sequence. So you can use a sequence function to chain together your existing middleware and this new wukil middleware. And then it's going to look at the search parameter called locale. So basically if you have a question mark locale equals a key like em or sv or any of the language keys you selected then it going to call this run with locale function and it going to pass this locale from the search params So in that kind of basic implementation, if you append a query parameter called locale, this is going to change the language of the app on the server. The thing with my password manager is that it's actually not a server rendered app. It is only running on the client side. In fact, you can run this password manager from just the HTML file. So for that reason, I am going to skip over this part because I don't need it. I don't have any server-side rendering. But if you do, then you just copy this part. And then we're going to talk a little bit about how we're going to set the locale because you have different options there. And then we come to the client part. And this one you also need to implement. And the way they kind of show it by default is that you do this in the layout, the JS file in the root layout of your application. And that's good because that's a place that is going to always load one time when you load the app. So let's just go ahead and take this existing one that they provide and they want us to create a plus layout dot. I'm going to do a TS file. It's going to go into roots, of course, we'll go and I'm going to paste the code. And as you see here, they use the same approach here with the search parameter. And we're going to keep this for now but later we're going to change it to something that makes more sense for our app. So that was actually the last step and now we can get into actually translating our application into Swedish. As I mentioned the PO files that are created are just normal text files so it's quite easy to translate it using AI and you can use basically any method you prefer. So the easiest one will be to just take the whole file and then we're going to paste it into the AI and we're to, in my case, Cloud, and we're going to write, please translate this file into Swedish contextually. Return the full file back. So I'm gonna go ahead and do that and then it's going to basically do that. So let's see how that goes. There we go and I just copy paste this back in and then I have a good initial translation that I can start working with. That's method one. Method two is to use something like cloud code or codex CLI or Gemini CLI, whatever agentic coding tool you prefer and then I can just, if I roll this file back, I'll just write the same type of prompt here. There we go and I'm going to just ask the cloud code to do it.

 and it's going to do it just as well. Let's go ahead and try that. There you go. And after some time, it finished, and we got the translated file back. I'm going to show a third way as well, which is something that I've been experimenting with recently and that I find has a little bit of a better output quality, and that is to actually put the whole code base into the AI, something called full context coding, and that way it's going to not only be able to translate just the text strings, but it's also going to be able to contextually understand where those text strings come from, which part of the applications they come from, and what the kind of surrounding text is like. So let's go ahead and do that. In order to do that, I'm going to use this MCP that I've developed called Context Coder. So all it really does is it makes it possible for the AI to load the whole code base through an MCP tool call so that it can have full access to it. So I'm going to go ahead and run this and to do that I run this mpx context coder command. Now the MCP is running and I can connect to it from my cloud desktop in this case but any kind of MCP aware tooling that you have. And now I can just write a very similar prompt and I don't have to even specify which files to look at it's just going to kind of figure it all out. Let's have a look. So first I'm going to go go ahead and get the whole code base to get that into the context. And once it's done that, it's going to kind of use everything it knows about the code base to translate the file. And in my experience, this works much better than just feeding it like the file without the kind of surrounding context of it. So let's go ahead and see how it does. All right. And there we see it finished. And as we see, it also directly wrote the files because this MCP also supports writing files and editing existing files. And now we have a translation that is good enough to get started with. So first, if we remember from the layout file here, we actually, we should also create a plus layout dot svelte just to kind of make this layout complete. There we go. It's just going to be empty. We remember that we're using the search params. So right now, if I just go to my site here and I append a query param. So let's say, what was it called? Locale, and I put sv, Swedish, and yes it does So you can see here that things are actually translated into Swedish So that already a really good start but what if I want language configuration to work in a different way Like what if I want to use a path segment in the URL Or if I want to use, in my case, like it would make more sense to use local storage. Well, we can control that ourselves. And that's what's so nice about this framework as well, is that you can use path segments like slash EN slash SV. You can use local storage or you can use such parameters. So let's just go ahead and change this and in order to change this I need to kind of do it the way it's done in this application which is using this like persisted the local storage store thing. So let me just go ahead and kind of set one store up for that. I go like export const language equals persisted the language options we have is Swedish and English. and I'm gonna call this the key of course language and the default value is going to be English. And now of course I need some UI for this and I'm actually going to ask Claude to write this UI for me so let me go ahead and write the actual UI for this and then we can kind of look at how how it will work in the bouquet. Alright so the AI has been hard at work making an input for me basically this drop down nothing more complicated than that and if we take a look here let's see if it actually correctly also binds to this local storage key that we expect. Alright let's see if we switch it to Swedish then we see here it's a little bit small but we see here that the language turns into Swedish and if we click here language starts into English so what it basically it did was just creating this select with the two values and it bound it to the language store. Now what we notice is that when we change the language here, the language doesn't actually change and for that we're gonna need to actually involve Vukail into the process here. So what it also did do was it went in the AI, it, it went into the load function and it actually already modified the store here. So instead of defaulting back to English, if no locale parameters found, it got the value from language store. Now, of course, we don't need the search parameter thing anymore because the whole point was to use local storage instead. So instead, I'm going to go ahead and just use a store and then when I reload let say I now go in and I change the language to Swedish It not gonna change by itself but if I reload the page now we see that it is in Swedish The only thing is left is to change language as soon as the user actually toggles the drop-down here and for that I think we can make just a simple effect here is probably easiest. So I'll do that and then we need to call something in Wukail right to change the language so let's go ahead and see in the docs here what they have and I wonder if just this await load locale is probably gonna be enough so I'm gonna go ahead and do that then I go ahead and do that and so basically every time language changes it should run this load locale function in this effect let's see if that works as expected so I'm gonna again go to the settings page then I toggle to Swedish Yes. And as we saw there, the language changed. And what's so cool here is that Wookay also has the runtime. So there was no full page reload. This is all happening live on the page without any sort of reloads. And of course, because we also get the language through the load function on reload, it's going to maintain the saved language. All right. So basically we're done here. Now we need to go in and change the action translations and stuff. But there is one more thing that is a little bit of a special case for SvelteKit. First of all, you might be wondering like when do these strings update? And the strings update, as long as you're running mpm run dev, the strings will update as soon as you change the component, but you can also manually trigger that by calling mpxvucale. Yeah, just mpxvucale. And what it's going to go ahead and do is just to extract all the strings again and then you will see like a diff in the files here. What we notice here is that we're only really extracting things from our Svelte files and the reason for that is that by default, yeah, we're not going to catch things for example in our load functions, right? So you don't see any of the layout.ts or page.ts files here. And in order to do that, we do need to add another loader to WooKale. This one is a little bit more tricky it not documented as well and I been in talks with the author about documenting this case better For now let me just show you how you can do that So what we need to do here is we need to go into the wu and we need to add another what called like loader here So a loader that is going to actually extract things from the our not only from our self files but also from our javascript and typescript files in there in the application. And in order to do that we basically need to add the vanilla adapter. So this one is included with Wookale, no need for another package. And then we're going to go ahead and create a separate adapter here. We're just gonna call this JS and I'm gonna paste the string that I have here and basically what the string contains is this you have this object with a files key and then in an array you have the kind of patterns of things that you want to catch. So this is going to then catch page and layout files. And since these are normal JavaScript files, this is going to work just fine without any kind of svelte integration. So now that I do that, I need to run mpxvuhail init again, Now that because I need a new adapter, so I'm going to go ahead and for this main one, I'm going to go ahead and choose existing. And for the second one, sorry, I said adapter, but I meant I need a new loader. For the second one, I'm going to select Vite because I think in SvelteKit, everything is kind of bundled with Vite. So this should work. And so now it went ahead and extracted using this JS adapter and it correctly extracted stuff also from our plus page.ts file. So if I were to have, let's say, so I have a message like here, or if I were to do something like error message and return something here, then if we just go ahead and run that, then all these messages that are added in my load functions are going to be included as well. This is something that was a little bit tricky because at first I was like, ah, where are all my messages in the load functions? But it was really easy to add, and I hope that the documentation will be updated to also include this. And that's basically it. Now, there is a few special things, like when you're working in such a different way from other libraries, there is bound to be some things like that. And aside from this loader concept, there's also

 a concept of extraction rules. So I'm gonna go ahead here and go to the docs again and here on the Svelte page we have this like default extraction rules. So there are some like special cases where Vukail will and won't like extract strings and I'm gonna be honest, I haven't fully like read all this through but if you run into an edge case where like one string isn't being picked up then you should probably check here because you might find the reason. And if you want to force it there is actually a few commands here. There is this at wcinclude so if for some reason your string isn't being picked up the way it should you can add this vcinclude comment into the context of where the string is and then it's gonna pick it up. You can also do likewise vcignore like let's say have some internal errors that you really don't care about internationalizing and you don't want to even see them in your translation files, then you can use this at wcignore to basically ignore those strings Now that we added these new strings from the load functions I wanted to show you another cool command that Wuhl has which is the status command So with the status command you can actually see here how many strings that are in total, how many are untranslated and these six untranslated strings were strings that were extracted here from the layout and page load functions that weren't present before. And you can also run a clean command, like if you have some strings that have been removed you run this clean command and it's going to remove all the no longer existing strings from your files. And that's basically it and this is the thing that I love about about this library. It takes you 10-15 minutes to get started and then you don't have to make any changes at all in your application. Thanks so much for watching, I really hope you liked this video. If you have tried this library or if you still prefer a different library, that's okay. Please leave your feedback and your thoughts in the comments. Make sure to like and subscribe and I'll see you in the next video. Svelte internationalization, Svelte internationalization, Lingui, or Paraglide to choose from?