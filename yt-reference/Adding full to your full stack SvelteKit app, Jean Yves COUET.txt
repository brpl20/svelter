 Thank you to Hermin for having the new branding and the new logo. So, bravo! So I hope the pizza was good. So today we will speak about adding full to your full stack SvelteKit app. And this is a subtitle to say I will speak about remote. Maybe some of you heard about Remult before. Show of hands. Very good. Almost half. Very good. I don't know if you know, but a few weeks back, we launched a brand new website for Remult 3.0. It was a big thing. At least for us. So first thing first, let's see the landing page. Wow, very cool landing page. Adding full to your full stack. And this landing page is a small editor, so you can play already or feel how easy it is to do an application. You can see define an entity, pagination, adding a form, and we'll go through all this. But the key point is that in 13 minutes you have a full stack up and running. So I will go on top here and I will create an NPM in its remote at latest to just do an application with you live. But before. Thank you to Hermine for having the new branding and the new logo. So chapeau. So let's have a look at this NPM init remult. So we do NPM remult and we will create an application called Meetdown. You know there is a lot of things going roll up, roll down, so we'll do Meetup, Meetdown. And we will select, of course here we will select Zvelkit. want to have OGS directly part of our application. We will use SQLite. We want a demo CRUD application with task and we want to enable admin API. Okay. Now we have our full app almost ready. Let's close this. We have the cursor open already in the good place. And I can do NPM Okay The live demo god is with me So we have our Mid app running With also thanks to Amin a very nice design So by default we have this nice design showing you that you selected SvelteKit, SQLite, and you have OJS. You can do interactive tutorial, documentation, of course you will go to GitHub and give us a start at some point. We have some tiles to show you some functionalities. So OAT, we will see later. admin part, we'll see also later, and we have already a to-do app at the bottom. I don't know if you can see well with this stuff here. It will annoy me, this. I don't know how to hide it. Okay. Is it working? Okay, so we have a to-do which seems to be working. If I refresh here the page, oh, the text is still here, so it's persisted somehow. Okay. Let's Let's have a look at how this application works. So on the left part I can see, and I hope it's zoomed enough. Yeah, tell me yes. So we have routes, and in the route we have a folder called API, and we have a dot dot dot remote. This is called the catch all route. Okay? And if we go in this plus server.ts, we have this get, put, post, delete, in the other order, linking with API. So the important part is the API. go there to my API, so server API, and in there I have just this export const API coming from Rebolt Svelte kit. I don't know if you saw at the beginning, it's for Svelte, but it's also for all other frameworks. And here we have an entity key and we see that we have a task here. And the task is what is served here. So it's just creating some REST API on your application. And if I go actually here to slash API slash tasks, enter, not found, of course. Task. ROMAIN GUY TRIBBLEDRAEBARD- You need to spell it right. Yes, we see our task. Is it working? So it's just a single normal REST API. I close even the website. Very good. And just under what do we see? We see a data provider. A data provider is just to tell you, I want to save everything in a database. And here I use the SQLite database with a file. And you can see this file on top here mydb If I remove this save and refresh of course my isitworking is not there anymore because it's not looking for the database. But I can ask the question again. Is it working now? And if I refresh, it still persisted. How come we don't have a database anymore? By default, Remult is taking an approach to have a JSON data provider. So you see here we have now a new folder called DB, and if I open it, I can see my task, does JSON, and this is also my data. So I don't need to ask a colleague to spin up a Postgres server or SQL server or whatever. I can already play with JSON, which is very convenient when we start to have a backend. And the cool thing is that here if I check up this, it's updating live, you know, with your editor, which is Pretty nice. So, again, if I continue my journey on this, it's just a REST API. So if I open this small tool here, I don't know if you know, it's like Postman in VS Code. So if you do a send request on a get, I see is it still working, okay? And I can do a post similarly to a get. So now I will send a post, and boom, Everything is up to date on the right side, on the website. To have all... Let's organize it like this. To have all my data. Just the rest. I don't know if you noticed, but I didn't hit F5 or refresh or anything. It's everything live query. So I just send a post, and on my UI, everything is refreshed. I didn't do any code here. I just added a live query. We will go into it later. So we spoke about the landing page. Okay, good. We spoke about rest. Let's speak about validation. I don't know why you are laughing. So validation is key, right? In the frontend, in the backend, in full stack, you need to do validation. So first thing first, when I send a request here, so same thing, I do a post on the API task with the title A. And I have an answer directly here, title too short. Cool. So we have a backend validation. And how this is working. So let's have a look at this API. Let's close some stuff here. And we have the entity task. Let's go inside the task and see how this is defined. So we can see that the task is defined like this We have an ID We have a title completed and created at And in the title you see this property validates So if it greater than two everything is okay If not, I answer too short. And this is doing my back-end validation. But it's also doing my front-end validation. Like this, I don't need to have two places to do this same check. And the cool part is that if I do F12 here to see the dev tool, and I put A here, enter, too short. But what is even cooler is that you don't see any network tab going. I know that this validation can run on the client side. I don't need to do a going back to the server. Of course, you can add some validation which are backend only. And then at this time, yes, you will need to do a backend call to check if the title is unique or something like this. Okay? Still good? So now let's code our application now that you know everything about framework already. So, as an idea, I said let's do a mid-down application. Oh, yeah, you're right. So the next point is mid-down UI. Not meltdown UI, it's not something else. So mid-down UI. Mid-down UI. So as my designer is just here, I ask, Hermine, please give me some nice CSS to have a mid-down UI. So I copy this here, because I don't do live coding, some other people just do copy paste and I will go to my plus page dot zvelt and here we see so mid-down what's next okay we go down down down down and we have a few tiles the authentication tile the admin tile that we can see and just just beside and the to-do and now we will add here the list of mid-down and if I save and I need to import of course If I save, I have two upcoming events coming. Okay, with a nice UI. Thank you, Hermine. Where I can say, okay, from 8 to 23, it will be in Vienna. June meetup is right now, and I can attend. Ah, no. Hermine gave me just the UI, not everything else. So, and then we see that we have seven attendees. Same thing in Berlin, July, and we have seven attendees. So let's have a look at this component. If I go inside, I can see that I have two examples of mid-downs, perfect, what we see on the right side. We have the title, we have a small for each where we get the detail of each mid-down, and I don't know if everyone know that you can put an S in each block. I love this small feature.

 It's very convenient. And then like this, if you have no mid-down, you can say nothing here. Small detail on the way. So if I go now in the detail mid-down, I can see my markup. I see my time. I can see my number of attendees, seven. OK, it's hard coded. Like this, the UI is prepared. Now I need to fill the rest. Then we have the console attend. So if I click here, nothing happens. But I probably have a console load. And all this is relying on a class called mid-down with an ID, a title, a date, a time, and a location. Easy enough. What I will do right now is what I call, I will remult my class. So to remult my class, how do I do this? I add a small decorator called entity. I need to import it from remult. And we need to give a name for the database. So mid-downs. And then I do the same for field. So very good. Cursor is nice enough to give me that the ID will be a UUID, the title will be a string, the date will be please give me, yes, a date only, perfect, string, string, perfect. So now the class is remulted, okay? It's able to speak remult. But to finally speak with my app, I need to add it in all my routes. And to do this, I go to my API server where I have already the definition of task, and I will add now this mid-down. Save. And if I hit F5 here, I have here you can see a new route available API mid-downs. So now all my cruids are directly available. I can create a bait delete mid-downs. Really cool, but now there is just an API but nothing else. What I want to do is to not have this statically done in the component. I want to add it directly at the start of my application. So to do this, there is a convenient function here called init API. So at the start of the server, see the data somehow. And to do this, I will do it quickly, not this file, close. I have my two, my two mid-down, cut. No, control KU, yeah, okay. API and I paste it here. Now I have my two mid-down and what I will do, I will loop, and thank you Cursor, I will loop through my mid and I will do repo So this repo is like repository of mid please do an upsert so upsert is what is not just insert but check if the data is here or not where mid is here okay and if I save now and refresh I still have nothing here normal because I didn't look for the data but let's see if the data is actually populated in the database and to check this very easily. Oh, why is it not there? Oh yeah, to check this very easily, I have my JSON database. So I know that my data is already there. We can even log it just under, so I will do a console log. Usually, Cursor is better than that. Repo of mid-down.count. Save. F5. Okay, we have our two meetups. And only two, even if I refresh, because it's an upcert and it's not inserting always data. Now let's go back to our data provider SQLite, because it's nicer. Why not? If I refresh, I have only my hits working, so I will just go to my task and send all the stuff there. And let's recap. We did validation. We have the new UI. We have the remote tower class. We have the API init and upset. that, oh, limit order by where? What is going on? So let's close everything and go to my list, because now we have still no event here. So we wanted to get it now out of our database and display it on the front end. To do this, so I go on my list. And in here, I will do an effect. Very good cursor. Repo. So my repository of mid-down. By the way, all this naming, I'm very happy that there with a C sharp guy in the room, because repository should sound familiar to you, because a lot of things are coming from C sharp terminology. So here if I do a find, and let's just remove this for now, and save. I didn't do a find job here. Yes. Okay, now I have my data. So this, I'm on the front end. Of course, I will not use a dollar effect, but just to demonstrate the simplicity here, I will use it like this. So I come here on repo mid and I do a find which will do a REST API call The REST API call the database SQL Postgres MongoDB or whatever come back to the backend and answer it here. So we see it in the frontend. And directly here, in the find, we can do a limit. And we say limit one. I have one event. I can do an order by. And I can change. Is it the other one? Yes, we see the Berlin one. So, of course, I want to see both for now. Okay, so now we have on the front end the data coming from the database. Next step. Next step, we need to click attend button, right? So I need to have a look at who is connected, and I will need even another entity in the database. I will need to save who is the user going to each event. So to do this, I will create another entity called userInMidDown.yes. And in here, I will not code it. I will do just boom. Yeah, I'm afraid of live coding. So just to explain to you what's going on here. So it's a class where I have an ID, created that. So when was it created? The user. We have the event ID, so the mid-down ID. And then we have a relation here, a relation to a mid-down. Okay? And we have a status, which is of type status. By default, I put coming. And it can be coming, not coming, or maybe. So by default, you attend. And then after, you can say, oh, maybe I'm not coming. And this is the idea of it. Da-da-da-da-da-da-da. Relation. Yeah, now maybe it's a good time to do a small break in building our app, because we build already a lot. So let's have a look at what is admin. So if I open admin... Ah, no, no, no. Wait, we don't open admin right now. We just go to API. Here, we created our class, but we didn't say to remote, hey, please use it. So let's add it here, user.emid down. Import, yes, save. F5 here. We have our three entities. And first thing first, at the bottom, we can see the diagrams. Let's have it in big. So we can have here our database structure directly from the frontend with an admin flag I just put it in the I don know if you saw in the API admin true and then I have it We can also restrict it by who is connected or not So we have our mid-downs and our user in mid-downs. Pretty cool. And on the left part, I can select this mid-down. I can see my two values of course. And I can add another mid-up or mid-down. full CRUD application, I can edit, I can delete, I can do everything. So, let's go back to this on the right side. Limit order we did, relation we had a quick look, admin we did, and looks the cool part, authorization. So, at this level, I want all my information to come from, let me close this, come from this entity guy. So we have this user in mid-down and in here, if I control space here, I see all the list of what is available on this entity decorator. And one of them is called allow API insert. So I can, of course I will not type it because, so I have two things that I want to set here. I want to say that A user in mid-down can be inserted only if you are authenticated. If you are not authenticated, you cannot say, I'm coming, I don't know who you are. And then you can update only yourself. How to say this? I want to say, if remote.user.id is known, and if my current row, so item of user ID, is me, then I allow myself to change if I'm coming, not coming, or maybe. If not, return false, I'm not allowed to update the row. So with just these two lines, I have security on my user in mid-down. Now, where is coming from this remul.user.id? So this is a small thing also, and maybe you saw it already as a preview. If I go to my API.ts here, I have this thing called getUser. And this getUser is getting the user from the request. You remember at the beginning, NPM init, I selected OGS. So all this is done for you already and the code is there somewhere hidden but just to give you a gist of it if I come here and say Get user and returning All data so name GYC myself all cyclist runner and admin because I'm the three of them If I refresh here I can see that the hot panel is

 is authenticated as GYC with these three rules. OK? And you can see here that I have an event coming from those event. So you can get the local and stuff like this that usually you have an old library that filled the local. And then in the local here, you get it, and you return the user. So just with this simple function, get user, you are able to say to remote, oh, by the way, here is the user. So we are not in remote taking care of authentication per se, but it's very easy to fill with what you have existing. So let's bring this back to OGS, save. Let me check if I do it in the correct order. Should I check something? Yes, authorization. Hooks. So what is a hook? Okay, I will switch a few things. What is a hook? Here in my user in me down, when I will click the attend button, I want to automatically say that it's me, the user connected. So I will add here a hook called the saving hook. And on saving, we will first check are we logged in. If we are not logged in, we say, oh, you need to log in. Second thing, if it's a new event, I will check if you already answered. So I will count the number of user in me down with this user ID and this event ID. And if you already answered, then I'll tell you, please just change your status. And then finally, if everything pass, I will say user.item, then user ID equals remold.user.id, because I know that you are logged in and I know this guy is here. So let's save this, and let's go to the attend. Not here. Detail. So we have our console log here. Not this, no. Not good cursor. Repo, yes. User in mid-down. Okay. No, not repo at all. What? You see, I have two lines to type and it's not good. Repo from remote, yes. Sorry, I'm not in the right file. That's fine. I mean the demo. It's not for the demo. We are doing real stuff now So in here repo user in mid import it And what should I insert? Control space, event ID equals to mid-down.id. Let's await this. Save. and I don't need to set the user ID because it's the backend who will set it with the saving hook function. You are following me? Yes. So if I click attend, forbidden. Forbidden, yes, it's forbidden. So my API is working. I'm not connected. Oh, I am connected. No, no, I'm not connected because I commented it. So I F5, I'm not connected. I sign in now. So let's go sign in. This is the OGS default UI. Jane, Jane, one, two, three, save. So, you are connected as Jane, yes. Attend. Okay, nothing happened because I didn't do anything on the UI. And if I click a second time, I have an error telling me, bup, bup, bup, bup, bup, bup, you are already attending this event. Okay, I know. Okay, so my hook is working. Perfect. Now, let's have a quick look at, and we will not go through all the steps. Just one thing that I forgot to show you is the disable. I can say, maybe it's not good to show that I can click attend if I'm not connected I know that I'm not connected. So I can connect the disable to a repo of user in mid-down, yes, .metadata API insert allowed. So this, if I'm allowed to insert, it will be not disabled. If I'm not allowed it will be the opposite. So let's just sign out, sign out, and now the button is disabled because I'm not allowed to insert. So this is pretty cool because in one place, single place, I define that to insert, I need to be authenticated. Single source of truth is this file. And then all my application can react to it or can develop to it. Okay, and now let's not look at this button because this button is not so cool. Let's do this at and select. and I forgot many things so please sorry. Oh I forgot something else. So now that we are let me go back to Jane Jane one two three So now we are attending this meetup but we don see it in the UI So I want to get my state, right? To get my state, I come here and I do query my state. So this is just an effect. I want to do repo of user in meetdown, and I get the user ID and the event ID, and I will know what is my state. Okay? And my state is, am I currently going or not? And now if I pass my things instead of the button, I have a bit more complex UI. Add and select. I need a few imports. Yes. Yes. Type. Okay. And now you see that the UI is a bit different. now I can, if I'm already coming, I can say I'm not coming or I'm maybe coming. Okay? As soon as I already answered myself. Okay, pretty good. What else should I show you? Maybe the counter. Here I have still my hard-coded number 7. So on the side here I can add another query called query attendees. And this will be a live query where the event is meetdown ID. and I want to see only the number of attendees that are coming. So I've saved this, and this will save into attendees. And now I just need to replace my attendees7 to attendees.length. Save. And since maybe I'm not coming here, and if I'm coming, I'm going to 1. Woo! So if I'm attending here also, attendees going to 1. Very good. and then you will be able to play with it in a second when I deploy this live. Okay, I'm arriving at my last part. Today I'm very happy to announce that we had a new feature in beta mode, or alpha mode, I don't know how to say. I don't know what's worse than this. Called module. So module is a way to group functionality together. Because as you saw here, in API, I have my list of entities, so now I have two things and then I have my init API so it a bit mixed of things So what I can do in Meetdown here I can create a new file called server slash index dot yes and in here I will export const mid Downs equals new module Yes the key is mid and it expects some entities. So now I want to have these two entities here directly. control space enter to import this one control space enter to import the other one and I want to have a you see here if I do control space I see all what is available as a module and as a module you see all the list of things which are available also at the root API remember and one of them is init API so if I do init API here I think this and that I can go to my API and just take all this off. Yeah, control X. So cut, come in here, save. I need of course to import repo. If I go at the bottom, hit F5. Now nothing is working. Why? I don't know why. Yes, exactly. So let's remove these two entities because now it's the module who should take care of this. And this is a new thing that we launched right now is this. At this level we can add a module called mid-down. Not like this at all. Call mid-down. Yes, coming from the server. Save. F5. And we can see still our meetup. We have two meetups and everything is still working. It's just that the code is a bit extracted away and you have this functionality into a module. Which is very nice because if you have two applications requiring the same module, you can now just share one maybe package and then you have the two in two applications. Pretty cool. Next level and last level is that one day we'll have some community packages. And for now I will show you one that I think could be very useful. It is called secret, yes, module. So actually in my applications, I I've been doing this actually for a long time, I have to say. And beside my roots I have a folder called module. And now I have a module that I call changelog. And the idea is that you can opt in changelog to all your entities that you have. So here what I need to do to do this, changelog is like, I will be able to see who edited

 in my application. So what I need to do to do this, I need to say, oh, I'm using the module changelog. Okay. And I need to change, oops, and I need to change to opt in this mechanism. So the task, I want to see that the tasks are changelogable. So instead of importing from entity, I'm importing from changelog entity. And for my meetups, so where was it? mid down, mid down. In here I will do change log entity. Okay. Did I do the import? No. be not like this. Okay. Second one also change. I need to type. I cannot copy. Okay. Change log. Okay. Now I opt in on this three class. I opt in to this change log entity. And now Now let's say that I'm coming. Why is it not live, server live? Okay, I don't know. Not coming. Coming as Jane, okay. And if I go to my admin, I see that I have a new layer called app change log. Let's make it big. And we can see already that Jane is doing some changes. It's not a new row. It's not a deleted row. It's some changes. And if I click there, I can see the status, the new value is coming and the old value is not coming. So with just this, oh, let's add this module with this functionality, opt-in to two, three class, now I have the full functionality working. What could be even cooler is that if I go to user here, I have the flat list of user, Jane and Steve, but I want to see all the change log of Jane or Steve. So let's add just this here. I go to user, BIM, so standard definition of a user, provider, la, la, la. And then I can add here relation. So in relation, I just say, okay, I want to connect this user to an app change log with this field called user ID. Save. Refresh this page. And now we can see we can open here all the change log of this user Jane So this is a one to many and one to one of course The two are working on both directions. And we can also see the diagram that is up to date with the user and the connection with everyone. Okay, so the next and last step, actually, is to, all of you go to meetdown.gyc.dev and play with the application live. So you can even just like this or let's not look at my calendar. Or if you are not, if you don't want to type, I prepare this here. And this is here. And yeah, you can sign in and you take any login, it will create a user for you. There is no registration form or something like this. So you just, any user, any password, you go in, and you will be able to log in and add, hopefully, some to-dos. And at the end, of course, you can go on GitHub and give us a star. Thank you very much. Thank you. Any questions while you are typing? Nothing is coming. Is it working? Okay. Let's see how fast you are going. Ah, yo! This is cool. Okay. Live query. Okay. So any questions? You have one there. This is very exciting. I'm also very excited about it. I actually did rewrite my entire private project and I'm working on it now. So before you finish your question, when I saw a presentation similar to this, two year and a half ago, I was maybe at your stage, and I already rewrote all my app in this. So you can continue your question. And if, let's say, the entity changes, how do you deal with migrations? Yes, so this is all baked in. By default, we add colon. If you want to do some complicated script to change, you can do it in init API. It's perfect for that. So we never drop anything. So it's only adding. And in the init API, you add a logic to say, okay, this field is now a concatenation of both, whatever. So this is the automatic migration story And we have also a flag to say I want to fully manage my migration myself You can switch this flag and then you write your own migration Even better the tool writes you the default migration and then you can edit it That's exciting. Yes. And how do you deal with... I guess you use this for your own spam.update website? Ah, no. No, there is no data. The data is static data, you know. We have a new talk. talk. Exactly. No, it is a VELT project and it's open source, of course. So someone else, yeah? Congrats on the V3 and the stunning landing page. My main question would be how do you deal with the live, what's the live query? Is it a web server connection? So in the background by default is SSE. Server Send Event, exactly, sorry. By default it is because it's working very well at least in my app and the app of Noam as well, the creator and all the apps. But it's implementation details. So you can switch to WebSocket if you want to. It's already prepared, there is a hook for that. I thought that sounds like a very good fit for server-side sending. Yeah, yeah. It's a very good fit for a lot of things. Okay, other questions? You, the repo implementation, how do you, I mean, as well, like, you support like five or six different repos, like SQLite and whatnot. How is the conversion taking place? So do you have to write everything from scratch or repo from find from then conditions and everything like link or whatever and all the five. Do you need to convert it to like SQL, like raw SQL? No, you don't have, I mean I didn't write any SQL and I was getting the data. Yeah, but they come behind. Ah, the library is taking care of this for you. So you don't need Prisma or you don't need Drizzle, remote is doing it for you. There's a lot of advanced features we can do SQL fragment, but I don't go in detail for now. Here I showed you maybe 10% of what I'm already capable of. Just to show you, this is all the framework we support today all the database we support today And it clickable so you can check Exactly So if I go here Postgres I see someone who created the clicks you know So if you click Postgres you go in Postgres and you say oh you need to install pg And then we have good defaults for everything. So if you put it a string, then it will be this in the database. If you put it a number, it will be this in the database. And add the, add the, let me show you in my editor, if I found my editor. I close my editor? No. Let's just click the icon. I just show you quickly here. In here you have a... maybe I should not show you live. You know how it is. DB... I don't know why... never mind. It's another property but you have a field called DB something. So if you have a something very specific to your database then you you can override the parameter. So you can create also your own fields. It's annoying me that I don't find it. So you can check the box. Yeah, input DB type. In the value converter. So in there, you can override what we provide as good default. And then if you have some, for example, vector in Postgres, we can support vector as well, because we've just this thing, which is quite trendy right now to do AI, for example. Another question? Did I answer everything? So when you first install the project, what comes in? Because you copy-pasted quite some stuff for the demo. So when you install remote directly, you have the panel that you can see, right? Yeah, exactly. So let me just do it again. Oh, you know, I will just tag. Because Toto is a good name. Let's keep the JSON default down. Yeah, it's, it's a good question.

 It's just the OTT is coming like this. So we have Toto now, and we have the new stuff coming here. But all what I copied from the static was just to save some time for the Svelte stuff. So there is OTT, there is work in code, there are examples of stuff, templates. But it's not only Svelte. It's also other things. Yeah, so just for information, since we are in Svelte, we do it here. But we have what I call 160 flavors that we test all the time, meaning that if you have an XGS application with Mongo, without auth, we test it out. And another thing that I quite love in this Remult project is that we have a test coverage which is really high. So you know when you change ORM layer, it's kind of a big thing, you know, you rely on your data fetching and everything, so you want to make sure that it's really tested out, and this is the case. That's why I made the change from Prisma application to Remult. Yeah? How many people are on the remote team? 200... no. No, let's say we are four, I would say. Four. The creator, the co-founder, I'm going there a lot. Hermine is contributing. But from time to time you have people coming, doing 2-3 PRs, going out, in, out. But the regular contributor, I have 2-3. Yeah, there was just like last week someone made a package for remote and better off . ROMAIN GUY TROPELAINI- There was a guy also saying that, oh, I'm using, I would like to use Cloudflare D1. And then he created the Cloudflare D1 adapter. OK. 200 lines and you have now Cloudflare. We are now reviewing the PR to make sure everything fits. Also we have all the test suites for all the database So when you create a new adapter We make sure that all the test suite is still passing Yes How long has this been around Is there like some production side or big side running this So define big. So first commit was in 2017. So it's not out of yesterday. The creator started to speak about it really three years ago. Before it was only for him, his project. He has a food delivery app up and running serving a lot of distribution. But then after it's all a question about what is big, what is scale, maybe I should do a real talk about this topic because I'm very passionate about this. I don't know if you know this Kaizu application, very popular, famous. It's of course running on Remult. The whole source code is open. And if I click here, well, I can see the data of, let's say, Blue Sky, number of users in Blue Sky. And this is more or less real time. We have 46 million of users. And this is served by a remote application. Of course, there is not a lot of traffic there, but it handles the scale of size quantity. I don't know. It's a 30 gig database. And you saw that the refresh is pretty instant, right, with the number of people. Also, in terms of traffic, I put all my SAS into this, this food distribution app. I mean, yeah, it's handling a lot. Of course, I would love to write down that your website is using a multo at some point. Let's talk after.