 Thank you. You're a web developer who's just been tasked with building a new web app for a client. Their marketing team tells you that they know and love WordPress. It's a trusted, rock solid CMS that powers over 40% of the web, and it provides them with the editorial workflows and content creation experience that their team relies heavily on and wants to keep. You dig in and learn a bit more about the project requirements. Two things in particular pique your interest. One, the need to support multiple clients. You learn from your discussions that after the web app is launched, the client also plans to launch iOS and Android apps. So that means the web client, iOS client, and Android client all ultimately need to be able to source their data from the same WordPress backend. Two, a persistent podcast player. The client tells you that they want to have a fixed podcast player at the bottom of the page. Site visitors should be able to start playing a podcast episode and then navigate around the rest of the site with uninterrupted audio playback. You take a step back to consider all of this. Using WordPress as a traditional monolithic CMS would certainly allow the marketing team to continue using their preferred platform. However, that would make it difficult and cumbersome for the WordPress backend to be able to serve up the platform-agnostic JSON data it needs to to serve the iOS and Android apps. Further, it would also be problematic for the persistent podcast player feature, since out-of-the-box, traditional WordPress performs a full page reload every time the user navigates to a different page, so the audio playback would then be interrupted. You find yourself wishing you could use something like SvelteKit, a single-page app framework that makes persisting elements across route changes nearly effortless, among many other benefits. So what do you do? How do you proceed with this project? I'm Kellen Mace from the Developer Relations Team at WP Engine, and I'm here to tell you that this time around, you can have your cake and eat it too. For the rest of this talk, we'll build out a proof of concept app to accomplish these goals. We'll use WordPress as a headless CMS and pair it with a SvelteKit front end. By using this decoupled architecture, we'll see that we're able to accomplish our goals of supporting multiple clients, as well as having a persistent podcast player that has uninterrupted audio playback across route changes. start by setting up our WordPress backend. Here I'm using a free app called local to create a local WordPress site for me to work with. And you can see I have it running at sveltsummit.local. And here's that site in a browser. You can see here that I'm at the WordPress admin screen. And here I've created a few dummy blog posts just so we have some data to work with. Next, let's turn our WordPress backend into a GraphQL server using the WP GraphQL plugin. So I'll head over to plugins we'll go to add new and then I'll search for WP graph QL We'll find that plugin on the list and click install now and then once it's been installed we can go ahead and click the activate button Now the WP GraphQL is activated I can head over here to GraphQL and then go to settings and at the top of this page We can see what our GraphQL endpoint is so we'll need that in just a moment here let's turn our attention now to our SvelteKit app so I went ahead and ran npm init Svelte at next and just gave my app a name that's all I've done so far this is just a skeleton code base at this point so the first step we need to do is link up our front end to our back end using that GraphQL endpoint so how we'll do that is we'll create a new file called dot env dot local and inside of that we need to define an environment variable. So we'll make it a Vite public WordPress API URL, just like that. And then we'll head back to WordPress and we'll copy this GraphQL endpoint. So we'll go to copy link address and we'll paste that in there. So I'll hit save and this is the endpoint our front end app will use to fire off its GraphQL requests. I also have a completed version of this app here. So as we go, we'll copy and paste some things back and forth and then I'll explain it each step of the way. For now, we'll just copy a few things over. So one is this layout CSS file. It just has some global styles in it That one will stick in our source directory to give us a bit of a head start there And we also take a look at this layout file as well So I'll copy that and then we'll put that inside of our routes directory. So for now, we don't have this podcast player. We'll do that later. For now, we'll just start with this. So in our application, we'll have the CSS file with our global styles being pulled in and just a main element that wraps our app and gives it a little padding and margin and so on. Next, let's see how we can actually pull data out of WordPress and display it on a blog page. So inside of routes, we'll create a new file and that'll be blog slash index dot svelte. So let's create that. And for now, we'll just make sure we have a page rendering. So let's check out this page in our front end app now. So I'll head to localhost 3000 and we should be able to hit our blog route. Next, let's see how we can query our WordPress backend to get a list of posts and then render those on the page. In our front end app, we have this completed file here and I'll just steal a few things from this. So ultimately, what we're going to render on the page, on our blog page, is this. So we'll still have our heading, but then we'll say if we have posts, loop over those and display list items. Otherwise, say no posts found. And for now, because we don't have a post card component, let's go ahead and just render a paragraph and we'll say post dot title. If you head over to the SvelteKit docs, you can see that there is a load function that SvelteKit provides where you can do any data fetching that you need. So this is exactly what we need. I'll go ahead and copy just the script tag and then our load function will grab from our completed app to save a little bit of time. So here I am with my script tag and then in our completed app here's what the load function is going to look like so i'll copy that and let's talk through it all right so here's the load function that we're exporting you can see it receives you know fetch and it um it uses the fetch api and it sends a request to our wordpress api url it's a post request and the type is application json then we're passing into it the query that we would like to run here so we need to define what that is above we're going to have const query equals some string here so we need to determine you know what that needs to look like and then fire off this request for a production application you know you might want to consider using a library here instead of just a straight fetch call so you could use like urkel or apollo client or um svelte query you know one of those libraries for our app though just using fetch for our proof of concept is going to work great all right so let's say we've made it this far and now we need to figure out what actually actual query do we need to fire off to our wordpress back end thankfully graphql and wp-graphql specifically have really great tooling around this so if we head back to the wordpress admin now and we go to graphql and and then graphical IDE. Here you can see that WP GraphQL provides this embedded graphical instance. And from here you can explore the GraphQL data graph and compose your queries very easily. So it comes with this explorer here on the side where if you want to drill down to posts and then the nodes of each post and get the date or whatever other data, you can see as I check these boxes, it composes the query for me over here. So then when I hit the play button to execute this, I see what the result would be, you know, if my front end SvelteKit app were to fire off the same query. So this is huge. This is super, you know, powerful and makes composing your queries very easy. Another trick you can do is if you're inside of, if you're nested inside of the query here, you can hit control space to get autocomplete as well and see, you know, what's available. So at this point, you would explore the data graph and build up your query and think about what your pages need to look like. For us, we'll skip ahead to the finished result. So this is the query that we would have composed here in the WordPress admin. So you can see it is called get posts and we're saying we want to get the blog posts and then for each of those nodes, we want this data back. So if I were to fire that off, here's the result. So this is what our front end SvelteKit app will receive and what we need to use to render these on the list. So armed with that knowledge, let's go ahead and copy this whole query right here that we've built up and we'll head over to our app and that's what we're going to stick inside of this string here. All right, so let's test this out and see if we can get it working. So we have our load function that's running this and it is going to fetch the data. and then when the data comes back assuming the response is okay it'll pull out the blog posts and then pass through those through as a prop to our component but our component can't use that data just yet because we need to export posts so that it usable by our component so let flip back to our finished product and we see further down what that looks like So here we just have this other script tag below the first one and we'll get rid of comment out postcard just for now and just leave posts here. All right, so here in the browser, we were successful. You can see we're getting back the post titles and we're able to render those on a list. So this is great as a starting point. You can see now our front end SvelteKit app is hooked up to the WordPress backend and it's able to pull out data via GraphQL. So from here, we can display more data about our blog posts. So to do that, we'll use this post card component. And then that's the thing that we're going to render in this place. So we'll say post card is there and then the prop it expects is post. It's like that. this postcard component will steal from our finished product so it's this one so I'll copy that and then we'll create inside of source a components directory and then inside of that we'll paste that in so that component is pretty simple this postcard there's not a whole lot to it it just receives you know the post as a prop here and renders an article tag with you know some info about the post inside of it and it has some styles at the bottom and this is what it looks like in the browser so this is pretty cool you can see that we have our blog post you know cards being displayed here so we have the featured image title and then the excerpt for each of our three blog posts and these are linked as well so if I click on this it'll send me to slash blog slash whatever the slug is for that blog post but we haven't implemented that just yet so let's do that next this will be our single blog post page so to do that I'll close out those files and I'll take a look at our completed app and look at blog and then this slug dot svelte so this will be a dynamic route for us so let's create the same in our new application so in blog will do new file slug just like that now inside of let's figure out what we're going to need so we'll do some data fetching just like we saw last time so let's you know prepare for that we'll have this and then our closing script tag all right and we'll need to define our query all right and we'll do some very similar data fetching to what we did in the last file where we'll use the load function and then you know the fetch API just to send through our query. This time it's going to be different in one way, and that is we need to send through a variable, though, to our GraphQL query. Let's inspect that a little bit. So inside of our load function here, we are still passing in the query as we were in our previous example, but this time we have this extra variables object that we're passing along. So we're saying, here's the query I want you to run, and it is going to expect a variable called slug. And here's the thing to use for that variable. And you can see here that we're drilling down to page.prams.slug. So that'll be our dynamic route here. Whatever slug is in the URL, that will be passed through and used when this query is run. All right, and then from there, we're saying if the response is okay, pull out the post data that was received and then pass that through as a prop. And just like last time, we need to make sure we export that from our file. So we'll need to do this. All right, so I'll export that. So we have it available to us in our component. And I have a few other helper, a little helper function to format our date. And this code just to pull out a list of the categories that the blog post might have. Below that, we're ready to have our HTML then this is nothing right home about again it'll be pretty straightforward so I'll have a link at the top to go back to the main blog post page if the user wants to and they'll just have an article tag with you know the info about this single blog post that the person is viewing and we'll give that some style as well There we go. So at this point we have all of our markup, all of our styles accounted for, but we still need to build up this query at this point to fetch the data for our individual blog post. So at this point, I would head back to the graphical IDE and instead of the getPost query here, I would do another query for an individual post and then compose my query here until I'm getting you know the data back that I expect so to get a bit of a head start though we can steal the finished query from our completed app so go ahead and copy this and then we just take a look at what that looks like here all right so this is different in one noteworthy way And that is like I said it expects a slug argument So this is what that syntax looks like You say, we're expecting a slug and the type is ID. And then we're passing that through and telling it the type of this ID we're providing is a slug because there are some other identifiers you could use to identify a blog post such as its you know ID in the database but in this case we're saying the type of ID we're passing through is a slug we'll try to locate it based on that if I try to fire this off it will crash and burn because I haven't provided that slug variable so down here let's actually do that I'll I'll open up the query variables section and I'll say here's the slug and we're passing through one of the post slugs. So let's figure out what one of those is. So I head to one of my posts and here it is, the URL slug. I'll copy that. And then in my career variable, that's the thing that we'll pass through as the slug. So if we try to execute that now, shazam, there we go. So we get our post back and then date, title, content, all the info that we want about this individual blog post. so this is basically what we're going to do in our SvelteKit app so we have this identical query so I'll copy that and we will make that the query that we're going to run so I'll head back to our front end app and let's just start out at the slash blog page again here's our first blog post and I'll try to click through to it and there we go seems to be working so I might you know link back to the blog post page and I have the featured image, the title, the author and date, you know, they're nicely formatted, the content of our blog post, and then the list of categories. So I think we're doing great here. We've seen in our web client how we can query for data from our WordPress backend and then create our blog post list page as well as individual blog post pages. But have we accomplished our goal of having a platform agnostic and know graphql server that can be used for a web client and also ios and android so one way to test that would be to use a standalone version of graphical so this one is embedded into wordpress right here you can you know we can simulate having other clients just by having like a standalone graphical app just like that so you can imagine this is like the ios app or android app if one of those sends a request to our slash graphql endpoint and requests you know some data like this and we can fire that off here and we see that they would get structured json data back just like our web client does um so this is great for you know consistency right anything any tweaks that you make to the graphql schema to serve the purposes of your web client that would that would also benefit any other clients ios android desktop or whatever else um so we've met that requirement Now we have our data being sent through to our web client and also any other clients that need to consume this in the future. Our one last requirement for this project was to have the persistent podcast player. And with SvelteKit being a single page app framework, that'll be pretty effortless for us to implement. So let's see how we can do that now. Back in our code base, I'll take a look at the completed project. and we'll see that we have this podcast player component. So I'll copy that and we'll paste it into our project and explain what that is. So here's podcast player. You can see it's pretty darn simple. I just have a wrapper div here with an iframe inside that's going to pull in this podcast player from this buzzsprout.com site. And then below, I just have some styles so that that stays fixed at the bottom of the page. So now that we have that player, we can actually render it somewhere in our app. So seeing as how we want this to persist across route changes, one place we could add that is in our layout for our app here. So we'll go ahead and open this layout in our completed app and do the same thing. So go ahead and import this podcast player component and then we'll render that out right below the main tag of our app here so I'll save that file and now you can see what's happened here so if we head back to the browser it's easy working just great now we have our embedded player down here so I can start playing an episode just like this and browse around the site as though I was a user I can head back to the blog list page I can you know find another post is interesting click through to that, and so on. And all the while have uninterrupted audio playback. So with that, we'll wrap things up. I hope this talk gave you a really good sense of when it might make sense to use WordPress as a headless CMS and pair it with a SvelteKit front end and some of the problems that that decoupled architecture can help solve. Thank you so much for watching.