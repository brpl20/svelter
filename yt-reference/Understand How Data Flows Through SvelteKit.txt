 Hey friends! In this one we're going to learn how data flows in SwellKit, which is confusing to a lot of people because SwellKit is this magical framework that blurs the line between backend and frontend. So we're going to talk about what each file related to routing does, we're going to understand the order in which things run, then we're going to talk about some routing, how data is pass-through routes, accessing parent layout data, we're going to talk about stores, adding custom data to requests, a bit about standalone endpoints and form actions, and at the end we're going to repeat what we learned so far by looking at an awesome Svelkit dataflow cheat sheet I made which should really help your mental model and understanding how data flows in Svelkit to help you work on your next idea. In this part we're going to talk about the files related to routing in Svelkit which you might be thinking that there's a lot and you might be overwhelmed when you're starting out you're like oh what is this plus page.ts plus server right it might look confusing but once you understand it you're going to appreciate it how genius it is because when you go to another Svelkit project if you open a folder for example with some route like post, you're going to know 100% that the data for that route is only contained in that folder. So let's start. So we have an app.html file, and I've included this because you can include some scripts here before your component mounts. So you can get, for example, the user preference from local storage. And then here you have what I refer to page endpoints, and yes, this is an endpoint because we're going to see how this works in the network tab, because just how you have a standalone endpoint, this is the data that gets fetched for your page, So Svelte creates this endpoint for the page. So let's say that you have plus page.svelte and you're always going to have a sibling page.ts or page.server.ts file which you're going to use to run a load function on the server. And you can also use page.ts to run a load function on the client. And another special thing about plus page.server.ts is that it also has form action. So you export form actions from that and we're going to look at it later. So if we go further down we can see that now we have a layout which is similar to your page swell so you can have a layout.swell then you can get the data from the layout from server.ts or .ts so you have your server and what also swellkit refers to this is universal and server load functions so universal load functions are ones that run on the server and client and your server load functions are just the ones that always run on the server right another awesome thing about data return from layouts is that the data becomes available to your child routes through export-led data in your child component pages or whatever. And then we have a standalone endpoint which is plusserver But yeah this is a standalone endpoint so you can use this to make a REST API And a standalone endpoint can return anything else right Basically the page endpoint just returns the JSON for the page in most cases but you can use a standalone endpoint to return text, JSON, XML, a stream, whatever else you want, right? And then we have hooks, which are really powerful. So hooks.server ts runs on every request and returns a response. So this is responsible for everything that happens in SvelteKit, because SvelteKit listens for everything inside this client hook, so you can even hook into the request or response and you can change it. And then you have a hooks file, which is hooks.client.ts that runs only on the client. And this one isn't that exciting because it only has one hook, which is to catch errors on the frontend, so you can send it to an error handling service or whatever. And then a honorable mention, we have the pluserror.svelte page, which is just a custom error page you can include in your SvelteKit project. Alright friends, before I continue on to show you the setup I have because I know you're going to be curious. So here I'm using a fancy console log I made, which is going to log for every route so we can know in what order things happen. And here I made a pre-component which we can look at here. So this is just my famous snippet I just made into a component so I can pass the name and value so the styling is consistent across components. And here is the log utility so it's using chalk as you can see it's nothing special. and then inside hooks since this is where everything starts we can log who is making the new request because we get everything here in the handle function so we can do event url path name so we know the request started and then we again use this log to log that it's hooks and then when it gets resolved we know that the page or resource in question is ready so it's sending the response so that's basically it for the setup and let's get started all right so let's look at the order in which things run and here i have the entire zoo in this cell kit project which you can find in the post, I've included a stagglitz example which you can just open and play around with what I have, where you can find the link to the github repository. So as always, we have to start the server, so you can pretend that this is in production or something, so you always have this running server. Okay, so what is the first thing that happens? You go to your url, right? You type in the url, and now when you press enter, you're going to make a get request. So I'm curious what you think in which order the files are going to run. My bet is that hooks is going to run first because it should, but some things might surprise you. Alright, so enough with the Suspense, let's just press Enter. This is going to fire a request which is Swell going to intercept because Swellkid is a server right And then let see what happens So I going to press Enter Now we log this ah cool So now it says new request is being made from slash which is home or root So you can see the first thing that runs is hook server TS All your server load functions run. So layout server TS, page server TS as expected. And then the universal load functions run. So layout TS, page TS. And this is really curious. And this is why you can also pass data from your server load functions to your universal load functions. And this might be more curious. Why is our layout.svelte and page.svelte running on the server? This might sound weird, right? But this is because of server-side rendering. So basically what server-side rendering is, SvelteKit needs to turn these components or what they return. It needs to get the data and then it needs to return the component as a string. And then the server is done. So we go to the client. So app.html runs. Then again, the universal load functions run because load runs on the server and the client. And then the layout is mounted. and that makes sense because layout is the parent for everything else. So it wraps everything and it makes sense that it should run first. And then after the layout is mounted, of course, the child plus page.swell component is mounted. And now when these components are mounted on the client, we need to restore the JavaScript on the page again, right? And this is what hydration is. So your component gets rendered twice. First on the server, it gets server-side rendered, and then it has to get rendered again on the client to restore the functionality. And another cool thing, if I close the terminal and open a new file, so approximately how layouts work. So basically, this is a layout, and it wraps everything, right? So you can have your component here, or we can name it page. So you have some data from the layout, like this data, which can get passed to the page again. And this is only going to render if there is no error. But when an error happens, instead of rendering your component, it's going to render the nearest plus error.swell file. So it's going to render this instead if there is an error on your page. And then when you have other nested layouts, it's like nested layout. So you have more layouts. And then again, you can have your page components inside here or whatever else you want. So this is approximately how it works if you're curious. First thing we need to do is understand how the SwellKit router works. So when you enter your URL and visit the page for the first time or you refresh the page manually, SwellKit is going to server-side render it. And then once the SwellKit app loads, it's going to load the client-side router. So you're going to get that awesome single-page application experience. So let me show you what I'm talking about. So let's pretend that you're visiting this page for the first time As we seen what happens it going to go through all of this process right And let me just clear this console and I going to clear it here so it clear what happens So when we go to the nested route it not going to refresh everything because at this point the client-side router kicked in somewhere in this code it is. It's really not important so I can clear everything. And you can also see why this is a page endpoint because we're going to see how it gets data for the page. Alright, so pay attention. When I'm going to click on this link, it's going to perform a client-side navigation. So as you can see here, a new request is being made from nested route, it runs hooks, the layout server function reruns, and as you can see, the only thing that changed, remember we already have the layout mounted, and it only needs to mount and unmount the old component and it mounts some nested route slash page dot svelte. Oh, but look at this, how curious is this? Here is the endpoint actually. Data JSON cell kit. So you can see here at the headers, and we look at the payload and the preview, here is all of the data for your page. So basically every route has this. If I go here, I can just do this, and I can say double underscore data JSON. And you're going to see this for every route. How awesome is this? And this is why this is a page endpoint. This was also named a shadow endpoint in the past. What's also really awesome is that SwellKit tucks this data in the page source so it can reuse it. So it doesn't run, it's smart enough to only rerun the load function when it needs to. So if you go to home, and if you go to view page source, and if you scroll to the bottom you can see here is the special secret sauce from Svelkit you can see here it is in the data so this is what Svelkit knows is there and you can reuse it for page navigation so it's really smart to only run load functions when it has to and also of course you're using client-side navigation but if a crawler like google or the gold bing visits you on each request they make they're going to get the service side render page so you're going to get great seo and this means that your site is also initially going to work without javascript But I want to emphasize that the point is not that your site should work without JavaScript, but before JavaScript, because it's going to be more resilient, and then when the JavaScript loads, you can use it for what it was intended, to enhance the user experience. Alright friends, so let's see how beautifully data weaves through an entire SvelteKit application. So we already know the order these things are running, so it's the layout server TS, then it's layout TS, page server TS, then we're passing some data to page TS. Of course, in 99% of cases, when you have a route, you're going to have one plus page svelte file and you're going to have one plus page .ts or .server file, right? And you're not going to have all of these files together.

 They do work together. You can have all these files in one place and they do interact with each other. So it's important to understand how that works. So as we already said, whatever you return from layout is going to be available to plus layout.swell, but also to all the other child routes. So let's return some data. I can say return, and then I'm going to return a number. I'm going to say A. And now as you can see here, we made the request. And now I'm inside the source route. So you can see here, the homepage receives this data. so we get a and then the page the data store updates which also gets this data all right so you might be wondering if you go to layout ts what now so what would happen if we return something from here let me save it and now nothing is happening so what is going on right and we can return the same pro so you can say a 2 and we can override it and the last load function that runs is always going to win all right but what if you had a layout plus 3 ts file and you want to pass the data to the universal load function the load function has a useful argument you can use which is data so we can use data and now let me just log it so you can show that i'm not lying to you so you can see here it logs in and the beautiful thing how we log things is that you can see where it actually happens so when this gets ran you can see here is our log which is really beautiful and you can also see it here all right so we get this data and returning to so you can do whatever you want with this data right now, but I'm just going to spread it like this, so I'm going to go here, I can say data, and I can name this prop B, and now I'm going to save it, and it's going to return A1 and B2. So now we're passing data like a river through CellKit, how beautiful is that? So let's look at what happens next, so we go to page.serverts, and this is already going to get the data, so this isn't going to get the same result as before, but you can override the data you had so far, so you can say A, 2 or whatever, and it's going to override it. So the data is always going to get passed from the layout. And you might be thinking we could use data here, but data doesn't exist for server load functions, right? And it's always passed, so we can just include whatever else we have here, so I can say C, free, then I'm going to update everything, so you can see the data is passed from the layout, so we have A, B and C. And then again, if we go to the UniversalLoad function here, we can overwrite everything so far so for example we can say a10 b20 c30 now we can save it and everything is overridden Or I can get the data in a universal function I can spread everything I got so far, even from the server.ts file, right? So if I save this, you can see we get a, b, c. Otherwise, we wouldn't get the data from the page server.ts. So now if I even spread that and then I can include the last one, It's going to be d4. So now this is updated for the data prop inside our home route and the page store also got updated. So you're already familiar how page.svelte and layout.svelte files have access to all the data from parent load functions, but you might want to get data inside the load function from a parent layout load function. And this is confusing when you read the docs because they don't make it upfront clear that this only gets the data from layout load functions. And of course, this is going to be a trivial example But imagine if you're deeper and you need to get data from a parent layout load function. So we're going to get this using this export. Here we're going to say data A plus data B equals to data A plus data B. So let's see how this looks like. Inside page.server.ts file is going to get the data from plus layout server TS. And you can say data await parent. And inside the universal function this is going to get the data from the universal layout. So you can also say data await parent. So what do you expect here to be logged? So we already know that we return from the layout server TS1. So this should be 1 or A, which is 1. And then this should be B, which is 2. So let me save this and it should rerun this page. So as you can see here from the layout TS, it returns A1. And then again, since we passed it down to the universal load function, it logs A and 2. So now you can do whatever you want with this data. But in this case, we're just going to add these two numbers together, which is a trivial example of course but it's a really powerful concept. SwellKit exposes a lot of useful modules which are just stores if you look at the documentation. For modules you can see a lot of them inside here but the one we've been using this entire time was the page store from app.stores. And this can be used for anything, to customize your error page, to send data from a child to a layout for SEO so you can get the title, description and etc. So, to show you this example, I have an error route here. So this is a page that says Error and here in the Universal Load function there is no Load function I just going to throw an error And at the root I have this pluserror file so this is going to get picked up as you can see here is the error and then I going to log the entire page store And if you didn't know, if you're inside a Svelte component and want to subscribe to the store, you can use Svelte Syntactic Sugar, so you can use the dollar sign, which is going to subscribe to the store when the component mounts, and it's going to unsubscribe from the store when it gets destroyed. Alright, so let's do one of my favorite things, cause things to fail. Okay, so we can go to errors, and remember as I said, if you have an error on the page, instead of your component for the page rendering, it's going to render the nearest plus error.svelte component. Another cool thing is that it triggered the hooks client TS. As I told you before, it's not that exciting just for error logging. As you can see, mounted slash error slash plus page.svelte. As you can see, here is the entire page store. So you have params, route, which has the ID, status, URL, form data, and the data itself, which gets updated when you run a load function for a page. So I see people often ask this question, they want to return some data from the server, and of course you can't use stores on the server, I mean you can, but then it's just going to exist on the server, because the server is separate from your frontend. A store on the frontend is just an object in memory, so when you end your session, that store is gone, and the server really doesn't know about that store. And it's also really bad to use a store if you have users, so you're going to store global data for that user, but SwellKit has an awesome section in documentation about state management and they tell you to use the page store instead to pass data to your routes instead of using a store but if you want to use a store you can use a store with context so let me just go to this example stores as you can see here i'm just fetching some data from the endpoint so i'm just going to get a different name each time as you can see here it is if i go here to the layout i just have some users and then i can return a random user so here inside the layout we can use a store so we can say hey const user writable and now we need to make it reactive so we can use this reactive declaration this isn't a store if you're confused this is a reactive declaration in svelte because it's always a dollar sign followed by a colon and then whatever is inside here is going to become a dependency so you can even make it shorter like this on one line so user set so we're doing a manual updating of the store using the set method So whenever data user updates, which is when the load function is going to rerun, it's going to update the store. And now you can use Swell context API which SwellKit itself uses for all of these stores So it unique on every page So you can set the context user and now when you have this anywhere inside your route you can get the context in the user so now you set the context for this entire route stores or whatever children you have and etc you can get the user by saying get context user and then you can subscribe to the store because you set the store in the context right and then you can say dot name and then it's going to output the name so let's look at this quickly in the Svelte docs. We can go here and let's just search for it. So we can say state management. So let's open that. So this is what Sveltec tells you. Avoid shared state on the server. So don't define a variable like this because a server process is long running. In a browser when you close your tab that's gone. Boom. The memory is wiped. But the server if it's running constantly is going to store your user here and then everyone is going to have access to this. And then it says no side effects in load. So again, it tells you you shouldn't return data inside an endpoint and set it inside a Svelte store because this really isn't great. And it even says, for example, you might be tempted to write to a story start a load function so you can use the store value on components. As with the previous example, it puts one user's information in a place that is shared by all users. So Silke tells you, hey, just return the data or use the page store. Of course, if you're not using server-side rendering, it also mentions here that this isn't as important, but in general it's a good practice. And then here's the same example I showed using stores with context. And yeah, that's basically it. Let's talk about something really powerful, which is adding custom data to a request. So you might have seen this if you used any authentication library, but basically inside your hook server TS, since this runs on every request, you can use the handle function to validate a user. But you can also do many different things. You can for example listen for a post request, so maybe that's a form, and now you can parse the form data and return it to that endpoint. You can do all sorts of crazy things, but let me show you a basic example. So inside of hooks I'm setting the event locales to a secret which is going to be banana, and if you're using TypeScript you're going to go to app.dts and you're going to update the type for local so I set it to secret which is a string, and now I have this route here which is going to be locals, and inside its server load function we're going to get locals as an argument here, so now we can check if locals.secret isn't equal to a banana, we're going to redirect the user to home, otherwise we're going to return the information. And also be extremely careful that you're not returning sensitive information from the hooks like the user's password. Even if you're doing authentication, you only send back the user information.

 this doesn't work so we can save this and now we can go to locals as you can see there's a request from locals it runs hook server ts and now it runs this so it was already redirected to home but now let's input the banana so now when we go to locals it should show the page and also now again we get the request hook server ts and then we see everything we have so again here we have the data since we're passing this from the layout we have access in the child route to this layout data. So you can see here is our secret banana. Alright, so far I haven't said anything about standalone endpoints, and that's because there's really nothing special about this. You can create a standalone endpoint which can return data or whatever else you want. You can get the data inside your universal or server load function. And another important thing to notice is that even if you're using server-side rendering, you can also use fetch in your components or using client-side rendering if that's something you have to do. But for completion's sake, I made this API endpoint called secret, so I'm ready to expose our secret to the world. Remember how I told you that you can get locals everywhere? So again, here is the handler get function inside a standalone endpoint, so we can get the locals, and now we can just return a response that said locals secret. So I'm going to go here, and I'm going to say API secret, and let's see what happens. So a new request has been made from slash API slash secret. As you can see, the hooks run, and then the plus server TS file runs And again nothing special here If you look at the network tab you can see here you get a beautiful banana And this is just by default returning text since we didn specify that it JSON or anything else. Standalone endpoints are a perfect segue into form actions. So if you want to work with forms, you need an endpoint. You at least need a GET and POST HTTP request method, right? So you can use a standalone endpoint for all of the HTTP request methods like GET, POST, PATCH, PUT, and DELETE. But instead, if you want to send data from the browser to the server, form actions are way easier. And let me show you if you haven't used form actions. So this is just regular HTML, right? Here we're using a form, we're saying an action, hey, this should go to lock it, which is just a query param, this isn't anything magical, right? And then we can overwrite it, we can say form action if you want the user to register instead. And that's basically it, there's no fetch here in JavaScript and etc. And this works without JavaScript, which is also great, but you can also use the enhance Svelte action imported from SvelteKit so now it's going to use JavaScript to progressively enhance the form. And then inside your server load function you can see here you can have a load function, same as before, but you can now also export an actions object. So you can map those query params, when SvelteKit sees this it's going to say okay this is a method I'm going to run so you can say login or register and then you're going to see how it works. And I'm also logging things here the same as before. So let's see what happens when you submit a form. So I can say test1234 and now I going to press login Alright so let see New request is being made from slash actions Now the hooks are going to run Now the login action is going to run As I told you this is just a URL How beautiful is this? Slash actions, query parameter. And because it uses this slash, SwellKit knows that this should be a method. And now because you're using progressive enhancement and JavaScript, SwellKit is going to invalidate the data on the page because you submit the form. And now again, it's going to make a request to slash actions. It's going to run hooks again. It's going to run slash form slash page server ts, the load function is going to rerun it, right? And then it's also going to rerun the load function inside the layout and it's ready. As you can see, it works beautifully. And also don't sweat the details because this is a lot to take in at once. The important thing to take away from this is that you have a general idea how data flows in SwellKit to help you build your next idea. Alright friends, that's it. I hope that wasn't too overwhelming. And you can always play around with the example, but also make this useful cheat sheet how data flows in SwellKit. So let's repeat what we learned. First you go to the browser and you start typing the address of your site, which is going to be the request. And now when you press enter, this is going to fire off a getHTP request, which the SwellKit server is going to listen to. And the first page visit is going to use server-side rendering. So on the server, first hooks are going to run the request. Then all your server load functions are going to run. Then your universal load functions are going to run. The components are also going to run on the server because we need to return a string from the server. and you can also get the data from Universal and ServerLoad function using Server rendering but you can also still fetch on the client inside your component using client side rendering if that something you have to do And then when we're done on the server on the client, you get AppHTML, then you get your Universal Load Functions because you can run load functions in the browser again, and then your page components are going to mount which is layout and page. And at this point in your app, the SwellKit Client Side Router is going to load, so on the next navigation, when you go back here and it makes a request. is going to do all of this again it's not going to use server-side rendering again but client-side navigation and we also learned that inside the hook server ts file you have this powerful event locals object which is available in server load functions and server ts handler so standalone endpoints and we also learned that a parent page can access data from a child route using the page store and we also learned that universal and server load functions can access parent layout data with a wait parent. And the most important thing, if you have more than one load function for the page, the last load function is always going to win. Alright friends, so I hope that cleared things up. If you like what you've seen, don't forget to like and subscribe. You can support me on Patreon and don't forget to join the Discord. Thank you for watching and catch you in the next one. Peace! Thank you.