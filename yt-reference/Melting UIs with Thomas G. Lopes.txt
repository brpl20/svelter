 Hey, welcome back to another episode of Svelte Radio. it's that time of the week again where we talk to you about svelte that was a really weird intro i'm joined by my co-hosts britney and anthony hello oh hey what's up what have you been up to nothing we're quiet this week yeah very very quiet anthony in particular just staring up at the ceiling it's like you asked me what's up i'm looking just checking i mean nothing oh terrible joke i know but i'm allowed now because my dad and it's a dad joke but no i mean it's been it's been a tough week actually it's been a really tough week so maybe i'm just exhausted i'm not sure but yeah it's all go again now it's all go yeah all right cool cool that's good glad to have you back all right so today we are joined by another guest it's thomas g lopez welcome Thank you. So you are the creator of a pretty popular UI library in the Svelte ecosystem, right? It's called Melt UI, hence the title, Melting UIs. And I cannot also see now that I've misspelled your name in the title. Sorry about that. That's right. So, Thomas, you recently became a Svelte ambassador as well, right? Yeah, I'm so happy about it. I was so surprised. I was rooting for it. I actually was talking to Hunter, who is also a Svelte ambassador for a long time. Like, oh, I would love to be a Svelte ambassador and stuff like that. But yeah, and then it just popped in. Oh, that's so awesome. We're so glad to have you. You've added such great contributions to the community. Yeah. Thank you. Let talk a bit about Melt UI and maybe actually before we do that why don you introduce yourself What do you do Are you a software developer Probably Why are you here Why are you on the podcast I just popped in here and they let me I found a link It's like the same as ambassadors, right? Just find a link and there you go. Exactly. I described invite link, a secret one. So yeah, my name is Thomas. I'm a front-end developer working at AppRite. I've been coding for a while now, seven years maybe. but my front-end experience only started in college when it was more or less 18 years and yeah i've been coding with svelte for a while now but it only became my full stack for everything like for work and hobby projects too when i joined that point but already was doing hobby projects with svelte before that i've always been keen on it i even wrote a portfolio with separate ones. Wow. So yeah. How did you find Svelte? Did you originally use something, some other framework? Yeah. My first framework was Vue, but then for work reasons, I moved on to React. But then like, I think maybe looking at Stack Overflow surveys or like a fire ship video, or I don't know, like Svelte is always like the popular kid in the block, right? Everyone loves to talk about Svelte. So I think I just tried it out once and I really, really liked it. Awesome. Now, I was just saying that you rode the hype wave. I think it's interesting because, yeah, Svelte gets a lot of mentions, doesn't it? I think I see it mentioned a lot. And I always thought it was unpopular, like no one really used it. Then one day, suddenly everyone mentions it at every opportunity, which is weird. Yeah, it really gets the fame of the popular, the loved framework, kind of like REST is the loved language. I'm not sure nowadays, but it's not just like the loved framework for JavaScript ecosystem. Yeah, I think a few people like got it from different avenues. Like I heard it from Syntax, listening to Syntax and Scott, like talking about it all the time. And then the surveys kind of picked it up and then the developers started like using it and liking it. And so each survey like had it popular and then that brought in more people. and so like we have different waves of people coming in but it's interesting like how people like found it i was actually going to mention that about the waves thing i feel like you had a couple of people like the very early adopters like probably anthony you were probably a very early adopter using like svelte 2 svelte 1 svelte 1 even like goodness what did that even look like nobody knows because it's gone in the ether double braces everywhere i think i think it might be svelte pre-1 effect to be honest i can't remember what it was but it was lots of double braces it looked kind of like svelte 2 what was it self called before it was felt reactive was it or was it there was reactive which was different to Svelte. It was Rich Harris, I guess, just exploring Reactivity within a framework. And then I think it got launched around the same time as React first came out. And React got that popular momentum behind it because of Facebook. And so even though it had some great ideas, it kind of disappeared into oblivion, really. And then Svelte was like, okay, but what if we did this? And the API became a bit more honed. it kind of looked a lot like Vue back in the day. Vue was already there as like prior art. So it intentionally looked a lot like Vue because Vue had some good ideas. And that's when that, so Svelte then got popularity around the point of three, really. But two as well, the 10 out of two. That's when I started using it for sure. I remember the Svelte 3 hacker news post. That's probably how I found it. Really? Wow. Yeah. In my head, that's the first wave, but it's probably the second in a sense i feel like it's it trickled in before that and then you got the svelte free release because it changed so much and it was so much better developer experience wise right there's also the rethinking reactivity video which showcases a lot of svelte free syntax which actually pulled me back in like i had tried svelte used a little bit i pulled back into react because of work and stuff like that but one day i saw that video i was like i really should use it again yeah yeah the funny thing is rich harris actually comments about a company a brazilian company called stone which used uh svelte internally and i worked there and i didn't know about that it was actually they used it it powers the you know the handheld things the pls yeah yeah yeah how was that it's crazy just because it was low overheads yeah do you know the funny thing though is they had that insight to use something more performance for their pos machines but then they were still using like react native that embed web views or their mobile apps with low 3g coverage and stuff like that Sounds like a lot of people didn enjoy that experience like with bad connections and stuff Exactly. I'm not sure how it is today. It's been a while since it's been there. Maybe it's changed since then. Yeah, I think the guy who did it at Stone, I think he left. So maybe the same impetus wasn't there to like roll out, start everything else as well. I don't know. Yeah, but it's also a really big company. it was like when i worked there was like 5 000 people or something like that wow so to roll out that in company-wide it takes some time right yeah absolutely absolutely yeah and then after the svelte 3 wave we had the i think svelte kit was probably next but that took a couple of years probably before before we get that got that next infusion of people well then it got announced and then it took two years to get it out even though it's gonna be soon i guess i guess svelte SvelteKit was two waves then, the announcement and the release. Yeah, maybe two waves. What's important about SvelteKit too is like, at least for me, when launch was like, okay, now I can actually use SvelteKit and Svelte in general in production. Like, of course, you could use Svelte. And since everyone was doing server-side rendering and stuff like that, it would be really weird if you didn't use it. It would also be weird if you use something that's not like ready for release, like 1.0. Yeah. ready so when stuff could launch it was like okay south is now ready let's say yeah i think the way of svelte was you say it got popular around three and i think the video helped but i think also for me when you were writing svelte 2 because it had like that embedded like you exported a graph by the component like a hash with stuff in it like computed block and things and it made you have to do a lot of gymnastics in order to get variables to other parts of the object or part of the component. So I think that put people off generally. The same reason view changed in the end, and it was the kind of hooks idea that came from React that made Rich and others think, well, hang on, why don't we just put state at the top level? And at that point, it makes more sense because if it's the top level that's not embedded in an object, it means you can access it as you would any global variable. And that, I think that was a massive shift. Then everything became simpler. And people again didn't like it because it's less obvious what was reactive and what wasn't, what was confused and what wasn't. But when they realized it's like, oh, yeah, that's much better. Yeah. And then, of course, the latest thing, runes. Runes.

 talk a bit about today but probably more towards the the second half but yeah let's get into to what you you've been working on thomas so we i think the first time i saw one of your projects was when you submitted the radix svelte package to the hackathon last last year this year earlier this year this year yeah yeah time doesn't fly i guess so what was that what was radix svelte so radix svelte came from a popular react project called radix ui which is a headless library and for those of you who aren't familiar with what headless means it's just like components that don't come up with their own markup or or styling meaning they are completely customizable They're made to be wrapped into your product like completely into your own design system. It was something I was really missing in the Svelte ecosystem. Like there were some libraries that were headless, but they either were missing some components or too much actively to maintain, or they just didn't have that DX or the features that Radix had. So I tried to port it to Svelte. That's what Radix Svelte was. Yeah, and I don't remember the exact like which spot you got on, but you did win some prize, right? Yeah, I think I went, got fourth place, if I'm not mistaken, for best library. Yeah. Yeah. But you've since abandoned Radixfeld, right? Well, yeah, that might be a bit harsh, but so you started working. That broke my heart. But you started working on something that I hopefully think that, hopefully you think it's better, the new project. Oh, yeah. Yeah. Yeah, for sure. So then I started working on MeltUI. It was actually a bit funny, just for a bit of context. RedixFault came out, and then Shetzy and Svelte also came out. Hunter talked with me. He came up with that product, which is also a part of an existing text product. It's RedixUI, but we built styles for the ones, right? You can modify them, but it's easier to get started with, basically. And then I talked to Hunter like, hey, I don't think RedixFault is working out too much. it's when I started Not Your Eye. Yeah. What kind of issues did you run into? Like Basically working how can I explain this There were some limitations with the way I was doing things like component that made it a bit harder to style and customize the components. One of them is due to how you style components in Svelte. For example, let's say you want to style a component in Svelte. So we have scope styles. That's how you would style elements. But to pass in scope styles to a child component, you can't do that. You can using wrappers and some hacks and stuff like that, but you have to use a global selector. And I get why it's done. It's a well-designed limitation, but it's a limitation nonetheless. And I wanted to make something really customizable. So there was that. And there was also another thing. So Redix allows you to change the element that's actually rendered. So let's say you have a tab button and you want to change it. I don't want it to be a button. I want it to be an anchor tag, right? The original Redix, you just put a prop as child. Then whatever you pass in that component is what's going to be actually rendered. But to do that in Svelte, it's a little bit less ergonomic. You would have to pass in slot props and stuff like that and actions. It would be a little bit too much. And I felt like I was battling against Svelte framework. I was just copying what Redix had done in React using components and I was battling against what Svelte was made to do. Melt gets a different approach. Instead, we have, instead of shipping components, we ship what I call builders. So builders are just a function and they return for each element that a component is structured into, a store and an action. So that's a little bit more understandable. Let's say you have tabs, right? A tab component, so you have a bunch of buttons and the content associated to a button. Tab one, content one. Button two, content two, and so on and so forth. So we would ship a button store and a content store, and also a button action and a content action. The store contains the attributes. The action contains any interactivity, any scripting, any event listeners. And you just attach that to an element. Why? Since I'm working with elements and not components, I can do whatever I want with them. I can style them using scope styles I can change what element I want to use It much more flexible doing it that way And I can create my own components with my builders and now it component builders It's more direct interactivity with the DOM rather than having that component scoping with the Svelte markup, right? Exactly. Well, use the platform. Yeah. And if anybody wants more detail on any of that, I had Thomas on the Sirens stream and he showed how Radix worked and then how Melt UI works. If you want to actually see any of that, like go through the steps, it's on YouTube on the Sirens Melt UI stream. Yeah. I also did a presentation on Svelte London, where I created the builder from scratch without importing any dependencies and stuff like that, only using Svelte. to see how a really simple builder can be done. It's not that complex at all. It actually made it easier to ship out new builders than it was creating new components in Redix Svelte. Does this mean that Svelte doesn't know about the DOM updates that have happened because you're manipulating the DOM directly or are I misunderstood? I mean, since I'm using Svelte actions, they kind of still know about the DOM updates and stuff like that. I'm still using, now it's still dependent. on Svelte stuff. So I even use lifecycle methods, which I want to remove. But I use unmount and undestroy and all that stuff too on the components. Why I want to remove them is just because so you can call the builders outside the component if you want. But yeah. Like when it's created, it's using the actual Svelte stores in action. So Svelte is still tracking that stuff. It's just directly interacting with the DOM through Svelte. And I kind of need to use... So when I pass in a store to a component, I'm not just getting the reference to the component, something like that. I'm spreading the store value with that dollar syntax and whatnot. Right. So yeah, which is actually, it's an interesting thing. Before Melt was using, I really didn't want to have to pass in spread attributes and an action. They are two separate things. So at first I did this really hacky thing where I would just pass in the store. I would pass in an ID or some reference. And then internally I would use that ID to document And then use the event listeners and stuff like that using tick self and stuff like that to make sure the element was created before. It was really hacky and eventually I found a bug where basically you sometimes wouldn't get the reference to that element or the events wouldn't be attached. They would always have to be reattached. So if you ran it in Bytest, you'd have to use sleep. every time something changed. We would have to wait to milliseconds. I was like, yeah, this is not working. Let's use actions. Yeah. Actions are nice. I really like them. So what kind of features can one expect from one of these builders? So I'm looking at the website here and you have a ton of builders. So you have an accordion, an avatar, checkbox. Why would you use a builder for a checkbox rather than just an input regular HTML element, for example? A lot of the builders replicate, as you said, like normal HTML elements. But the thing is, HTML elements are notoriously hard to style some of them. For example, a select. A select is one of the most requested things in a headless library, especially because you can't currently style a select really well. You can style the box, but you can style the options themselves, right? So with Melt, well, they have the same functionality as a normal select mostly, but now you can style them. But it's not only that, you could try and build a select yourself, which is styleable. The thing is, it's missing a lot of accessibility concerns, which are not easy to build out from scratch and keyboard navigation and all that. I have a question about like native selects, like how do these translate to different platforms? Like if you're using them on iOS or like a mobile device, how does that select box? Does it just look the same as you've styled it or like a date picker, for example, if you use a date picker, like does that use the native date picker? Like how can you get around that stuff? It depends. You can change it yourself if you want. For example, what you could do since Melt is really flexible is, let's say that in desktop, I want to use the native select, not the native select, sorry, I want to use Melt Select style on my own.

 But on mobile, so that the select doesn't overflow the screen, even though we do have helpers for that, or I don't know, you really like iOS's and Android's native select options, well, you can change that. You could do with CSS selectors, you could just change what is being rendered. You could also just not apply the melt action when a certain break point is being passed. That's something you could do. Okay. But the benefits too of using actual divs and stuff like that rather than selects is sometimes even styling just the select box between different browsers and operating systems is a bit hard. They use different properties, some properties don't work in a certain browser and stuff like that. While styling a div is really easy. Styling a div and making it look the same in different operating systems and stuff like that is much easier. I say a div, but it could be any element. Would that be a selector from Melt or would that be an if block like in your spell markup to use a native select box though? Can Melt actually style a native select box? I guess that's where I'm asking, is it a native select or is it divs? No, normally we use like for select, it's a button. And then the menu itself, the options are just tips. But the actual clickable option should be a button, but you can use it if you want. So I think you would have to do an if, like an if mobile something in the Svelte markup for that. Yeah, or you could also just use CSS selectors, like use display none after a certain break point or something like that. You don't need to use ifs to detect the size. That's why it's even more progressive enhancement friendly. It's something I actually want to do too, progressive enhancement examples, meaning I do something like if browser, like if JavaScript is enabled, then I show the multi-wide component. Otherwise, I just use the native select. That's something you can do. I feel like you could use the action for that. and just attach the action to the outermost. So in example of select, you would have, I don't remember the syntax off the top of my head, but it's like it's a select and then there's options inside. Yeah. Yeah, option element, right? So you would put the action on the actual select one and then you would just replace that with whatever Yeah we could do that We do some similar stuff for example in avatar You have an avatar component which has a fallback and whenever the image is loaded, we just hide the fallback. Yeah, we could do that, actually. It's a good idea. Because then it would work, even if JavaScript was disabled, right? You would still have the select kind of work there. We would just require you to actually create a select element in your markup and stuff like that, and duplicate the options. because the way options work out, it's a little bit different. We don't use that native option element, right? You have to duplicate markup a little bit, which is the downside. Yeah. That's also a downside if you do it the other way. If you did the if mobile in the markup, you would also have to duplicate markup. Exactly. Yeah. I really enjoy progressive enhancement and SSR stuff, doing stuff without JavaScript. It's very exciting to me. And it's one of the things that breaks my heart working in the mouth because I know that all of them require JavaScript. And I really, really do like progressive enhancement, too. I love doing experiments with it. I did a Reddit call, which is fully non-JavaScript friendly. It works fully with the server. So it breaks my heart a little bit, but I do want to address that at some point. It's sad to me that a lot of the elements that we have to create need JavaScript to make them fully accessible. but we are getting there with HTML elements. They've added a lot of HTML elements and OpenUI is doing a lot to come and add more elements that are actually native to the browser that are fully accessible too. Yeah, I'm pretty excited about the popover API, the select list. I don't remember what. Yeah, I was just going to mention it. Yeah, some really exciting stuff is coming up. There's dialogue now. We have lots of things that we didn't have just a couple years ago. There's a search element as well. There's a search element? Did you say search? I did, yeah. Isn't input search? Hasn't that been around? Like a combo box? No, so it's really just a semantic element. Doesn't really do anything. It just tells the browser that this is for search. But would it be input search, but it just is a search? No, it's just search. What is it? It's just an element. But inside of that, you would put a form and stuff. I guess it means you can interact with control K or command K or whatever So you would have to put a form and then a search and then an input I don remember the exact order I'm going to have to look that up after this because I have to make a global search bar. That's something I want to do with mounts. I was going to say that the reason these things are exciting is because they're boring. If that makes sense. It's great. I think it's great. this stuff is not boring to me this is like literally my entire day like i could just talk about this all day i mean boring in terms of something that is not fancy rather than oh yeah not interesting yes yeah that's true yeah it's really an infrastructure like a really low level thing and there's lots of different ways to do this stuff and so it's kind of complex problems that you have to figure out what's the best way, what's the best API, what's the most developer friendly. Like it's, it's really kind of difficult to figure out like what's going to be the most or the, I guess the best DX and then also be the most performant and just the nicest to work with. It avoids reinventing the wheel and it, it avoids bike shedding, I think. And that's, That's two massive points of value for me. Imagine how many hours people have spent building these things over and over and over and over again, just because it doesn't exist. There's Redix UI, Zed, Melt, React, ARIA, ARIA, Kit. I can go on. That is literally the point of OpenUI. That's what they're trying to solve, is they're building components for the web so that people don't have to keep doing these design systems over and over and over again. So you have native elements that you can just use and style how you want. And they are headless, so you can just style them to your heart's desire. But you have accessible native elements that just work and are styleable. Yeah. The thing is that we always... The only bad part, kind of, like, of the web in general, is, like, things on the web that are native need to be backwards compatible. So if, I don't know, someone shipped the dialog element and said, oops, maybe this shouldn't be that way. It is now. So there will always be stuff on top of it. But yeah of course having native elements there that are much easier than hey you need to install a packet and you need to learn how to use it And maybe get some bandwidth or something like that Yeah it obviously easier And I think OpenUI is a fantastic thing I would much rather have all of these as native elements so that I wouldn't have to create melt. And I think there's always going to be other UI libraries because people want choices for styles and they want easy components to bring in and style their own thing. So there's always going to be a million of those, but to have the native elements without the JavaScript is the goal, right? For sure. Of course. Yeah. I mean, if we had everything working natively, we would maybe have 10 million different style. Instead of me doing Malta as a Havas library, I would do like a styled library instead. You would be helping Hunter with Shadzian or making more like styles for Shadzian. Exactly, exactly. I do like my CSS. Speaking of Shadzian, so that uses Mount UI, right? Under the hood? Yeah, now it does. You do Stratix, but then it's refactored to use Mount. Maybe we should specify Shadzian Svelte because Shadzian started as React library and that's by Vercel, but Shadzian Svelte is not directly affiliated with that. And I know this is a Svelte radio podcast, but we should specify that just to clarify. It's very easy to get people to like, you said this, but then take it completely out of context. Yep. Classic. But yeah, ShadCN is built with NodeUI. And when I started NodeUI, I talked to people like, hey, I want to do about another thing, but I still want ShadCN Svelte to work out. So I'm going to try and have all the components Redix felt in to melt. It's still not a thing, but almost all of the components that you have in Redix, you have in melt, they're still missing like two or three, I don't know. So you two are just collaborating and working together, kind of building both libraries to kind of help build on to the other one, essentially. Exactly, exactly. I'm not working too much inside the ends felt. Mostly sometimes Hunter, like ask me for some feedback or something like that. But now to why he contributes a lot. He's been working a lot on the date picker, which is super hard. Yeah. Because time zones, locales, accessibility, he gets the really frustrating components. He worked on them almost.

 all the menu components too. And I'm just there doing tabs, which I love. Yeah. And combo box. I feel like Anthony has issues with the time zones. I do. I have issues with many things, time zones and date pickers and everything else. We built our own a long time ago, and we're now slowly replacing it with a native date component. To be fair, we built it because I think Safari had a 13-year-old bug where the date picker wouldn't render. It's just 13 years. just 13 years, you know, get to it. Oh my goodness. Did Jen Simmons finally get it fixed? I believe it got fixed, yeah. I think it probably was that emphatic from her, but yeah, so now we can get back to using native ones again and be happy, as long as they break it again. I swear, as soon as they hired her, Safari just took off like a rabbit with everything. Like a flying turd. Yeah, Mozilla needs to hire someone for Firefox because Yeah. I love Firefox. I know. I still use it. I'm using it now, in fact. Yeah. I'm now back to it. That tree tab extension. If tree style tabs doesn't work, try Panorama Group. It's cool too. I just wish it would collapse. That's the only thing I wish it would do is collapse and expand. Then tree style tabs works for you. Okay. Do you have a workflow that you use to follow, like, if you're watching Shad I've seen libraries for updates. Do you have a workflow for watching updates on that library? And when updates happen, how do you track that? So to be honest, Melt is more concerned with the Radix UI side of things, and they don't add components as frequently. They are working on the foreign components as a better. But yeah, they do things a little bit more slowly. They actually are focusing a lot on Redix Teams, which is kind of like Redix but Teams as well. Yeah. So it's not something that concerns me too much in that sense. Yeah, because it's the other way. Yeah. And ShedCN South sometimes, yeah, they have some components that are not in Redix. They created their own ones. For example, the combo box one. Like ShedCN South has an autocomplete component, but Redix doesn't have an autocomplete one. And the way that ShadCN the original one has the autocomplete it different actually Normally a combo box is an input and when you click on that input it opens a bunch of options So a mix between a select You write it and the options get filtered The way ShadCN works, it's not that way. It's a button which opens a menu that has an input and the options. So the input is actually contained in the menu, which is weird. And I know that, yeah, it's different. It's actually pretty. It's really pretty. But if you look at the Y-Area examples and patterns for combo blocks... Our filters at work, I think that's how they work. We have an accordion that comes down and then we have a search input and then it filters a list. That's fine. I think that's fine. I think that's fine. Probably. But normally... Sounds confident. I'm not... Even though I'm doing accessible library, I'm still learning. Accessibility is really hard and nuanced, and there are thousands of people who know much more about accessibility than I do. I'm really actually looking forward to a course by Sarah, and I don't know how to pronounce her last name. Oh, Sudan. Yeah, exactly. And she's working on an accessibility course that's going to go out this month. I'm really hyped for it because I really want to grab it. People who are doing, I think it's on early preview for some people, and they're saying really good stuff about it. which I'm just trying my best to learn accessibility stuff because it's hard. Even though there are conventions, sometimes conventions aren't super well-defined in some places too. There's nuance. It's not like a strict science. I'm going to shout out Ben Myers too. I'm actually wearing one of his shirts, HTML shirt, but he's also big into accessibility. He works for Microsoft on the accessibility team there and puts out a lot of good content on accessibility. Yeah, there are a lot of really good accessibility content creators who write tons of articles. Some components which look simple are really hard to build. And think about two tips. Yeah, I mean, accessibility is not easy. So the course is called Practical Accessibility. Exactly. It's going to be linked in the show notes. All right, let's talk a bit about these new magical things that are coming in Svelte 5. Runes. Runes. Runes, yeah. Nice So you pretty excited about runes right It simplifies your work immensely So much that he could not take his vacation Like he was on vacation talking in the threads. One day I was like, Thomas, there's a beautiful landscape stop looking at this guard. Focus. But then I was at the hotel. I need to write a Twitter thread about my rooms are great. I mean, I'm at the hotel at night. It's fine. Yeah, that's true. You can't see anything outside if it's dark. Exactly. Exactly. What is it with runes that are particularly exciting for you? Maybe actually we could give a short intro to runes. Does anyone want to give it a try? What are runes? Runes are magical symbols that are going to increase the developer experience and fine-grained reactivity of Svelte. Is that you? No, I did not type anything. Do we want to know what the actual runes are? Certainly. Runes are compiler hints for Svelte. So that Svelte can figure out what should be and shouldn't be reactive. They also work in JavaScript and TypeScript files. They're not just for the compiler, right? Yeah. And then they're kind of compiler markers. They're not even methods that you import or anything. There was a discussion about this exact topic today, which is why I was waiting for everybody else to kind of say what they were first. But I think, yeah, basically that's it. The best description probably is a compiler symbol. there's another library that wants to use the same word for a slightly different concept and i'm wondering like is it is it the right thing to do is it not the right thing to do but yeah so we'll see how that pans out signals well so signals are different again aren't they signals are under the hood now so signals are something that the browser has or browser supports i think oh not yet not yet not yet so they're not it's not yet native but it's kind of planned like it's a potential upcoming thing are the signals also coming as a browser pr are only observables i think i said i read somewhere on on twitter that there were library maintainers talking about signals with twitter is the source of truth well i mean these these people i give them a high i know reliability score or what it whatever you call it giving you crap yeah it did sound kind of sketchy right oh i read on twitter yeah but if you said oh no rich Harris tweeted about it. Okay, that's more credible. Yeah, I don't remember who it was. I don't remember who it was. They have loads of numbers for the name. I think one thing that I've seen a lot in... So there's a runes channel on the Svelte Discord now, and I see it a lot, and people think that the runes are functions. They just look like functions, but they're not, which is I guess... It's not super clear that they're not functions. I wonder if there was... some other way to make it clear? At the same time, like, spelt already, spelt as a delicate compromise between it needs to be valid JavaScript syntax because of tooling. At the same time, we want this to mean something else. For example, you would have $sign, two dots, something, like a variable equals something. That actually translates to a let assignment and then a reactive statement, right? Something like that. So, The difference here is though that no one uses labels. Everyone uses functions is what I would say. I agree. I agree. I'm not the kind of person that needs to know like what everything is doing under the hood. So it's not a function under the hood. I guess I assumed it was too because you're passing in like an argument and it looks like a function. But not in the derived one, right? I don't think you pass in a function there. Or do you? I don't. No, in derived you pass in an expression and in fact you pass in a function. The curious thing, too, is that since they look like functions, with TypeScript tooling, you can also do things that are normally restricted to functions. For example, in TypeScript, you could do const count equals double, which is a function, and pass in a parameter. But you can also pass in a generic, right? Double is not the best function to pass in a generic, but you could do double, then that generic symbol, which I don't know the name, which looks like arrows. and you can also assume that with rooms you will also be able to do that like state and then pass in something like a inside derive to say what the type of

 with this, I think I may be totally wrong. But in props, you will be able, I think. Isn't props like up in the air? Like they've talked a lot about props and what they're going to do with it, if it's going to happen or not. But it would be a big DX lift for the way props are currently handled because of how we have to do, especially in component libraries, how we have to do spread props and rest props. Yeah, I was actually like talking with the other ambassadors the other day about this, like, I was doing a component where I had to type props somewhere, and then I already had typed them, and then I had to explicitly declare off them. And in those cases, the Dx is massively improved. But I can also see where in some other cases, it's not so much massively improved. Sometimes you don't need to do that. Sometimes you just want the type to be automatically inferred by an assignment or something like that. And now it's not going to be the case with the props room. So it's a delicate balance. I had a thought in your case. Could you not do like a one-line export and commas and just then equal to like your just whole type instead of... Like export let props, right? Something like that. Well, export and then you have to do them separately. But you do it as like one big object instead of export let and like the whole list of things. Yeah. Today I learned. I'm going to have to look into that because red Xmelt was written like that too. A bunch of export labs, just a big list of export labs. Oh, yeah. And it gets really annoying when you've got a lot of them. And if they've got default values, you can do them in line like that too in the commas. But that is kind of hard to read. So some of those I would pull out. But if they're just no default value, I would just put them in an object at the end. damn i really didn't know about this i feel like a fool especially because i did do export with object syntax for like class class name right smart class name as class look like that huh okay i'll have to look into that what rune are you most excited about for melt ui i would say actually i don't say there's a specific room to be honest i'm just excited about it as a whole because of what it brings. For example one frustration that comes up with Mouth a lot not as a consumer of Mouth not as a creator is passing down stars or something like that In Svelte let say you have an object and you have stars inside that object, which is my case. You have the cost dialog equals createDialog and have dialog.element.root. Let's say I want to pass that in to an element. So .dialog.element.$root. Oh, that doesn't work. That doesn't work. You have to remove the root from there and do const root equals dialog.elements.root and then you can spread it. With rooms, no, you just do dialog.elements.root. I would change the syntax so it's more concise. But yeah, you can just pop it in. So that's one thing I'm really excited about. I'm also excited about, this is not mouth specific, but just being able to use the same reactive syntax and Svelte components that copy-paste into a function in JavaScript and just do some getters and centers, that's marvelous. That was a huge win. Yeah, exactly. It always irked me. A lot of people coming from other frameworks were like, I can do this with a custom hook with Vue Composable. Can you do that in Svelte? I'm like, probably, but sometimes it would be a bit of a headache. Now you can. Now it's easy. So, I mean, now in the future, with reals it will be easy. I am excited to actually learn more platform stuff because like, I don't really know much about Gitters and Setters because I've never had to use them. And now I get to learn more. Well, maybe unless they give us like something to prevent us from having to write it. You can always do it on your own, right? If something was added, it would probably be... I don't have time to learn that. Okay. I don't have a need for it. If I had a need for it, I would, but I just don't. Yeah. Yeah. Because there's been talk about adding a helper thing, right? Like a runify or a box thing that would do this stuff for you. This is something that I'm really curious about. When I first... I went for a roller coaster with runes. I learned about runes. I was like, this is amazing. Then I tried to do export let's a state, right? From a TypeScript function. It wouldn't work. And I was like, runes suck. Just kidding. I wasn't like that. But I was like, huh, this is an oversight and stuff like that. And why is it this way? Because I already knew about the concept of signals and I know that Spelt uses this underdift But then I understood hey we not supposed to think of this as a signal or think about signals You just supposed to use this But my interpretation of it was like, think of this as a variable. You can't export a variable from a TypeScript file and then just modify it. To do that, you would need getters and setters, just like a normal variable. So that's when it started making sense. So state is kind of like just telling stuff like, hey, watch this little guy here. It's kind of that way, just saying, hey, this is reactive. Pay close attention to this one. That's it. Yeah, under the hood, it uses signals, but it's unlike view and solid where you have access to the signal reference, right? You can hack it a little bit, not hack it. You can create a function that has its own internal state with its own getters and setters. and just use that, it would look really similar to solids or views implementation if you want. Which is, I'm curious, like, what's going to look like when rooms are released? Like, if there's something new that's going to come up because of getters and setters, or if the community will adapt and just start using a convention like that somewhere. Like, it's curious. I know that the state not giving us access to the signal reference was intentional from a design point of view to avoid spaghetti code and stuff like that and avoid not being able to track what's going on. And I agree with that, but I'm curious how the community or how rooms will change until it releases or how the community will adapt when it does. I'm really curious. I'm curious how the browser API is going to develop too. Yeah. Yeah. There's been... Like browser APIs tend to always be a little worse than what frameworks kind of make the DX a little better than what browser APIs tend to be. And I would rather use the framework because it makes the DX better. Hence, web components are always my go-to awful API of death. Well, yeah. They're not bad if you use Svelte. If you use Svelte, but it's a framework that has made the DX of web components better. Well, I always hear from web components fans or advocates that, you know, they're really easy. Just use, you know, extensile. Yeah, or lit. Extensile. Well then that not web components you know Exactly But you know the same thing can be said here you know let let say that signals are hard to to use raw or whatever it fine because it felt subtracting over that and when it goes into the browser that will just be an automatic kind of flip and you'll use the browser native one as we do like you know a lot of the observers if they're not in the browser we'll create them if not then we'll use a native uh if they're not in the browser we'll create them if they're in the browser user native ones and it keeps everything and you'll just do it under the hood and keep the same dx for us exactly but us but ourselves as well power as felt compiler yeah yeah actually one one weird thing about runes of course is it it's almost like a step away a bit from that kind of compiled reactivity to more real-time reactivity which is interesting run-time reactivity yeah but this is something i'm also eager about like sometimes reactive statements since they work with static analysis they have these weird behaviors that you don't expect because you're not the compiler analyzing it statically you're a human and while when you work with svelte for a long time you are mindful of these sometimes with a more complex component you miss those i recently when i was working on the app website i was like why isn't this working why is this happening and stuff like that and i switched the reactive statements how it works and with runes, that won't be a thing, which is really exciting. You just said AppRite and I just realized we didn't even get to that. And we've been talking for almost an hour. Yeah, yeah. The new AppRite website, built in Svelte and Kit. What's this about? Is it the landing page? AppRite has been working on its new brand for a while. And with that comes its new website and docs. Why do I separate the two? Website is more like blog and some landing page stuff, some cool animations, just so newcomers can see what AppRite is all about with some really fancy design that our exam team has worked tirelessly on, but also much better to work with docs, both for users. We now have searching docs like everyone else. But yeah, there's some interesting stuff I want to get into there. how Svelte helped us in our brief time. I don't know how much time we still have, but yeah. So it's built in SvelteKit, which is amazing, but only because I love Svelte, it's now much easier to develop compared to our

 a stack, which was PHP with Docker. Each time I had to change a single line of code, Docker Compose, or I'm a noob at Docker. I'm familiar with that. I have to do that, even with our Spelltap. Oh, yeah. And then it's just like 15 seconds and, oh, I forgot a line. No hot pillow, just mental. But even barring that, I really love Spelltap's developer experience. It was really great about using it. It also helped me a ton. As I said, we really wanted this site to be visually appealing and interesting and unique. And so we have a bunch of animations, for example, on the landing page. And I love making animations interactable. So I also... I don't use only CSS transitions and web animations API and stuff like that. I also use Seltz transitions and animations for stuff because it's so much easier. for example, sometimes I simulate an entry entering into a database. I show the table, right? And instead of me manually animating, like, this element needs to go down, all of these need to go down, and then one pops up, like with CSS, I just add it to a Svelte store and just use Svelte transition and animate with slides and fades and stuff like that. Super easy, really, really easy in that sense. It helped quite a lot. I used it at time there. one thing that was really cool too just like file-based system routing stuff like that we're using static files for our tutorials and blogs and stuff like that together with something that's not well known and i think should be which is a mark doc processor have you all heard of mark doc no no you know mdx i assume yeah md6 md6 yeah yeah yeah that's it so mdx what like astro uses and React folks use. And then we have, of course, MDSFx, which is also a great thing. I use it on Mouth, actually, MDSFx. But MarkDoc is a thing by Stripe, which is also a Markdown processor that allows you to put components and stuff in there with drops. But the thing is, there was no adapter for Svelte. Then my team lead, Corsten Bitman, created a Svelte preprocessor to allow using MarkDoc. It's actually published on NPM, stuff like that. You can check it out. and it's what AppWrite Websites uses. I think it's really, really awesome. It really cool We use it with normal SvelteKit We have the name of the article in the folder then plus page That it We use it a ton there It also really helpful in that sense I feel like Svelte preprocessors are one of a big pro in Svelte. It's not something you're going to use all the time, but I really love preprocessors. It's not something I've seen in other frameworks. Yeah, it's something that definitely gives you control over doing something that's your own almost like a custom language on top of Svelte, which is quite amazing, really. Could be a foot gun as well. Of course. I agree. Everything is escape patched and a foot gun, right? But with great power comes great responsibility. Yeah. We use it in Melt, actually. Since we have to spread the prompts and use an action, we actually have a preprocessor that just uses a single action. Use, melt, then you pass the element, and that's it. With a preprocessor. But yeah, I think that's a little bit about it. It looks great. Everything else. I was going to say, just a little over halfway down the site, there's the cards that just swipe in. And it's so cool. So if anybody has time, ibrite.io and just swipe through the cards. It is super cool. Thank you. Thank you. Yeah, it was pretty great. One challenge with those animations, we're making them between certain animation states. You have to interrupt an animation. And when you go back, it needs to start back from scratch. But then using JavaScript, it's an async function. You cannot interrupt an async function. I had to do some really wonky stuff in there to make it work. It works quite well, but it was definitely interesting using some custom stop stores for that too and stuff like that. If anyone is curious enough and crazy enough to try and understand what's going on there, it's a little bit interesting. I also modified, created a custom flip directive for the animation. I overwritten it a little bit. Because the way Flip works, it just scales it up or down according to where it's going. But then the internal elements gets warped. So I modified it by passing CSS variables that you can apply internally to inverse the scale warping. I feel like that was good to do too. This one I like. So that's pretty accessible with these transition directives and post directives. Yeah, definitely something that I think I would probably mention it all the time on the podcast. But if you using other frameworks like you and React you not accustomed to having these things built in And they are really nice Once you use them you like oh this was so easy Maybe I just keep using Svelte because why not Exactly. Exactly. It's quite a... They're enduring features. They're not like must-haves, but you love them so much that you don't want to abandon them. Exactly. How do I do transitions now? All the library? No. It looks like it's all open source too. It is. It is. So we'll put a link to it in the show notes. I think we've chatted a bit about Runes, Melt, the website. Let's move to the next section here, which is our most popular section, the unpopular opinions section. Who wants to go first? Does anyone have an unpopular opinion? I have an unpopular opinion if we need someone to go first. Yeah, okay. I mean, it's as usual. Go for it. my unpopular opinion relates to what we talked about earlier about not reinventing the wheel and my unpopular opinion is reinvent the wheel and the reason that i say that is because a lot of me saying that don't reinvent the wheel actually made me realize that you know sometimes someone who has a great idea needs to reinvent the wheel because that's how we progress you know that's how we find the wheel was square the wheel may well have been square the wheel could have been trying it was well it was square at first yeah yeah the first wheel was square if they didn't reinvent the wheel we would not be on like the wheels we are exactly there you go so i guess yeah do do reinvent the wheel yes now no in in you know don't do it for the sake of doing it do it when you feel that there's a need when you've got an idea felt that means reinvent the whale, right? Kind of. I don't have an unpopular opinion. I think outside the box. My unpopular opinion was just going to be that browser APIs, while I like having them, are not great to use, but I don't know that that's that unpopular. It depends on the API, I suppose, yeah. I'm excited for the temporal API to expand, but I mean, it's just because dates are awful. Can I have two unpopular opinions since Kev? Yeah. I love to talk, as you can also. Sure. Perfect. So my first one that I had thought of was free commit hooks are bad or unnecessary most of the time. Oh, why? They just slow you down Like commit is just me saying I want this at a point in time Most people will just not verify it It stuff that should be caught by our CI anyways Okay, I am going to disagree with you. You want to know why? Okay, so we have Prettier set up in our code base, and our CI will fail if Prettier is not ran. There's no pre-commit hook or anything before I set up one to run prettier on the code base. And then it fails in CI once it builds 20 minutes later. So you have no check between. I mean, if it takes 20 minutes to build your product, then yeah, I would say it's mostly fine. But I would say most projects don't take that long. So my pre-commit hook runs on anything that you have committed. So it runs on like a few files. it takes like a second and it just runs prettier on the files that you have committed. Still, I would say that if you're going to use hook like a git hook, do it for push instead of like commit, because I just want to save my state. I don't want anything getting on the way. Pre-push hooks, I still don't like them, but they're preferable in my opinion, much preferable than a commit hook. I think I disagree. I disagree because the pre-commit hook is better in that you're not going to have a commit full of errors and problems and then have another commit that cleans them up. If you want to make sure you can commit easily without any worrying, then you can just do dash dash no, but dash verify on the end and then it won't run any hooks. So you can always escape it. Yeah, but that's the thing. In that scene, if people share that opinion like, hey, this commit's an eye, I just want to save my state, and they just will not verify it anyways, then why have it? But I understand what you mean. You can squash later when you want to save your state and you've got a bunch of commits where you fix stuff. You can squash them all together. Whereas if you're doing it on pre-push, those commits are already in. I suppose you could squash them in retrospect, but I don't know. Yeah, normally that's what's going to happen when you're going to put it in a PR. That's true. When you're working on it. But yeah, my opinion is really unpopular. Yeah, it is. We do squash and merge at the end too. But then we have some teams that rebase and some teams that merge with master and that's really annoying too. Yeah, we just started using Squash and Malts and it's so good. It's the first time I'm using Squash mergers, honestly, and they're so clean.

 My second unpopular, this one, I think you will agree with me more. Performance is more important than you think. A lot of people, when they go and say, hey, I'm fine with using something that's not as performant or something like that, because in the end, it doesn't matter or something like that. But I would say it matters. It doesn't until it does. Someone may have a device that's not as powerful. you may end up implementing a feature that is going to be a CPU or something intensive, stuff like that, and then you're stuck. Then you're stuck using something that's not performant, and changing from that is going to be a pain. So if there's a good default that is something that by default is performant, and it's a good tool, not only performant, but it's generally a good tool, like Svelte, it's performant, and it's a really good tool, then I would say that performance is a really good selling point. Some people try to downplay that a lot. I think it kind of depends on the framing. From like a front-end framework point of view, I think that makes sense. But from a back-end point of view, I think you're generally in a position where you can just throw more strong, bigger, better servers onto the issue. Like if you don't have to use Rust to optimize your back-end kind of thing. But yeah. I also agree. It depends. I agree with you. Yeah I talking more of a front framework I guess But I agree with you on that Okay I think that our controversial or unpopular opinions Maybe we should change it to controversial opinions Then we can pick a lot more stuff. Maybe not. I don't know. Let's move on to picks. What are your picks? Who wants to go first? Anthony, you look like you're I have another TV show. Yeah, I'm pensive. I don't think I have a pick necessarily this time. Let me have a pick. Nothing is interesting than last week. You've been too busy. I have been too busy. Be fair. Yes. All right, Brittany. Invasion. Another TV show. Yeah, this last episode, it's just building up for the end now. So this last episode was a little slow, but it's been really good this season. Yeah, I like it as well. It's good. All the Apple shows have been really good. They're knocking it out of the park. Have you all watched Severance? Yes. It's amazing. Very good. They're taking a while for the next series, the next season. Every show has done that. And it's so long between them that I need almost to watch the season again because I forget everything that happens. Maybe they do it on purpose. Well, I don't watch the season and then I just have to kind of catch up as I go along, but it's a problem. Or watch a 20-minute YouTube recap. Well this is why I like it enjoying the whole binge watching thing Just wait till it all done and released and then watch it Yep At your leisure Yeah but also I like participating in the hype I joined the community and I'm like, did you see that episode? Yeah. That does feel like it's coming back. Yeah. The weekly shows where you can actually have conversations about them rather than binge-watching everything. Weekly shows are much better. I wonder if Netflix kind of realized this since they've started splitting up their seasons. They have started doing miniseries and like little parts series. Yeah. I think so. Yeah. Okay. I'm going to pick now. So my pick is The Continental. It's a TV show based on the John Wick universe. It's like a three episode miniseries. It's pretty good. I recommend it. That's nice. If you like the John Wick universe, of course. John Wick isn't everyone's cup of tea. That's pretty awesome. That's my pick. Okay. My pick, then, will be the Berserk mangas. When I was a kid, I loved animes and stuff like that. Not too much of an anime. I kind of stopped for a while. And I always wanted to read Berserk as a Dark Souls and stuff like that. And now I can't stop buying these massive books that my girlfriend's wearing. I'm like, I'm going to have to buy a new shelf. It's a very good manga. Yeah I really enjoying it And it made me start watching anime all over again So yeah It pretty fun You from Brazil right It complicated I was actually born in Switzerland. With three years old, I moved to Brazil. But I'm actually Portuguese because of my family. All right. But I feel like Brazilians watch a lot of manga or anime, I should say. Yeah, they do. They do. It's a pretty big thing there. There are a lot of anime cons, like Comic-Con, but for anime only. i've been to tusa it's pretty fun yeah that's that confirmed my suspicions not suspicions but brazilians like anime yeah okay it's pretty big there for sure at least where i was yeah with that said we have come to the end of the show thank you for joining us thomas where can people find you thank you oh yeah on twitter as thomas g lopez mostly twitter is where i'm at and the discord threads oh yes and the discord threads discard the spout discord on the rune spread or on mouse discord too we'll put links to both and yeah again thanks for for joining us thanks so much for inviting you it was great yeah i'm glad you liked it and for everyone who's listening thank you for listening again we will see you next week bye bye hey it's cover if you like the show please drop a review on your favorite podcast player it would help out a lot thanks