 Thank you. Thank you. When building an enterprise-grade full-stack web application, the tech stack you choose matters. We imagined Raster without compromise or limitations. Our engineering goal was to build a fully-featured enterprise application with minimal loading no performance issues or crashes, and super fast reactivity to make a great end user experience. Raster is a modern image management solution a Jamstack digital asset manager for a Jamstack web Instead of a messy solution with folders Raster uses tags driven by AI to recognize what in your image and provides tools to help designers and developers manage and integrate the images in a modern way. Additionally, Raster has built-in real-time collaboration backed by ultra-fast Imgix and Vercel-powered CDN to serve images quickly. Nonetheless, this is a long list of requirements. User authentication, complex queries to databases, stateful actions on the front-end, powerful search interface and lots of interfacing with backend APIs. And of course, with all of these, we could make no sacrifice on performance. To add to that list, we wanted a simple developer workflow. As Rich Harris said, frameworks are not tools for organizing your code, they are tools for organizing your mind. A simple developer workflow means less boilerplate, which means smaller bundles and less bugs ultimately. So Monogram spent time and energy researching the best tech stack to build Raster. It made fully functioning prototypes in both Nuxt.js and Next.js, but had two fundamental issues. First, performance. While we love Vue and React for most apps, the virtual DOM simply made Raster feel sluggish at times, especially when viewing lists of thousands of images. And second, simplicity. Both Vue and React have relatively complex developer experiences that ended up increasing the bundle size of the site, which leads to a slower end-user experience. At Monogram, we always want to use the best technology for any task, whether it be a simple website or a full-scale app. So looking at Svelte's benefits like the built-in animation library, its intuitive stores, lightweight package size, endpoints with SvelteKit, and super-fast Vite development workflow, we quickly realized the potential that Svelte had to make Raster amazing We prototyped a new version of Raster in SvelteKit in days not weeks despite this being our first production SvelteKit web app It no secret Svelte is incredibly intuitive for developers so we were able to ship much faster, especially when paired with Vercel. Because of all of Svelte's built-in benefits, Raster is able to have features that set it apart. We fell in love with Svelte's stores. Stores let us easily share information across components and have them update in real time without a bunch of boilerplate code. We've actually integrated them with Firebase's Snapshot listeners, which is what allows us to have real-time data across the app for multiple users without having to make multiple queries or making our front-end code too complex. Combined with Svelte's dollar sign reactivity syntax, Svelte stores allow us to always use the latest data while being impressively performant. We also use stores for user authentication, which allow the whole app to feel like a spa. Even when changing workspaces, the browser never performs a full refresh, making Raster feel wicked fast. Additionally, Raster demands lots of backend interaction. For authorization, performing a search, or uploading hundreds of photos at once, we needed a super fast backend. We utilize SvelteKit's endpoints to make fast API calls that live securely right on our production server. When you create a new view in Raster, for example, the image URL for that view is cached and ready to be deployed in seconds. Or generating a unique and secure Algolia search key, for example, is just one call to the endpoint away. This gives a powerful command palette right at the fingertips of our users. Additionally, we knew that while Raster's power users would love the web app, they might want something more performant and integrated in their machine. So with SvelteKit secret weapon of adapters we set out to build a desktop app from our existing code base While other frameworks would require using complex export commands and weird management of build workflows we simply used SvelteKit Adapter Static and had our desktop app running with changes only in our Svelte config file. And because of Svelte's performance and small footprint, Raster's desktop app is more performant and lighter than most in its class and uses much less RAM. So with the same codebase, we're able to power our web app using using the Vercel adapter and our desktop app with the static adapter. SvelteKit makes it easy to switch between. Then, we used Vite's intuitive handling of environment variables to add conditional logic to make the desktop experience even better, like having a translucent sidebar that feels at home on Mac OS. And lastly, we love Svelte's built-in animations library. Despite being only one kilobyte, the animations on Raster never skip or frame and make the app feel buttery smooth. We were able to integrate all of these features into Raster without sacrificing performance, both load time and front end performance. Just navigating around Raster feels amazing and intuitive. No loading bars, no spinners, everything just works. Now that Raster has launched in private beta, we are confident that Svelte was the right tool for the job. Everything is really fast and lightweight by supporting every feature that we imagine and more to come. Because of the innovation Svelte has brought to the web, Monogram proudly supports Svelte and its development on Open Collective. If you'd like to use Raster for free as an early beta user, please drop us your email at raster.app.