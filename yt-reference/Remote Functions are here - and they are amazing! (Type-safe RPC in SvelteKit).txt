 If you've been building apps with SvelteKit, you might have run into some frustrations around data loading. For example, if you need to fetch some data that's only used in one tiny component on your site, you still have to put it all the way in a parent layout load function and either prop drill that data down, use the page store, or put the data into context. I know I've struggled with this quite a bit, just having this disconnect between where data is loaded and where it's actually used. And if you've ever tried calling a form action from one route on a completely a different route, you know that it can get quite tricky both to understand and with the whole types situation. So today I'm excited to show you a new RFC, request for comment, for SvelteKit that the Svelte team has cooked up and that completely changes how data loading works in SvelteKit. It's called Remote Functions. This is a brand new feature proposal that makes it possible to call remote functions just like if they were regular client-side functions while keeping everything type safe and secure. This proposal actually builds upon a second proposal called Asynchronous Svelte that finally allows you to use await inside of your Svelte components without any sort of workarounds. While I don't usually make videos about upcoming RFCs, just because of how important this one is for the future of Svelte and SvelteKit, I wanted to showcase it and get it in front of as many people as possible so you can provide your feedback on this RFC. So in this video I'm going to show you the four new types of remote functions that SvelteKit is introducing. Query, Form, Command and Pre-Render. We'll talk about why this approach solves a lot of the current pain points with data loading and then we'll jump into a demo where I'll show you exactly how these functions work in a real project. So let's talk about why this matters. Right now in SvelteKit, when you want to load data, you use load functions and they work great for a lot of cases, but they have some drawbacks that become really apparent as your app grows. First, there's the implicit coupling between files. Your page.server.ts file loads the data and your page.svelte file uses it. But if you have a complex routing structure with multiple nested layouts, it's easy to lose track of what data is being loaded where and how to invalidate just the parts of your data that you actually need to invalidate. Second, when you want to refetch data, it happens at the loader level. So if you just want to refresh one tiny piece of data, you end up reloading the whole load function. That's not great for either performance or for your wallet if you're paying for hosting. And third, there's no built-in way to do mutations except for form actions. If you want to update data without a form, you end up writing a server.ts endpoint and doing manual fetch calls, which makes type safety tricky. There are of course workarounds to this like using Zod, but what if it was built into the framework So this is where remote functions come in The idea is simple You write a function in a file import them into your component and call them like regular async functions On the server they work exactly like normal functions. They can access your database, read environment variables, whatever you need. But on the client they automatically become wrapped fetch calls to those same server-side functions, essentially something like a remote procedure call. The amazing thing here is that everything stays type safe. You import the function, TypeScript knows exactly what arguments it takes and what it returns. And this is secure as well. Because these functions live in separate .remote.ts files, there's zero chance of accidentally leaking server-side code or secrets to the client, which is a problem in some other frameworks. Let's now break down the four types of remote functions that this RFC introduces. And we'll start with the query function. The query function is essentially for reading data from the server. What's really cool is that queries aren't just promises that resolve to the function value. They're actually objects having .loading and .current properties, plus methods like refresh and override for optimistic updates, which we'll see in just a little bit. When you call a query during server-side rendering, the result gets serialized into the HTML, so you don't have to double-fetch during hydration, just like with current load functions, and queries are automatically cached and duplicated. If you call the same query with the same argument multiple times on a page, it only makes one request. Next, we have form functions. These are for writing data through the server and they are of course progressively enhanced by default as you would expect from SvelteKit. You can spread the form properties onto an actual form element and it'll work completely without JavaScript. But it also automatically enhances itself when JavaScript is available, just like UseEnhanced did. After form submission, all queries on the page automatically refresh by default. But you can also control this granularly, refreshing only specific queries. And you can also do something that the Svelte team calls single-flight mutations. and you do this by moving the refresh call to the server instead of the client. This way the updated data comes back with the form response so you don't need to separate requests to refetch your queries after you submitted your form and got it back. Next is the command function. Command functions are like form functions but for JavaScript only interactions. It's perfect for things like button clicks or keyboard shortcuts where progressive enhancement doesn't really make sense and where you before would need to create a plus server endpoint. Command functions follow the same pattern as forms. Automatic query, refreshing, single flight mutations, all that good stuff. Finally we have the prerender functions. These are like queries but they run at build time Basically this function augments the old entries functionality but this time instead of prerendering whole load functions you can prerender individual parts inside of any component This feels super powerful and I be interested to see what use cases people will find for this. Now, let's see all this in action. We're going to code together and try out all these new functions and see how they feel. Let's get into it. Now, I want to start by giving a huge shout out to Matt, who runs the Joy of Code YouTube channel with tons of good Svelte content. So if you're not subscribed to him, please subscribe because he made this template project that you can start with and where you have all the right branches to get a synchronous Svelte and to get this new remote function stuff in SvelteKit. So that's what I've based my example project on. So what we get in this project is just a very basic SvelteKit setup. We get a little bit of styling using open props. We also get this basic layout, and it has a svelte boundary, which catches errors for us that might happen. And it also uses this new snippet pending. And this is what's going to be shown while the sort of asynchronous stuff is loading. Now, in the RFC, they talk about how server-side rendering is going to work for remote functions. It doesn't work right now. So right now, it's all client-side. But keeping in mind, this is just still an experimental suggestion for how they want things to work. And then we have my starter component that I thought we'd start with. And just for reference, right now, it looks like this doesn't actually have any logic in it yet. So I thought we would make a basic global counter using SQLite and basically use these new constructs to see how it feels and how it differs from using load functions. So let's start by loading data, right? That's usually where you start. So instead of creating a plus page.ts function, I'm gonna instead create one of the new remote functions. So let me go ahead and do that. So I go to routes here and I create counter.remote.ts Now I have the new remote function and then I can import query from App server And our query will essentially be like my load function but much more granular than that of course So now that I have my query function, I basically need to export a function from here. I'll call it getCounter and I will export the query function and inside here I will wrap what I actually want to show So yeah let start with just doing this return counter zero And then from here, I can just say we have an old toast import here. It's fine. We'll use that later. I'm just going to go ahead and do this just as the AI suggests for me. And then I can do, for example, await getCounter. And of course, it's going to be plus, let's see here, what did I call it, plus dotCounter. And you can see there we even got the type suggestion there. How cool is that? All right, let's see how that works. Now, this is something that I've run into. I think this is a a bug in the PR because essentially what or maybe I didn't read the the spec close enough but essentially you need to do something like this you need to wait get counter up here and then do a wait count but counter Let's go like that and now it is going to work. There we go. And I think this probably has something to do with the fact this is not just the promise, this is you know the sort of several promise that has all these other cool features baked in. So now let's replace this with an actual counter. So I have a function already prepared. It's called getCounterValue. And what this libDB class does, essentially it just uses betterSqlite3. It initializes a database, creates a very, very, very simple table with an ID and a value, and then it will actually insert like zero by default into it. And then it has some functions like getCounterValue, incrementCounterValue, resetCounterValue, and setCounterValue. So kind of everything crud that you might need. Now, instead, I'm going to return getCounterValue directly, and this is going to be a number. So we no longer need this.counter. Instead, all we need is awaitCount. Let's see. All right, we still get zero.

 which is what we expect. And now we're done with the data loading for now. So this is like we finished with our load function. And instead of writing a form, which we would do normally write to increment the value, let's try the new command function to do that. And we'll see how we like it. So we're going to go back here and we're going to import additionally command from app server. and then we are going to create a function called increment counter and yeah we get some help here it is a little bit of a hallucination potentially let's see here this so far this is correct we can make a we can pass a function to command I believe command can also take properties let me let me check here. Command, yes so command can take properties but we don't need any properties here because we're just gonna increment the count with one. So what I need is to call the increment counter function. Let me see here what is it called here. Increment counter value, there we go. And then, well let's see what happens when we just do this right so we'll see if we have any invalidation that we need to do manually. Alright then let's create a button here to power this new command. We're gonna create an onClickHandler for this because it's not a form and then we're gonna do a function. There we go and inside this function we're just gonna call this increment counter function that we exported from counter.remote. Now it is not liking me here because I because I'm lacking some of this accessibility stuff. Let's ignore it for now. There we go and now let's see how this is going to look. This button has seen better days. Let me give it a label there. Increment counter. There we go. All right. It's looking pretty good. Open props is cool. All right. Let me click the button and see what happens All right So it worked one time but now it is no longer working for some reason Let see Okay I think that was some sort of a hydration thing so if I if I try it now it is working every time and what we can see here in the in the network tab here is that we call this RPC function which is loading from app slash remote we're getting a response but that response doesn't contain the new count. Instead, the new count is automatically invalidated. And so directly after this increment counter function, we get the get counter function every time that gets the actual new value. So if you recall, we have this feature called single flight mutations, where we can basically tell it to refresh the value right away without doing this extra step. So let's go ahead and implement that so that we skip this extra call. So in order to do that, we need to call refresh on the getCounter value. So actually, what I think should work is just to do, I guess, getCounter.refresh. This looks a little bit magic. I think the command should also return something. So let's just return success true. Now, of course, we could pass back, we could call getCounter in here, which would not create a new request that we just call the function directly and interface with the database. But this refresh should in theory do the same thing. Let's see. I'm gonna do a full reload here to avoid any sort of hydration problems. This is expected as everything is still just, you know, work in progress. Now let's press increment and see what happens okay very cool so now we get only one increment counter call and inside this call uh we have this like refreshes keys refreshes key and this one actually says that get counter is also being refreshed and here is the new value for get counter this is extremely cool so now we eliminated that extra query and did you see like what's so cool about it. Did you see how little code this is? Do you see how easy it is to do this kind of stuff? It's so little code to do these sort of things. And Svelte just does so much for you now, thanks to these functions. And look at how fine-grained everything is. You can imagine that you have dozens of functions Now SvelteKit is going to be in charge of like loading all these functions in the most optimized ways And this is just really cool But the fun doesn't end here. Let's continue. And let's talk about optimistic updates because this is also something that you could do in Svelte and SvelteKit. It was possible to like, as the request is being sent, You kind of like show a temporary value. But then there's a lot of stuff you need to do. You need to kind of keep track. What if, let's say, the user presses a button multiple times and the requests take different amount of time to finish. And then, you know, you kind of get them scrambled. So the earlier invocation of a request would come in last. That way you would get like the incorrect value. Now, SvelteKit will actually solve that. And I'm going to show you practically how it does this. This is going to be a little bit hard to see, so we need to introduce a little bit of delay here. So I'm going to create a delay. It's going to be like basically between zero and two and a half seconds here. And then I'm going to, as we call this command to increment the calendar, I'm going to call a delay. So I'm going to delay the request. Now we have the delay. Let's see how it looks. Great. And what you saw there was really cool. So these two requests finished really quickly. And this request, which is actually the request, the second request finished last. And even though, even though despite that, we still got it in the correct order. So even if the requests, like let's do like 10 requests, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. So we should end up at 53. Now, even if the requests come in out of order, we still get the correct value. This is huge. This is going to make optimistic loading so easy in SvelteKit. Insane. They didn't have to solve this, but I'm so grateful that they did. Now, so far, we saw how the requests work now with the command. And I promised you optimistic updates. Let's implement optimistic updates. So what we mean by that is that as I'm pressing here, you see a delay. So I press, but it takes a while before the number updates. So what we want to do is we want to show the optimistic update of the number So it will be like if you had clicked and it went through right away And then we want to automatically roll back to a previous version if for some reason this update fails. So if I click and the update fails, then it should first show the new number as if it had completed successfully, then go back as we see that the command doesn't succeed. So let's add a little bit of random errors and let's add a little bit of optimistic loading to see. First let's start with optimistic loading. So in order to do optimistic loading we use the override function. How it works is we call counter which is the promise we got from a remote function dot override. Sorry it's called count not counter there. Count dot override and here we are going to temporarily override the value with something else. So override takes a function, the function signature accepts the current value and then you return what you want the optimistic version of that value to be. So in this example what you want is basically just current plus one. So because if the current value is zero and you want to optimistically guess what is the future value going to be, it's going to be zero plus one. And this works for anything. Like let's say you have a chat app and you have like a list of messages. So the current value would be the current list of messages. And what you would return from this override function would be the current list of messages plus the message you just sent that hasn't been acknowledged by the server yet. So here we go. I do have a little bit of type issues. It's not liking me for some reason. Ah, yeah, I need to actually, yeah, need to actually return a current plus one there. Well, first, let's see how this works, right? So now, one, two, three, we see right away that it works, but there's one more step that we need to do, which is that we actually need to call this release function that comes back from count.override. Now release isn't really clearly explained like kind of how it internally works. I assume that this is part of this sort of having to correctly resolve

 to the correct value in the end because functions can be returned out of order. So I think with release, we ensure that the function will actually always resolve to the correct result in the end, even if network conditions make it so that some requests finish faster than others. And the way it works is that you need to basically call the release function as we see here. Now there is for some reason no completion for this yet, but it's not technically out yet. So what we do instead now is we switched the await just to be put inside try. We catch it if there's any error in this function and that's gonna come in handy when we do error handling inside here in just a second. And then finally, meaning that always, we will call release. So let's see now how that works out. So I'm at 62 now. I'm gonna go to 65, just waiting for it to refresh. There we 65 and now I'm going to click 10 times and you will see that we were going to end up at 75 immediately but then also as the request finished we're gonna still be at 75 so let me click 10 times here. There we go. So you saw there that the updates were optimistic, all the requests finished and we ended up in the correct state. Now let's add like a random error to our function and see how SvelteKit helps us with this. So what I'm going to do is just say if map.random, let's say 20% of cases, I want to throw an error. And this is the same error that you are used to from Svelte load functions actually. Here we go. All right. So now let me just reload that. Now I'm going to click 10 more times, but I'm actually expecting some of the requests to fail and hopefully I should also see some nice toasts when that happens. So the count we end up with should be how many times I clicked. I'm going to click 10 times minus basically how many toasts we see or how many failed requests. So let's see how that works out. Okay, here we go. Did you see it there? So I clicked 10 times, we ended up at 85, then two requests failed and we actually like went back down to 83. How cool is that? So great. So now we've seen query and command. and let's look at forms next. So what I going to do is I going to update the menu I going to create a new route so that we can start working with forms So this is what I have now I basically have a new form page and I once again put in a little bit of placeholder stuff here, just the number. But let's now make a form and we'll see how easy it is now. So we're going to create a new remote file again. We call it form.remote.ts. You can, of course, call it anything. You're no longer restricted to calling it plus page.ts. And also, I assume you could easily put this in lib, which is probably what people are going to do. I just put them here, co-located them with the routes, just out of old habit, honestly, from the plus page.ts. But I think it's going to work just as fine to put it in the lib folder. So now let's make our form. Now in order to fetch data we're still gonna need the query function so same as we did before so just export const get counter we're gonna have the query and inside the query we are going to return get counter value and of course this can be a promise if you want and you can await it. So this is going to be the same as before and then now we're gonna create increment counter and for this we're going to use the new form import. The form import looks quite similar to what we used in command. Of course if you think about it like what does it accept? Well it accepts the form data that the user is going to be sending through their browser and basically this function looks almost the same. We're gonna call increment counter value and we can await it here and then we are going to again call getCounter.refresh so that we get that single flight update going and we can return success true. Now I really love this pattern where you know normally I would have to do something like this write count, await, getCounter. But why if we can just say that, yeah, this function actually updates this other query and this query can presumably be anywhere So queries can have interdependencies and it going to be so simple now to sort of invalidate stuff and it no longer going to be tight load functions So we don need this at all I going to go ahead and do that. Now let me go back to the form route. So let me create the form here and the way it works according to the spec is that we're supposed to be able, Wow, VS Code really didn't like those three dots here. You're supposed to be able to spread the actual import of form. So let's see here. If we import increment counter form here, and then we're supposed to just spread it here. There we go. The syntax highlighting is going insane. I really didn't like that. It's supposed to be increment counter form and then we need, of course, a button to submit it. Well, let's see what turns out here. I have messed up something here in my... Oh, yeah, this is gonna take a little bit of time to get used to. Of course, the spreading happens inside these brackets. There we go, and stop complaining. Okay, so now if I submit the form, hmm, that didn't work. Let me see here if I forgot something. Now we also need to of course import getCounter here, replace this static value. Here we go. Yep, need to import it from the right file as well, not from my other file. Okay, now we're getting the correct value, 89. Now let's see if we submit this form. There we go, 90. Now I read through the RFC quickly. I didn't see a way to do optimistic updates in the form mode, so I'm not sure if you can do that or if there's some work around for it. But what should work is if we just disable JavaScript here. Oh yeah, that's not gonna work of course because the server-side rendering isn't working. Yeah, so but when everything is is kind of in production if we end up with this standard then you gonna be able to load the page without JavaScript and then actually submit the form without using JavaScript at all How cool is this All right Also something you can do is that according to the spec, you now have support for schemas. So they actually use Zod the way I understand it or something that is Zod compatible. So we can see here that you actually have this validate function as well, where you can validate data in your query. Now, I don't want to get into it because I don't want this video to be super duper long, but I think this is huge as well. Just the fact that you can also validate stuff and that we get kind of first party support for Zod, or at least this standard schema way of specifying the format of data. And of course, this works in form and also in query. Really, really cool. Now, let's look at the final big function, the prerender function. So as I mentioned, like before, when you were prerendering, you basically prerendered on the route level. So you say this page is prerendered, this page is not prerendered. And that's basically the granularity that you had. But now what's so cool is that you can pre-render individual remote functions. And this is huge, right? Because this means that if you have, let's say, some data up in the right corner that you only really need to pre-render, you know, occasionally every few days or maybe you never have to update it except for when you build. And this is great. You don't have to make the whole route pre-rendered. and there was a little bit of talk in the RFC if I recall also about stuff like incremental static regeneration which is a is a feature of Vercel I'm not sure if it's available in many other platforms but basically it's a way of like pre-rendering data but then occasionally refreshing it without having to redeploy and this is also huge and I hope this also comes to the node adapter and other adapters, because it would basically be a way of having a sort of built-in timed cache in your cell kit site. And you can say, oh, the calendar entry in the top right of your page, we're going to update that once every day. And that's going to lower your usage, because you're not going to have to, let's say,

 fetch that data every time somebody comes in, but only like every hour, every day, whatever you want. So I think that's huge. But let's look at the pre-render we have today. And pre-rendered is good for when you have this sort of heavy data to compute or when you actually don't need to refresh data all the time. You only really need to refresh it every now and then and doesn't impact the user experience. So what I thought I would do is I thought we would calculate a really big Fibonacci number, specifically the five thousands Fibonacci number, which takes a few seconds on my computer to calculate, but not too long. So we can still see the benefit, but we don't spend like 10 hours building it or like 10 hours for it to generate. So let me set up a Fibonacci route and I'll be back in a second. So what we have here is this stubbed object here that just has value zero timestamp zero and then we have the actual value which we're showing and a timestamp and this is going to be useful when we want to double check that the value isn't being recalculated every time and so what we need to do is again specify a remote function how many n's is in Fibonacci let's hope it's one there we go and then we're gonna of course export const Fibonacci number, but instead of a query, we're gonna actually use pre-render. Here we go. And so what is this? What is a pre-render here? Well, it's a function that looks very similar to query, but there's actually one really, really big difference, because if you remember in SvelteKit, we would have these entries. So for a pre-rendered page, we can say these are the different kind of values for the pre-rendered page we want to support. And that allows SvelteKit to build all of the variations that we want to build at build time. And this actually is maintained in the pre-rendered function. So we saw here, we pass in the first function, which is going to be the actual R function that does all the calculation of the Fibonacci number and then the pre function also accepts the second function which has as you would expect a not pre that wrong but an entries parameter So very very similar to what we have before. And now I'm messing up again. No, it's not a, yeah, it's not a array. Let's see what we have here. Entries. It's a function. So what we have here is like this function. And it being a function is super useful because let's say you want to fetch all the blog posts inside this function. Well, you can and do it at build time completely dynamically. You don't have the hard code, but this function will return basically the values of the params here. So there we go. This one was a little bit tricky. So it's an array of arrays. So array, array, 5,000. Okay. And then the 5,000 is going to be passed in here in params. And if we had multiple ones, so let's say we also have like 10,000 here, then when we're building the site, we would actually run this function twice, one for 5,000, one for 10,000. Very cool. But we're only going to run it for 5,000 now, just to show it off. And then here we actually need to No, not here. Here we need to actually calculate the Fibonacci value and we have a function for that. This function isn't so interesting but I can show it. Yeah, params is wrong here. What we need is actually it is just the just a number and then we calculate it for this number and then I also prepare this like stats function which is going to give us the basically the time I think when the current time so let's see here so the calculate Fibonacci function gives us it calls this Fibonacci npm package and then just returns the number and the stats function well now it actually just gives us how many digits they are so I must have refactored this at some point And of course from this function we will return the number the value let just call this value to avoid the repetition And then we gonna call stats and timestamp Perfect so yeah so this is so when the function runs we gonna save the current timestamp and that's actually the thing that's gonna be static later because we're not gonna be rerunning this function all the time. There we go. And now we are going to import the function very as we, what did we call the function? Fibonacci number. Here we go. And then we're gonna do that. And I think that is correct. So you pass in the... let me just double check that with the docs here. Yeah. So you pass in the number here. And I think, yeah, this is probably because... hmm... it's probably because the function can be run in dynamic one. Now I do remember seeing a part of the spec where they're kind of talking about different ways of pre-render like I mentioned with the incremental stat-tieper generation and that things can still be that I think that's why you would still want to pass it in. Well we'll see maybe you don't have to pass it in but let's try this first and see how it works. All right here we go so if we reload we see it takes a couple of seconds here. There we go. And then finally we get the pre-computer value. It's a really big number. We see the timestamp when this was generated. So now it says 4233. And if I reload, it's actually going to run it again. And the reason for that is that in dev mode, just as with pre-run the droughts, in dev mode, they do rerun every time because it would be super annoying if you got stuck on some old value. And then the only way to kind of get out of it would be to restart the dev server, that wouldn't be very good development experience. So it is actually super useful that the even like pre-rendered functions actually reload every time in depth. Well, let's see if I pass like a different number. If I pass one, does it work? Yeah. So it does actually support, as I expected, it does actually support the different numbers. But I assume if you were to call a number that is not being pre-rendered and it's not in a dynamic environment, then that wouldn't work because the number hasn't been calculated. Okay this is cool but how does this actually work That something that I was really interested in because let say we now build our site So I going to go ahead and build the site I'm just going to mention that I did actually put in the root layout, I put pre-rendered true. So that's something to keep in mind. So now that I built the site, let me run npm run preview. I'm going to open up the preview URL. And I mean, of course, this stuff works. But specifically, let's go to the pre-render. Did you see how fast that was? So if I reload now, it is super duper fast. And if I check the time here, it's a little bit small, but if I zoom in and check the time, well, it actually doesn't update. So it says 4403 and I reload a few times and it still says 4403. So there we saw that it is actually being pre-rendered. Now, this is just scraping the kind of surface. It's going to be extremely interesting, especially in the context of like adapter static. How are all these remote functions going to work? Are we going to be able to, for example, build a static version of a site that calls remote functions on a different endpoint? That would be super cool for stuff like capacitor apps or other places where you kind of have a static environment. So this is really just the kind of a first look. And like I mentioned, the spec isn't fully completed yet. Now, there's one more thing I wanted to show you, which is how these remote pre-render functions actually look in the build output. So what I've done is, like I mentioned, I'm pre-rendering the whole page. I've set up adapter static, which is going to build the whole page into a static folder inside build here. I'm going to go ahead and run the build command. It's going to take a while now because it needs to calculate that Fibonacci number. And then I'm going to open up this build folder. Now, I don't expect the SSR to work, so I wouldn't expect the number here. Yeah, I'm just getting that loading suspense boundary that we set up. But somewhere in here, we need to have the number, right? Because it has been pre-computed and everything is static. So I noticed that we now have this new remote directory and inside it, there is this file, which is called something, something, Fibonacci number, something. I don't know if this is some sort of hasher or something. And then in here, we do have the number. So as we see here,

 it has been pre-computed and it's actually been saved so that it can be accessed right away without having to be recalculated. That means you can do servers, like before, you can do server-side stuff during build, and then you don't obviously have to ship the dependencies for that server-side stuff to the client. Instead, they're going to be kind of like baked into the output. So I hope you like this overview of these functions. please go to the GitHub issue and read through it, read the whole RFC. And if you have feedback on it, please leave that feedback. There's already a lot of feedback right now. But I think this is such a huge change to the way SvelteKit loads data and really like modernizes it, moving away from loaders to this like per component data loading where every component can get exactly the data it needs. So please check this out. Check also out the asynchronous Svelte RFC. If you have any questions or if you want to see more about this or about something else, please leave a comment. If you liked the video, leave a like. Subscribe for more content like this and I'll see you in the next video.