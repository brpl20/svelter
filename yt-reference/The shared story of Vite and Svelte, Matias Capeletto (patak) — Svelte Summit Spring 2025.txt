 So, let's talk about the shared story of Svelte and Vite. First, I'm Matias Capeleto, but you may know me as Patak Online. He's Zorro, one of our three cats. And I'm a Vite core team member, and I do open source at StackVite, focusing on the Vite ecosystem. And let me say that I'm extremely happy to be here, finally at Svelte Summit. I have been a big fan of the Svelte community in general and Svelte Summit in particular. For example, when we started our Bit Discord, we took a lot of inspiration of how you do things and work together in the Svelte Discord. And when we did the first BitConf, we also like one of the main inspirations for the bit was Svelte Summit that was online at that point. Like we really like the vibe, the community spirit that you put on it. So, yeah, thanks a lot for Kevin and all the organizers. Like, it takes so much work to do an event like this. So, thanks. And I also wanted to bring a shout-out from Stagwit because of the BellKit playground tutorial that you push it as to do the WebContainer API and, like, to be able to run Node in the browser, and that really, like, unlock it a lot of experimentation later. And I'm going to mention some people in the talk, but this is not all the people that are around. These are some of the big contributors, and you might see some familiar faces. I just want to say that to everyone that collaborates in open source, we really appreciate what you do. This is all about collaboration. and 10 years ago Rich Harris sent this first commit to Rollup a next generation EX6 model bundler I think next week is going to be 10 years exactly of this first commit and Rollup ended being one of the most important pieces to me of Javascript tooling not only because of the project itself but also as a philosophy for build tools in general. It pushed web standards like ESM modules and also innovated on tree shaking and its plugin API was day and night compared to whatever was around at that time. Whoever had worked it with Resolve ID, low transform hooks, they know how powerful and flexible they are to customize a build. And if we go five years forward, Rollup was being used a lot by library authors. At this point, Lucas had to cover the project, and he was doing an amazing job with it. But there was, like, amazing pieces for the front-end story. Like, Webpack was king at that point. And this is where Bit came into the picture. Evan Yu paired the flexibility of Rollup with the speed of GoBundler, ESBuild, and, like, with very good defaults, and for all the common patterns that we were using at the time, and a very good snappy dev story with a bundle dev server, that it really felt magical at that point. I think it's a good thing that we got used to it, and now it felt common, but it really felt really special at that point. And VIT was not alone here. It was one of a new generation of tools like Snowpack and WMR from the Preact Fox and Web Dev Server Parcel, we can also count it. And they were all having a similar infrastructure, the way to work. And they share a lot of ideas at this point. And actually, the Svelte community was using Snowpack at this point. Svelkit was built using Snowpack. And I always say that we could be happy with any of them. We just needed to choose one. Because the ecosystem was ready to collaborate at that point. And Snowpack was working very well for Svelkit. One of the very interesting things that you did during that time is this idea of an unbundled dev SSR shim like to be able to reload modules in the server like similar to how we do it in the client and this like bit they didn't have that piece so Snowpack was flexible enough to provide for that and yeah I thought at this point that maybe Snowpack will be it Evan Yu like took a tour here and VidOne never saw the light So he, using the, like, old experience for the last year, and also taking the best ideas from other tools, did a sprint to create V2. And one of the big important things that he took is from WMMR, so the universal rollout plugin API. We did like you could write using the plugin API directly drive build and dev at the same time using the same exact API. With this it was a lot easier to remove all framework specific code away from the core. So there was in Vite1 some branches about Vue and React, and you may imagine that Svel was not that happy about that. And then also it took the unbundled dev SSR shim that SvelKit and Snowpack did together, and it adapted it to Vite and exposed it with a good API for everyone. And at this point, Vite was not only like a front-end tool, like starting to feel more like a toolkit to build meta frameworks. And this really, I think the release of B2 market like a change in the tides and Project is starting to lean into B2 and especially Svelkit that like reviewing after the release of B2 decided that to move from Snowpack to B2 and that will simplify a lot of the internals. And this sent a big signal to the rest of the ecosystem and one by one other projects migrated to VIT and all other tools. And around the same time that there was the announcement of Svelkit moving to VIT, the VIT team was created. Evan refocused on Vue for a while and we created the VIT team at the beginning because of the history of Evan creating Vue, it was very heavy on Vue people. But the first member that joined the team after that, in like almost immediately, was a member of the Svelte community And this was very intentional because we wanted to make Vita as framework as possible And it had to be Svel because that was the closest community to us after Vue at that point. And it started a tradition of shared team members. Jorn, for example, Bluey, joined the team afterwards, and he became one of the pillars of BIM maintenance. it is interesting to me to see the open issues growing with the new users showing in VIT and all the downstream projects instead of the NPM downloads we were having these exponential open issues and we saw that it will just keep going but Jorn at one point said enough is enough and in a few months he lead a bug sprint squash that took us halfway to 400 and VIT has stayed whatever we do, it stays like that. I think it's just a constant now. And another very important team of the BIT team and Svelte team is Dominic Xi, that you may know him for the work on BIT plugin Svelte or Inspector or a lot of the other things that he does around the Svelte community. But for BIT, in particular, one of the things he did is completely change the release game for us. So when we started to have all these massive amounts of downstream projects, we were starting to be a little bit worried about regressions. A lot of people depending on the stability of it, and stability was one of the best features we could deliver. and Dominic Chip using GitHub Actions and another repo ended up with a shim that let us run not like all the CIs of our downstream projects against Bitmain or APR before we merge it and we can see and we can decide we only merge, we only release when everything is green, not only in our CI but we know that we're not going to break anyone in the ecosystem, at least if they are testing and And this completely changed the way we work with other maintainers. Because we will detect that regression, we will decide if we have to revert or if we need to work with them, like with a fix. And this was very, very successful, and several downstream projects actually adopted. Like Svelte is having one like this, Vue, Naxx, Vtest,

 A ton of projects have the same for their own ecosystems. And I wanted to mention Ben also, because talking about ecosystem, I think he embodies this idea of ecosystem work. While working on SvelteKit, Ben actually went through all the dependencies, like not only VIT, like VIT tests, storybooks, like V-plug images, you name it. Whatever is below SvelteKit, he improved for the rest of the ecosystem. And you can see this also in his recent work in the E18E community, like this ecosystem performance initiative to clean up the ecosystem, not only in our project in Vita and Svelte, but absolutely everywhere. This is, for example, a difference between the dependency tree between Svelte preprocess, two versions. And him together with other people from our communities and from other communities are getting together and cleaning up everything, improving performance, porting to ESM modules only. So yeah, I wanted to shout out Ben and the community too. And Svelkit, so give a lot to VIT by adopting it. Not only this bundle SSR dev shim, but also because there was the need, like relative-based support was triggered by Svelkit, Rixo, added HMR, partial asset, for example, and I could go on. And also one important thing that I wanted to mention is this idea of a framework as a plugin. So for frameworks like Svelkit, like NACs, Astro, BitPress, in the Bit team we were saying you should do your own CLI because you will have full control, you can do whatever you want. And as well, kids say, no, like, we want to do a plugin, and like we say, like, you are not going to enable because it is not flexible enough. And you hack it your way out of that and actually made it work and proved that that is extremely powerful because shared documentation, shared config knowledge, like, there is a lot to gain from all of us using the same CLI for dev and build. And yeah some of that hacks actually we are finally going to be able to provide some better support from it And this is in the past two years we have been working to like the biggest overhaul of the API in VIT So getting back to this unbundled SSR scheme that we have, we always had two environments that are fixed in VIT. So you have the client environment and then this optional SSR environment that during dev, it always runs in the same process as the bit server. That was what bit provided. It was enough to actually drive a lot of innovation in framework work. But frameworks keep evolving, and now you can have several environments, not only two. and maybe you are using WorkRD and you want to have a better dev experience that is closer to production. So how do we model an app that has more environments? The answer in bit 5 is you can't. Frameworks were actually creating several bit servers to do it. And in bit 6 there is this new environment API that is experimental and the idea is that we are going to let frameworks probably users are not going to even see it but frameworks are going to be able to define all the environments that are going to be bundled with VIT and sharing the same plugin pipeline across all, the same middleware. And not only that, but we have this new concept of a module runner, so each of the server environments, you don't need to run it in the same node process as the VIT dev server. You can run it in a thread. You can run it in MiniFlare for WorkerD. You can run it where you need it. And this is going to be the new structure of the bit.deft server, so instead of just having these two fixed ones, you are going to be able to have any of them. Again, with the middlewares and plug-in pipeline share. And this actually allows us not only to have more flexibility, but also to do it in a way that ends up having better primitives that simplify the API. This is, doesn't matter the code, but our solve ID hook that we will get SSR boolean just to identify is this hook running in the client or in the server And it was a boolean because there were just two environments at that point But this will mean for example for the model graph you will always have to pass it And all these APIs they were added like afterwards in B2 so they were it was optional so it was very error-prone. People could forget to pass the SSR flag around. And it wasn't configuration across environment, it wasn't uniform. like if you have to for example grab result conditions you will have to branch you will have to say like if I am an SSR I have to go through this path of the config if not I'm going to go to the other and with environment API now we have a proper concept of what is an environment and we can in context give an instance of the environment that has their own module graph that is independent of all the others and you don't care like you could write now environment agnostic implementation for hooks You can just grab the module from the model graph. And the config also is the config of that particular environment. And you don't need to branch anymore. And hopefully the branch is now only for high-level stuff. And these APIs are also moving now that we have the environment abstraction into build time. so one of the hacks that the Svelte team had to do in Svelte kit was bit build will only build one environment and to be able to have a CLI that bit build a complete app, they will need to use like the last hook of the build and they hack it there that they start another build and now we are going to be able this is a built up hook it's going to be able to be in bit 7 like in a week or so and the idea is that a plugin can define, okay, these are the environments I care about and this is how you need to build them. And you can decide, you do it in parallel, which one go first, do things in the middle of them. And one thing that is important, this is still experimental. It helped a lot to simplify stuff. Our own internal plugins, for example, got a lot better. and now when Svelkit will adopt it and start to experiment, we can still make it more flexible, we can still, like, improve it. We are not going to... This is... Because this is the biggest API change, we are not going to be like very fast and stabilizing it And talking about this idea of API changes and what is the API of Bit I think that this is what mainly a framework or a tool that Adopt Bit is adopting when they Adopt Bit. The API is what is really important, and then the implementation can change over time to support that API. Apart from Brolap and ESBuild, for example, at the beginning, we were using a lot of Babel, like, for example, for React, the plugin was using Babel, and PostCSS, if you were doing CSS modules, for example, and as there are new projects that are faster, we can start to change the internal implementation without disruption for all the ecosystem, or when there is, like, changes that make sense to make the life of everyone better, we can work with the ecosystem to move forward together. And so one of these changes from the Parcel team, we got Lightning CSS, that is a RAS implementation of, like, similar to post-CSS, and VeeD was able to provide it, so to speed up CSS processing. and then, for example, SWC was starting to be used in BitPlugin React and RollApp is starting to use SWC also to speed up itself and this was all performance improvement that everybody in the ecosystem felt without the need for changes. And there is still the implementation is there is need for more because it is still quite complex especially we have RollApp and ESBuild that are two bundlers and they all have their small differences and what we really need, if we could wish for is a bundler that has the flexibility of RollApp and the speed of ESBuild and this is what the Voice Zero team has been working on for the past year and a half or so and this is going to be RollDown So, rolldown powered by OXC is the best attempt to keep rollup compatible API, but it's ported to Rust and it will have the speed of ES build. And this will heavily simplify the implementation of it. And again, the idea is to move everyone with us.

 keep the API as stable as possible in the way. And this is not just some kind of science fiction. There is a fork of bit called rolldown bit that you can use right now. You can do a PMPM override. And you will need some environment variable. You can read more in bit.dev slash rolldown about it. But these slides are done with Isabel kitab running Animotion, and I build it with rolldown bit. Like, this is not using ES build or roll up at all. And the build is a lot faster. I will let the roll down team, and as well, kit has already appeared to solve something so they can share the statistics. But this looks very promising. And to me, like, as we started with the talk, like, this idea of the plugin, roll up plugin API being so powerful and so flexible, I always say that maybe after Bid there came another bundler, another project, but that I hope that we will use the rollup plugin API because it's awesome. We already find it. This is how we should work. And I think with rolldown, this API, the rollup API, will continue through the next decade hopefully and powering like our projects And yeah so this relationship that we have between our communities have, like, helped it, first, VIT at all, a lot, because it's felt, like, adopting VIT, like, made VIT so much better for everybody else, but this is a story that is repeated across, like, all the other projects that are using VIT, And everybody that ended up adopting this new share layer, like Rich Harris in a Bitcoin previous say, like the department of infrastructure, that is not that fancy, but really it helped to end up powering a huge ecosystem of tools that we can all end up working together to, yeah. actually at the end, remove the need to think about how we build and focus on what makes each project different. So I really look forward to see where this continues and how much we keep working and collaborating together. So thanks a lot. you