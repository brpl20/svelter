 Hello, SvEAT community! I'm going to talk to you about how you did elevate the developer experience of using Storybook Post-Fate. My name is Mateusz and for the concept of this talk, I'm just a Storybook contributor. Let's briefly introduce what is Storybook. For me, it's a tool which enables me to have a productive workshop to develop, document and test UI components and page and isolation. And that means I don't need to worry about running the whole application architecture to start working on them. And inside the Storyboard, I can cover every possible visual hk's and write tests. Storyboard also has a very rich ecosystem. Recently they announced an integration with VTEST testing framework, and that's quite exciting. Ok, let's move on. This code example shows how do you write the stories for Sv8 in regular format. And I'm gonna show you a quick preview on what is produced in practice. Now, please just try to remember that in this regular format we can see the export default meta as well as export objects. objects for each story. Right? And since Storybook is a catalog, this is a headline that helps populate the sidebar on the left. We got that, right? So, what if I told you that you can write stories using space syntax? That would be awesome, right? And yes, it's possible. to this add-on which allows us to achieve that. And to make it simple, I'm going to call it Spade Format. Now I want to show you a difference between regular and Spade Format. On the right is the regular one. And on the left is Spade. There is no somewhat difference, right? And that was intentional, because this add-on is supposed to adhere closer to the Storybook API. So there's less confusion, less surprise, and more consistent. In the regular format, the stories are objects, and in the space format, stories are components. Still, you might wonder why we wanted to make it possible. Two reasons. using the space syntax language I am no longer limited to use for example space blocks such as if loop if condition or promise with await And the second reason is that I can leverage sprite feature I am talking about reactivity binding runes etc I am no longer limited to what I want to be displayed inside the story because of the JavaScript language syntax. And about space 5. Recently me and JPEG from Turbo Core Maintainer Team did a ground reflect on this Turbo addon to support it and it better its paradigm. So the challenge we encountered and the lessons we learned are the reason why I am here talking to you. So finally let's hop to this question. How it works? Ok, so the first challenge I want to talk about is how do we communicate the storybook with stories are in the stories spelled by. As you might remember that in the spelled format, we don't have any exports at all like in the regular one. So how do we send the satellite crucial data so it can populate the site back on the left? Luckily the solution for this case is quite easy. Firstly, the Storybook has an indexer API. So, what you need to do is to hook into it and use the parse function from the Svelte compiler module to get the AST, and it means abstract syntax tree. In practice, it's one big scary object with a lot of the syntax nodes. But, it doesn't have to be scary at all. If you already had the chance to play around the Svelte 5 playground, you might already show it and I'm going to show you. Okay, on the left, there's fed code format as input. Please notice that on the Rain pane, there's desktop called ASD output, and this is what we are going to use for this particular case. It's very usable because as soon as you for For example, hover on the module property, we get the script tab, highlight, and it's a body score. Or, for example, when we hover on the fragment, all of the stories in the score will get highlight. We can go deeper than that. For example, if I wanted to find the first story in the fragment, we can go to the second item. For example, if we want to extract the name attribute and it's literal below, we can go into the component attributes and find the attribute color name, then extra this value which will be primer. This is nice, and this is what we are going to use for static analytics for this add-on need. What I show you was a base foundational knowledge on how you can explore the space LSD. Back to the solution. Lucky this frame maintainer creates also a really nice package called a similar frame, which allows us to do some really convenient working on the AISD object and extract the particular nodes for our needs Okay time for another challenge Very major one What we did before, it didn't enable the storybook to render the stories correctly. And what I am talking about is the body of the storybook, and this is what it looks like, to remind you. So, the challenge is that the space has adopted a concept of the single file component. And how it updates us in practice, I'm going to show you using the space file playground. In the playground, on the RainPane, the second tab is called JavaScript output. And that's where we can find our compiler output. Now, everything that we write in the storage space file becomes one big-man function, which is one component, and is exported by default. And that's a problem, because the Storybook engine has no idea what's at all with this one. To quickly remind you, in the regular format, we defined our exports, for example the meta or the storage, and that's how we tell Storybook what to render. And this is the reason of why we have to transform the compile output. And BID plugin API can help us with that. Thanks to Jeper, I learned that there's really nice debugging tool which I am going to use and explain better of what is happening inside this atom. This is how this inspector tool looks like. Let's focus on the button storage field file and click on it. On the left sidebar, we can find the transform stack, and it has every plugin which shows from the first input to the last transformation. We are going to focus on this storybook add-on plugin. On the left, we can see the compile output. And on the right, there is our transformation that is happening for this file. It's like this deep preview. Quite convenient, right? So you remember that in the regular format, the each port default is meta, but in the compile-out port is the main component function. So we have to remove this line and then replace it with meta. But where is meta? And this is where we do the heavy lifting for you behind the scenes to help you focus on writing stories, to improve the developer experience. Anyway, what happened to the meta is that we are destructuring it from the defined meta function call. And then, at the end of the transform compile output, we add the export default meta. Okay, now the story. They need to be exported to ride. But where are they? We shall make a good guess if we remember the concept of single file component that they live inside the main function scope So, the first story shall be there, the primal. And there it is. And the second story, small, is there. But the question is that given they live inside the function scope, scope. What do you echo them? Okay, so we can see that everything that is happening in the main component function scope, everything that is happening here, I'm making a white guess that what is happening here is related to the reactivity, binding and templating. We don't need to understand in depth what is happening here. Anyway, what we can do about this? Create runtime stories. This is a fancy name, GreenInventByGeb, to help us understand better the purpose of this function. We don't have time to explore more in-depth what it does, so that's why I'm going to skip to the end of this transform output. You can notice that I'm importing the GreenRandTimeStories function and then use it to export every storage we define in the first storage file as component. And this is how we solve this problem. And now this is my take you away to understand what is happening here and it's quite advanced even for myself. Regardless, you might have noticed that we We didn't really modify the mine component function a lot. We just add more exports at the end of the compile output and allow it to break out the paradigm of space, which is single file component. Now I wish I had the more time to explain the rest of the transformation, but I have to move forward. Finally, just brought to start with some takeaways. Firstly, I hope I got you some inspiration on how you can do some AST transformation on the speed compile code or the input. It doesn't have to be scary at all if you have the right tools. And this is how you can improve the developer experience of your projects. And even the obstacles such as the first single file component doesn't have to block you from doing it. And lastly, I want to buy some excitement because as soon as this fake pipe is out of the RC, I hope it's soon, then this TurboCanton to help you write stories in this file format will be shortly ready. And by the way, you're going to have the support for the legacy API, so you can still have the stories in the OIS syntax because they are supposed to still work. We got your back there and you can already try it out in the next version of this talk. So if you have the time and opportunity to try it out, please do share with us what do you think. Thank you.