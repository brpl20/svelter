 Hey friends, what's up? In a previous video we made a screen recorder using just browser APIs and Svelte which you can check out if you want. So we get these beautiful WebM videos but unfortunately the reality is that a lot of things like social media prefer MP4 videos so that's really inconvenient for the user to have to convert those files. Which you can simply do. If you're familiar with ffmpeg it's really an awesome utility. So you can say ffmpeg dash i and then you can give it the video so video webm and the output you want and it should be done in a second. So this is really awesome, but it's really not a great user experience to demand for them to have FFmpeg on their system, right? And to do this, but we can use FFmpeg in the browser thanks to WebAssembly. So today we're going to make a video converter using FFmpeg in the browser and Svelte. So let me show you how cool this is. So I can just drag over this file and we get this drop zone. So now we have this cool transition. Alright, so the video is done, so we can save it, let's replace it, and that's how simple that is. Alright friends, but before we get started, don't forget to like and subscribe, and you can also support me by becoming a patron. Alright friends, so let's start from scratch, and if you want to follow along, you can go to your terminal, and you can just type npm create swelte, and this is going to scaffold a swelte kit project. And you can use npm or pnpm, doesn't matter, in this case I'm just using pnpm, so I'm going to do that. and here I just have some defaults in this project so inside of this layout I'm just importing some styles which is just a regular reset here I just have some global CSS variables and some default values so you can just copy this over in a couple of seconds if you want but yeah that's basically it so let's get started all right so first let's create a script tag and then let's define a state so this is optional if you're not using TypeScript so let's think about all the possible states of our app so first you want to start in the loading state because we need to load the fmpeg binary so when that is done we can say that it's loaded so our user can drop the video right now and then let's for the conversion say convert start so we know when we start the conversion and then in case of an error maybe we can say convert error and then when it's done we can say convert done so now let's define the state of our app so we can say let's state and then by default is going to be loading and then i also going to add an error state which is going to be empty so whenever we have an error we can show it to the user So we going to need a reference to FFmpeg I going to say FFmpeg and this is going to be just to type FFmpeg And then we're also going to track the progress of the conversion. So we can just say let progress, but we're going to use a Svelte tween store so we can animate the value over time, which is going to be really cool. So I can just start typing tween, and this is going to be imported from Svelte slash motion. and then we can give it a default value of 0. Alright, so next let's work on the markup. I'm going to add a title H1 and then I'm going to say WebM to MP4 Converter. And now if I save this, we're going to see we get our title here. So now let's specify the drop zone and that's really simple. So let's first create a div and now inside of here first I'm going to say on drop and now we can use this pipe symbol and we can say prevent default so this is really a nifty shorthand in Svelte and then we're going to create a function handle drop and we need to do the same for the drag over event but in this case I'm just going to say prevent default and then I'm going to give it an empty function so I don't have to create it prevent default in this case is going to prevent the default browser behavior which is when you drag a video or a media file inside your browser it's going to try to open it, right? So that's the default behavior. And let me just create this function here. It doesn't complain. We can say handle drop. And now as you can see if we hover over it it's complaining about some ESLint rule which I really don't care about right now. So I can copy that Lint rule. I can go here. I can create a HTML comment and I can say svelte ignore and I can paste that rule. another thing I'm going to do is use the data attribute later for styling so I'm going to say data state and I'm going to assign a state to it and lastly I'm going to give it a class drop and since we're using explicit state now inside of our markup our job can't be any easier so here I'm going to use this if snippet so now I'm going to say if state loading in this case we can use a p tag and let's just say loading ffmpeg and let's also use a Svelte transition, so we can say in, so when the element is created we can say fade and this is going to be imported from Svelte if you look at here so how cool is that let me just move this up so we have fade and that how simple that is alright so now we can just copy over these blocks so that was the loading state, so when everything is loaded, we can say drag video here, so let's go to the next state, alright, so now if we're converting the video, we can say convert start. So in this case, we can say converting video and we can make a nice progress bar. So let me just go here. I can say progress bar. Now we're going to create this div and let's create another one inside, which is progress. So here is something really cool that we can do. So since we're using a tween store, this value is going to get animated over time, right? So now we can just pass a CSS variable to animate the width of this element. So we can use the percentage for that. and we can use this shortcut, you can use this attribute, you can do it inside, but Swell has this neat shortcut, style, colon, and then we can say progress, so this is the name of the CSS variable, and now we can say, let me just do it like this, we can say progress, and this is a store, we have to use dollar sign, and then we can just use the percent sign, and then for the store here, we can again use this, we can say progress, and we can say to fix zero, so it doesn't have decimal points, right? And then you can also give it a percent at the end. And that's how simple that is, right? And we're going to see how this works in CSS in a bit. And then if... Let me use an if block again. I can say if state convert done. And then we can just say... First I'm going to use this confetti library so I can say div use confetti. So I'm going to show you that in a second so that we're going to use NeoConfetti which is a really simple library. So this is just a svelte action. and then we can give it the speed tag. We can say in fade and then we can say done and let's just give it an emoji. We can say ta-da. And if you don't have it installed, you can use PNPM or NPN, whatever. So you can say PNPM add at Neo Confetti Swell. So you can just install that and that's how simple that is. And then you can just go here to the top and you can say import confetti from Neo Confetti Swell. and that's how simple that is. And I think that's it for the state and now we just need to log an error if it exists. So we can say if error and then let just log it out Use a p tag and we can say error we going to give it also a class error and let's say also in fade also so now we can save this and the only thing I'm going to do I'm going to copy over the style so I don't have to type in here for half an hour right and there's really nothing special I'm just centering this title here I'm going to define this drop zone give it a width height some padding using good old CSS nesting, nothing special here. And here for the progress bar, I have some CSS variables that I'm using, nothing special. So this is just a regular progress bar. So the interesting thing is here that we're going to pass in progress as a CSS variable. So here where we have this progress bar and the progress itself, we're going to set the progress for the width, right? So how awesome is this, right? This is really simple. All right, so now if we save it and preview it in the browser, we're going to see now we have our UI. so now we can move on to the next part and also let's keep track of the state right so that's fun so we can go to our script here and let me just scroll up and I can say $ console.log so I can console.log out the state and as you can see the only state we're in is in loading alright so let's implement the drop feature and of course I can never spell confetti properly alright first try let's go so let's really talk about the drop zone and for that i'm going to go to mdn and of course all of these links are going to be in the description so you can read this if you want and we already done what they told us here so we added these events and they now show you how to handle the files and this might be intimidating if you never use this before because now we have these two methods that they really don't explain really that well to be honest so you have event data transfer items and event data transfer files and this is something i see often people have these analysis paralysis they think they have to always pick the in quotes right thing but there is really no such thing just pick whatever works and if you do some research for example what is the difference between data transfer items and files you're going to see that it supports things like subdirectories it's a newer api but it's really not important do you need subdirectories no right and you're going to see just pick the path of least resistance so i'm going to show you that in code what do i mean by that so let's just go here and i'm going to say here event is going to be drag event i think so now we can console log event data transfer so now we can just see what we have this is what you always have to do just console log out everything

 And let me just open this file. So now I can drag this video. So I can get the file info. And now we can see, okay, here we have this data transfer thing, right? So now we have files and items. These don't look really useful yet. So maybe you go back to your code. And then we're going to say items. And now again, we can drag this. Then we can see what we get. We again get this scripted thing, data transfer items. So we have to do more here. And then probably, okay, what if I just pick this folder API files? what happens then let me just clear this drop all right and now this immediately gives you what you want end of the story right so pick the path of least resistance right is this going to make your app 10 times worse i highly doubt it right so there is really never a wrong choice you can make unless it's leaking your user's personal information that is a story for another time maybe yeah you can just pick this and that's it so now we can use this without worrying about these things let's just also limit this to one file so I'm going to say if event data transfer files length so I'm going to say if it's higher than one then I'm going to set the error to upload one file and that's going to complain so let's go here I'm going to say event data transfer so if this doesn't exist then we're just going to return alright so now it's not going to complain anymore let's see if our state management works so I'm just going to copy over this file let's create two and now when I'm going to drag them, upload one file awesome, so now this works and again now we can gleam more information, so for example I want to limit this to just be of type webm, so we already saw that information, right? So that is really simple to do now, so we can say if event data transfer files we're going to pick the first one because we always assume in just one file, otherwise it's an error, right? and then we can say type and we can say video webm In this case, we're going to clear any errors that we have, and then we're just going to get the file. So we can say const file, event data transfer, files, and let's pick the first file. Or you can use array destructuring. So in this case, you can just wrap this file into an array. You can name this whatever you want, by the way, it's not like object destructuring. So you can give this any name you want, like file. And let's see if this works. So now when we console log this out, Let me just drag and drop this video Awesome That it Now you have everything you need to move forward right Always pick the path of least resistance And then we of course need to make sure this error state so otherwise else if the type isn't video webm we can set the error to only webm is supported. That's how simple that is. So maybe if I go here let me just new document if I create an empty file let me just drag this in only WebMU supported so you can see even that works and let me just delete these things so they aren't bothering me and yeah that's it alright friends one more thing I want to mention is that you can always gain a deeper understanding of these things so for example what the heck is this file type right so if you go to these docs here there is a link somewhere for this and then you can open it in MDN again and then it says it here that the file comes from using drop input and etc. And then you can literally find out what it means here. A file object is a specific kind of blob. Blob, mysterious, right? You can maybe now go further and investigate what is a blob and can be used in any context that a blob can. And here you have some foreshadowing because it says in particular, file reader, url.createObjectURL. That's interesting. Maybe we're going to see that later, right? But yeah, that's it. That's how you learn about these things. All right, friends. So now that we have our video, let's set up FFmpeg so we can go to the FFmpeg site you can go to try it now and here is a bunch of cool examples but let's go to their docs and see how to set it up so we can see getting started and then we can see installation so we can do it using npm or pnpm so we can install FFmpeg slash FFmpeg at utils but there's going to be one catch and that is that FFmpeg utils won't work for some weird reason but I'm actually going to show you to not be afraid of looking at a source code of a library so we're just going to yoink their code and it's going to work as expected and we're also going to learn something in the process so actually let's follow their advice inside of my terminal i'm just going to end everything and i'm going to use pnpm i'm going to say pnpm add and i'm going to say ffmpeg slash fmpeg and i'm also going to install utils just so i can show you the problem and yeah that's basically it so now let's just start the development server and let's look at So you can see here is an example which uses React. And you can see sometimes you don't know how lucky you are. Unless you already using React then I feel bad for you What the heck is this So they using useRef here to keep a stable reference to the FFmpeg instance right Because this React component constantly re My question is though, can they just define it outside? But anyhow, that's just a wild tangent. But as you can see, it's really not that bad. So here they're going to, they initialize FFmpeg and here they're going to use this base URL because they want to load the core later because it has 10 megabytes or something so we don't really want to include that as part of our bundle and we can also see that we can add event listeners and then we just have to use this fmpeg load so we can load the core and the vasm right and then we can transcode it here and it's really not that difficult so this default example is single threaded but there's another example here that is multi-threaded so it's going to be way faster but they ran into some issues trying this out but you can see it's really not that different they're using core dash mt and they're specifying this worker here so now transcoding the video is going to be a lot faster in the browser but yeah that's really it so we're going to look into how that works all right so the first thing we actually have to do is initialize fmpeg so i'm going to create this simple function function load ffmpeg that's going to be it so now let's actually go to the top and i can load fmpeg here i can say import fmpeg from fmpeg awesome so now we have this imported and now when we go to our function here we can first create the base url so we can go to the fma documentation let's just go here and again this way reading the docs is important because we're using VIT so we need to use this ESM version easy peasy. In the future I would actually prefer to download these files and ship them as part of the bundle because I actually don't care. It's better than doing it over the network like this. Alright so now we can reassign our FFmpeg so we have a global reference to it right? No use rep here boys. Oh my god. We can say new FFmpeg so that's basically it. And then we can say await ffmpeg so we can use load and then we can pass it these things and you can see in their example they're using this to blob url which is again some helper but in this case i actually realized i don need it but again if you encounter this problem later then just use this to blob url but what i prefer to do i just going to copy this over And let me just do it like this And I just going to remove this code since we don't need it. So we just need base URL to point it to this file. So now we can save this. And now we can set our state that it's loaded. So we're downloading fmpeg. We can say loaded. Boom, that's how simple that is. alright so let's see if that works but first we have to invoke this so we can use on mount and then let's pass it as a callback and we can say load ffmpeg now when we save it let's go back to our app so now let me just load this and if you go to the network tab we can see you're going to run into this problem so again this is just part of live development right you run into this problem you really have no idea of what the problem is here right because the docs actually don't explain it but actually the reason why you run to this problem because you need to enable some settings in the vid config and how do you figure this out well for example you can go to their examples and look here they have some vid example so you can open this and then you can make some assumptions right so we can go here and then you're going to notice in their vid config they have this optimize dependencies so they're excluding ffmpeg so this is the reason why this is happening and you can also include this server thing with the headers and that's really trial and error sometimes right because that's how you solve problems so now let me just go over here and here's your bit config right so you can open this and you can just paste it here cool so let's save this and i can close this file so now we're going to see when i go here to the network tab ah you're going to see we don't run into a problem anymore and now our state updates that's just development for you right? So we can see here is really interesting. So it's 9 megabytes. This is why we want to load this later, right? So this is loading our state updates and how beautiful is this, friend. So let's go to the console. As you can see, let's just refresh again to see what's going on. So here we have our loading state and then it's loaded. Boom. So now it's faster than it's cache, right? All right, friends. So now we can work on converting the video. So here in our function where we get the file, now we can do whatever we want. But I want to make a convert video function which returns some data so we can download it later. But in this case I'm just going to say const data await convert video and we're going to pass it this file that we got. And we need to make this function async now.

 and above we can make this async function so we named it convert video and it also accepts an argument video wishes of type file so now we can set the state since we started converting the video to this and now we're going to run into a problem so i already told you about this when we go to their example let's go to the the usage. So as you can see here, they use this helpful utility. So they use write file and they use await fetch file, which is imported from this helper fetch file. So that basically just turns this file type into a uint8 array or whatever is the name, right? Because this thing expects it, right? And let me just really show you what I mean in code. So you're going to understand it. So for example, if you say await ffmpeg write file. So now we're going to write this file in virtual memory I think it has some file system I know and now if you press here you're going to get this type data file data and now if you go over to the type we can go here to this data so we can immediately deduce what file type it wants and then we can reverse engineer it back how we have to convert this file right so this file data is uint 8 array or a string right and then you're like okay then you maybe google how do I turn file type into uint array alright that's basically why this helper exists that's why they use it in their docs this is what this does and you just learn this by reading the docs, right? So this is what they use, fetch file, but they're going to run into a problem. So let me show you what that problem is. So if I go back here in this code, and just by importing it, it's going to break everything for some reason, right? So we can say import, it was fetch file, I think, from ffmpeg util. And then let's just save this, and we're going to see our app, let me just refresh, our app is actually going to crash. So now when we open the terminal, it has some problem with this import, right? Which is really weird. So it has this weird error, cannot use import statement outside a module. And again, this is the story all this time about problems with modules in JavaScript. So now you probably look for this on the internet, right? And then I found actually an issue where someone else using VIT or SvelteKit, right? Has this problem. And they said, okay, I have the same error, right? And I'm like, okay, someone probably gave them the answer. Do you want spoilers? their answer is downgrading to an older version. Yes friends that development Nice All right so the next lesson is don be afraid to dive into the source code So here in their GitHub for fmpeg here is fmpeg.vasm packages so you can find their utils. Here are the utils so you can go to the source and then you can open this file. You can search fetch file and you can probably find it. Okay, cool. so now you can just spend a minute reading this and then you can see okay here it is we have a file type right so else if a file instance of file oh so they're using this function read from blob or file okay cool so this file is actually defined at the top and now you can do two things you can either yeet their code which really isn't the problem you can just save it anywhere you want or you can just implement it yourself and now I'm actually not going to use this package but again let's go back to our function here so now I'm going to create another function I'm going to say const video data await I'm going to name my read file right and then I'm going to pass it this video right and you can copy paste it over but let's actually learn something so I can say async function read file and it accepts a file resolve the type file, right? And then it returns our result promise uent array. Cool, and it's really not that hard, right? So we can say return new promise, resolve so we have to do something and then resolve it. So now we're going to create the file reader you can say new file reader, and you can hover over it and read what it does so it basically lets you read the contents of a file, so raw buffers stored on the user's computer, etc. using file or blob. So this is what you're going to do to convert this type into a UINt array, right? Or however you pronounce it. I have no idea, to be honest. So we can say file reader. So we can say onload because it's the same thing they've done in their code. So now we can destructure the result from the file reader and then we can just resolve it. That's it. So we can say resolve and we can create a new UINt 8 array and we can pass the result so we can just change it into that and it's going to go plain because it has no idea what this is so using TypeScript we can say if result instance of array buffer and now it going to be cool with us alright great so now that on load so we can just make one for an error so we can say file reader on error, and let's just assign an error, could not read file. That's it. So you can actually learn a lot just by copying over the code, and I don't mean like copy-pasting literally, but just try to read the code and understand what's going on, it's actually not that intimidating. So now when all of this is done, we can say file reader read as array buffer. And now we can pass in the file. That's it. Boom. Done. As you can see, it's really not that intimidating. It's a couple of lines of code. At the worst, you could have just copy-pasted there example. Alright, so now we get this thing. So now if we log out video data, let me just go here. So now we can see we don't get any weird errors. Let's just drag our video. So now we're going to get this u, e, enter, race. So this is really this raw data of our video. But let me just refresh this so I don't burn my eyes. But yeah, as you can see, it's really not that bad. Alright, so now actually this was the hardest part. Now we can just use their example. So now we can go here and we can do the fmpeg part, which is really simple. So we can say await fmpeg. So now we have to actually write this file to this virtual file system or whatever. We can name it inputwebbm. It's really not important. And we can pass this video data which expects this to be of a certain type right and now we can say ffmpeg execute and now we can pass it the same command prompts so we can pass it an array so we can say i we can say the name of the file webm and we can also name the output file and now we can say cons data await ffmpeg so we're going to read the file so now we can give it a name you can name this video mp4 if you want. Actually I'm going to it has to be the same name as you gave it here. So you're going to read this as output. And when this is done you just reassign convert to done. Alright. How cool is that? So now we can return the data as a UENT array, right? That's how simple that is. Alright. So let's save this file but let's also log out some things because we actually have no idea what's going on. So we can do that easily if we go here where we initialized FFmpeg and let's just make some space. So you have two options here We going to use on and then you can pass log or progress We going to use progress in a bit to show the progress right but let me just first show you log so we can the structure message again this is in their docs i didn't make this up right we can say console message and let me actually just show you this so if you go to ffmpeg in their example here is a log somewhere let's see yeah here they use logs so you can see you can output this however you want all right but let's actually collapse this i'm going to refresh everything so now let's see what happens when we drag in a video so now this is loaded boom and now you can see this really looks the same as your terminal output but you actually have no idea what's going on right when you look at this like that because it really has no progress indicator and that's why i'm going to refresh this so let's cancel that and instead of doing that let's use progress and another thing you have to keep in mind when using progress some videos might not have metadata so you're going to get some weird issues right but most videos have metadata thankfully all right so let's just do this again we can say ffmpeg on and now in this case you can say progress and now you can just do this and now we can reassign our store progress in this case we get this event right so we can say event progress cool and now we can multiply this by 100 let me just really show you if I say awesome log and then progress awesome cool so now this is loaded so now here we're going to see this is where it gets output so we get these decimals here and here we're going to convert the video so this is why you're multiplied by 100 and that's how simple that is right and we're almost done friends we only need to implement a download feature. Alright, so implementing the download feature isn't anything new if you watched the previous video, but basically we just need to go here where we receive this data. So now that we have this, we can create a new function, download video, and we can pass it the data. And above here, let's just create a function. So you can say function download video. It's data of type uentharray. So now we just need to create a link element. We need to assign the ref of that element to some blob, right? Which we received. And now we can assign the label to the link and we can download it. So let's do that. We can say const a document.

 create element and now we can say a ref and now we can use this url if you remember our foreshadowing previously we can say create object url and now we can create a new blob we can just say new blob which accepts an array of buffers this thing so we can say data buffer and we can also give it a type in this case the type is going to be video mp4 all right so now we can give it a label by saying a download you can name this whatever you want i'm just going to name it video mp4 and the last thing you have to do is say a click but i'm going to use set timeout just so we can get our confetti animation so i'm going to say set timeout i'm going to give it one second and here i'm going to say a click and that's it so now we can also go here and let me just remove this console log so we can see what's going on and now i'm going to refresh everything let me just drag this video so you can see loading, loaded, how beautiful is that? Boom, let's drop the video, conversion started. So now it shouldn't take that long. As you can see, now we have state updating, so do our styles. And this should be done any second so now we should see our confetti and how beautiful is this friend so now our conversion is done we can download the video, and we can even check if it plays, so everything looks great, how awesome is this friend, so now we can close this, and let me also show you one thing, so you might be wondering, okay how do we change these styles, and remember here in our code, we set this data state to state here, and now one thing I didn't show you in styles app.css here we have this global CSS variables so now we set this for the body as the color the background color and now we can use this has selector so now based on the state we can change those variables right? How beautiful is this friends? Alright friends if you like what you've seen don't forget to like and subscribe and you can also support me by becoming a patron thank you for watching and catch you in the next one Peace.