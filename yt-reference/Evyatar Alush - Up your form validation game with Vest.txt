 Thank you. As users of the web, we often come across forms that are so hard to use that it almost feels intentional. For example, when you type in one character in one input field and suddenly all the other fields light up as well as if they have a validation error inside. Or when it doesn't matter how much you try, you just can't seem to be able to submit the form. And I have just one question for you. Do forms on the web have to suck? Hi everyone, I'm Evyatar. I'm a front-end engineer at Meta and I'm the author of Vest Validations Framework. If you want to check out the stuff I do, you can go to my homepage or GitHub profile and I'm also on Twitter. Today, I want to talk to you about how you can use Vest to improve the way you write form validation in your Svelte apps. And Vest is an open source form validation framework. It's framework agnostic, so you can use it with any UI framework out there. and it's highly inspired by unit testing libraries like Mocha or Jest. So if you've used either, you'll feel very much at home working with VEST. But before I talk about VEST itself, I first want to mention some of the problems I was facing that led me to write VEST to begin with. And I think there are three main problems. First, when writing for validation, there is a big lack of structure. We're never sure where to put the validation code. There is no coherent structure the validation should be written in, especially if we have multiple validations that some of them are feature specific, some of them are not, if we have fields that depend on one another. And eventually we do make it work, but everything becomes very feature specific, tied back and down to the feature itself. And it is very hard to separate. And when you come back to maintain the form like months later to add more fields that you didn't plan on or change the logic in a way that you didn't think you would need to do in the future, you sometimes have to actually refactor the feature itself, just to accommodate for this tiny validation change. And because forms are the interaction heavy parts of our apps, they are also very hard to test. Because everything we try to do, for example, if we want to test fields that depend on one another, or some conflict between fields, we first have to simulate the user events. And these are very costly, so we end up not doing this. And unfortunately, forms are the interaction heavy parts of our apps. So this is usually where our users face bugs. And our users deserve more, I think. And a couple years ago, I thought about fixing this. And I thought, what would the ideal solution be? And the ideal solution has to accommodate for all of these. First, it has to be separate from the feature code. So it cannot be be feature specific, and it shouldn't require feature effector just to make a change. Second, it has to be very easy to read very easy to write and very easy to understand. And back in the day, I was learning first about for unit tests with Mocha and later with jest. And the similarities struck me because what we do in unit tests is essentially what we want to do with form validation. We have our functions that we run through a series of tests to make sure they behave correctly. And this is separate from the feature. And when we work with form validation, this is exactly what we want to do to our data. We have our data that comes from the inputs and we want to run it through a series of tests just to make sure the data is written correctly. And I tried to use this same pattern for form validation. And I came up with something very nice, I think. First, we have our form validation suite that we create and inside of it we have the suite body. The suite body has the different tests and these are very similar to unit test tests, only that you specify the fill name that you're validating, the message that the user would get in case of an error, and then the validation body, the test body. And it looks like this. we have our enforce, which is very similar to just expect or assert. And you enforce that some value matches some criteria. And apparently this works perfectly for form validation. And I want to show it to you in action. What we have here is a very basic Svelte form It is not connected to VEST yet and we going to do it now So I show you the form We have two input components and one submit button And the input component is very basic. It has an on input change handler that all it does is just passes the name of the field that we're interacting with. And we have a few more props to the input. So we have the pending prop that shows a spinner in case of an async validation. We have a validity class that gives a class name of either errors, success or warning to the form or to the input. And also we have a messages array that takes an array of strings and when added, it shows a validation message to the user. This is all we have at the moment. Let's try it in our form validation. So first I'll import in a new file create from VEST and I'll create my new suite. So const suite equals create and it takes a callback and let's initialize it with an empty data object. And now this will be the data that we get from the form. Now let's export default suite. And also let's write the first test. So this will be for username. So let's import enforce and test. And now let's do test that username. Let's say username is required. This will be the message the user would get in case of a validation failure. Let's do enforce. The data dot username is not blank. Now, this does not do anything yet, because we're not connecting it to Svelte yet. But it should be very easy. So first, let's import our suite. So import suite from suite. And let's get the validation result from the suite. So in a new variable, let's do let which will be our validation result equals sweet.get. This has the most up-to-date validation result. And also let's connect it to the form, to the input. So let's do messages equals res.getErrors or the field username. Now, all we have to do is just on change, run the validation. So let's do inside of it, let's do res equals sweet and pass it our form state, all our inputs. So form state. Now, if I type inside username and remove it, we'll see username is required. Just like that. Now that was easy, but this is a very simple validation. Let's make it more complex. So let's add a few more inputs or a few more tests. We can add another test for username, for example. We can have multiple fields for the same validation for the same field, but not in the same function, which is very easy to read. And you can see what is failing very clearly. So let's do instead, username must be at least three characters. and let's do longer than and let's say two. Now let's duplicate this for password as well. And let's say password must be at least five characters because it should be stronger. So let's do longer than or equals. Perfect. Now let's connect the password field to it as well. And if I type inside username, we see the validation for username and we see the validation for password. But you saw this as well, right? When I just typed inside username, we got a validation message for password, which is okay when we hit submit. It's okay when we write the validation for the server. But this is not good for regular user interaction. And fortunately, this is very easy to handle. VEST allows us to specify which fields we want to validate. And this is really easy. So in our change handler, we have the name of the field that we're validating. Let's pass this data to the suite as well. And let's also accept it here. So field name, let's say field name. And now I'll take the only function from VEST and only allows us to specify which field we want to validate. And here, let's do only field name. And now if I start typing inside the username field, only the username field is validated. And if I type inside password, only the password field is validated. Now I promised you callers with the error messages, the error class name and everything. So let's do it. VEST is not a UI framework but it does come with some UI helpful utilities like class names And what class names does is it allows us to specify a valid validation class name to show it any validation state. Let's see. Oh, class names. To show a validation class name at any validation state. So what we do here is we can specify a few class names to show at any stage. So for example, let's do a CN. CN is what it gives us back. Class names gives us back a function, and it takes the validation result. Now let's do, let's do when it's valid, we'll show success. When it's invalid, we'll show error. And when it's warning, let's show warning. Now, all we have to do is pass it over to the validity class. So for example, in our input component for username, let's do validity class and say CN for username. And let's do the same for password. And now if I type inside the username, it's getting green. So I must have an invalid type of typo here. Okay. So it becomes red. And if I type inside password, it's red as well. And then it's green. Now, while we're here, let's also disable the submit button on validation failures. So only when it's valid, it should be enabled. So let's also do disabled equals not res is valid. And now I can take this and add it to the submit button. And now I can refresh and we'll see that the submit, oh, disabled. Yep, that goes. We see that it's disabled. And now if I start typing, we'll see that it works correctly. Now, what if I had a validation that shouldn't prevent submission? So for example, I have a password strength validation that even if the password is weak, we want to allow the user to submit their form. This might be very difficult to do with other frameworks. With VEST, it's really simple. All we have to do is import warn from VEST and create a warning test. So what it does is specifies that this test is put in a different basket. Let's do for example, a simple test for warning, let's do maybe add a number because it's optional. And let's put inside warn. Now instead of longer than or equals, let's do matches and put a regular expression for has a number inside. if we start typing inside password and pass the five characters, we see that it's orange. We're still not seeing the validation message, which makes sense. We only asked for the validation warnings. So let's go over there. And let's do, as we said, the get errors returns as an array. So let's do concat res dot get warnings for password. Now, if I start typing, oh, you already see it. If I start typing, you see that maybe add a number. Now, this is nice. This is very simple to do. But what if we had a more complex validation, for example, an async validation for user already taken. This could be again, very difficult to do with a different framework with VEST. It could be very simple. And all we have to do is return a promise or an async function from our test. So first I'll use my API function, my mock API import, does user exists from API. This is a function that returns us, that rejects a promise in case of a user that already exists. And I can tell you that my username is in the, is on the list of taken usernames. And what I have to do here is test that username. And let's say user already taken. And now I'll pass in the function, does user exist and pass over my data dot username. Now we'll not see anything if I start typing because we did not show the spinner in case of a validation for the username field. So let's do this. Inside our change handler let say if name equals username Let do the username pending equals true Now we also have to cancel it when the validation is complete. And all we have to do now is res.done, which gives us back a callback when the validation is complete. Let's do result. This gives us back the result. Let's say res equals result, the most up-to-date result with the async validation result. And also let's do a username pending to false. Now, if I type inside username, we see the spinner and it disappears after a second. And if I type my username, we'll see after a second, the user is already taken. And if I add another character, it's not taken anymore. Now let's say that everything else still works. So example one, yep, everything still works. Now, if I remove everything, you'll see a spinner here, even though the validation is already failing for the user. So it's too short or it's empty, and we shouldn't go to the server to make a costly validation when we already know that the field is failing. And we can tell best, hey, hey, hey, please don't, don't do this. Don't validate when the username field is invalid to begin with. And this is using the skip when conditional. This allows us to wrap some field in a conditional and say, I don't validate when this condition is for is truthy. And all we have to do is sweet. That yet and this gives us the most up to date in our case, the intermediate validation result has errors for username. So as long as we have errors for username, the async validation won't run. It will be registered, but it won't run. So let's do, as we can see, there's no spinner now. And if I type my full username, it is shown. And I'll type another character and now remove it. And And we see that even though we know that a user is already taken because we ran it before, we still go out to the server again. And what we would usually do is memoize the validation result and tell best, Hey, we already have it. So we don't have to go outside, but that's does it for us. All we have to do is add test.memo. And then tell best, Hey, we have here a dependency array. And as long as the values inside this array don't change, so for example, data.username, as long as the values in this array don't change, just don't go outside. Just use what you have. And what we do here is type my username and we're going to see the spinner. Add another character, we see the spinner again. And what I expect to happen here is when I move that number I added at the end, we should not see the spinner, but instead we should see the validation result immediately. And if I move one character, This is exactly what happened. We see the validation result immediately. And again, if I add a character, instead of going after the server. And as you can see, let's check that everything works. Yeah, everything works perfectly. As you can see, we were able to introduce VEST into our form with only a few lines of logic. If you call that logic inside your code, it's very easy to use. It's very readable and easily to me and easy to maintain because you see everything it does right here. And you don't have to refactor your feature to make changes. Now we've seen some of best feature features. It has more features and more than you can see here. We can validate the changed field upon interaction. We can validate multiple tests for the same field. We have warning validations that don't fail the validation. We can make fields that depend on one another. We have async validations and we can memorize them. We can group them inside basket baskets. And in general, the form and the validations are structured. So they are really easy to move around, change, modify, read and write. Now, going back to my question from before, no, forms on the web don't have to suck. They can pretty easily become pretty good. And I think Vest brings to the table both power and comfort. Now, Vest community is still growing. So if you are interested in helping out with the project, feel free to go to the GitHub page or reach me on Twitter. And if you are just interested in using Vest in your Svelte app, you can go ahead to the documentation page. You'll find there this exact example using Svelte and other frameworks as well. So reach out, enjoy. Thank you so much for joining me today. It was a pleasure. Goodbye.