 This is really cool that everyone's here. Svelte has always been a very community-centric project. Even though I'm kind of like the public face of the project, everything that goes into it, like all of the design decisions, the way that the templates are structured, all of that stuff, has been hammered out by a community of people who are sometimes quite boisterous in expressing their opinions, and if you show it with a bad idea, then it quickly gets thrown out. But it's fun, and it's collegiate, and it's collaborative, and it's why the framework is the way that it is today. The thing was that even though it was very community centric, until recently it was a very small community. And this year it became not so small when we launched Svelte 3. We now have more than 200 people who have contributed to the Svelte repo in some form or another, which is really cool. People from all around the world, every continent apart from Antarctica, apart from Antarctica, I believe. And it's true that a lot of these contributors are people who are just adding their company to the list of people who are using Svelte. But that itself is a great thing. It's a sign that people are actually using this to do real stuff, which is very exciting to me. This was the London meetup, the first ever Svelte meetup, which happened in a pub in Islington, I think. somewhere. I believe Anthony is talking about minimalist web design or something, because he's just pointing at a white square. And these are some of the other meetups that are either in the planning stages or are going to happen. So I think we can say at this point that Svelte Society is a thing, and for that I'm extremely grateful to Sean for taking the initiative. I think he deserves a round of applause for making this happen. And I'm also very grateful to all of you who've taken time out of your evening to come and be here. A quick opportunity to plug what we're using Svelte for at the New York Times at the moment, which is where I work, just over the road. So this weekend we published a story that Michael and I, Michael sat at the back there, have been working on for some time. And when I say Michael and I, I mean Michael. I sort of came in at the end and held some of the graphics but we did a story and just as a heads up it pretty uncomfortable topic but I going to give you a look at what it is So this is a story about proliferation of what is referred to as child sexual abuse material online, which has become a massive problem, particularly over the last few years. And my task was to take the design work from two designers that we work with, Rumsey Taylor and Adriana Ramich, who had this idea about taking the subject of this article this article and putting it front and center like when you come to this article we're going to confront you with with the reality of what we're going to be talking about and we're going to take what could be an abstract concept and make it concrete which is i think one of the the really powerful things about visual journalism particularly visual journalism on the web using web technologies so each of the images here these are these were provided by the canadian Center for Child Protection. These are actual images that have been found by the center, obscured using a neural network called the Pyramid Scene Passing Network, or PSPnet, so that the people in these photos aren't re-victimized by people viewing them, and also the people who have to work with this material are protected from the effects of that as well. And as you get into the story, you start to see that this is a problem that is just exploding in volume. And recently we've reached a breaking point. And then we get to the headline and we can start reading the story. So when someone comes to you and says, this is what we want, this is the experience that we want readers to have when you first open the screen, it's difficult on a news site because you have a lot of stuff. You have analytics and you have ads and you have comment widgets and all that stuff. So it's kind of difficult to just pile in lots of JavaScript and kind of solve it that way. And so this is where Svelte comes from. This is why I started the project is because I'm a great believer in the power of web technologies to enable richer and more interactive and dynamic forms of storytelling, but we don have a big JavaScript budget on new sites We have to get things up and running very quickly This is actually using using a project called Svelte GL, which is a very experimental, not ready for production, WebGL component library, which you can use inside Svelte applications the same way that you might traditionally use something like 3JS or Regal, but it fits inside that very constrictive JavaScript budget. And you can actually play with it in the REPL that Sean was talking about earlier. This is a very simple Svelte GL scene with a little cube down there, which is defined by this mesh. Let me make that bigger so everyone can see what I'm talking about. This is a GL.mesh component, which is like all of the objects in your WebGL scene are created with a mesh component, and you provide it with some geometry, and there's a bunch of pre-made geometry builders, like this GL box one. The one above is GL plane. Then you pass in some parameters, and you pass in some WebGL uniforms, and hey presto, you've got a theme. And because it uses Svelte's reactivity system, you can use all of the same binding logic and everything that you normally would, so you can change the color of this, and we can use HTML form elements to control what's going on here. We can spin around with that. So that is how the introduction to that article was built using this, and this is something that I hope that we'll be able to get to a stage where we can actually honestly recommend it to people to go out and build stuff with. Where was I going with all this? Ah, yes. Abstract syntax trees. So this is what I'm going to talk about this evening. Abstract syntax trees is a term that I first heard, I think it was 2011, and I was in the basement of a pub in London called The Shooting Star. And I got into a conversation with a bloke named Alistair Dant. and we were talking about some kind of programming topic, some programming problem that I've been trying to solve and Alistair was like, oh right, so yeah, you've been dealing with abstract syntax trees and so here the thing Alistair had set up the Guardian interactive journalism team in London and they been doing this mind work and he kind of one of my heroes right And I don't want to stand there and look like a complete idiot. So instead of being like, I have no idea what you're talking about, I was like, oh yeah, I've seen Tax Street. Yeah, definitely use those things. Very familiar with them. So this is what UK meetups look like. They are booze fests. This is the transatlantic cultural divide, I guess. And I went home and Googled it and discovered that actually they're not that scary. And so tonight I'm going to be introducing you to abstract syntax trees, how they work in Svelte, and some of the work that is going on in the project at the moment to overhaul the cogeneration side of things. also as good fortune would have it Alistair who currently lives in the Bay Area is visiting us in New York so hi and thank you for not calling my bluff all those years ago I would just like to say I'm very proud of Rich so I would also say that I hired him as a result of meeting him in a pub after this pub there was a following pub thing where he revealed that he was, where were you working? City Wire So he's working with a site called Citywire, but despite the fact that he was employed, what was your actual job at Citywire? Oh, I had a few different ones. I was a web producer, which is a job title that they give to people who they don't know what to tell them to do. But he built a chart component library for no good reason other than the fact that he thought he would do it. And he's continued on in that vein to the point we find him now, where he's taken over the world of JavaScript. So yes, ASTs. They are one of those things that sounds very confusing, but they're actually pretty straightforward once you've kind of got your head around the basics. This is a website that I absolutely love. It is the first website that pops up when I type A into my URL bar, because I use it all the time. And what it does is it tells you what the semantic structure of a JavaScript program is. It takes the input on the left and it turns it into the thing on the right. And I can turn this into a JSON view so you can just see

 the actual output. Answer equals 42 is an assignment expression with the operator being the equal sign. On the left, we have an identifier whose name is answer, and on the right, we have a literal whose value is 42. And it's kind of interesting to open a page like this and just kind of play around, put different code in it, and kind of get a feel for what the computer sees when it's interpreting your code. For example, if I put let in front of this, To us, it looks almost the same, but now it's a completely different structure. We now have this array of variable declarators with IDs and inits and all of this other stuff. And it's just kind of fun to visualize code in that way. AST Explorer actually lets you do... Oh, yes? Isn't it a silent technical statement? It is, it is. an expression statement. So the program is a thing with a body which is an array of statements. Statements or declarations. And an expression statement is a thing with an expression and the assignment expression is the thing that I described. So yes, you're right. The difference between an expression and a statement is it makes sense to have a semicolon after a statement. It doesn't make sense to have a semicolon. for an expression. That's kind of the easy way to remember the difference. So in AST Explorer, you can explore all kinds of ASTs, and I recently discovered that there is, in fact, I'm just going to grab some code from here. There is a Svelte puzzle inside AST Explorer. So you can see the AST that is being generated by Svelte when you type code in. But that's not what we're going to look at right now. Good question. Yes? Do you know if they did that by using Svelte code, or did they implement it themselves? I have to assume that they're using Svelte's own compiler. It exports a parse function, which generates that AST. And so anyone can do that. And that's useful for if you're building an editor extension, or some syntax highlighting, stuff like that. So I think they're just piggybacking on that. But I haven't looked at the code. I not actually certain how that happens Okay let move over to VS Code and we can sut mae hynny digwydd Ym Iawn ydym ni symud ymlaen i cod ysgol ac y gallwn ni wneud hynny fwy cyffredinol Felly, dychmygwch fod gennym rhan o'r rhaglen sydd wedi'i alw'r llyraeciau i'r thema o'r swydd yr Italian. Mae pawb yn gwybod hynny, ydy'r iaith? No? No one's seen the Italian job? Come on! OK, well, I'm importing a module called Acorn, which is one of several libraries which will take JavaScript code in and give you an abstract syntax tree out. And it's really good. I recommend Acorn. If you want to dabble with this stuff, it's very cool. And if we run this, if we run this code here, bydd yn rhoi gwylio'r rhaglen honno fel y mae'r cwmpi yn ei weld, mewn ffordd o ddysgu syntagol. Ac efallai os byddwn yn gwneud jason stringify fel hynny, byddai'n fwy haws gweld hynny. Iawn, felly dyna'r hyn rydyn ni'n ei gael pan fyddwn yn parhau'r cod hwnnw. Nawr, gadewch i ni ddychmygu ein bod eisiau newid y cod hwn. Rydyn ni eisiau newid y cyfnodion i gyd yn gynnal console.logs. Felly, y peth cyntaf yr ydym am ei wneud yw ddod o hyd i'r cod a chael y nodion unigol o fewn. Felly, rydyn ni'n mynd i ddod i ddod â llyfr helpol ychydig, yw estree walker. Estree yw enw'r asetau AST. Ah, wyt. Dwi ddim yn dweud y gallwn ddelytu hynny. Dwi ddim yn dda iawn yn codi'n fyw fel Sean. Dwi ddim yn gwybod os oes unrhyw un wedi gweld ei sgwrs o JSConf Singapore y llynedd. Roedd yn llythyr yn codi'n fyw clon Reac mewn o dan 30 munud. Roedd yn eithaf anodd. Felly, yma, rwy'n mynd i logio'r mathau o'r nod. yma. Iawn. Felly os yw'r nodau'r nôd yn un identifydd ac mae nod yn alerth yna mae angen i ni wneud rhywbeth Ond beth ydym yn ei wneud Ac mae hyn yn Rwy golli ddau Iawn Sut ydym yn mynd i edrych y cod hwn Don we know that we need to do something But what do we do right And this is I missing the hand How are we going to actually edit this code Now, the traditional approach that people have used for years is you take that tree and you return another tree and then you stringify that. And a few years ago, I was working on some stuff kind of adjacent to this and I thought, well, that seems like overkill, honestly, because a lot of the time you just want to make small targeted edits. And so there's a library that I wrote called MagicString, which is designed to do exactly this stuff. If we now say it becomes code equals a magic string and we have the code and the AST side by side, then we can do edits. So we can do code over write. And we'll take the start position and the end position. And then we'll just replace any instances of the alert identifier with console.log. So we're actually changing the structure of the program, right? Because that was an identifier, and now it's a thing called a member expression, which is different. and we can log out the result of doing that. Okay, so that's progress. And what's interesting about that approach is that you're passing in the original indices into that string, but magic string is keeping track of where that is in the current string because every time you make one of these edits, you're offsetting all of the subsequent indices. And so you need to kind of internally keep track of that. And so magic string has this linked list, and it has this heuristic about edits probably being close to each other. So it's a pretty easy and efficient way of editing code. And let's just make one more change before we carry on. type equals literal and mode value equals self, code overwrite mode.start and mode.end. This is a spell of preservation in society Okay so that technique kind of works for some things It's something that we use in Rollup, which is a module bundler. and it works there because you're basically just concatenating the input modules on the left hand side and generating a single output bundle on the right hand side right, that's how you take a bunch of different source files and turn them into something that can be easily run in the browser and you see that we're not actually changing very much, like we're changing this export default 42 into var answer equals 42 just by overwriting that string and we're getting rid of the export default there and turning it into a module.export. But we're just making small edits here and there. Most of the source code stays untouched. And so in that context, it works pretty well. And we thought that it would work pretty well for Svelte as well. And it kind of works. But it turns out that when you're making lots of edits in lots of different places, that technique starts to fall apart eventually. So this is an example component that we have on the website. We have some transitions here, and we have an if block. if visible that code corresponds to this code here you will understand how that transformation happens thank you, Swix we have some code here that is getting plucked out and then moved into a different place up here and then we're inserting all this other code in between And that process starts to get a little bit chaotic, especially when we're doing stuff like taking some of the things that are in the script block, like this let visible equals true. We just put that inside the instance function, like Sean showed earlier. But then other stuff, like this spin function, because we've been able to determine, or the compiler has been able to determine, that it's not using any local component state, it'll just take that function

 I'll hoist it out of the instance so that you don't need to recreate that function every time you create a new one of these. So that gets moved up here. And if you're doing all these things, like you're moving things out and putting them in different parts of the output module, then this technique starts to get really, really hairy. And a few weeks ago, I was like, I'm over this. We're going to change it, and we're going to do the traditional thing of actually editing the abstract syntax tree and turning it back into real code. So, what I'm currently engaged in on the Svelte repo is this big PR that is going to completely change how Svelte generates code. And we're using this thing called Code Red. I wanted to have coding, because pain-free AST generation, but it was paper. So now I'm going to just put a letter B in front of that, and that turns it into a tag template literal, which if you haven't used these features of JavaScript yet, insanely useful. Change that, we don't need the text anymore, so we're just going to get rid of that. Log it out to confirm that everything's working, just going to comment that out real quick. Right, so we've got our abstract syntax tree, or at least an array of statements. So we can now just get rid of acorn and magic string. They're not doing anything more for us anymore. And just like before, we can walk over the AST. But this time, instead of overwriting the code, we're going to call this.replace. and we're going to create an expression this time console.log and then the same here But now we have an abstract syntax tree that has been edited And actually, if I do the whole JSON.stringify thing, then you'll be able to see that I'm not making that up. Right, so we've got these console.log things here that have been... So this expression has taken the place of all of the other expressions. So the final challenge is to take that abstract syntax tree and turn it back into... Yes, George? Just quickly, what's the difference between X and B? So earlier we were talking about the difference between expressions and statements. B will create a block of statements X creates an expression I thought maybe get away with just having one thing that did everything but it turns out not to be the case so that is the difference X is creating an expression there's a really nice library called I think it's pronounced A string do you know what live coding is really difficult on one of the new touch bar Mac Pros because the The keys literally come off the keyboard. I should get one of them. It's a typo. Yeah, the T key is particularly sticky. . Right, and now hopefully this is going to work. Right, okay, so it's now taking the modified abstract syntax tree and it's turning it into the code that it's actually going to run. And this is the process that Svelte is in the middle of adopting and the next release will be doing it this way Um does okay so here the process Mae sfelwm yn y cyfnod o adolygu a bydd y llawr nesaf yn ei wneud yn y ffordd hon Iawn felly dyma ble bydd y peth yn mynd i fod yn ymddiriedol oherwydd dydw i ddim am y broses o gael eich codi codi gweithredu gweithredu i fod yn sly Ac os ydych chi'n rhaid i chi ddewis acon ar gyfer pob un o'r ysgrifennu hyn, yna bydd yn dod â rhywfaint o gyflawni, a dydyn ni ddim amdano. Felly, beth dwi am ei wneud, ac mae'n dal i fod yn cael ei weld a yw hynny'n bosibl, yw ysgrifennu'r compiwler sy'n cymryd y compiwler, sy'n cymryd y cyfresion hynny ac yn eu cymryd â'r hyn y maen nhw. Ac, wrth gwrs, dwi'n gwybod os oes unrhyw un yn ddefnyddwr TypeScript yma, ond mae TypeScript yn golygu bod, os dwi'n dechrau tyfu yma, mae'n barod i gael cyflawni pob un o'r gwahanol ffyrdd sy'n bosibl, sydd yn eithaf anhygoel. Felly, byddai'n cymryd y teg tenpleidau'r ymddiriedol a'i roi i'r gyfweliad AST, fel nad ydych yn cael y cychwyn o parcio'r cwmpon pan fyddwch yn gynllunio'ch cwmponion. Felly, mae'n debyg i ddiffygwyr cwmpio, mae'r cwmpio'n bodoli i bawb. Ac mae hynny'n dod i'r cyfweliad Svelt AU yn fuan, gobeithio. Hey Rich, efallai y byddwch chi'n ymwybodol o hyn, ond beth fydd yn ddefnyddio'r ffordd yma o'r ysgol? Dyma'r sleid nesaf. Mae'n gwestiwn gwych. Mae'n rhesymonol iawn. Felly, mae rhesymon yn ymwneud â'r hyn rydyn ni'n ei wneud. Mae'r cyfnod cyntaf yn gwneud y cod ychydig yn llai cobwebyddus. Oherwydd mae'r holl cod sy'n generu'r allwedd o gynulleidfa Svelt ar hyn o bryd, yn fawr yn cymwysol iawn. A ph'un peth rydw i'n mynd i mewn i'w newid, mae'n gwneud i mi fod yn gweithio. Oherwydd hynny mae un o ffactorau sy golygu ei fod yn anodd i gynulleidfa newydd ddod i mewn a helpu chynnal Svelt sydd yn un o nodau amser hir It one of the factors that means it kind of hard for new contributors to come in and help with building Svelte which is definitely one of our long goals It means that we can eliminate an entire class of bugs, because we don't need to worry about whether a particular expression needs to get parenthesized to maintain the correct operator precedence and all of that stuff. There are things that, when you get into the details of this, you find some truly frightening edge cases, and we just don't need to worry about those anymore which I'm very excited about. And lastly, it opens the door to various optimizations. When you're thinking about this stuff in a structured way, you can start to apply more transformations after the code has been generated. You can collapse consecutive if statements and you can do all sorts of things that you can't just trust a minifier to do because in the context of a minifier, it's unsafe. But in the context of code that we know has certain characteristics, we can apply those optimizations. And so in theory, this will make Svelte component code smaller and faster over time. That is the why. I don't even have another slide, it turns out. So that's my talk. Thank you for listening. Cool. So we're going to take a quick break. there's water out there and I think whatever other stuff that they have. We'll come back at 8 and then we'll have some suggestions for stuff that we can all hack on and work together. And I'll see you at 8. Thank you.