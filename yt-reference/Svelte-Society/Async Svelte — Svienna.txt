 Welcome to my talk about async. Svelte. So I'll give a quick introduction about myself. I'm a husband and a father of four kids. I'm originally a mechatronics guy and made my hobby into my profession and I'm web developing I'm currently a web enthusiast at WOM and I'm also a musician and the screen has a different ratio than my my screen there it says I'm also one of the founders of Svelte Society Vienna let's take a look at the why and the how of async svelte async svelte gives us top level await so we can just use it in a script tag it gives us await inside of derived which is really nice for fetching data for example and transforming it and then even inside of a markup we can just await stuff. Wait for promises. And the tool that we need that was already existing is Svelte Boundary. So this was extended a little bit and now provides us also with a way to handle async Svelte. Hooray! and there was a fourth point, fifth point. Yeah, so inside of the Svelte config, this is the standard Svelte config. There's one thing that needs to be adapted. We need to add the compiler option for experimental async true. It will become standard and not experimental with Svelte 6. So let's see how long that will take. Wrong key. And the really basic example is we have a spelled boundary. We have our async stuff that happens here. So this could be loading data on the client side, having an async component, and some asynchronous stuff. and then we have our pending state and we can show our loading indicator. So a question into the round. What are some things that you think we could use async Svelte for? So what would be some examples that would benefit? Fetch some data. Fetch some data. Excellent. Yes. Yes. Call the confetti library. Yeah, waiting for confetti library to load until we make the confetti. Yes. Another example. Okay. Yeah. Cool. So I came up with some examples. Let's see how many we see. So we could have typed data loaders. So depending, like we could have a generic data loader, depending on what data promise we send into it, we get as a child prop. And I'll show some code later. So if we change the promise output, it will reflect in the snippet the props that are expected there. We could have async component loaders, for example, a component section that loads on interaction or some visi-vic editor that loads as soon as we interact with it or something scrolls into the window and then we have a async component load in lazily. We can have an image loader with blur. I'm quite a huge fan of the thumb hash because it provides base64 image with minimal bytes so not even kilobytes that we can just stick as a background CSS image and quite handy for for lazy loading stuff and whatever you can imagine So I think this is the time where we look at some experiments that I did. so I also used the SV toolkit already and I used it not with the bare bones but with the with the example page already so I did some experiments so we have a component loader we have our pink square that already loaded asynchronously and of course we know that squares they go into the square hole and we have a blue circle in a moment and the blue circle goes in a square hole and we have a green triangle and of course the green triangle goes into the square hole and we have a red semicircle lazily loaded that also goes into the square hole and then at last we have some gibberish something went wrong so I I hope we have sentry built in so we can monitor our errors. It doesn't go into the square hole. Sorry. Back to the experiments, I also created an image loader. And just to simulate the loading, we load the image. and we have this blurred version of the image and then as soon as the image is finally loaded it displays so this was taken two septembers ago and this was the view outside of my room on schneeberg where i went up by foot and went down by foot again with my wife together without the four kids so this can be quite handy to have some some asynchronous prefetch the image data and then as soon as the data is done we can then show the real image instead of the placeholder and we can have our type data loaders and we load our important data and it takes time to call the API and call all those important numbers. And yeah, we see our loading state here. And as soon as we get our response from our API, we can display all of our important numbers. So this wouldn't be a Svelte meetup if we wouldn't take a quick peek at the code as well. So let's just close all of that down. Too many tabs open and then I'll move it over. So. Which of the experiments do you guys want to see first? Image loader. Image loader. Good. Let's start with the image loader. It's one of the simpler ones. So let's see. So we simulate a promise and trigger that when we click the button, we wait for two seconds and then we return that promise we return the sunrise image as the parameter. And inside of a swell boundary, we have our source. So we can use at const and await inside of a component. We can await that promise. And then as soon as it's available, we can use it as source inside of our image. and as long as it pending we can use our blur hash B64 image or either inline that as a background image that would also be possible to have it as a background image here. So next data loader or component loader? component loader good excellent so this is just the select and all of the magic happens inside of the lazy component loader component so just a small disclaimer here because it's experimental and you probably shouldn't use it that way svelte boundary stops listening to promises for pending state as soon as it resolves one time so I had to hack around it a little bit with two effects to make sure that that I reset the svelte boundary and have the lazy component promise again. So what this component takes in as a prop is just a component name and inside of my lazy component loader which is just a util function I have a map of importing the components lazily so they only load when I actually need them by component name. I theoretically could type this but then I can then I'm not able to have a fallback if something should go wrong so I'll just take any string and I could maybe add some to a stock to add better hints there so the component that when we set the lazy component promise what happens here is we just await the lazy component and then render the lazy component so if we import any component also on the top level so if we would import a button it's similar to that we can just use the component and even if we don't know the actual name this will just render the component. So just forget those two effects these are just there to reset the promise so that we have the skeleton loader loading again and not just their component popping in after the lazy time. So last but not least least we have our data loader this one is also quite fun we have our snippet here we have the button to toggle our promise and we have our data loader and the cool thing about the data loader is it takes in a promise with whatever type that we decide from the outside so it's a generic component and the children take a snippet with a data of type of the same type. So if we would for example change the promise type that we get from our API or remote function to a number array for example we would then get an issue that the types no longer match because type promise and number are no longer compatible so let's take a look at the data loader itself so to generate a generic component we can use the generics and then t we can even theoretically say we extend it from some base type if we want to have some shared comment functionality in our type. And then we can use that when we declare our props. We can say our promise needs to be of promise T and our snippet needs to have a data property or an object with a data property of the type T So in that way we can make sure that the data that is passed in also matches the snippet that we render as soon as the data resolves. So it's quite small, like five, six lines, counting is hard, six lines of code for having a type safe component loader available. So in order to resolve the promise, we also need to fix our snippet here to number. And then TypeScript will be happy again because the types of the API that we call match again with the child snippet that we have. The same thing is of course possible with typing svelte components and expecting certain props if we want to pass in components that then take on the data loader. I just thought Snippet is a little bit easier to visualize in this example. So before I remove the code any code related questions Yes. You have chosen to use the const in template. Is there any reason you do not choose, for example, a prior statement? I know, for example, there is just a, for my time, you use the const. Could I just have a prior statement in a script, a part of the component, and then use that one? I guess so. I'm not really sure. I haven't tried that. I would guess so. Yes, I know you have to change. If you bring on top of the sketch, you are out of the set . So you would need to grab or this into a set . If you grab or this to a set , you can bring the time . It's more a syntax way of . How you bring on the sketch? So then the usage of the . Yes, which would, So then you would need to move that part out into a subcomponent in order to have... In order to have the predefined skeleton loader showing here. I was going for simplicity, so I didn't try any other. Cool. Good. Then I'll switch over to the slides again. switch over to the slides again which is actually a svelte kit oh come on mouse come here or maybe i can do it like this yes perfect so the the slides this time around for the first time are also a svelte kit app, actually the same app as the experiments. So I have them neatly deployed if anyone wants to look. So this was my talk. Thank you. If you have any more questions, feel free to ask. If not, let's have some fun talks. and enjoy each other's company. What's the add const? The add const is to await the promise. And then as soon as we have awaited it, we can use it as a... It's nice to have it. Instead of repeating a longer . And use . This is the . No, at const is a normal spelt concept. I think there are some boundaries, but it's not necessarily only svelte boundary. OK. . For example, this. Then thank you so much.