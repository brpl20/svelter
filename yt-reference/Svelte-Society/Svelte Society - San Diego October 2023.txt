 Hi, everyone. This is the meeting of the San Diego Svelte group. My name is Attila Bitarla, and I'm going to be talking about Svelte 5. So what is coming in Svelte 5? Well, at a very high level, we get some performance improvements. Now, Svelte already performs very well, beats most major frameworks already, but it gets significantly better. And I'll go over some more details in the next slide. It also has smaller bundle sizes. So as you know, Svelte already has very good bundle sizes. They're going to get even smaller. And then the team is making every effort to be 100% backwards compatible. So if you have a Svelte 4 site and you're upgrading Svelte 5, everything should work. They're not removing any features. Having said that, it's always good to test and verify, but every effort is being made to make it backwards compatible. There are some new features coming, which I'll go over in just a minute. Because it is a work in progress, some of these things are subject to change. Not that I expect any radical changes to come, but it is It is possible. And then just to be clear, Svelte 5 is not out yet. It was just announced September 20th of 2023. So there is no way you can, as of right now, do an NPM install or go to a public repo. But what you can do is go to the Svelte 5 preview site. So I have a link here, Svelte 5 preview.versell.app. there's documentation there and then there's also a REPL so you can play around with the new language features. There is no known release date or no announced release date. The team, to best my knowledge, the team is targeting a release of sometime of this year, 2023, but that is all subject to change and I think it's very possible we'll see a release then, but nothing is set in stone Okay So this slide here might be a little bit difficult to read but this is a tool that used for benchmarking front framework So in our previous meeting we compared Svelte to React Angular and a few others and saw how it compared And just a quick recap is that Svelte was very favorable. I think maybe not every single benchmark, but most tests, it came out on top. And so, you know, the conclusion is that Svelte 4 already has very good performance. But as you can see here, or if you can't see it well described in a second, Svelte 5 is significantly faster. So the leftmost column is basically various tests that are run. The next column is vanilla JavaScript, followed by Svelte 5, and then finally Svelte 4. And then basically, I believe these are the number of milliseconds that it took, either milliseconds or seconds it took to finish certain tests. So smaller is better. Or if you have difficulty reading the numbers, essentially the greener the square, the better. What you'll see here is across the board from Svelte 4 to Svelte 5, Svelte 5 has made significant improvements. In some cases, it's right on par with vanilla JavaScript, which is basically as fast as it could get. So for some of these, it's basically the most optimal performance you can expect. So all that to say is, Svel, Ori has very excellent performance, but it's getting even better. Oh, and just kind of quick attribution. And so this actually comes from Rich Harris, something he tweeted out a few weeks ago. So this is just a screenshot I grabbed from his Twitter. Okay, so how does Svelte 5 get these big performance improvements? So I believe most of you know this, but essentially Svelte is different than a lot of front-end frameworks as it's a compiler. So it takes the code that you write and then outputs very highly optimized JavaScript. And that's why even in Svelte 4, you get great performance. The Svelte team basically rewrote the compiler or significant portions of the compiler for Svelte 5 And more specifically they followed a pattern known as Signal So if you read a lot of blogs in the front end space there a lot of chatter about signals and other frameworks are either adopting or looking at adopting signals Svelte 5 adopts signals. But one thing that's interesting about it is it does it entirely under the hood, so to speak. So the compiler takes care of all those details of signals. So as a as a developer working with Svelte, you actually don't need to know anything about signals or how they work. Now, it's certainly good to just have information. And if you're really curious about signals and more details about them, if you just search for front-end frameworks and signals, a lot of great blogs will come up. All I'm really going to say here is it's a pattern that allows Svelte to be much quicker. And again, you don't, as a developer, you don't even need to know how that works. And that's, you know, coming back to one of the strengths of Svelte is Svelte does a lot of the heavy lifting for you and helps you just focus on being productive. I also mentioned the blogs. I also swiped an image from one of them and I'm not even going to bother to explain it too much, but I just, the reason why I picked it, because I thought it was very interesting, this was a blog posting about signals. They show the words state effects and derive state. And you've probably, if you worked with other frameworks, you've probably seen similar nomenclature. These are, of course, not, these are general concepts. These aren't specific to any different frameworks. But I thought it was particularly interesting. It was relevant to signals. And you'll see why I kind of included this shot in a second. So, okay. So how does it work? So under the hood, it's using signals. As a Svelte developer, how do you take advantage of these signals. So as part of Svelte 5, they've introduced what we're calling a new set of primitives known as runes. And it's just a grouping of this new functionality. And runes are a set of primitives for fine controlling reactivity. Now they look like functions. I don't have a code example here, but I show some in the next couple seconds So they look like functions that you pass parameters or some of them don take any parameters Technically they are not functions They what we call symbols for the Svelte compiler. Just an important way to distinguish them. And I think to some extent, they help also just with readability. So they're a little more explicit than, say, some of the traditional ways of handling reactivity and Svelte. Depending upon where you sit, you might love kind of a lot of the magic behind Svelte. And of course, I think most of us do love that. But when it comes to reactivity, sometimes it's good to be a little more explicit. And for simple scenarios, it's usually not a problem. It's when you're dealing more complex scenarios, being just a little bit more explicit can go a long way in both from a developer side, but also from the compiler side, understanding what needs to be reactive, what doesn't need to be. So there's four new runes. I'll go over them. Each one has its own slide, but at a high level, it's state, derived, effect, and props. what is state so state is basically replacing the previous way of defining reactive values in a svelte component which was just using let so today um in svelte 4 and earlier you would say let and then essentially declare a variable at the top level of a svelte component and that's how Svelte knew something, that's how you declared something that would be reactive. Instead, now, instead of using let, you use $state. And I'll show you a specific example. There was a few limitations with let. Number one, it only worked at the top level of a component. So for example, if you had a function within your component and you use let to define a variable there, It would just be a regular variable. You wouldn't be able to use it reactively. And in addition to being anywhere in the component for state, the state rune, it'll work anywhere within the app. So it could be outside of the Svelte component. It could be in any sort of utility JavaScript file or if you're using TypeScript, a TypeScript file. And again, I'll show some more information.

 more examples of that. So there's a lot more flexibility. And let me, I'm going to go over the next spruin, and then we'll go to a couple of code examples. Okay, so derived, similar to state, except for instead of replacing kind of the way of using let, it replaces the previous method of using the dollar sign colon to designate a derived reactive value. There was actually a couple shortcomings with dollar sign, the dollar sign colon syntax. For example, if you did a console log in your component for a derived value, it would actually be out of sync with the actual value that the component had. That was just, I guess you could say some quirks to how Svelte works. And if you're not familiar with that, that probably could throw you off quite a bit if you're trying to debug something and relying on console logs. There's also some scenarios with the dollar sign syntax, the dollar sign colon syntax might not be really clear how it works or understanding why. So I have an inline example on this slide here where I have this function called multiply by height. It takes a parameter, a single parameter width, and it's multiplying width by height. Now, if I wrote this function, I'd make sure both of these values were parameters, but just bear with the example. And then in this reactive derived value area, it will re-update the value when width changes, but because it doesn't see the height, it doesn't look into the function and see height is actually being used within the function, it won't update if height updates. $derived does not have that problem. You can pass it a function and it will work. So I'm going to go and show, before I get to effect, I'm going to show just a couple of simple code examples to help illustrate some of these points. So this is a real simple example. Let me refresh it. I was playing around with it earlier. You can see here I have $state. and again the previous way just so we're like clear on how this would work before let me do it first with the old way and then I uncomment those out so dollar sign And let say double equals excuse me count times two And if I did everything correctly, yes, it works as expected. Now I'm going to go ahead and delete the old syntax. It's going to complain for a second. and use a newer syntax. And as you can see, it works the same. Now, you might be thinking, what's the benefit here? I had to put a dollar sign state before I didn't have to do that and essentially does the same thing. You might even say that for derived. I have to add this new syntax. Granted, it's just, it's a very small difference in syntax, but why do I have to add this syntax? So yeah, for some of the reasons I listed, so it's more explicit, especially someone coming from a non-Svelte background. I think this is a little more intuitive if they see, okay, this is, I'm declaring state, I'm declaring a derived value. It's more explicit and it can work outside of a Svelte component. That's also a real big advantage. And I have some more complex examples I'll show in a minute. But this is kind of the basics of dollar sign state dollar sign derived. And the real value of these runes isn't for necessarily the real basic scenarios. It is a little more explicit, but you're going to see the real value when you get some more complex examples. And it's in the complex examples allows you to do things you couldn't do before. So if you just look at the very most basic, simplest example, you might miss the value and you might be a little bit wondering why you have to use this syntax. But again, it's for the more complex scenarios. OK, let's go back to the slides. Next one is effects. So this one is, my opinion, probably the most interesting one. So this, essentially you pass a function, and I'll execute that function whenever, basically whenever the component is mounted in the DOM or whenever one of its reactive values are changed So if you familiar with Svelte development you probably are familiar with on mount So it works similar to on mount that they both execute whenever a component is mounted to the DOM. And you can still use on mount and dollar sign effect together. They're not mutually exclusive. But the big difference with effect is that in addition to running on the component being mounted, it will run whenever reactive values change. And I have an example that will hopefully make that a little bit more clear. Also, dollar sign effect has a couple more advanced features. So you have an optional return value from that function you pass. That return value would be in a callback function, and that callback function can do any sort of cleanup. So, for example, if you had some sort of open connection, let's say WebSocket connections or anything for that matter, any sort of cleanup, that's where you can use that return value, the callback. dollar sign effect also has a way if you want to run some code before the component is mounted there's dollar sign dot effect dot pre and then you pass it a function so let me go show a couple examples to help illustrate dollar sign effect i believe i have here yes okay so i'm gonna i'm gonna make a slight adjustment and reload this. And let's just, let's see. Why do I? Let's see. I don't need to include. Okay, I'm just going to remove this for now. It's not really important for the example. So I'm just going to rerun it. And you're going to see when I first click this button, you see this hello. And this hello is coming from the effect right It only runs once And actually now that I think about it I didn need to comp these out So let me fix that Yes. So you can see the reactive values change here. There is no change here whatsoever. It just runs one time. Now I'm going to reset this again. This time I'm going to uncomment this console log that I have that actually references these derived values. So you can see, of course, it's logged here. But now each time I click, it is getting in this effect. And it's just, it's because the compiler knows, okay, this effect is referencing count and double in this example. So it knows it needs to re-execute. So I could remove double. It's still going to work. It's still going to re-trigger because count is a reactive value. And just to illustrate that one more time, if I remove it, it doesn't re-execute. So that's effect. All right. I do have one more complex example, but I'll go back to the slides and just go over the last rune, which is props. Now, the props is very straightforward. So in the past, you would use export if you want to expose something as a prop as part of a Svelte component. So props essentially replaces the need to do that export syntax. So again, it's similar to state. Using props is probably a little more explicit versus kind of doing what you could say tricks, maybe, or magic around export. Again, some people like that. Some people don't. So I believe I have an example here. This is a very simple example. I have a component here. I am defining a property called double. I can put a default value. I can have as many props as I want. If this was TypeScript, I could specify types. There's, as I mentioned before, there's optional default values. And as you can see here, I happen to be using a derived value called double that I'm passing through.

 and of course it works as expected. There's some more advanced scenarios, by the way, if you use the older syntax or props where dollar sign props is a little bit more advantageous. I won't go into those just because they're more edge cases that a lot of people are less familiar with. But if you're interested in those, those are covered in the docs. And, you know, the main takeaway is the new syntax is strictly easier to use and more explicit. Okay, so bringing it back, I have a third example here where you can see I have this plus minus reset. Oh, my reset is actually broken. Let me fix that. Okay. So this is, it's pretty straightforward, but you can see here, I'm not declaring state. I'm not declaring any derived values or anything like that. I'm not using runes at all. So in Svelte 4 and earlier, you would use something known as stores. We actually talked about that in our September meetup and how stores are a way of handling global state. So this counter here is not a store. It is code that we're using in this example, specifically using dollar sign state. And so I mentioned several times now you can use these runes outside of a Svelte component and it allows you to create reusable functionality. So. So very straightforward. I define a state default value zero Of course we have these various functions And one thing that people get hung up on so we returning a function here And that function, when called, will return an object. If we just call count, meaning if I comment this out for a second and I just put counts here, it won't work. And why does it not work? Well, because, and this is just how JavaScript works. This is not anything specific to Svelte. I think sometimes people miss that when they see this type of example. This isn't really anything specific to Svelte. It's just how JavaScript works. It's just going to get the initial value if you write it this way. So you can write it as the convention is to use a getter. You could also write your own function. So just for demonstration purposes, I could call a function. I can call whatever I want. I'm going to call it get count. I can spell. And as we'll see here in our example where I have count, I could also â€“ oops, it's a function, so I need to call it. So I could also do that if I wanted to. It is nicer and really kind of if you look at code examples for salt five, this is really kind of the pattern people are using. But just to make sure people are aware how that works, you know, you could just have a function. Now, the other day someone inquired, can we use derived here? And absolutely we could. So I could just say let double equals derived oops counts times two and then in my I have to I have to write a getter for double now. Get double. Turn double. And now if I want to, I can, just like I have count here, I could put a space and put double. And I didn't have any typos. It should work. so yeah so it shows the double and someone asked about the other day about effect so I'm putting an effect directly in a function and let's just say hi from effect make sure everyone can see it. It says hi. Now it's only going to execute once, but if I change this to reflect for demonstration purposes, I'll just put in Govel here, but it would work for count as well. I have to use the right syntax. So it's smart enough, just like we showed in our early example. So you can use state, you can use derived, you can use effect. I think props, if I remember correctly, I don't think it makes sense to put props in here because this is not a component But anyways this is how it works So the real power behind runes and again being explicit is also valuable But the real power is what you can do by having these sort of utility functions. You know, all the best patterns and practices, people are ready. I'm on the salt discord channel. People are ready trying various things out. So we'll have probably very soon blog articles, et cetera, explaining some of the patterns that other people are using. But there's going to be a lot of great stuff you can do with this. And if you use stores, of course, you can still continue to use stores today. But even Rich Harris remarked he thinks using runes in this manner will probably replace the need for using stores. If you want to continue to use stores, they're not going away. But that seems to be the way things are headed. So just to show these examples. Okay, so to kind of wrap up runes, so they're entirely optional. You cannot use runes in Svelte 5. You could use your code just how you do today and not use runes at all. That's totally fine. Now, the suggestion, the recommended practice would be to adopt runes. If you want to take advantage of all the new performance gains, you'll get that with runes. I mentioned this before, runes work outside of Svelte components. They can replace the need for stores. They help with clarity, code reuse, fix some of the edge cases that you might deal with, with some of the current Svelte syntax, and again, performance. So that is it for today. So thanks, everyone, for coming. We'll be meeting again in next November. Looking forward to seeing everyone. Thank you.