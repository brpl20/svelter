 Hey everyone, welcome to Stalk Society NYC's third Stalk Meetup, and the first one in 2020. Yay! Thank you all for coming here. So, this is the program for tonight. We're doing opening notes, 10-minute lightning talks, learning halftime, show and tell, and at the end we might go to a nearby bar. So opening notes. So first off, some announcements. We have new branding, Banks Vudin. He's over here. And we just updated our tour account and everything else with our new logo. And we also have new videos on Twitch. Yay! Say hi to Switch. And to remind everybody, this is our code of conduct. We are dedicated to providing a harassment-free community that's inclusive, so we did not tolerate any harassment of community members in any form. I think you guys agreed to this when you guys signed up on Down to Meet. And of course, call for speakers. For our last couple of meetups, it's been like Rich and Sean, and we really want the community to speak up more. So today I think we have our first community speaker, and we're going to get started with our 10-minute lightning talks. So first off, it's introduction to thought stores. Yay. Okay. Thank you. all this possible Thank you to Sandy for organising the night Thank you to the AV people in the back And thank you Valen for the new logo which is fantastic If I can get on the internet here, there's just one thing that I want to share. If you haven't seen this, this is the annual State of JavaScript survey. it's a survey of all the different frameworks and build tools and this, that and the other and this was the first year that Svelte was one of the possible choices in the front-end framework section and I want to show you the results because it's pretty cool if I can find it I think it's 2019. Here we go. So the brand frameworks. First time that Svelte has been included in this. and we are number two in satisfaction, right behind React, which, given that we're a little bit new, we don't have dedicated dev tools yet, we don't have TypeScript integration, which people keep yelling at me for. I'm pretty pleased with how this small but perfectly formed community has acquitted itself in 2019. Obviously, next year, we're going to have to shoot for the top spot. But in the meantime, on the interest tab, we are already at the top spot. Spelt is, by a little margin there, 3% of the VJS, the most interesting framework to front-end developers currently, which is a nice little accolade to have. We are, however, right at the bottom of awareness, which is, I guess, where events like this come in. We also have the Prediction Award for the up and coming technology that might take over or not. And after what the state of JS people call an explosive debut. Now, there are a lot of reasons to take all of this with a pinch of salt. The state of JavaScript survey is mostly filled out by a very self-selected group of people. That is to say people who hang around on Twitter and really really care about this stuff It not at all representative of the majority of developers But I think it probably fair to say that it a reasonable proxy for the early adopter crowd the people who are going to be kind of shaping opinion over the next year or two. So I think this is a really encouraging sign for the future of Svelte. So hopefully 2020 is going to be a cool year and hopefully you can all be a part of it. Is Sean locked up yet? Yeah. Cool, I have to show you. Okay, thank you. Wow, I can just speak and it works. Okay, I also need my slides, which I presume is here. It may not be, so I'm just going to go to my own Twitter. Slide, slide, slide, there we go. Okay, cool. See, Google is wonderful. Thank you so much for Miles and for hosting and for everyone for showing up. And I recently rewrote one of my small helper apps. I have a Twitter overlay called Better Twitter. It doesn't do much right now. It's just a better search UI, but it at least doesn't tell you the trending news about Kim Kardashian when you search, is positive. I rewrote this from React to Svelte, and I, in the process, discovered how amazing stores are, so I figured I would just do a talk about Svelte stores, and I think I can just, you know, sort of blast through it. So it's not a Svelte store as an e-commerce store. I, you know, I was just, like, hunting for, like, a meme to start things off, but What stores are, based on the docs, it says, so store is any object that allows reactive access to a value via a simple store contract. You can see the docs for that. But let's just talk about what that store contract is. It's actually super simple. Store contract implements means that your object should at least have one or two of these methods. The first method is subscribe. So when spell call subscribe and you give it a function, the subscribe function must be called with the store's current value. and you should also return an unsubscribe function to it to clean up any subscriptions at the end. You can also optionally provide a set method and the set method turns the store to a writable store so you can actually set the value of the store inside it What use is a store that you cannot set We talk about that as well. And its job is to accept new values for stores and to call all active subscriber functions as long as you have, you know, it's like a pub sub type of model, and I'm sure everyone here knows. Okay, so let's write a store from scratch to really understand this model. Again, I really just love writing things from scratch just so you really understand it. And for people who are new to Svelte, this is the REPL and it's a really good way to explain concepts. So I'm just going to create a new file called store.js and I'm going to export a time store. I'll just call this a time store. And then I'm I'll have a current value and say, well, the current time, I guess, let time equals to new date. I'll have you subscribe here. That takes a function, right? And then, so back to the contract. Again, if in doubt, just kind of refer to the contract. When spell calls subscribe, the function must be called with the store's current value. So you should call the function with the store's current value. And that's about it. Let's actually see if we can import that and show it. So over here I'm just going to say import, what do I call it, Timestore? Yeah, Timestore equal from store.js. And then I'm going to say Timestore.subscribe. And I need to expose it, so I'm just going to say that time. and timesword does describe an opacity function, so I'll just say x. Very, very terrible naming practices, but whatever. And then we can use felt's setter thing to show this. Okay, so, right, cool. We have a basic store implementation. This doesn't really do very much, so I'm also, but it just really gives you an idea that it's an object. it has one method called subscribeUpacityFunction, and then you can expose it inside of your small components. So, and then the other, so let's actually make this do something interesting. I'm gonna have to sit.

 interval. I hope I don't screw this up. And let's see, every interval I can set a new date, I guess. So the thing here is that I should be returning something. So I'm calling, I'm setting this this time every second or so, right? Because of the set interval. Hi, welcome. I'm calling this time because I'm setting this every second, but I'm not really broadcasting it to my component, right? So this is not really a complete store implementation. What I should do is keep track of the number of subscribers. I'm going to use a set for this, which equals to new app set. And so subscribers, I can just say, like, sets.add function. and then whenever I call this and then so whenever I set a new time I can say subscribers for each I have a function and I can just call that function with time did I sorry here no On link 5, you don't need link 5. Can I just delete this? Yeah. Delete this? Ah, no worries. Look, it's cooking. So yeah, that's the basic PubSub model, right? You have a bunch of subscribers and then you... All the subscribe functions are called every time the store updates. You should also, for memory leak reasons, you should also return a cleaned up operation. And this one is going to be a pretty simple, like subscribers.remove function. And that's the whole idea. There's also a sort of memory leak over here, in the sense that if this component unmounts, we've called this subscribe function, and it's just going to keep subscribing and updating. anything updating. So we actually technically should say something like undestroy, which is a Svelte lifecycle And then we should say something like let X or whatever Y It doesn matter And then we should call the unsubscribe function over here So that technically the interpretation that technically what we should do But really, all of this is sort of border-play-y. And what Svelte lets us do is append a dollar syntax. So going back to my slides, you can either call .subscribe or you can prefix stores with a dollar syntax. The dollar syntax auto-unsubscribes for you, which helps prevent memory leaks. So this is pretty cool. So instead of all this junk, I can just delete this and then just put a dollar in front of the time store and that was also going to work as well. So this is some kind of core to this philosophy of you have syntax to deal with very, very common issues. Let's also make this a... So this is kind of like... there is some sort of core event source coming out to this store. But what if we want to set things from our user interface, right? Like we should have a writable store. So for no apparent reason at all, I'm going to call this writable. Actually, so one more thing before I go through that. So a store is an object that implements that contract. But actually most stores that come from the official style interface are actually kind of store creators. They create stores. So you actually wrap this whole thing in a function, so like a function create store, for example. And inside of it you put all the junk that we just coded. Let's see. And then the real API looks something like create store const, oh, well, let. It's up to you whether you want to do consta or let. And this is kind of a lot closer to the official spell story. So let's actually make a writable store, and then I'm mostly done. So for no reason at all, I'm just going to call this writable. And I'm going to take an initial value. I will set that value to initVal and then get rid of all of this. actually, whatever, is this carver's reset? Okay so I call it with vowel yup yup yup Okay so a writable store actually implements a couple other methods so let actually look at what those are I should probably have introduced them first before I show them to you Never mind. I'll just explain. The couple other methods that they should also implement is the set method. I did say that. Let's just call this new value. We're calling it set new value. So every time a new value comes in, we're going to set the value to a new value, and then we're going to broadcast that, subscribers. I hope everyone can see this, for each, and then I'll get a function back, and I'm just calling every function with the new value. So let's actually see how this works in practice. Writable, again, writable. So we created that store. we don't read, it's undefined right now because it should actually start it off with zero as it changes to a button on quick equals blah blah blah just giving an event handler over here what do I call this store dot store equals plus equals one for example Ah! The auto-formatting got me. Okay, cool. So what do we have here? We have implemented a writable store. This formatting looks terrible, but let me just clean it up a little bit. Okay. We have implemented a writable store. So, again, I'm using the $ syntax to assign instead of just read. This is, this would have been a lot more annoying without the $ syntax, which is which is very nice. Actually, it's not that much annoying. It's just like store.set. And so this happens to be the official API of Writable, which is the official store. I mean, there's actually more stuff, which we'll probably talk about right now. So for Writable stores, this actually works with setting values as well as binding values, a two-way binding syntax for spelt stores, which is super cool. I mean, I have an example for how this is really good for forms. You can bind fields to just an entire store, just bind every single field to a form, and that's it, no code. So anyway the subscribe API is so flexible because you just have to have an object that has a subscribe method that it just works with RxJS out of the box Ben Lashley the maintainer of RxJS was very impressed by this But obviously, now that you know that there's no magic behind stores, it's no surprise. So this is an example from my code. Don't worry about the exact details of the code in there. But here I'm actually doing two-way binding, and then accessing the store and indexing into it by key name. So imagine if you do a form, you can just have every single field has a specific key name, and you just put it onto an object in your store, and it's just two-way binding there. Very, very cool. No change handlers to write because it's already two-way binding, so that's very cool. And for me, this is a nice comparison, contrast to React, where it's one-way data flow. You have to write all your manual change handlers. and you can kind of replicate store with context-based state as well as other fun stuff as well. So all of this is on that GitHub repo for that project and I save versions of React versus Svelte. It's not like some sort of step change sort of superior. I would say it's just like some things are easier to write and for me especially getting rid of the manual change handlers is very nice because I don't want to deal with those. So there are three kinds of official store APIs, and there's a fourth one which is kind of an orphan child. So there's writable, which lets you subscribe, set an update, and then also pass an optional callback for unsubscribing. There's readable, where you cannot have, so the first store that we wrote was a readable store, you can't really set it from the outside, but you can set internally, so here's actually how you do the set interval with the readable API. So it's kind of like a read-only store. And a derived store calculates a store based on stores. So if you want to do any sort of deriving logic, that's a really good place to put things. I actually highly recommend people to check out the source code. It's very readable, which actually gives you a lot of confidence about the store. So if you want to look at the Svelte runtime, you can just go to the Svelte source code. You can see animate easing internal motion in store. We're going to look at store here. And this is the entire source code for everything. It's only about two of your lines. So yeah, that's the, you know, you're fully able to sort of dive in and write this from scratch if you need to or just write your own custom implementations. In particular, notice that we

 We don't actually have to set values right away, and we can set values more than once. And that's very relevant for what's about to come next. So let's talk about when to use stores for passing reactive values between multiple components. Reactive is important here because if you pass it by props or pass it by context, it's not really reactive when it updates the document immediately. But you can actually pass a store into a context to do that. When LCU stores, you can use it to wrap things that are naturally event sources from outside of your app, like your mouse position, browser, sockets. I also think a state machine will be pretty cool. When you set things, it just processes through a state machine, and then the final value is returned. And finally, one other official store I got is Svelmotion for easy tweening and spring animation. So let's talk about that. This is super cool. So Svelmotion are a kind of writable store. So, writable stores have implement the subscribe method, name implement the set method, right? So, there are two ways to do animation with this thing. So, you can tween, which is like you have A, you have A in your initial value, you have new value, and you want all the things in between, right? You want to update it smoothly over there. Or spring, where you have sort of physics-based animations for your values. So, actually, let's actually take a quick look at the tween tutorial. So this is how a normal state update would be. I want to set things to 25%, I want to set things to 50%, I want to set things to 75%. So the nice thing about tween being the exact replica of the Rigable API is I can just switch this to tween from Svel Motion. And so now I have a different type of store and it just animates nicely with the values interpolated in between, which is super, super cool. you can also one of the other things I really enjoy about this is being able to customize the interpolation function so interpolation function let's actually just stick it in here so when would you want to customize the interpolation function is when you have something that's just not a simple value so here I'm going to interpolate between RGB values I'm stress testing your REPL right now So I have just straight RGB red RGB blue RGB gray and being able to interpolate between them from a custom interpolation function is very cool. Treating them as single values and you're just interpolating them. So very very customizable and it's all from the underlying store concept, which is really cool. Spring is kind of the other child, so I'm just going to show you how to do this. You have some physics-based animations to this, and it has a very nice natural-based easing. Although Svelte itself actually shows a bunch of easing functions, which are really useful as well. Okay, so that's it. What can we learn from stores that are reflective of Svelte overall? Svelte embraces mutability, and you can see how we use that inside of stores. Svelte also tries to offer more first-party APIs instead of a very thin API surface area. Offers sugar syntax for common use cases. A simple contract that you can keep in your head. As well as a bundler which only includes what you import. There's a whole bunch of first-party stores, but if you only use one of the stores then it's going to only include that in your application so very very core to the Svelte philosophy in general so I like that about Svelte Source yeah now you know Svelte Source thank you if anyone has questions I can quickly answer if not I can just kind of move on yeah alright cool on to Jeff Thank you. I'm going to be dropping in out of the slides. Just not really that much by way of slides But anyway so my name Jeff I on the Web Development Relations team here at Google Sometimes I have to build web applications I'm not really great at building web applications. I found myself needing to build a web app a few months ago, leading up to Chrome Dev Summit, which is our big event. And sometimes we launch new features in Chrome, and we want to show people how to actually use them. So I was like, I'm going to build a web app. and it seemed like a great opportunity to use Svelte. So I am by no means somebody qualified to get up here and talk about Svelte in any detail, but I thought I would share what I built and maybe just run through the code a little bit and maybe share a couple of little question mark things. One of the things I do do a bit though is progressive web app tooling and kind of things with service workers and maybe I'll spend a little bit more time talking about that bit within Svelte. So that's the idea. This is what I built. It's only runnable on Android, unfortunately, for reasons of the actual 8th guys that it's currently using. But if you happen to have an Android device and you have to have Chrome installed, you go there. It's scrapbook-pwa.web.app. And I'm just going to drop out of this right now. And go to this Android emulator and show folks what it looks like and see how the Android emulator built is the change in resolution. Let me just restart that. Just so folks have some idea of what I'm talking about. Okay. Hopefully that's kind of visible on the screen. So basic idea of, well, first of all, a little bit behind progressive web apps because maybe not everybody knows what that means. It's the idea of building a standard web app and then having some additional capabilities usually powered by technology called service workers. One of the things in particular is being able to install them and having hopefully all the data you need cached and available offline. I'm going to go here and you will see this little ad scrap of PWA to home screen prompt at the bottom over there. That's kind of, as a user, if you happen to navigate to your URL, you're paying to that, hey, there's actually something that you can install and that's going to behave like an application. Normally that's not super important. You could normally do stuff with web apps just from within the browser. But for this specific technology that I was trying to demo for this which is integration with Android native sharing sheets you do need to go through the install flow and that will actually generate a web APK is what we call for. So it will behave like an Android app at this point. And that's important for this. Fortunately, it seems to work fine in the emulator. I did not fully test this in the emulator. So hopefully it works. Otherwise I might just hold up my phone So, okay, so it's added, and I scrapped with PWA to the home screen. You see here, you have a nice little icon and everything. And I just want to show you what it does before I talk about the code. So, open this up. Looks like an app at this point. It's all built and spelt. Doesn't do much right now. Basically, I'm not sure how well folks are going to be able to see the screen, but it's like you don't have any saved images. The idea is you can go to other applications in Android, you can then share to it, and then you can also share from it. So it's kind of like a temporary scrapbook or like, I don't know, temporary flip board type thing. It does not store anything in cloud or anything like that. Everything's stored locally in cache storage. And it's pretty useful. And this is like a test account that I have not used in many, many years. We have some nice pictures from Prospect Park in 2007 and when my wife made biscotti in 2006. So that's what's available. Let's get a biscotti picture and share that. Sure. Okay, and hopefully, yes. So this is just the standard Android share interface. By virtue of having gone through that install flow, my scrapbook with PWA appears there. And I select it, and you see that it has now been shared to my web app. And from the web app, I could then, I don't know, I think I have a view over here. I'm not really good at web app design, so that's what looks like that. I also have a share, so this test is going the other direction. There is also, you know, APIs as part of the web platform for doing sharing out. What we just saw previously was known as a share target API. You have a web app that is a target for sharing. This is just a web sharing level two, which lets you share output to other things. And I don't think I have very much installed here.

 So this will do the uploaded photos. So it's all just nicely integrated with the Android operating system. Hopefully other operating systems in the future if other press managers choose to implement that. So anyway, okay. What we're looking at though is a pretty basic single page app. I will dive into the code in a little bit and then also talk a little bit about the service worker part of it because that was actually kind of cool for handling the incoming sharing I don't think I have anything too meaningful here. Yeah, I was just getting this myself. So the code for all this is available in the samples repo that we have. I'll share it out some point later. Actually, if you go to the web app and to the help screen, I'll take you here. So you should be able to get to it. But yeah, I just wanted to talk about a few things in particular. First of all, I really like Spelt, so thank you, Rich, and everybody who worked on the docs in particular. It was a very, very easy experience getting started, in particular because of all the interactive docs and examples there. So I think if you have been thinking about trying to use Spelt and haven't actually committed to going forward with it yet, like start with the docs. They're great. And this is the structure I came up with. I'm using what may or may not be the official way of doing single page app routing. It's like using Svelte SBA router which worked pretty nicely. And then I decided I was going to break all my different pages into different routes and expose some metadata on those routes. Kind of the interesting thing is that that probably is pretty standard of building SBA. Kind of the interesting thing in this particular case is I had to share some of that data between both my kind of actual web application but then also the code of the service worker, which needs to know about how to handle incoming share requests and then how to route, basically, after you do the share. I don't know if you remember from the demo, but it took you to the page that actually had the new thing that you shared. So that's the metadata that we wanted to reuse. and I thought that in particular I've been doing a lot of stuff with ES modules and the fact that everything is an ES module made it pretty easy to share all that I don think there anything super interesting out here and this is just my attempt to play with an app structure One of the things that I think these are all pretty much the same, one of the things I like doing is just keeping everything together in one place. That's another thing that was Svelte that probably folks who have used it in the past have been pretty happy about, is just having one file that has your code, has your HTML, has your CSS. It was very nice keeping this all together. And this was a really nice little piece of syntactic sugar that Svelte offered, which was native support from promises and things that are async and returning promise. so I have a lot of interactions with cache storage API, which is a standard way of saving HTTP response data in progressive web apps. That all is promise-based, and all you need to do is put this pound away, and you get direct access to the resolved promise once the ASync operation is actually completed. So it's really nice not having to write any code to structure and natively do then or anything like that. Just say, okay, don't do anything until this promise is resolved and then assign the value to this miracle and it all just happens. So that was really nice. All the other routes kind of went the same way. And components, kind of just little bits and pieces. I don't see if it's interesting there. The parts that are probably a little bit more interesting, though, In particular, let me just talk about the Service Worker implementation. So the Service Worker is, I think there's never played around with the rest of the web apps before. I can definitely talk a lot more about this, so grab me after, but just really briefly, it's the idea of basically JavaScript that sits in between your web browser and the network, and it can intercept network requests both outgoing, which is normally what you do, you do, but also kind of incoming, which is what we're doing in the case of the web share API. So the way that web share API, or web share target API, is defined you basically get an incoming HTTP post request to your web application or basically to whatever URL that you want but in this particular case it the URL of my web application And you get to say, over here, as part of the manifest group, you get to say, hey, use this particular URL, use post and platform data and that sort of thing. And then pretty much the way you're always going to handle this I think is the service worker. I don't know if anybody would do this by posting directly to a web server. So I think the expectation is that you're going to use the service worker. But the service worker here is listening for an incoming post event and there's actually just really nice web platform primitives for parsing multi-part form data automatically and for dealing with bodies of these incoming web requests pretty directly. So the amount of code that I had in my service worker was pretty minimal. And the other thing I'm doing is using a set of libraries that I work on as part of my main job called Workbox for handling things like different caching strategies and going to the cache first and the network and pre-caching a bunch of stuff. So this is an example of using those within the Svelte app as well. But the main things I was doing, so here's what I was talking about a little bit before, where I'm sharing data about routing between my kind of visual component that's being used for doing SBA routes, SBA stuff on the web app, and I get the same data playing to the service worker because it's all ES modules, and I can make use of that later on. I'm going to skip this part about the content. Sorry, this is the content indexing. Maybe I'm going to skip that for a bit. This is the part that actually handles that incoming post-repost. So it'll try to post a message to NK, saving media locally. And then actually just getting the body of the post-repost super straightforward. It's these, well, not all of these lines, but some of these lines are pretty much just just reading the body. And once I have the body, you could then write it out to cache storage via this cache.foot, and create the response it uses incoming body. And here's the part that's actually sharing some of the routing data and just figuring out hey what kind of media is being shared So it supports images videos and audio And depending upon the first file because we might also share multiple images in one go, whatever the first one is, I try to find the appropriate route, and then I return an HTTP 303 response to go to the page within the Svelte app. So that all worked pretty straightforward, for me, at least, well, no, let me take that back. That was kind of a bit of a hassle to come up with, so I don't want to minimize that, but I was happy with the final result. And just the rest of this is a little bit of kind of boilerplate for doing things like honoring range requests because the browser will add range headers when it's playing back, cached video or cached audio, and we have plugins and wordbox to take care of that, and then doing it with some pre-caching of assets generated by skills. And yeah, here's just registering that share target for a post, and here's registering something to handle the caching media. So that's the service worker. The part that's part that's not the service worker is this part, and this is kind of boilerplate. It's basically, I want to do the approach of registering my service worker when the page loads, but then also just listening for visibility change events to check for an update. I think one of the things that people sometimes don't realize with a single page app is that if If you have things that are cached very aggressively by a service worker, you will not necessarily get an update when you click on links within the app because it's only during real navigation when that happens. So I want to account for that by forcibly checking to see if there's an update for any of my stuff that's pre-cached and then basically calling reload if it does. I'm cheating a lot, and I think if I knew where I was built, kind of like in the area of things I would improve and well, hopefully improve as I learn more about Svelte. I think listening to some, what I'm assuming exists in terms of native Svelte events, for like figuring out if maybe visibility has changed or dealing with some native transitions and triggering these updates during those instead of maybe when the browsers document that visibility state changes, that might be one thing.

 I'm also cheating quite a bit by just forcibly reloading my page whenever I know that I'm making changes to the cache storage rather than doing some excellent things related to storage. Sean was just talking about where I can probably have a way of subscribing to changes in something that exposes the cache storage and then updating things on the fly. The kind of wrinkle with this particular application is because it only really works if you are launching it from the ad to home screen flow, you're only gonna have one instance of it running out pretty much so I wasn't quite as worried about like synchronizing the state or like having another instance modifying the cache storage and leaving it in a consistent state or anything like that. So that shaped some of my decisions as well as like laziness and not being super familiar with still. But yeah, that's pretty much what I wanted to talk about. I am happy to go into detail later on about anything specifically like Progressive Web Appy because that I feel a little bit more qualified to talk about but I would recommend folks who haven't tried Elspel yet for little projects, for bigger projects, give it a try because it is super fun to use and yeah, that URL again over here if you want to check out that, it's scrapbook.ua And I love that. So, cool. Thanks very much. Thank you. Okay, so I'm going to be talking about tracking changes with bitmasks, which is a new implementation detail in the new versions of Svelte. Not a new feature, doesn't actually affect how you write Svelte components at all or the things you can do it just some tuning under the hood that makes things a little bit smaller and a little bit faster This image is a screenshot from Eyes Wide Shut the Kubrick film which is a really fucked up film with face masks And tonight I'm going to be showing you some fucked up code with masks. Also if you've seen the film, a lot of the characters do like to show their lips, so it's appropriate. So the point is felt in one sense I mean there's lots of points I felt but the point I felt is to generate optimized code paths for different state change scenarios and what I mean by that is that if you have a component like this with three values all of which can change we can change A, we can change B we can change C it doesn't make sense if when I change A we need to update the DOM for the B and the C paths so the code that it generates or generated looks a little bit like this. We have this object called change and it has Boolean properties corresponding to each of the variables inside the component. And then there's this other thing called context which contains the actual values. And so we'll do if change.a, that means if the value of a has changed since the last update, then we will change the value of that text node by directly manipulating the DOM. And this is all done good. It works. It's pretty efficient. It's like the reason that Svelte is relatively performant in most situations. But if we start to do things like this instead, and then replace our single character variables with those, then you'll start to notice that the generated code gets a little bit more unwieldy and I'll show you what that looks like so down here we've got change.firstnumber ctx.firstnumber and so on and the reason that's bad is because when you minify that code those property names will still be written because property names don't get mangled unless you're using Closure Compiler on the advanced setting or something. And even then it doesn't always work. So that's not great. And also down here at the bottom where we doing the setup work we creating these click handlers to handle the events And then we creating this object that contains all of those things named So if I just copy all of that and paste it into the terminal and then minify it with the module setting then you can see that we've got click handler referenced here and second number and third member over here. And it's not great. So, can we do better? Yes. As we repeated several times in the generated code, that changed object, the dirty object, which is tracking what's changed between renders, that's got to be recreated after each component updates. So that means that the garbage collector has a bit of extra work to do. Not a lot, but every little helps. and actually doing the object property lookups isn't a free operation. There's a very minuscule cost there but these things mount up. So a while back we started thinking about using bitmasks which are a scary sounding technique for combining multiple Boolean values into one. For those of you who've got a computer science background this might feel a little bit CS101. I don't so this is kind of new and exciting to me and I want to share it. what a bit mask looks like is this I wanted to do this within the PowerPoint slide but I figured it's actually easy to just generate this in a REPL so you can see it here so the first row of numbers here are my five options call them A, B, C, D and E and then the second row contains so the first row we're going to call that the bit field and the second row we're going to call that the bit mask and the way that it works is you assign a number to each of the options, doubling it by two each time. So A is 1, B is 2, C is 4, D is 8, and E is 16. And then the bit field is just the collection of all of those added up. So if we have A and C, the bit field will be 5, and D, 13, and so on. And the bit mask, if we wanted to do an operation on that, say we wanted to add B to the mix, we could just add 2. to make it 15, but then if B was already set, we'd be making it 17 and that would be wrong. So we can use the bitwise operators, which are these characters You seen the binary operators when you have like if A double N ampersand B that means if A is true and B is true. And you've probably seen the corresponding one with the pipes, which is if A is true or B is true. These are kind of similar, except they operate on integers at the level of the binary bits that make up those numbers. so if we use the pipe bitwise operator then we can see, in fact maybe if I make this a tiny bit smaller so that we can see the whole thing and get rid of the enter full screen there we go, a bit more space maybe so the bitfield pipe bitmask is 15 that's all of A, B, C and D So for the next operate, by the next time we come round, because we've applied that operation, we'll have all of these things set. And this is really useful because you can check whether an individual option in that bit field is set by comparing it with your bit mask. So if you have a bit mask that contains the 4 for the option C, then you can see on this first row right here that that lights up. because it's taking all of the bits that make up that binary number and it's seeing which ones line up, which ones are both one, and then combining them. And so you can start to see how you could use this to determine if certain values have changed inside your component. The last bitwise operator is the little hat sign there. That is the exclusive all, which is all of the things where only one of them is 1 and all the others are 0. So here A and B are both true in the top case, so these are both 1, but because both of them are C, that is a 0. And I haven't actually had to do a whole lot of setup to get this to work because I'm using some other bitwise operators. This double left arrow here takes the binary numbers and left shifts them by 1. So your 1 becomes a 2, your 2 becomes a 4, your 4 becomes an 8. And so if you do 1 left shift by 0, you get 1. If you do 1 left shift by 0, you get 1.

 by one you get two, one left shift by two you get four, and I can actually show you that here. So this is how you write a binary number, you prefix it with 0b in JavaScript, so that is two for example. Two shifted to the left by one is four, if you have a number like 10 and shift it by 3 you'll get 80 this is a really fast and efficient way to do a very limited subset of arithmetic operations and we're literally just querying the bit field itself using the bit mask that is generated from the index within the loop so we're not tracking separately whether A is true and B is true and C is true and so on, it's all being done using the Bitwise operators. So that was kind of a confusing and quick introduction to thinking in Bitwise operators. How does it apply to Svelte? Well, if I can go to my saved apps. I can show you the thing that we had before, but this time it's using the most recent version of Svelte. and if we look at that update code now it's comparing the dirty value against the number 1 for the first number against the number 2 for the second number against the number 4 for the third number because it's 1, 2, 4, 8 and so on and then here we've got an expression that contains all three and before we would have had to do change dot the first number or change dot the second number or change dot the third number. But now we can just do dirty and seven. And that is the expression that determines whether or not the contents of that paragraph tag will need to be updated on the next update. And the really nice thing about this is if we take a hold of that and run it through here. That's 1087 bytes If we go back to the previous version before we had this feature do the same thing again 1548 bytes. So you see we've made a pretty substantial saving, admittedly in a somewhat contrived example, but you can see how this will result in smaller applications. And because the memory usage of this is reduced because it's just an integer, it's not an object with a bunch of properties. And because of less work the garbage collector do, in theory this is going to make your applications faster as well as smaller. You can also do stuff like this. This is a tweet that I just happened to see today which is absolutely nutso. But whether or not you will ever find a use of this is debatable. but it's nice to know that you can. There is a catch, however. In JavaScript, bitwise operators work on 32-bit signed integers, and one of those bits determines the sign, which is whether it's a positive number or a negative number. So what that means is that we can only represent 31 values with a bit mask. And most components will not have more than 31 values that you can change, but some might. and so we need to have an array of bitmasks instead and so that's why if you look at that code back to the current version you'll see that we're actually destructuring the dirty array to get the number because in this case we only have three so we don't need to use the array so we're destructuring it to get the underlying number instead if that makes sense okay so um i haven't found a ton of uses for these techniques but when you do come across them it's pretty fun um this is this is a nice little example i often find myself manipulating colors in various ways, like trying to pass color strings or turn a collection of color components into a color string. And this is quite a nice way to do it. Let's say you've got a hex value representing a color Something like this right So F70E00 that is the hex colour that you might use in your CSS That corresponds to a number which, when written out in hexadecimal, is basically the same. You prefix it with 0x to write in hexadecimal in JavaScript, and then it's just the same thing, F70E00. Or you can represent it in base 2 and you can see that there's 24 different bits that make up a colour, 3 bytes. And then in base 10 it's a number which doesn't really correspond in any meaningful way to the number that is displayed on screen. and so we can take that hex value and remove the pound sign at the beginning and parse it into a JavaScript number using parsing and passing the second argument which is the radix that determines the base of the number system that you're dealing with and then once you've got that number you can split out the different components of that colour The red is what happens if you apply the RGB bitfield and this bitmask, FF0000. It means only keep the red values and discard everything else. And then you right shift it 16 bits so that it becomes a number between 0 and 255. And then you do the same with green, except this time you're only preserving the 8 bits in the middle of that 24-bit string. and then you're shifting it eight bits to the right. And then the same for blue, except this time you don't need to bit shift it at all. And so you can see, as I'm waggling my MyStream here, the components are updating to show how that color is broken down. And that's just using a regular old progress element. And actually, if I switch over to this view, then you can see that the sliders in my color input correspond perfectly to the components in the progress bar. so that's a fun thing to do if you ever need to deal with colours also recently someone raised this PR on a library that I maintain called MagicString which is used inside Rollup, Module Bundler it's also used inside Svelte and there was a bit of a problem with MagicString because it maintains all of the locations of the source code that you pass into it so that it can then later generate a source map That kind of the whole point of what this library does But it super memory intensive because it was storing all that information on a giant object And it was causing people's browsers to crash or causing people's node browsers to crash rather. And so someone came along and said, what if we use a bit set instead? and a 200 kilobyte JavaScript co-filer had a source map locations object of 980 kilobytes. After this PR, it's 36 kilobytes. An almost two order of magnitude improvement by using this technique. So it can be useful if you find those rare cases. Those are my slides. Get your bits out. Thank you. Oh, which one? Yeah, uh, check time. So we're going to take a break and when we come back we'll be learning at time until So we're fine. Yeah, well, so I realized that the main hack time is basically the same as the rate. Typically, we're in the same room. So we don't like meeting this up in a room or something. So we might as well show the rate in hack time. Just a little bit. OK, so for those who are using this meetup, we kind of have two sections. First is about the cost to get you motivated. Second is for you to get your hands dirty and work on something and try something else. So for total beginners, I recommend going to spout.w. slash tutorial and then guide you through the basic APIs. For people a little bit more advanced, take a look at SAPR, which is the server-side study of the primary that comes with that. It's not for building . May I have your attention, please? Yes. May I have your attention, please? We will be conducting tests of the building's viral system.

 Please disregard all signals, tones, or alarms you may hear what's seen. I remain, we will be conducting a test of the building's fire alarm system. Please disregard any signals, tones, or alarms you may hear what's seen. This is only a test. Thank you. Smell this off. I didn't move that off. And then the third one is all the third party community libraries. We're trying to aggregate all of them here. So, Svelte community slash code is where it is. And you can see all the links on Svelte. And also, like, my demo, Jeff's demo, Rich's demo, you can also just try it out. Do something you haven't done before. That's super helpful. So I think, oh, and by the way, if everyone hasn't connected to Wi-Fi here, it's Google Guest Wi-Fi and no password. So that's super helpful for just break out like four small groups. And then we have a show and tell at 745. And also, the reason I have this box here, sorry. I have a spell sticker. So I'm going to be putting it on. Yeah, that's it. Great. All right, great.