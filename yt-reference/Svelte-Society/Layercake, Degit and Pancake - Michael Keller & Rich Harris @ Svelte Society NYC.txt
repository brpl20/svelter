 I'm Michael Keller. I'm a investigative reporter at the Times. I have the pleasure of working with Rich Harris. I also make graphics and do various kind of data journalism things. And I want to talk about chart making. And a project I've worked on is kind of a side project for, which is weird to think, like three years, making charts. that started out as D3-based and then did a Svelte 2 version and just finished the Svelte 3 version to kind of talk about both the problem with chart making and then moving it into Svelte and kind of the cool things that Svelte both does as a library, like handling the state and reactivity that made a really cool choice for this type of problem and also the component API in Svelte It also made it really nice to just build charts in this way. Does anyone, chart making is not what everyone does, but who has made charts and things generally? Okay, cool. That's pretty good. So I'll start with some history of the problem that I was trying to solve. And so this is around 2015 or so. I started getting a pattern, like, all right, charts are tedious. and we would generally build things in D3 and we would start, I'll show some codes, mostly it's about structure as opposed to syntax. So this is a general basic line chart and kind of the background for making any chart is you've got an extent to your data and your values go from 1980 to 2000 and whatever other fly values go from some other things. and then you measure the DOM container and its width and height and you map your x extent in your data to the width and your y extent in the data to the height and it's pretty much the whole thing and when you think of it that way it seems pretty simple but it's really annoying to do over and over again and it was compounded by the fact that you see all these examples online where they were in blocks if you're from the deep world and you say oh that seems really cool but it wouldn't have any of the architecture to be updated when you resize the screen which would just get really annoying and so you'd see this cool example and it works in blocks and you try and copy it into your project and you like okay I actually have to re all this stuff and identify all the things that are going to change when I update versus the stuff that going to render and what clobbers what updates what mutates and it was really annoying So this is a basic chart, and this is kind of what you would get off a block. So you have, we're just setting up some basic global variables, which is also the pattern, which wasn't great. within your load data callback. You're measuring the extent of the data, your y extent, your x extent, setting that on your scale. This is your little line generator. And then you make the path. Pretty simple. It works. But the issue is, you know, you open this up on its own, and you try and resize it, and it doesn't resize. And I remember I was talking to someone on our graphics team who was really, in my previous job, who was really into doing things in Illustrator, and they were kind of getting into code. And they did this really cool kind of lollipop chart, otherwise known as a Cleveland dot clock chart, and they were super proud of it because they did it, and they were like, okay, Michael, can you help me make this responsive? And I was like, four hours, and they were just like, all the enthusiasm for using this new tool just drained out of them. I was like, this is really annoying. This is what, essentially what you do, this is the same chart, and you can see it's more code, and this is what you have to do to make it responsive. So you have, like, here's our load data callback, and we're setting, like, chart data, because again, it's like global was kind of the paradigm here. You, like, bake your chart, which, like, renders the chart, then you, like, set your values, and these are all various things of, like, same stuff, like measuring the data, measuring the extent of the DOM. Render chart is the thing that actually is touching the DOM, drawing it all. You have to think about all this stuff and it's annoying. It's like, all right, on resize. Do the on resize function, which you set the values, you render the chart. And it was just like, I know how this works and I don't want to do it every time. And so that's a good opportunity. It's like, that is great for a library. I'll take a step back. So this is great. It's like, great, I want to make a charting library. there are many different approaches to this. And I think most of them, well I'm not saying most of them, but I'll say there's two is kind of like the low level, which is what is kind of the D3 way, where it like here a bunch of utility functions and scales and scales just being the heart of any chart thing Add it do it You end up with this situation where you have to manage the architecture yourself as a user Or you have the kind of like, anyone remember high charts? Yeah. Kind of like dates myself. Yeah, like high charts or like the Vega paradigm where it's like, all right, I don't want, I just want to say like scatter plot because it's kind of insane to like do all that for just a line chart. These are like pretty basic chart forms. you should be able to get some data say I want a scatter plot and you get a scatter plot the problem then is it's very rare that you just have a chart that you reuse the same over and over again there's always going to be like a little fiddly thing, there's going to be like label placement needs to be done done special or like the x-axis ticks need to be different no matter how many times everyone's like we have a style guide there is no style guide for x-axis ticks it's always different every time And so if you do that kind of like very high level, high charts or vega scenario, you end up with kind of like this spec where it is kind of very, like I'm just typing out some JSON, but you have to learn, this is like I think a grammar of graphics implementation, all of this very specific vocabulary and concepts. concepts. Like, what is a series? What is a tick? What is a mark? And it's really neat, because you can get into it, but then when someone is telling you, oh, can you just, like, make a little tick in between the year to kind of show each month? You're like, okay, I need to translate that into the language of the spec. And that I find just even harder, because, like, I'm kind of like, well, why did I learn all this thing? I can just know how to write a loop, and I can place that on my scale. So I didn't want to do something that was super high level as that, which is what a lot of the charting libraries were. Any questions so far? Show us. I'm trying to go back to that. So that's kind of the first two issues. One, low level is kind of tedious. High level, you lack customizability. The third issue we run into in the newsroom, we're building things on deadline. you have to decide really at the beginning of the project often, what kind of technology we're going to use. Is this going to be like an HTML? Because if it's a column chart, you can just do it in divs, that's totally fine. Is it going to be SVG? It makes sense if you have a line But then you like all right this is an SVG and then I have a little label for my line annotation and then an editor comes up at the last minute and you like actually we want this different label that like 10 more words and it needs a line break And you're like, I have to implement line breaks in SVG for mobile and all that, and your editor, of course, doesn't really understand why a line break is so hard, and to their credit, it really shouldn't be, but it is. So I was like, I want to build something where those changes in language I can abstract away a little bit, so that if someone says, like, all right, we actually need a ton more data, and I think I should render this in Canvas as opposed to SVG, I can do that more easily, and I'm not working on, all right, I can kind of do it, but I need to make, like, a Canvas overlay that matches my D3 margin conventions and that type of thing, which I'd done for a few charts, graphics, and it was fun and cool. I thought this could also be a way to eliminate some of the differences here. So I ended up building Layer Cake, which is layercake.graphics. You can check it out. This is a little bit of the API. The idea is that the library itself uses Svelte Stores and Svelte Context to do all of that scale handling. It measures the extent of your data. It measures the target div that your term's going into. It does the scale for you. And then because these are all stores and reactive, you get all that resizing for free when the dimensions change, which is, number one, a great thing. It works really well with the spell reactivity. The second part is the spell syntax of the component. So you can see here we import a layer cake component from the library, and then it exports these SVG HTML and canvas wrappers. The idea was that it would be really declarative. I didn't want to repeat myself that much. So when the main thing you're declaring is kind of like the X and Y accessors for your data, so if your data looks like this, you tell it, all right, get the X dimension on the X, Y dimension on the Y. Here's the data. and then you can use the built-in layout wrappers, or what they're called, to put your components in there. Now, one key thing is, you'll notice the axis, the line, the scatter, the labels, are not part of LayerCaper. Those are components

 that live in your own project and are really up to the user to build. And that's because, I think, one, building libraries is fun, but maintaining libraries is really hard. And so you also lose that customizability. So by putting all those, like, you can't really build the end-all, be-all scatterplot component that's going to work for your project. So don't even try and do that. The user can start with a little bit of sample boilerplate, and then just start building off that to make it custom for them. So I'll show you a basic scatter plot. And then because all of the coordinate systems are synced between the SVG HTML on Canvas, it makes it really easy just to kind of move between them because you can add as many of these overlays as you want. So this is the main one. So this is an SVG scatter component. You use the svelte get context function with the keyword layer cake. And so you get your data, and you get this xget and yget function. And so this is really just what the starting scatter plot component would look like. xget goes into the data and grabs the x key from your accessor, and that also applies your scale translation. It also exposes just the accessor and just the scale if you wanted to use them separately. But most often, I use them together. And in a lot of D3 code, you see this just, like, nesting of, like, X, you know, D, X, X scale. And I get confused, like, is X the X scale? Is X the accessor? So it just needs to be one. Most often, that's the case. But if you need them to separate, there's an escape hatch. and the other thing building it building it in D3 was alright but you didn't have this great I think it's really nice to be able to start composing graphics like this because then from project to project you can start reusing them more you have a common starting point for each of them as you're jumping off point you know you're going to customize but you can start composing them and it feels much nicer it's also nice because in Svelte 3, the exports are really cool. And that was one of the big changes from going from Svelte 2 to Svelte 3. I used to have this options object that was kind of annoying And it was actually still a JavaScript API so in this new version of AirCake it all as a component API So you can start to build kind of this like canvas scatter component export the R and the fill color, and you have kind of what's a pretty good beginning of a reusable scatter plot component. And it uses internally D3 scales. so you said it is expecting either an x, a y, a z or an r accessor you kind of get four if there's a use case for more than four let me know, it seems like four seems to be enough and uses d3 scales internally, you can pass in your own d3 scale your own scale as long as it has like a actually I think it's pretty open as long as it has like a domain and a range method on it the idea was there I wanted this to be maintainable and just bite off as much as I could chew. And there's so many different use cases that D3 scales comes up with that I don't want to have to fit into my head, the ordinal scales and all that. So it's time to work there. And I think that's pretty much it. And then so Rich is going to present on a similar charting library, which is really cool. And he gets at some of the SSR issues that I hadn't thought of with this. And then we'll talk about some of the, like, I think they're very compatible. and some really cool techniques that he's thought of. And yeah, any questions? We'll do questions at the very end. So yeah, on the website there's more examples that show some interactivity. This is one that shows kind of the idea of why you can have a canvas background if you don't want to waste DOM elements on visual elements that don't need interactivity, whereas SVG is much easier to do hover stuff on than canvas. So that's a use case for where you want to mix the two. You can do swoopy arrows, some other kind of tool tips. Voronoi, that's that Cleveland doc plot. Animatings, this is when you want to switch between the domain of the specific data versus a global domain, and then some kind of other interactivity. Yeah. This is super cool. So all the implementation for all these examples is not going from the library. you're just coding it yourself. Right. Do any of them use D3 in user land Can you do that if you wanted to get the data reactively and then have it run D3 code every time it changes Yeah I mean it a spell component so whatever goes in that is totally up to you Yeah, it uses the layer thing slots, so it's just going to plop whatever goes into your component into that wrapper. So if you wanted to run some SVG stuff, you could have your own little SVG thing here. And I think I have some examples that this one has for the line generator. This one is using just constructing the line manually, but I have some in here that use D3 SVG generators. I mean, this is all using my D3 projection. So that's an example of D3 Geo making the projection reactive, and I built this one. I tried to build the examples on the website of thinking of, like, What's a pretty good generalizable example? So this one kind of lets you pass in the projection name as an export. I think, yeah, the area used to D3. D3 shape. And also imports just a D3 scale to do the work and all stuff. That's using the area generator. Very cool. Yeah, as someone who's worked with a lot of your libraries, I think there's a lot of wisdom in just taking on the data part, you know, and like you said, basically taking off the rest of the user plan. Yeah, I think it was kind of like just like the nib of the pen. Right. Because that's really what you want to, you want to worry your time about, like, what is actually touching the DOM. And then let, and Svelte does a great job just handling the reactivity for you. and then those wrappers just kind of give you some escape hatches of what format am I using this in and the margins. So you can do the SVG and then the axis bumps off the edge, so it just uses that, like, margin convention. How many years do that work? Yeah, I've used a version of this sitting next to Rich, which makes great graphics, so I've only had to make a couple, what charts that is. But, let's see. I used, what was the headline of the YouTube one and the Chan story? Flourishing the business of YouTube views. This was the story I did that I did the charts for this was the first this was the Spell 2 version which was like oh Michael you writing this story by the way also make the charts for it. And that was about six or eight months in or so of the job, I was like, I want to learn Spell. So I was like, all right, let me try and import the D3 layer cake into Spell. And it worked really well. And so these are layer cake ones, which was really nice, because you can start building it up. You have, they all share the line component, but the color gets passed in as a prop, so that's reusable. Again, it's small multiples, so that really lends itself well to the component style. And then there's like, you know, that line is one layer, and then the annotation and the arrow is another layer. So it was nice to compose it in that way. Fighting the good fight, that was it, right? Yeah. This was using what I learned was a not well-written and buggy version of Laracade 3. These are all just awesome graphics. And then I made this very fine chart. But yeah, so those are two. This isn't the version that is now published. This version is not as good. But yeah, we'll have this much to work. But that chart down there is made with Laracade. Yeah. So that's pretty custom. If you try to do something like that with high charts, it would just be that way. Yeah, yeah. And there was stuff in this where this was a little bit of a challenging, it's a pretty simple chart. I guess that is a sign of a good one where it's kind of a challenging data set with a very simple visual, but we had some data issues where you can see the y-axis is over 150,000. And so we had some months where it was very, very small, but we still wanted that to show up. So it wasn't like a pure mapping, so we kind of had to set a base, a floor of one pixel. So similar things where if you want to use D3 path generators, the defined method is really useful. Whereas if I don't have data, here's a function that will tell you whether to draw data. You run into stuff like that all the time, and it's a very simple chart format. Would the logarithmic chart work better for that? Logaritan charts are really difficult, I think, for readers to understand. I think we also, the visual effect of this was we wanted to show the massive increase of the narrative.

 would have been a little counterproductive. It was flatter. Yeah, it's always really challenging when you get a data set that has those huge differences. And I think, yeah, there was a log scale for some of the coronavirus stuff that you were, I'm sure if you were involved in that, you can speak to log and make scales in general and make a decision on that one. Yeah, it's tough. Just wondering, like, it seems like kind of high stress, like you mentioned, all these deadlines. Do you need to have a fallback option if whatever you have in your head doesn't work? Or are you just that good? Chart-wise, the first attempt never works. You just have to cobble together stuff that eventually does. But I think it's a good... It's kind of like a high stress often yields a good result because you have to constrain sometimes what you want to do, which in the end crystallizes it. At the end of the day, it's all about kind of telling a specific story and a really clear story. And so that kind of like, all right, we really need to get something there. How do we boil it down to that really simple idea? Just one last question. So like this example where you do the annotated column, it's kind of what you're talking about where like you want to use HTML to render text so it takes care of wrapping. Exactly. And I should have pointed that out because that is one of the real things that I wanted to do is like, SVG chart, HTML, does text really great, let's throw the HTML in there. But again, this is like a really, it gets complicated really quickly, because you have an SVG layer for the column, a text layer, and then arrows. And the way I wrote this arrow, I don't want to call it a library, but the arrow component in here works really, I don't know if declaratively is the right word, I don't know all the definitions this works. We all are better programmers than I am. But I, for me, working, and take a step back, there's also a lot of people that do Illustrator stuff, like charts in the newsroom, which is great. Why I've gravitated more towards the code approach is I do better when I just kind of have to do things in one area, like one spot, and then it cascades down. What would that be? I'll make the chart once, and and then it can work for mobile, as opposed to, like, let's do three different charts for different widths And it like all right there a misspelling in this annotation now to change it across your files I much worse at the latter problem So what I designed for this example was the arrows attached to the text the HTML text So you can move the HTML text around and the arrows will follow it. Because I always get annoyed when it's like, all right, I want to change the arrow, I want to change the text, which is constantly changing until another publication. And then I've got to change the arrows again. You've got to follow it. And it's like, I don't like that. So then you not only have the column SVG, we do those two layers, you have the column layer, the HTML layer, then the arrow SVG layer can read from the HTML annotation layer and kind of cascade down. Which for me I like better and it's kind of cool to have that only be done in one place. But yeah, so again, it's pretty simple, I'll have to say. It's already simple, but having in those different components helps. You were saying if you changed the text, the arrow would just stick to the edges of it? Yeah. So I kind of wrote this little bit here where the annotations you define in this JSON object. And again, this is all outside the library. This is just however you want to build your components. You define where that text is based on percentages, and then it has an array of arrow objects, which can be clockwise. The source attaches to these options. You have a DX and DY, so you can fiddle with it, so you always need to fiddle with it. And you can apply the target. I think you can apply the target in percentages or pixels. I think is how I ended up doing it, but I'm going to always do it in percentages. Yes, this one has two arrows coming off of it. And so this is an example. The only difference if we reduce the D3 margin convention is I've renamed it to padding because margin just didn't really make any sense. The CSS padding paradigm is much closer to it. And then it's normally a linear scale, but you can pass in your own scale. over a column you may want to do a scale band or whatever, you can pass in your own. If you want to overwrite any of those built-in, kind of measuring the extensive things, you can pass in your own custom ones. This is a feature I often found for the line chart is a good example of this. If you want, sorry, for the area, obviously the y-axis you want to set up R4 at zero, So that actually is showing it from zero. But you still want to get that automatic extent calculation. So you can say set Y domain at a four of zero but null for the max and then it will just take what it needs off of your data So I built in some things that for me as a user I want to offload as much of that automatic calculation like if the library can calculate it, let it do that, and then me as a user I'll just kind of add in a little bit of custom things that I need. Thanks. I was going to use the same screen recording. Yeah. Okay. It makes it easier. I'm going to edit it later. See if I can turn off that sound. I mean, you said it shut this point. Yeah, it's probably actually... Browser discourse. Oh, yeah. It's all this. It's cool. So this Game of Thrones thing that Michael pointed out earlier I think it was the first thing that we did with Svelte at the New York Times and you can tell that it was done in 2017 because Daenerys is still in the good although you go back every few months and she's shifted a little bit Okay, so today is not just Svelte Society in New York City it's also happening in London today a worldwide Svelte Meter extravaganza and in a couple of weeks it's going to be happening in Russia as well and the organiser of the Russian Meter asked if it could be called a video to set things off what do you say sorry I'll what's Russian Privet Privet Privet Privet well that means hello yeah for sure ok ok so I will say in the video I will say on behalf of of Svelte Society we will say Privet Privet Hey there, it's Rich coming to you from the Microsoft headquarters in the middle of New York City. There no windows in this room so I just going to have to take my word for that It the 4th Svelte Society New York It been really incredible to watch the growth of the Svelte community in Russia and it's awesome that you're having your first meet-up and the leadership of Pavel and others in the community. So I just want to say from everyone here to everyone there, Prima! Prima! Prima! Prima! Prima! Prima! Prima! Prima! Alright, thank you. So the other day I posted a blog post about this charting library that Michael mentioned. So what happened is a few months ago, before the new version of LayKate came out, I was tasked with building some charts for a story that Michael was working on, which was what delayed the release of LayKate in the first place. So our bank of desks at the New York Times has a very high ratio of stalled charting libraries. And so I started from scratch because Layer Cake didn't yet work with version 3. And I came up with a chart in library that does a very tiny fraction of what Layer Cake does, but it just has one clever trick which I felt was worth putting into an NPM package and releasing, which is that Pancake, the chart in library that I'm talking about, can render charts that don't actually require JavaScript to run in the browser. What I mean by that is that we go to the website, the Pancake website. So this is an example of a Pancake chart. We've got a tooltip here that shows the data, and it's changed the way it's off from . But if I were to disable If I were to disable JavaScript, then it would still work. We don't get the tooltip anymore, but the chart itself is still visible, the data is still visible, and this chart is totally responsive and all the rest of it. If we had some responsive CSS on this, then that would also work. It's just the JavaScript that's missing. So this is a good example of something that is being progressively enhanced. The same is true for the other example charts that we have here. I can't click these buttons and I can't use this filter here, but the chart itself does work. I'm going to re-enable JavaScript so that I can show you what they do. So this is a population-period chart. You can see that back in the chart.

 Back in the 1850s, there were way fewer people, and then you kind of see here that there's more men than women in their 40s and 50s, in the 30s, and then at a certain point around 1970, all of a sudden, that flips around. There are now, like as you get older, men die off a lot sooner. I'm not exactly sure what that is but it's kind of interesting to see that that has kind of fewer graphs in general but flipped around. Ah, is that so? Okay. Probably. That's a pretty good hypothesis. Yeah, so it's interesting to see how that's flipped around between 1930 and the present day. And then this life expectancy chart, we've got some interactivity here where it'll find the nearest point to where the mouse is and then highlight that line. and you can filter a specific country like that. This is the kind of thing, you saw that Vega chart configuration earlier, that giant blob of JSON. You can't imagine trying to do all of the little micro-interactions and customizations that you can so easily do with JavaScript through a component library using some sort of configuration type approach. Because it's spelled, we can also do nice motion and transitions and stuff. All of that, without having to put that in the charting library as well. I'm not going to talk too much about how this works, because I covered it very briefly in a previous society, and also I've written this blog post. So if you are interested in how it works without JavaScript, then it's all written down there. One last thing I'll say about this. I'm actually using the same technique in a mapping context. We're doing these charts at the moment, tracking the outbreak of coronavirus. And these charts need to work on mobile and on desktop. Like that. Completely responsive. But it also works without JavaScript. An earlier version did use JavaScript, and it meant that the first thing that you saw when this page came to life was this Like you would see some text then you would see a header then you would see a footer then you would see some more text. And you had to wait for all of the analytics code, and the ag code, and the comment code, all of that to get out of the way before our JavaScript would run. And then D3 would load, and then we would load some geodata, and then we would construct a map and put it into the DOM. but now that we're using this JavaScript free technique, as soon as you load the page, the map is already there so it's doing a better job of conveying information to our users That's enough to talk about charts for one night, I wanted to make some announcements about a tool called DGit, which is not technically part of Svelte but it is what you see when you first visit Svelte.dev under the getting started section npx dgit svelte.js slash template mysvelte project is how you start a new svelte project by default. npx, for those of you who aren't familiar, is a tool that downloads and executes packages from npm. So dgit is a thing that you could install globally, and you could just type dgit svelte.js slash template mysvelte project. But npx means that you don't have to have it installed globally, and whenever you use it, you'll get the latest version. svelte.js slash template is the repo on GitHub where this project lives and then MySpot project is just a new directory. So this is to my mind the simplest possible way that you can scaffold a new project. And it's a little bit different to how this stuff normally works. In React land you have create React app. In Vue land you have Vue CLI. Angular has its own CLI as well. And this is how most front-hand frameworks handle project scaffolding is by having these sorts of opinionated tools. and there's a few pros and cons to doing it that way on the pro side you can be extremely opinionated when you're building tools like this you can have all sorts of nice error messages give the user lots of good feedback after you've created a project like the Create React app you can then maintain it later if there are updates to the project template new version of Webpack, whatever it is then you can add that even after you've made changes to your project you can do things like add new routes to your app if you're using the Angular CLI And you can have wizardy style interfaces where you'll ask a question like, are you using SAS? Do you want to use Babel? And you can say yes or no, and it will configure your project accordingly. But there are some pretty concrete downsides as well There a lot of complexity There a lot of stuff that you need to try and learn and understand in order to deal with these CLIs The tool itself is under constant pressure to encompass more responsibility A lot of people will be like, why doesn't Create React App use TypeScript? So the CRA team has to consider adding TypeScript, and then it just becomes this ballooning thing of like, addition after addition after addition. The third one I think is crucial. You can't make your own template. make your own templates. My idea about how to create a project might be very different from yours and if you need to do something equivalent to create React or the Angular CLI in order to customise these tools then I think that's a pretty major downside. And the last one you're going to eject anyway. The point about being able to update stuff after you've created it only applies until you eject from the project which is the thing that happens when you need to add some customisation that the tool did not anticipate and then you just turn it into a regular project and then start editing it. And at that point you can no longer use the tool to maintain the project. So I prefer a much simpler approach which is just clone a Git repo and from that point forward you can't make any changes unless you want to faff around with the Git history but you're probably not going to need to. So DGit is a tool which allows you to clone a Git repo without also cloning all of the Git history and it's faster and it works offline and there's less to type because you just need to type mkxt git.js slash template instead of Git clone and then a fully qualified Git URL and then like dash dash depth equals one or whatever to stop with the history. And it seems to work pretty well. There are some downsides to this approach but it does seem to work pretty well. The reason I'm talking about it tonight is because as of today there's some new stuff in Digit which will make it nicer to start a new self-project. Firstly, faster installation through bundling. And I can demonstrate this. So if I were to do MPX... Do you mean to pop it? Yes, I can. Yes. Hang on. 2.6.0, so that's the last unbubble version. You see it took 3 seconds to install there and then if I get the most recent version hopefully this is going to work. Yes it did, okay. Okay, so way faster to install, and the reason for that is because dgit no longer has any dependencies. all of the dependencies are def-dependencies, which means that they get bundled into the package, which means that you're only requesting one thing from NPM. You're not requesting one thing and then requesting all of that thing's dependencies and all of that thing's dependencies until you've got the entire graph. There's just one blob of JavaScript that takes care of the whole thing. It also works with private repos, thanks to... You still have their CD in and Yarn install or whatever, right? Yeah, so if I go into that... directory then I was still going to do MPM install which if you saw MPM install in one second man I'd be all I'd be on your creature honestly we could probably make the project template a little bit simple so that we might not have to do any of this no chip stuff oh god that took 20 seconds well my first thought sorry I can ask you about another thing No, no, no. Keep going. Well, I was just quickly going to say, like, my first thought when I saw this was it's a good way to, like, if you want to reproduce something, like, if you wanted to, like, maybe not even for a project, but, like, let's say you wanted to create a spell starter or something that people could create to reproduce an issue before opening an issue. It seems like a really good way to do that. And what if you could, like, cache the node modules there? So it's basically just a really easy way to get that on my computer, and I can reproduce my issue, you upload it and then post it. As an open source maintainer, I have the same problem. It's hard to get people to reproduce things. Yeah, one thing that we can do with dgit is add what are called actions. This is where it gets slightly opinionated, and actions is actually a micro-color idea. Where after you've cloned the repo, you can then do something like remove some files or add some new files. You can see we have an NPM install step there that would do that automatically. The way that it's implemented is it just goes and fetches the latest table for whatever you've specified using the local cache if that fails for some reason.

 and then it's just extracting that table. So you wouldn't have Node modules inside that unless we changed the architecture a bit. But it's definitely an idea. Yeah. So the other change is it now works with private repos. It used to only work with public repos, but thanks to a pull request, it can fall back to using GitClone. So if you have your own private project template, it will work with it. And perhaps the most exciting new feature is we now have an interactive mode. So I can just do mpx.git. And it will give me a list of all of the things that I have cloned already in reverse order of how recently I used them. So because the last thing that I cloned was the Svelte template, I can just hit enter, destination directory. I can decide whether I want to use the cache version. I don't. And then off it goes. so cloning Svelte projects or creating new Svelte projects just got a little bit easier again thanks to a brilliant pull request from this person's I don't know, I guess it's how that's pronounced yeah that is that is it, new version of Digit hope you all like it that's all for me applause applause applause applause Bye.