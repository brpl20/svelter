 So I'm going to just create a little demo repo to show off the integrated testing that we now have. If I do MP and it's felt at next, my demo app. Yeah, can people see that? Yeah. Create a skeleton project. we will no TypeScript no ESLint we'll use Prettier and we will use Playwright and so now if I CD into my new project and MPM install then it's going to install along with SvelteKit and the other dependencies that are involved here it's going to install Playwright for us which means that once it's finished it should just take a second And if I do npm test, it will run some tests. And what that looks like here is, yes, I trust the authors. In here, we have a test.js file that was created for us that just has a single simple test. And what it's doing is it is opening a browser. It is navigating to slash on our development server. actually it's building the app first and then it's running the app the production version of the app locally and inside our our SvelteKit app we have an h1 that says welcome to SvelteKit and it is verifying that the contents of that h1 are in fact welcome to SvelteKit and because this is Playwright which for those of you who are not familiar it's it's a headless browser controller thingy it's built by the people who did Puppeteer back in the day and it's basically just like running a full browser, but in a controlled way. So it allows you to test your app in exactly the same way that your users will end up using your app. We don't yet have an integrated way to do unit tests, but this was the priority. We think the integration tests are a lot more important than unit tests, because those are what verify that the app is gonna behave for your users. And in case anyone hasn't actually seen what the skeleton app looks like. This is all it is It just a blank page to which we can add stuff I going to actually shut that and go over to the here one I made earlier My slash demo whoops cd And open this to walk through some of the other new features that have been added to SvelteKit in the last few weeks. If I start up the development server, ppm dev. Oh, something else is already running it. Let me get rid of that. Move this over to one side so that we can have the code and the browser side by side. Local 3000. And this is it. This is the demo app with an additional slash photos route and a little bit of extra CSS. So the first thing I'm going to show you is what's called page endpoints. Those of you who have used SvelteKit so far or its predecessor, Sapper, you're probably familiar with how data fetching has operated up till now. And what it is, is your Svelte component, which defines the page, will have a load function. How do I have the, there we go. So if you look at this photos page here, what it's doing is it's fetching this photos.json file that we're generating. And it's passing that back to the component as a photos prop. And then the page is just iterating over that and rendering each of these. All very simple stuff. The trouble is, all of this is just boilerplate. Most pages will have similar data fetching requirements to this and everyone is doing it in a subtly different way, but this is unnecessary work. This is grunt work the computer should be doing for us. And beyond that, there's no error handling here. If the network failed or if the payload is malformed or whatever the problem is, we're not handling that error inside this load function. So what page endpoints are are a way of getting rid of that boilerplate If we take the index file which is powering that photos endpoint and we change that to index.js, but otherwise keep the endpoint completely the same. It's just generating that list of photos again. And then just get rid of all of that boilerplate. we'll hopefully see that the app continues to work. So not only have we saved ourselves some time, but we've also added error handling because SvelteKit just does all that for free. So that's page endpoints. Very useful feature for the majority of cases. You can still use load because there are some situations where it's useful, like if you're hitting an external API and you don't want to go via your own server, then you can still do that. But for the majority of cases, page endpoints are now the recommended way to do data fetching in SvelteKit. Next feature is generated types. So here's another page endpoint that we've got, which is powering an individual photo page. If I click into one of these, it's just going to show me the title of the photo and the full image. And all it's doing is it's grabbing this data from the JSON placeholder website. And we have some types declared here. So this is JS doc or is TypeScript inside JS doc. So every, every API in SultKit is fully typed and JS doc gives you access to those. Even if you're not using TypeScript, obviously you can also just use TypeScript, but my preference is not to. But whether you're using TypeScript or you're using JS doc, there is one little minor detail with this type that is kind of annoying. And that is that it gives you everything you need to know about the event object that is passed in, except that. So you've got a client address, you've got your locals, your platform information, the request itself, root ID, URL, all of that stuff. But the params object, which is telling us what this ID should be, isn't tight at all. So like event.params.foo, as far as this is concerned, it's totally valid. And that's not very helpful, obviously. So what SvelteKit now does is it actually generates TypeScript declaration files for you and it puts them inside the hidden directory This ID DTS file takes the generic request handler and turns it into a more specific request handler. And all we need to do to access that is change this import link to the file itself, and event.params is now fully typed. You see that it immediately tells us that ID is the option there. And if you do something that isn't ID, then you're gonna get a red squiggly. So that is something that is hopefully gonna add a bit of type safety to applications and save us a bit of time. Okay, next feature is root matching. So right now this params object, it contains an ID and it's just whatever is in this part of the URL bar here. So at the moment it's one, it could be two, it could be three, it could also be potato, and then stuff just isn't gonna work because that is not a valid ID for the photos. And we could do the validation inside the endpoint, that would be totally valid, but it's better if we can do the root matching before we actually execute any code because that way we can have multiple routes that share a pattern, but are matched on different content that goes into that pattern, if that makes sense. So we have this concept called parameter matches. And in the source directory, we have this parameters folder here with a module called integer.js. And it exports a function called match, which takes a string and returns a Boolean that tells us whether it matches or not. And in this case, we're matching based on whether the parameter is composed entirely of digits. If it is, then it's an integer and it's a valid ID. And all we need to do to use that for the parameter is do equals integer. And we'll do the same for the endpoint. Like that. And so now when we visit slash photo slash potato, we get a 404. And obviously we could gussy up that error page if we wanted to, but for today's purposes, we're not gonna bother. So that's pretty useful. And it allowed us to simplify the code base quite a lot

 with some other stuff that wasn't as useful. Last thing I'm gonna show you is something that just landed today or yesterday, which is named layouts. And named layouts are a little complicated at first, but they're quite powerful. And oh God, VS code does that stupid auto import thing go away. We're gonna need to fill that out. um so the idea behind name layouts is that some parts of your app um may need to have a different layout component than other parts of your app a layout component is just something like this uh so every every page right now uh on here has um the same layout it has this nav bar with the home and the photos um and the everything is wrapped inside this main element which has a a maximum width of 40 Ms, which is why this isn't spilling over to the sides of the page. Maybe for the photo page itself, that's not what we want. Maybe we want that to fill the page because it is a photo after all. So what we could do is we could create a new layout that is specific to photos and let's just call it layout blank. So it's not gonna inherit any of this stuff. It's just gonna be a completely blank route. So layout dash blank, excuse me. And inside that we're just going to put a slot element so that everything just kind of flows directly through it. And then we'll rename the page here with at blank, which says instead of using the default layout, we'll use the blank layout. And we'll do the same for the endpoint. And so now our photo is using the full page, and it's not constrained by the layout that is used elsewhere. Oh, something broke on the app. Okay, I'm just going to talk through a couple more small things. So we got rid of the load function here because we have a page endpoint. But there are actually situations where it's quite useful to run a load function before your component renders. And one reason in particular that you might want to do that is we loading these images from somewhere God knows where And you might notice that there a bit of a flicker when you click on these there a gap before the image loads and it would be nice if we could defer navigation until the image has loaded so i'm going to add a load function to this page Import get the core dread desperate selected bar. Repetable error. We want the props in this case. Actually, you know what? I think there's some bug with the generated type, so I'm just going to use the default ones. So the first thing that we're going to do is just return the props back to the page so that it loads normally. But what I'd like to do here is load the image inside the load function, but only in the browser, because it doesn't make any sense to load an image in node. So I'm going to await, sorry, if browser, and you'll see that it's auto imported browser from app end, then I have a little utility here called load image. so I'm just going to load image props.photo.url and then I'm going to await that and so now if I load one of these images you'll see there's no more any flick there's no no flickering anymore because it's loading the image beforehand so that is that is one way to solve that problem. Obviously, if you're in React land, then you would solve that differently. You have suspense and you would attempt to render the page and you would hit the requirement for the image and React would be like, actually, we need to go away and we need to resolve this first and then we'll come back and try again once that's resolved. We don't have the ability to do that in Svelte so we do that inside a load function And there is actually an advantage to that because when you have the render tree and the data fetching tree as separate constructs you're not only, like you don't have to render a page in order to find out which dependencies it has. And so that means that if I were to show the network tab here, you will hopefully see that it's gonna load the image as soon as I start mousing over it, because we have a prefetch link applied to each of these links. In fact, let me show you where that is on the index page. We have this SvelteKit prefetch attribute, which just says that if you mouse over it or you tap it, then immediately start fetching the data for that route, even if the click hasn't completed yet. That way you get a little bit of a headstart on loading the data and it makes navigation absolutely instantaneous and in this in this case um it means that we're able to load the image that you're about to go to before you've even tried to render the page um and so with a combination of all of these different techniques you're able to get very fast navigation even when um the services and apis that you're relying on aren't necessarily that fast uh there was one other thing i wanted to show you uh but i i don't know if I'm going to have time because it's a little bit complicated, but I'll describe it instead. So on this page here, previously, you could only get pages and that was a limiting factor. With page endpoints, you can now post to pages or put or delete or any other HTTP verb besides get. If we had a post handler inside our endpoint, export async function post, then this handler would be invoked whenever we posted to the page. In fact, you know what, I have an even more here than I did earlier version of here. I'm just going to copy and paste some code into it so that you can see what I'm talking about here. So I added a post handler that is going to accept a form that I now going to add to our photos page I'm going to add, going to expose new props, errors and values. and now if I select a file I'll take this one and here is a photo it's telling me that the file is too large because we have we have this server-side validation as soon as a file gets over a megabyte and it's populating this errors object and it's just passing that back. So the post handler is passing back errors and values, which just like the photo object before, the photos object before, is being treated as a prop by the component. So errors and values here becomes errors and values here. And we're able to re-render the page with knowledge of what the user previously submitted in their form. If I try again with a smaller photo, then the endpoint is instead of hitting this error state, it's going to render a redirect, which means that we'll then see the created resource. But what's interesting here is because we're returning the errors and the values, we also need to return the photos prop. So it's going to run the post handler, and then it's going to run the get handler as well. If you've used Remix and you're familiar with the loaders and the actions, this is very similar to that, except it's a little bit more kind of HTTP-ish because we're actually using the HTTP verbs here. And so this is something that you just couldn't do before in SvelteKit. And I think it's going to make it really easy to build complicated form apps. All right, enough of the stuff that is already in the framework. I'm going to talk about the stuff that is not yet in the framework. OK, so I don't have any more code walkthroughs or demos for this because obviously this isn't done yet, but I can describe

 So layout endpoints. I've shown you page endpoints. The layout components that you're familiar with, they also use a load function at the moment, and it will be better if they had their own endpoints. So we're going to have, in the same way that you have under underscore layout dot Svelte, you will have underscore underscore layout dot JS, and that will provide data to a layout component. um pre-rendered endpoints okay so svelte kit has this concept of pre-rendering um which is to say that if if you're building a site where some of your pages or maybe all of your pages can be generated at build time because they're never going to change um then you can do that as a performance optimization if something is a statically rendered piece of html then you know it can be distributed to the edges of your cdn network and and people can access it instantly There's no computation that needs to happen, so it's very cheap. And pre-rendering is sort of generally seen as like a really useful performance optimization. And SvelteKit lets you choose which parts of your application are pre-rendered. But up till now, pre-rendering has only happened at the level of pages. And that is a little bit limiting. So most frameworks are the same. They think about pre-rendering as if it's either all or nothing or it's something that happens for a page in its entirety. but there are actually lots of cases where that's not that useful. Let's say, for example, you're building an e-commerce site. And for the sake of argument, obviously you wouldn't do this, but hold that thought. Let's say that every time you update your product catalog, you redeploy your app. If you're doing that, then each product page could maybe be pre-rendered, right? Because it's just containing details and an image of the product. And that's just HTML. You could generate that at build time. but of course you're going to have other stuff on that page like you might have the user's shopping cart or you might have related items or you might have any promotions that are currently happening and so you probably can't pre-render the entire page but you also don't really need to hit the database to get product information every time you render that page there's a halfway house here which is you take the data out of the database and you pre-render the data but then you dynamically you server end of the page. So you have the bits of data that can be generated ahead of time, mixed in with the bits of data that need to be generated on demand And because of that if you can do that then server rendering your page is going to take less time and it going to be more cost effective So the way that we're going to achieve that is by pre-rendering endpoints as well as pages. It already happens if a page is pre-rendered, then it will pre-render the endpoint and it will store the result as a JSON file. But in future, we're going to be able to do these things that are more granular level. and that is going to unlock some future stuff for us which i'll talk about in a second also still to come better handling a config.kit.path.base um so most people don't need to use the the base path config but if you have um if you're deploying your app to somewhere other than the root of your domain um then you need to configure a base path and it's it's kind of broken in a lot of cases it's broken on some of the platforms that we target like it doesn't work I don't think on Cloudflare and Netlify. And so we need to fix that. But also it would be really cool if you didn't need to configure it at build time at all, because there are some situations where you just don't know the base path until the app is actually running. Examples include Chrome extensions. If you're just double clicking on an index.html file on your machine and it opens up as a file colon slash URL, you're not going to know the base path in that context. Some sites have like a kind of a white labeling thing where you're using the same app, but for different customers and with different environment variables. And in those cases, you don't want to have to rebuild the app for each customer. The Internet Archive is another great example. If a website gets archived by the Internet Archive and it's using a framework like SvelteKit, then there's a good chance the client side router is going to look around and be like, I don't know what this is. I don't understand this URL. And it's just not going to do anything at all. And in the worst case, it will just like nuke the entire page. I've seen this happen with NextAS apps in the past. Like I looked for something on the Internet Archive. And as soon as the client side router kicks in, it just nukes the entire page. So you have to be careful to view those pages with JavaScript turned off so that at least you get the advantage of the server side rendering. But we don't need that. we can make the base dynamic and resilient. Final example, IPFS. IPFS sites the base path involves like a content hash And so you can know that until the build has already happened So we going to fix all that stuff Another example navigation types Okay, so I actually lied. I'm going to give you another quick example in here. If I was on my photo page like this, I'm going to get rid of the blank layout because I need the links. So if I'm on a photo page like this, maybe I'm editing something or something like that and I want to be able to prevent people from navigating away. I can do that with the before navigate hook. It's going to give me the from URL and to URL and it's also going to give me this cancel method. And if I call cancel, then it will actually prevent me from from navigating away from this page uh and you can take that opportunity to pop up a like are you sure dialogue box if i try and reload the page altogether then i i get the little confirmation dialogue the browser confirmation dialogue um which allows you to prevent users from from losing data however uh this by itself it's useful for some things but in many cases it would be really useful if you knew inside before navigate and it's after navigate counterpart what type of navigation was occurring because there's lots of different types of navigations there are navigations where someone has landed on the page for the first time there are navigations where someone has clicked a link there are navigations where someone is using the back and the forward buttons on on the browser there are navigations where someone is trying to move away from the site to another to an external site and then there are programmatic navigations using the go to function and it's useful to be able to differentiate between all of those different kinds of things because they might involve different responses for example if you're going back and forward then maybe there's kind of an animation that you would want to indicate that you are moving back and forward in the stack and you you you could do that if we had something like a a type here so navigation types are going to be like if type type equals unload, then we know that we're leaving the page. If type equals initial or something like that. Lots of details to sort out, but I think that's going to be really useful. What else? Modal navigation slash history store Okay so this is something that really hard to do with SvelteKit at the moment If you go to an Instagram page a profile page and then you click on one of the images it will show you the photo in a modal without leaving the current page but the URL has changed to the URL of the photo So if I refresh the page, I go to the dedicated photo page. That kind of navigation is really hard to do in SvelteKit at the moment, and we want to make that easy. scope middleware and hooks uh anyone who's used svelte kit has probably encountered the handle hook which is um this is essentially the core of your application it gets a request event and a function which does the server-side rendering for you and your job is to invoke the resolve function with the event to generate um to generate a response uh Pardon me. And this is your opportunity to do things like response.headers set svelte society. Cool. Oh, I didn't await. Always need to. There we go. there are lots of situations where you want to be able to have that level of granular control over the request and the response but only for a subset of the application so in the same way that we have layouts that apply to a subtree of your application we're going to have scope middleware that allows you to to intercept requests and manipulate responses client-side hooks so that You can do any kind of client-side initialization before your application runs. Also, importing any CSS that is going to apply to the whole application. Stuff like that. This is a common requested feature, which we'll get around to. We're going to rename some stuff, probably. I don't love the fact that the roots directory is called source slash roots, because if you're just building an app with a single root or you're new to web development and you're not yet familiar with a lot of our jargon, then roots is kind of a weird name. And so I personally want to rename it to source slash app, but there is a robust discussion happening in the issue comment. Get load arguments is another API that we plan to add, which is going to make it really easy for people to integrate things like GraphQL clients. You will be able to to interact with the GraphQL client from inside a load function without having to have.

 it, the fetch implementation and all of that stuff because it will be able to access the fetch implementation belonging to the currently executing load function, if that makes sense. It's one of those things that sounds a bit weird in the abstract, but once we get some concrete examples, hopefully people will see that that's kind of useful. Streaming requests and responses. So earlier I tried to upload a photo and it was too large. On some environments, like Node, for example, you can stream data to the server and you can stream responses back out of the server because spelt kit is built to be environment agnostic and it works on a lot of serverless platforms like lambda and what have you um that hasn't been a priority for us up until now because and you can't stream in lambda you you get an event object and you return a response object um but for people who are using platforms where streaming is a possibility we want to make that as straightforward as possible um consistent handling of environment variables uh yeah this is this is another one that's just hasn't really come up yet um you so the only way that environment variables are handled at the moment in svelte kit is through veet and you have your environment variables with a uh you'll have something like import.meta and veet something and that will get statically replaced at build time in your application. But some environment variables aren't known at build time. They're only known at runtime. And some environment variables are only supposed to be visible in the client and some are only supposed to be visible on the server. And we don't really have a good way to distinguish between all those and handle them in a cross-platform way. So that's another thing that we're going to fix before 1.0. And obviously we have a whole number of bug fixes. Phew. Okay. stuff that is not going to make it into 1.0 um internationalization is something that we really want to get right and it's a huge topic and so we're just kind of pushing it off until we have the time to design all the aspects of this in a way that is going to make sense until then you can you can internationalize your apps but like you kind of have to figure it out yourself there's lots of different components to this like knowing which locale to use localizing routes so that your slash contact dash becomes slash new dash contact or whatever French um actually getting the translations into the page so that uh the html gets rendered with uh uh translations um all of that stuff is uh and authoring translations as well all of that stuff is is is going to be difficult to figure out but we think that an opinionated framework like SvelteKit can make all of that stuff way way way easier than if it's um left to to use land incremental static regeneration okay so before i was talking about the e-commerce site where you uh you rebuild your app every time you update the product catalog obviously that's not going to happen in real life but what you might have is um you might want to have the the json files that represent the snapshots of your product database be things that can be regenerated and then just kind of stored somewhere next js has this feature called incremental static regeneration which um i basically want us to steal and the way that it works in next is you have these two kinds you have the the basic kind which they've had for a while uh where um if someone hits a page they will get the the statically rendered version of it and then in the background the framework will regenerate that page and then just put it in storage and then the next person comes and they will get the more recently generated one um and so the the pro of that is that everyone gets an instant response because there's no computation that needs to happen the downside of course is like you're you're doing more rendering than you need to because you need to do it after every new request and everyone is going to get a slightly stale piece of content and so there's this new thing called on-demand incremental static regeneration where say your your content management system fires a web hook inside your app and the framework regenerates that page on demand so the next time someone comes to it they get the statically rendered page and then it's not touched again until the content management system talks to the webhook again and so that's incredibly efficient but it only applies to pages and that kind of makes sense in in a react framework land because server-side rendering is is a little expensive when when you have to generate a component tree and then serialize it server rendering is very cheap in Svelte And so what we thinking is that if you can have your pre endpoints be incrementally statically regenerated then you can have fully dynamic server-side rendering using ISR data that is available to your server-side rendering process that runs at the edge. And in that way, I think we should be able to get pretty close to the platonic ideal of web performance without needing to like push all of your data out to the edge all right faithful dev environments this is an issue that swix raised a little while back and it's something that we haven't really begun to wrap our heads around if you're using a platform like dino or cloudflare and then in production you have access to a slightly different environment than the one that you have in development because in development stalk kit is just a node framework Everything is node, so you have access to the file system via the FS module and all of those sorts of things. And that can introduce paper cuts, because while we want SvelteKit apps to be as portable as possible so that you build them in one environment and they will run in other environments equally, number one, it means that you can't really take advantage of platform-specific features like Cloudflare, KVStores, and all of the Bino web APIs. um number two it's possible that you're going to do something that is allowed in node but is not allowed when you deploy the app to production and it would be really good if we could make the development environment um faithful to the production environment we haven't quite figured out how but that's something that is obviously going to be really important um web sockets in real time kind of goes without saying um again because we're targeting serverless platforms and serverless platforms generally don't really have a good story around web sockets it hasn't been It's something that we've prioritized up till now, but it would be really great if we had a turnkey solution for doing real time communication. Better monorepo support for packages. That's boring. I'm not going to talk about that. More performance improvements. We want to be able to use import maps so that your modules can get cached more aggressively. We want to generate more preload links so that browsers can do a better job of fetching assets before they're needed. all of that stuff um and i i don't know what this is doing on the post 1.0 page because that is very much a pre task um we need to build out um interactive documentation for um for spelt kit in the same way that spelt has the the interactive tutorial which i sure a lot of you have seen we want to be able to have this but for SvelteKit which is a much bigger engineering challenge because you need to get what is a node framework with hot module reloading and all of these other things to somehow run inside the browser. And we have some ideas, but we're not quite ready to talk about them. And obviously we need to get loads of examples and demos and stuff ready as well okay so that is the the roadmap um i've been waffling for a long time so i'm just going to wrap up quickly uh we are getting there um i know we've been talking about svelte kit for what seems like forever um but we're close we're going to be able to have a stable release i think not too far away hello i am i'm not i'm not ready to put a more concrete um date on that we're really sweating the details um so that named layouts feature that i showed you uh it's it's very powerful it's more powerful than the equivalent feature in other frameworks because we spent so long going through every possible iteration of the design um and the goal is that when you use felt kit um most of these features and there are a shitload of features um you won't be aware of them until you need them and when you do need them they're hopefully going to feel kind of intuitive and cohesive and all the rest of it if um if there's something that we're striving for we want to we want SvelteKit to be kind of Apple-like in in the way that you get this really nice onboarding experience you know you you get your Apple device you pull it out it's fully charged it's ready to go um all of the apps are already installed they work together all of that stuff that's that's what we're aspiring to with SvelteKit we're not just trying to get the right primitives and like bash them together we want this to be a really polished experience um and and it takes time uh i do think it's coming together pretty well um i don't know if you saw the state of js survey that came out um a month or so ago svelte kit um obviously it doesn't get a fraction of the use of express and fastify and all of these other things but of the the new breed of meta frameworks it's actually the most used and it's also the most loved and that's despite the fact that it's not yet at 1.0 and it has some pretty rough edges so um i'm pretty optimistic about what it's going to be like.

 when we do eventually get there. And I want to thank everyone who has used it, everyone who's building apps with it and everyone who's been raising issues and finding pull requests. It is going to make the framework 10 times better for the people who become adopters after we launch 1.0. So thank you. And that's it. That's all my waffling done. Thanks for listening. Thank you.