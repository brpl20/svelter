 Thank you. Thank you. Hello everyone, I'm Samuel from the Inlang team and today we're going to announce what we believe will become the best e1.8n library for SvelteKit, other frameworks and the web platform in general. This is over two years of research and development and if you can't tell, I'm so excited to finally show what we got. Before I do so, huge thanks to the Svelte community. Over the last couple of months, early adopters gave us a lot of feedback on how to make things right and how to get where we got. Now for everyone who doesn't know what an e1.itn library does, in short, if you want to adapt your application or website to different markets, for example, you want to show you the Uber application in English, Spanish, German, French, Chinese, and so on and so forth, you need a lot of technical infrastructure that loads the right translations, determines the user language, doesn't bloat the bundle size, you don't want to ship all translations to the user, only the ones that the user actually needs, you want to server side render those translations so that they appear on Google, and so on and so forth. It's a lot of technical infrastructure. It's not about creating the translation, it's about making it possible that your application can be showcased for different user groups. Now, what will make Paraglide.js the best E1NN library for SvelteKit and the web platform in general? Two things. Again, the result of over two years of R&D, and I'm so excited to finally show it. A breakthrough innovation when it comes down to an E1NN library and a plug and play ecosystem that takes care of all the other things that you need to do when you adapt your app to different markets let start with a breakthrough innovation wow we call it tree shakable message functions paraglide js leverages a compiler similar to svelte that takes your translation files and contain messages and compiles them to pure JavaScript functions. Pure JavaScript functions mean that your bundler, Vite, Rollup, Webpack, Turbo Pack, can automatically tree shake them and optimize them. Your bundlers can't optimize your translation files but your bundlers can optimize your JavaScript files. That's what they're built for and this is the innovation. Now if you do that, for example, if you only use the message login button in a particular component or page, your bundler will automatically get rid of hello and login header stuff like that now why is this so amazing as I mentioned you don't have to care about async loading anymore like how do you load this translation file and how do you split it so that you don't send everything to the user you don't have to think about it anymore and usually with async loading comes a lot of bottlenecks for server-side rendering and everything for Paraglide.js this is not a problem you're gonna import your JavaScript files, you don't need to async load stuff. Your bundler automatically import, synchronously imports your stuff and gets rid of all the unused messages and optimizing everything. This means that with Paraglide.js and it seems, all right, this seems easy, but wow, it took us so long to get here and nail it. Server-side rendering works. Client-side rendering works. Static site generation just works everything just works because it's plain JavaScript now manual message splitting if you if you take your translation file and then usually you know if you have let's say let's say you have 10,000 translations right 10,000 messages for English you don't want to send 10,000 messages for the login page which only uses 10 messages and traditionally a lot of you know a lot of manual optimization comes in where you need to split those files this is not the case with Paraglide JS your bundler automatically bundles only the messages that you're using this means that Paraglide JS is the most efficient type safe and after all simple e-wanted and library that is out there it took us so long to get here it's so obvious in hindsight we believe everyone will copy what we did here with Paraglide.js is just so good. But yeah the innovation comes down to three shakable message functions instead of trying to resolve your translations during the runtime it means that your bundlers can automatically optimize them This is the innovation in a nutshell. And I said there's more to it. There's an entire ecosystem. Let me show you Paraglide JS in action. I'm going to show a SvelteKit example now. Mind you, this is a pre-release. So some things you see might change by the time you try Paraglide JS. I recommend following the guide that we're going to link in the comments or description. Generally, I hope that you see just how simple Paraglide JS is and how the in-lang ecosystem comes into play. This is the page I built. Hello, Samuel. Let's do it in English. Hello, welcome, Samuel. You have five messages. The current language tag is en. And I can switch the language to German and back to English. And in German, I have a missing translation. OK, this is the code behind that page. I'm saying here, greeting. This is the welcome Samuel, current language tag, your current language tag is, and two buttons to change the language tag. You already see Paraglide.js in action here. We're importing our message functions as plain JavaScript, except that we're using a namespace import. The namespace import enables the bundler. If I'm not using greeting on this page, it's not gonna be bundled automatically. This is the simplicity of Paraglide.js. Now, I want to use both messages. Let's look how those messages work under the hood. As I mentioned, Paraglide.js uses a compiler that takes your translation files or message files or sometimes called resources. In my case, it's this messages.json. Warning, this is optimized for machine readability. You can use any format that you'd like. Classical JSON key value pairs also work. Now, this is the messages file again, machine readable. Paraglide.js takes those here, this file. Again, unopinionated, you can use any format and compiles it into the paraglide.js directory. You can name it however you'd like. It's git ignored. It won't bother you. In that paraglide.js directory, we have that messages.js, which serves as an index file. This is exactly where we're importing our messages from. If I go in here, for example, greeting, this index file serves as a, all right, your language tag is en. So I'm returning the en message function. Let's go in here. This is it. We're now in the en.js file. The de file looks similar, except that current language tag is undefined. But this is it. Those are tree-shakeable message functions because they're pure JavaScript functions. Your bundle can automatically optimize them however it needs. And this is Paraglide.js. There's one second side to it. So you have the messages file and you have a runtime file where you define what is the the current language tag and you can set the language tag which is exactly what we doing here We saying set the language tag to DE and EN Then I have a tiny adapter, which depends on your app. We're going to provide that in the library, which has, in this case, another 10 lines of code, and it defines what should happen if the language tag is set. And in this case, it also sets the context for server-side rendering. Overall, the entire runtime, if we go into the compiled output, this is unminified, is 38 lines of code. 38 lines of code. It comes down to around about 500 bytes. And with the adapter code, it's maybe 10 more lines. So you're well beneath 100 lines of code. This is the beauty of Paraglide.js. I mentioned the ecosystem. So we have a missing translation on the side here. and if I run the CLI as part of the inlang ecosystem, I can say, hey, lint, my code, you can run it as part of CICD and I see here, for example, hey, the message ID current language tag has a missing earn variant for the language tag DE. So it's missing. We get a warning here. I'm lazy, so I'm going to say, you know what? npx inlang machine translate that and the moment it machine translates this, we can go into DE and what we see here, boom, it machine translated that and I can save this and if we go into the app there we go it's now machine translated in my application and I'm good to go I'm going to send my translator a link to the web editor in the ecosystem that opens the repository we're running no joke we're running git here in the browser our own version of it and your translator can now directly contribute towards your repository without any setup here and i'm going to add the language french let's add that unfortunately i really don't speak french so let me machine translate that and push and you're going to see here now that we're going to see french translations coming in again this is optimized for machine readability this format you can use a human readable format as well let me pull there we go there's french and it's now in my application there was no hand of it all just works let me lint it lint it are we good to go we're good to go linting is successful the example is successful and i hoped i hope to get across how simple uh paraglide js is thank you very much for listening in two years of r d here was the presentation we're really excited to for you to try it out if you have feedback let us know we're gonna link a guide in the description on how to get started and uh yeah thank you Thank you.