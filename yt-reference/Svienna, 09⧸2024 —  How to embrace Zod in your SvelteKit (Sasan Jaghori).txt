 ZOT Alright everyone, I'm gonna talk about ZOT and how you can use it in SvelteKit. So the first thing, why do we need actually validation? ZOT is a library for validation, right? So there are a lot of reasons for that. I've just counted seven. The first one would be data integrity. So you want to ensure that your data is actually the correct one. It shouldn't be bad formatted. The second reason is the security. So you want to avoid SQL injections and XSS vulnerabilities. The third one would be the user experience. You want to give your users a seamless feedback. You want to say, OK, this input maybe isn't correct. You should correct that. The fourth one is preventing server overload. Imagine someone just putting clicks thousand all up on the submit button. If you don't have the validation, you would send 1,000 requests. The fifth one is the legal and regulatory compliance. You could actually create custom validations so that you can say your minimum age should be at least 18, for example. The sixth is the business logic is very similar to the last point. And last but not least, the number seven is unreliable external APIs. Imagine you have an unreliable API that doesn't reliably give you the data that you want. Maybe sometimes it gives you a server error, maybe sometimes it gives you just empty strings, and you want to avoid that. So there are a couple of validation layers that you can implement. You should have at least some layers in frontend as well as in the backend So the simplest in front end would be using HTML attributes in forms for example There are some kind of attributes like required, minimum length, the type, if you see about type password or type date. There are also patterns. But additionally, you can also use custom validations with validation libraries. is. Just doing that in the front end isn't enough because there can be bad actors or maybe the client code doesn't correctly load to the to the browser so maybe the data that the client sends isn't the correct one so you want to make sure that you also validate the request in the backend as well. So at least having a schema validation or some kind of custom validators is recommended. But additionally, you can also create some database constraints to make sure that the last point, the last line of defense is the database, right? When you write something in your database, you want to make sure that the data is correct. And database constraints is one way to do that. But we will focus on schema validations today. So how do we want to do that? I'll just show you one way to do it, but there is no... That's not the only way, you know? So one way to do that is using schema validation libraries. There are a lot of schema validation libraries. I just mentioned three of them. Those two are the popular one and ValiBot. I don't think anyone has heard of it. So who have heard about Zot? Can you raise your hands? Okay. There shouldn't be something new for you. So Zod is the most popular schema validation library. Then comes YAP with 33,000 stars. Zod is, I think, on 60,000. And ValiBot is a newer one It tries to minimize your bundling size So it tries to at least have a lightweight API An API that is enough for your needs, but it's lightweight. I just put the GitHub links of each library. You can check it out if you want. um here's a snippet of how you would use it with value bot as you can see if you have used result already it's almost the same right it's the same also with uh yup it's uh it always begins with a schema declaration um here you see you have a really simple login schema with email and password the email is validated so you can only pass a string that is like an email it uses regex under the hood and the password has a requirement of minimum length of eight characters so if you pass a string of seven characters it will fail And like SORT, you can infer the type based on the schema. So if you define this type, login data, we've saw this similar one. You will get a type with email and password, which is a string with email and password is also a string. So here, the last two lines are some examples. If you pass the actual data, let's say you pass an object of empty strings, like email is empty and password is empty, then it would throw an error for email and password. But if you pass a correct object, like here with the last example, jane at example.com with a password that has at least eight characters, it will return the actual data. So it's very similar to Zot. So Zot is like the validation library, right? But with the front libraries, with the front end frameworks, you have forms and you also want to validate your forms There are some libraries like superforms which abstracts a lot of boilerplates that you need to write So it brings some kind of utilities for your frontend and backend. And it works with SORT and Vali-Voat and other validation libraries. is a snippet of super forms. But there are also other libraries, like Svelte Forms Lips, inspired by Formic. I don't know if you have heard of it. It tries to be a simple library, tries to really minimize your code, validation code. And it only, that's a drawback actually, it only works with your, and you cannot actually use Zot with this one. But at least from the examples that I saw, I personally don't use it, but at least from the examples, I could see that it's really easy to use it. Now I will just show a short demo of how you could do validation. For that, I will just start the dev server. Let's go through the code. I just create a normal SvelteKit with TypeScript setup. There are just a route with to-do. The to-do has a server-side code and a client-side code. We can have a look at the client-side code first. As you can see, it's just a form to create to-dos and also to delete to-dos. So form actions is actually a way to define... alternative to use the apis right you you could define apis and you could define um on click events on submit you could make a post request but reform actions you don't have to actually create an an api you can just create the the backend code in the

 in the same directory. And yeah, it makes it a little bit easier. So you don't have to think about the restful path. That's the advantage of using form actions. And here you have actually two form actions, one for creating and one for deleting. And if we go to the demo, there it is. So it's really simple. I just copied it from Svelte Learning tutorial, but rewrote it with TypeScript so that we have at least some types. The app is really simple. So you can write a to-do, and you can have a deadline for your to-do, and when you click enter, you will actually trigger the submit event. And you can see it's created the form action brand and it created an object in memory. The fake database that we defined, it's also the same from the Svelte tutorial. It's just a map of string to do this list. And you see we hardcoded the first to-do with LearnSwebKit. Yeah, let's go to the form actions code. Here we don't have a validation, actually. Here we just take the whatever it comes with the form data. and we hope that we get a description we hope that we get a deadline and we hope that the cookies are set for user ID and when you go on the when you hover on the type the type is a form data entry value or null because it can be null and if you want to make it if you want to make TypeScript happy then you would actually have to cast it right And it not the right way So this is also another reason to use validation library It gives the type safety So how would you write a schema for that? I will skip. I won't write the schema right now, but I will just use the code that I wrote. So it's really simple. I just defined a create-to-do schema, and I defined a description and a deadline, and I require that a description should be at least one character. You can go with whatever requirements you want. You can also have complex requirements with refine. And here you get access to the description and deadline data. And you can have custom logic. You can say, okay, description. Is there any other description in the database? If yes, then it should be unique, right? I'm not saying it's the correct way to do that because actually you would go to the each time you would go to the database and see if there is another description with the same string. But here's the possibility to do that. How do I validate the data with the current schema? For that I wrote a valid utility. I passed the schema, I passed the request, and I say the data is of type form data. There is a typo here, should be form data, not form data. And the validation is really simple. If the kind is JSON, you would parse JSON, but in our case, it's form data. And with form data, you go to each field and you get every field of that form data. Then with the schema that you passed I use generics here I could pass any schema With the schema that you passed you can validate the payload And the type would be the output of the generic schema that I passed. So if there is any error prone, then we would come here to this catch clause, and we would actually return a defined of, we return a status error with the validation description, you know, what failed actually. This is also a type that I got inspired by Rust. They always return a result of some kind of data, like a result of OK or a result of error. It's using pattern matching, right? Here, when you come back to the status, you check if it's success or if it's an error. And with that, you tell TypeScript, okay, if it's success, then you have the correct type, right? The data is not an error. The data has description and deadline. But if it's the type of error, you say, okay, you should fail and pass the error message. We can do the same with delete if you want. So that would be delete to do schema. It's an object of what to pass. We pass an ID. It's a to do ID. Let's say it's a string. And that's actually it. So if I use my utility function await the schema that I wrote with the request object and the kind should be form data OK. And here you get... I'm not used to this keyboard, sorry for that. Status and data. you can just use the same code, right? You can copy paste this one. Then we got here the data. You can delete. That's it. Here we read cookies.get user ID. So of course, cookies can be undefined if you just get that. What I do is I check if user ID is defined. And if not, then return fail if I don't know what status it is. Maybe then 403? Yeah. Forbidden. Yeah, something similar like that. And you can pass anything you want, right? It will, at the end, you will have it here in the action data. Right, could not get user. And yeah, that's actually it.

 We can try that again. See if we can actually... I'm not sure if it... Yeah, because I'm not running anymore. Let's write another test. And let's see if we can delete it. Yeah, it works. I don't have any console logs, but it would appear here because this code is running. Just one question from the audience. What do you feel about writing the actions and writing some generic kind of name here, like create and delete? Do you feel better when it's create to do or do you feel better when it's delete to do or? What do you feel? I like the name Scorpion. Name Scorpion? Me too. Yeah. I see that you should use the library for the routes. for the routes you can do a spelling mistake yeah from data all right and that's actually it thank you any questions I have one. Where is the URL parameter? Ah, you mean this one? Right after that, the slash, like, is this something you invented or is it something that kind of... No, no, no. Actually, it's the way how form actions work. they call this URL, right? This comes from SvelteKit, and it actually looking for this route if there is any form actions So it very key to syntax for looking The question mark and slash up right after this Yes, yes. But there are other ways, because you are not... It's not mandatory to have the form actions on the same path. You can actually have it under some other directories. And then, as far as I know, I don't do it, but there is a way you can define a specific path, or you can define wildcards. This is some kind of wildcard, you know? Yeah, so there are other ways to define the path. I have one other question. Yes. Of course. In your first part of the presentation, you shot like seven points where the validation can be used and the second one was like preventing cross-site scripting. Yeah. And this is what I'm thinking like how from the validation. I mean, not necessarily through the form validation, this is just general. I mean, why we need validation, right? And XSS is, you validate because you want to prevent XSS, but it's not really scope to form validation. But, yeah, you could still write some SQL injections in your form, right? And with some kind of form validation, you could prevent that. Yeah, but content validation won't prevent . It depends on how you write your back-end code. Yeah, it's entirely unpermitable in back-end. Exactly. That's why you should have at least two or more layers to prevent some kind of bad actors. But this is superforms actually using . Yes, it is. But the thing with super forms is I always feel like it does more than I want to. So there is just a lot of utilities that it gives like have you heard of tainted Tainted means when the form is dirty right You write something new and then tainted is the Boolean that returns true And that's actually too much, but it's really nice. Yeah. But at least for someone who has a complex form with, like, 40 fields, So I don't hope that you have a form that has a lot of fields. So I mean, if you have, for example, when someone starts changing something and they click accidentally back, you don't want to let them go back because maybe they're in the process of changing things. Yeah. Any other questions? Did you look at the implementations of the differences between the ZOD and the other two you mentioned? The internal implementations? What I mean is how big they are, like the bundle sizes and stuff like this. Oh, I have one. With ValiBot, the zipped bundle size is just one kilobyte here. You can see in the first line. Zota is a little bit larger, not a lot, but it's larger. So if you care about bundle size, maybe value bot is the right one. Yeah, the other thing is that you have value data is something that you don't expect to have bugs. It's like a code that you can't expect to be minimal, right? So you don't really want to know. The thing is, if you're a solo developer, it doesn't really mean a lot, right? Because you know what you wrote. But it's the same thing with error handling, right? It's something written for the developers. And I know everyone writes great code, right? You want to prevent that. And it's just a mental model for ourselves to prevent that. It's just a process. So it's one of the processes I use to prevent bad things. Besides it doesn mean that you shouldn test You also have to write tests It doesn also not mean that you shouldn do error handling Because as you can see I using input validation Then I'm checking for errors in the database. I'm also writing integration tests for the endpoint. So you should have at least a lot of layers from different aspects. If you have no choice of three validators, I don't really care that much about it. Yeah. I would take the one with the smallest. Yes. Valibot is also kind of different from that. You import exactly what you want basically. Only the part, like for example the pipe or string, as you can see, that's only what is bundled. That's why it's so tiny. If you just need a couple of validators, it can be like maybe even a couple hundred bytes instead of... You can do that, but as you can see, the maintainer changed the documentation, and he uses this wildcard import. So maybe... It is still three seconds. Yeah, you can still use the ES build import. Yeah, you can still use that. Sometimes when it grows, when you have more than a pipe, a string, when you have a date and then an email, then the import lines grows, right? That's also a drawback. Would you say it's better to use the function of parse? Use the parse function that throws the error or use the save parse that is silent? Or is it just a person it depends um i don't know which one but i usually use the the one that froze but it really depends on your use case there was a explanation i can't remember anymore but it it was really good to explain um why you need sometimes this and why you need the other one maybe we can have a look at the when you bought documentation again also documentation but there is a reason for that okay thank you thank you