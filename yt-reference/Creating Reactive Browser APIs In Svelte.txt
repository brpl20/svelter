 Hey friends, what's up? If you didn't know, Svelte recently introduced some cool new features like the Reactive Media Query API. So you can just define a new media query and it's going to be reactive. But that's not the most exciting part to me. The most exciting part to me is the advanced techniques I'm going to show you today how you can create this sort of reactive browser APIs yourself. Not only does Svelte have a new create subscriber function to do that so your life is easier, you can easily create this sort of reactive APIs using this. but i actually want to show you why you would use something like this so we're going to actually create this create subscriber function from scratch to understand how it works and not only that but we're also going to understand when do we use advanced runes like effect tracking and of course these aren't mandatory things that you have to know so why do we learn about them well we don't learn about them because we have to but because we can because i think it's infinitely fascinating so in this example i'm using svelte's media query nothing special i'm just importing from swell slash reactivity you also have things like prefers reduced motion and there's probably going to be more in the future so we just create new media query and that's it now it works if we go to the example if we go above 800 pixels we're going to get large screen otherwise we're going to get a small screen and what we're going to talk about mostly today this works anywhere so for example usually if we would log this value outside of a tracking context like this we would get that mysterious error of effect orphans, because effects need to have a parent effect. But in this case, if we log the value of the media query, you're going to see there's not going to be a problem. So what's happening here without us looking at the code is that the Svelte is using a fallback to read this value instead of using an effect. And don't worry, all of this is going to be clear once we go through a couple of examples. Alright, but before we get started, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support! Alright, I'm going to replace svelte.svelte.svelte.ts from lib.media.svelte.ts. And if I go inside media query, this might be an implementation you will do yourself. So let me explain, I have this matchmedia function, we're just passing a query string then we're checking if we're in the browser context is so then we can safely use window otherwise we're just going to use an empty object and here we have a media query class so here we have a query and then a reactive piece of state matches so we're going to return that using this getter current so we're going to return this dot matches and once we initialize this in the constructor we're just going to assign query to match media and we're going to use this effect so we can add an event listener on change and we can run this update here so we can update matches with e.matches and the reason we're using this effect here because we want to run a cleanup when this component is destroyed and honestly if you're using this for yourself you're just using this inside of a component this is perfectly fine right because we can go here i always like to refresh for good measure we can actually see that this is just going to work but let me actually show you what is the problem of this approach if you're making something more serious that's maybe going to use by more people let me show you the first mistake what's going to happen so because you're using an effect when this is initialized now if you invoke media query outside of the component initialization phase you're going to get an error so for example we can just say new media query we can invoke it we don't have to do anything let's just save it and we're going to immediately get an error effect orphan effect can only be used inside an effect so during component initialization because in svelte effects need to have apparent effects for cleanup so for example if you have nested effects their cleanup has to run and i often hear people ask when would i nest effects and etc but the truth is that you're already nesting effects without knowing this because basically your entire template is svelte is actually a root effect so svelte under the hood tracks all of these things and then when your component gets destroyed or unmounted it can just run the cleanup for those effects that is basically why you get this error because svelte can guarantee the cleanup for this thing now let me show you another problem because we're using this effect outside of a tracking context, here where we have this value, this value is going to be undefined. So let me show you that. If I go back here to the example, I'm going to refresh, and now if we log the media query, remember in our event handler, but in fact it's going to output undefined until we actually attach the event listener. So let me just change this reactively to large right Now we can log this value and you going to see it works so in this case the best course of action instead of creating this effect on the constructor when you create this media query it doesn make sense to do it here but only when you read the value right so we can just take this effect and we can move it here let me save this and you're going to see if i refresh is going to work the same as before but now we're going to only create this event listener when we actually read the value. But now we're going to run into the same problem as before. Because we're logging the value of the media query outside of the tracking context, we're going to get an error. And the error is of course going to be the same. We're going to get this effect orphan error. And to circumvent this, we can use effect tracking. And when you read this in the docs, it kind of doesn't make sense because it has this confusing example, to be honest. But this is just the simplest part that we have to understand for now, the tracking context. So for example, if we log $effect.tracking, so this is a function, if we invoke this in the script tag, it's going to return false. And that is because the script setup runs once and that's it. That's not a tracking context. If we log effect.tracking inside of effect, it returns true as expected because that is a tracking context. If we run effect.tracking in the template, it returns true because your entire template is basically a large root effect. You're basically checking, hey, are values tracked inside of here? If so, okay, then we're going to run this code. So we can actually use effect tracking here to our advantage. So we can just go back to our code here, and I can say if effect tracking, let's invoke it, we're just going to wrap everything inside of here. Let's save this. I'm going to go to our example. Let me refresh. First, is it reactive? Okay, it is. So now when we log the media query, you're going to see it's actually not going to run this effect, but it's actually going to default to this matches value right so it's going to read that so now your code is more robust all right so now that you have this you can do things like creating media queries inside of this file outside the component initialization phase so for example you can create large you can say new media query you can just create media queries in advance right we can say with 800 pixels or whatever and actually make this large let's actually make this small, but you actually get the idea. So now you can actually export this, use this wherever you want, and now you can track these values. But because you're not using the effect in the constructor, you won't run into an error. So this is really great. And I think it's also really important to understand why this is reactive in the first place. So what is our actually goal here? We actually just want to rerun this value current. And because we're running this update function, where we have this reactive value matches where we assign it so now it knows because it uses this value inside of here when this changes is going to rerun this function but this is actually quite problematic if we have this effect here this is going to create a new effect each time because for example we can log something like high here and then if we go back here and we can just create how many versions of these that we want. We can go back here, and we're going to see it creates high eight times. That's fine. But now each time when this reactively gets updated, this is just going to multiply the event listeners, which really isn't a good idea. All right, so the next thing we're going to do is we're actually going to fix this problem inside of media query, and then we're going to take that code and refactor it into our reusable create subscriber function, just like Swell does, so we can understand how it works. All right, so stick with me because this is going to get a bit complicated, but that is the price of knowledge because we're doing this from scratch. All right, so here is the game plan. First, we're going to remove this reactive state because we actually don't need this. This query is going to update and our only goal is to rerun current. So this value is going to reactively update. And now we can return query matches. All right, but now we actually need some extra pieces of state to make this happen. So first we actually need a reactive value to rerun current. So I'm going to create version, assign it 0. We're also going to have subscribers to fix our earlier problem. So we're only going to add an event listener if the subscribers are 0. And then we're also going to keep a track of the cleanup. So this can be null or this is going to be a function that returns nothing and we have to wrap this inside of parentheses Let assign this null by default and inside the update function we actually don need this we can just increment version so we can just say version plus plus and then i'm going to create a private subscribe method and then inside of this we're going to actually move this wonderful and now here where we have our effect we're just going to say this cleanup so we're going to assign this to the cleanup we're going to say equals this subscribe we're going to invoke it but remember we only want to do this if the subscriber count is zero so if this subscribers is equal zero only then do we want to do this once we're done with this we're going to increment subscribers and then we can actually return a cleanup for the effect so when this runs we're going to say subscribers and we're going to subtract them and then if the amount of subscribers is zero we're going to run the cleanup so we're going to say this clean up and then we can just invoke it and we're going to use optional chaining in case it's null all right and now when this is done we can even reassign the cleanup to be null and it's really not that complicated if you think about it but can you spot what the problem here is this actually isn't going to work and this is why it's really important to understand reactivity in svelte so our goal here is to rerun this current function when a value updates but what value are we updating if you think about this so maybe if i scroll up of course we're updating the version so we can go here under effect tracking and we can just use this value when svelte reads from this value it's going to say okay something inside of here is being read when this value changes rerun current that's it nothing special so now if i If I save this, I'm going to refresh, and let's see if this works. Ah, beautiful. It's reactive and everything works. So now we fixed our previous problem. We can log the media query, no problem. The only thing left to do is take this code and create a reusable create subscriber function. And you're going to see, once we do that, all of this perceived complexity is just going to melt away. All right. So the first thing I'm going to do is create a createSubscriber function. So I'm going to say function createSubscriber, and createSubscriber accepts a function. And then I'm going to move this piece of state inside createSubscriber. And let's just say let, that's basically it. And now the only thing we have to do, we can just return function. So now we can go back here to our code. Let's take everything from here. and we're just going to place it inside of here all right so we just need to remove this and gone beautiful and of course in set of subscribe here we're passing a function so we just need to invoke this function and then we need to pass an update function and what is the update function well we want to update this version right here all right so we can just pass this we I can say version++. And I think that's it. So now we created this simple create subscriber utility. Let me just paste this code out so it's more readable. So you can see it's simple as this, right? Because we know how reactivity works, we know that this is going to rerun. So now we can create our wrong subscriber and we can just invoke it inside of current. All right, so let's save and do this. Again, we don't need any of this. Let me just remove this. I'm going to cut this. so now here the only thing we need is subscribe we can say this subscribe and we can create the subscriber so this is going to be the function that you're going to pass in so this is going to add the event listener and then we need to run the update and this is how simple it is if you think about it and this is from the swell source code right it's really not that intimidating this just has this reactive version thing when it gets update it reruns this effect and it also takes care of the subscribers it's really not that complicated if you spend a minute thinking about this right and because we created this update function right so we're invoking this function that we passed in that has the subscriber and now we can use this update function right here right so we can go here and let me just grab this update function here let just update this we can just say update and now inside of current we can subscribe to it we can say this subscribe and we can invoke it and that it you can see how simple this is if we ignore the create subscriber function so now if i save this i can go back to our code let me refresh everything and i'm going to see it works beautifully we can log the media query and everything works and now that you understand this you know how Svelte does it so in the case of Svelte we can actually just delete this code no problem and we can just go back to the top we can say import create subscriber from Svelte reactivity that is all you have to do you save this and it is the same thing right if I go back here going to see it works and of course Svelte does some other things which we didn't want to include for sake of simplicity as you're going to see this is actually the exact same code the only thing that swell does differently it also uses on track here so you don't get into infinite loops if you have other reactive values but basically this is the same code that we've done and it also uses this tick here so it does it on the next browser tick i'm actually not sure why it does that but it is what it is they also have these nice explanations in their code all right but with that being said, I actually want to show you another example where you might not need create subscriber. Because when you see something like this, you might be tempted to use create subscriber instead of using actual state. All right friends, here I have this simple mouse position tracking component. As you can see, everything works as expected and we can even log the mouse position and we get this proxy object. Because we're actually using state, and I have two versions of this. One, which is mouse position state and mouse position subscriber. So we're just creating a new mouse position state and we're logging the x and y coordinates of the mouse so let's actually look at the code here if we look at mouse position state this is something that you would do yourself so here we have this reactive piece of state position which has x and y and in this case it doesn't make sense that we read this mouse position only when we read current because this event has to run before we can read it otherwise we wouldn't have any mouse position value right So we can just do this inside the constructor, no problem. Here I have this mouse move handler, and I'm just updating the mouse position. And this is going to run the cleanup. And this is honestly enough, but of course you're going to run into the same problem if you go here and use it outside the component initialization phase. So if we say new mouse position state, and save this, we're going to actually run into the same problem, because effects require parent effects. But if you don't care about that, that is perfectly fine. So this is something that is really great, which you can do, and you can forget about it. But if you want this code to be more robust for some reason, I don't know why you would use something like a mouse position outside the component initialization phase, but in this case, you can reach for a subscriber. And as you can see, here where we have position, this doesn't even have to be reactive because the only thing we're going to do, we're going to rerun current. We're going to create a subscriber, we get this update function, I'm going to create a mouse handler, so I'm going to move what I want to update and I'm going to invoke the update function. Here I'm going to add an event listener and I'm going to return a cleanup. And then we can subscribe to this so we can rerun current whenever this gets updated. So now if we go back here and use mouse position subscriber, you're actually going to see it actually works the same. It tracks my mouse position. We can log the mouse. And another benefit of this is you can see we don't get that snapshot because we're using proxy state. This is just a regular value. So it really depends up to you what you want to do, right? when it makes sense to read the value first and when it doesn't, when you want to just set an event handler in the constructor or somewhere else. Of course, it doesn't just apply to classes. This works the same in functions and classes. The only reason I'm using classes in these examples is because that's what 12 does in theirs. But yeah, as you can see in this example, if we go back here and we just, for example, invoke mouse position subscriber, we're actually not going to get any errors, right? If you want to do that for whatever reason. But that's basically it. I hope you now understand more how things like Media Query work under the hood, how you can create your own reactive browser APIs and more. This doesn't just apply to browser APIs, of course. And I hope you understand when you can use more advanced runes like effect tracking. There's also effect.root, but the only difference with effect.root is that it doesn't auto-clean up. But yeah, basically that's it. If you like what you've seen, don't forget to like and subscribe, and I'll catch you in the next one. Peace.