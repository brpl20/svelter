 Hey friends, today I want to show you a new way of working with data in SwellKit, and that is remote functions, which are currently experimental, so use them at your own risk. But let me tell you the truth, remote functions are so enjoyable and fun to use that I honestly don't care. Basically, if you ever use tRPC, then you know what remote functions are. So remote functions basically let you invoke functions from the server on the client like they're regular functions, and under the hood they're just a fetch request. Alright, so let me give you a taste of remote functions. Let me show the URL bar because this is going to be important. So usually in Swell the URL segment dictates where you're loading the data. So for example in this case where you're on the homepage usually this is going to be a load function. So you would have to create a plus page.server.ts file. And if you go to the post you would also have a load function here. So you would have to create another file and the same is true for this form. so you would use form actions for something like this. And let me think deep about some of my favorite comments on YouTube. So of course it's going to be Svelte is React now. Banger comment. Let's send. Okay, so now we can also say view did it first. That is also one of my favorite comments and we can just post it. As you can see, it works beautifully. But of course if we go here to the admin section here we can actually control the posts. In this case we can have many different authors that each have their own posts. And in this example here we have a layout. So this is a nested layout. So on the left we can just list the author's post. So again we would need a load function. And then if we go create this post. Again we would need to use form actions. So we can say remote function slap. And we can say this is a post about remote functions. Awesome let's publish it. And we're going to see it works as expected. And now we can go back here and we can look at the post. And if you don't like the post, no problem, we can go back to the admin and we can just delete the post. But in this example, we're using zero load functions and instead we're taking advantage of remote functions. So if I open VS Code, you can see that there are no plus page.server.ts files. Here we're just using a regular function. And thanks to asynchronous felt, we can just use it straight in our template. And that is all possible because I have it enabled in the Svelte config As you can see under compiler options here we have async true and for SvelteKit it important that we have remote functions enabled And that it Now we can invoke the Svelte config As you can see under compiler options here we have async true and for Svelte kit it important that we have remote functions enabled And that it Now we can invoke functions from the server as regular functions on the client. So for example, if I go here to get post, you can see this is a special .remote.ts file, and on this line, we're querying the post from the database. So going back to our example, we can open the developer tools, and if you go to the network tab at first if you refresh everything you're not going to see anything special because the content gets server side rendered so if you for example open localhost you're going to see in the preview here we get everything so that's really great but if you for example go to the admin section so now the site is going to use client side navigation so if we go back to swell tricks you're going to see it's going to load our posts and if you click on the post you're going to see this is just some good old-fashioned jason and in the headers we can see this is just a regular API endpoint. And this is the advantage of something like this being baked into SvelteKit because the developer experience is so much better compared to something like TRPC. Of course, this also means these endpoints are public. But from what I understand, SvelteKit doesn't allow someone to make cross-site requests. And we're also going to look at how we can validate the input so you can't submit junk. Alright friends, I wanted this tutorial to be as real as possible. So I'm using Better Off for the authentication and I'm using Drizzle as the ORM. And of course, it would take forever if we did this entire project from scratch. So I included all these examples here on the main branch. But if you want to follow along in this tutorial, I'm going to show you how we can set everything up. So you can start from the starter branch where I deleted all of the remote functions code. So you can follow along with me and learn remote functions. So let me show you how you can quickly set up this project. All right, here is the setup if you want to follow along. So first I'm going to say npx degit, then the name of the repo, pound, starter. So this is going to be the name of the branch, and then you can name the folder whatever you want. So instead of example, I'm going to name it remote functions. And then press enter. And sometimes there's this weird thing where degit hangs, for example, so you can just press ctrl c if that happens to you. But it basically just takes a second. Awesome. So now we can cd into remote functions and now we can list the contents and let's say ls-a so you can see hidden files so now you have to rename the environment file so for example if you say cat environment example you going to see here the environment variables so you don have to set anything up and don worry about this better or secret this is just auto junk from their tutorial so everything is going to work fine for you all right so you don have to set anything up and don worry about this better off secret this is just auto generated junk from their tutorial so everything is going to work fine for you all right so we just need to rename environment to environment so we can say move environment to .env all right so now if we look at our files you're going to see it's renamed properly so if we cat.env you're going to see everything works as expected all right so now you can install your dependencies and you can use npm, pnpm, whatever you want. It doesn't matter. I'm going to use pnpm because it's faster and it should take a second. Awesome. So let's create the tables in our database from the drizzle schema. So you can say pnpm, you can say run db push and then it's going to ask you, hey, do you want to create these tables? Yes, I want to execute these statements. Boom. That's it. Now we're done. And now we just need to start the development server. Alright, now you can open the project in your favorite code editor. As you can see, it's mostly placeholder data. And if you go to localhost 5173, everything should be working. And there's one more cool thing that I want to show you. So in this example, we're using SQLite so we don't have to worry about setting up a database. And as you can see, I can even open it inside VS Code. And that is thanks to this SQLite viewer extension. So you can install this if you want and it's really awesome in my opinion. So you can get SQLite Viewer by Florian Klemfer and you can just install it and you can open an SQLite database inside VS Code. Alternatively, if you want, you can also use Drizzle Studio, which is a fantastic graphical user interface for interacting with your database. Alright friends, let's take a brief look at remote functions before we start using them. Most of the time you're only going to use two remote functions, So the first one is going to be the query remote function. So this is used to read dynamic data from the server, such as this example where we read posts from a database. And this is just a promise, so you can use it directly in your template thanks to asynchronous wealth. But of course, you can also use it at the top level of the script block. And there is even an alternative syntax if you want to use something like tan stack query. So we can just use this promise here. Keep in mind, we're not awaiting it. We're just assigning it to query. and now we get access to the error, loading, and current fields on the query itself. But in this video, we're mostly going to use the await form. And of course, you can also pass arguments to the query, which you're going to do for the posts, and then you have validation using any standard schema library which is really awesome when we talk about forms So you can also batch queries in this example So this solves the n plus one problem So here we looping over the cities and we want to get the weather This would be multiple requests. But if you want to make a single request, you can use query.batch. So instead of a city being passed here as an argument, now we get cities. So this becomes a single query. And this is not something that you're going to use often, but keep that in mind if you ever need it. But the most exciting remote function to me is the form function. Because you can pass in any standard validation schema, so you can use Zod, ValleyBot, and so on. And as you can see, now you no longer need to do that form data dance using some utility or a third-party library. We can just pass the schema here, and based on this schema, now we get back the title and content field. And now you can do whatever you want. And I absolutely love this, because this is so much less bureaucracy than before. And if you don't need a form, you can use a command function. So let's say for example that you want to like a post, which is something that you're going to do. Well, in that case, you might not need a form, so you can use a command instead. So this is a simple way to write some data to the server. So just like in this example, as you can see, we can just define this add like function, and now you can invoke it by clicking a button. That being said, most of the time you're probably going to want to use a form, because you get progressive enhancement out of the box. So your form is going to work even when JavaScript is disabled for some reason. And if you want to pre-render content such as blog posts, you can use the pre-render function. And this is very exciting because now you can have pre-rendered and dynamic content on the same page. So it's not all or nothing. And you have other things here such as how to handle validation errors. But one thing that is more important to us is get request event. The beauty of remote functions is in the name, functions. That means you can compose them like regular functions. So inside the query, form, and command function, we can use getRequestEvent to get the current request object. So we can see if the user is authenticated or not. So we can just create a simple authentication function, which we can reuse across our queries. Alright, enough talking. Let's see how we can use remote functions. Alright, let's start by creating a simple function to fetch all of the posts. The beauty of remote functions is that you can create them anywhere. They can be inside your routes, co-located alongside your components, or anywhere else where you want them. But in this case, I'm just going to go

 to the lib folder and i'm going to create a new folder called api this is irrelevant you can place them anywhere you want and i'm just going to name this post remote.ts and this is the only important part this file name has to end with dot remote.ts or dot js if you're using regular javascript and that's it so now you can create this file now all of our post logic is going to be located inside api slash post dot remote dot ds all right so let's create the get post query so we can say export const get post equal query which is imported from swell kit and you can just pass an async callback all right so now you can use drizzle to get the post so here is how we do that we can say await and then we can say db so we can import the drizzle client as you can see here nothing special and then of course to select the post you can say select and in this case i'm going to import all of the tables so i'm going to say import all as table from lib server database and it's going to be schema i think so if i go here you're going to see here i have just all of my tables so here's a user table if i go to the bottom you can see here i have comments posts and etc so yeah that's basically it all right so you can go here and then we can just say from and we can use the table we want. So we want table.posts and then we can return the posts. Of course, we don't have any posts yet here. So let's create another query which is going to be get offer posts and this is also going to be our guarded query which we can use in the layout and then we can redirect the user if they try to go to the admin section if they're not logged in. So let's just say export const get offer posts then we can say query and we can also make this async if you want. Alright, so to get the offer post, we actually have to know the offer ID and that is only possible if we know the information about the logged in offer or user. And to do this, we can create a simple off function which we can reuse across all of our remote functions and it's simple like this. So let me show you. So we can say function require off or you can name this whatever you want. So now we can use getRequestEvent to get the information from the locals. And if you don't know what I'm talking about, we can go to hooks for example, and this is how I have better off setup. And this is most of the solutions you going to encounter when you implementing off in SwellKit So here we just using this better off await of API get session Then we checking hey if there a session then we can just set the locales to this session and the user. So now anywhere where we're requesting an event in Soilkit, we're going to have this data. And if this is confusing, let me know in the comments if you want a dedicated better off video. All right, by going back to our code, we can just say const and we can destructure locals from get request event. which is going to be also imported from SvelteKit. Alright, so now we can just check the locals for the user. So we can say, hey, if there's no user signed in, then we can just redirect. So we can import redirect from SvelteKit. Then let's say 307. And then we can redirect to our slash off slash login route. And in case the user is logged in, we can just return the user data. So you can say locals user. As you can see, this is already typed because in app.ts I included all of this information. So I imported the types from server database schema. And this is really simple if you're using Drizzle, so we can just infer the type from the table. That's basically it. Alright, so now we can make this guarded query. So we can say const user equals requireOf. So we're going to get the user information. And anywhere we're using this query, since we're checking if the user is logged in, we're going to redirect if they're not. So this is how you make a guarded query. And of course, if this isn't enough for you, you can use hooks.server.ts and you can actually check the route here. And then if you have an entire protected route and if you want to be more sure, you can just put a conditional here and you're only going to check for that route. So you can always use hooks.server.ts instead. All right, but in this case, we just want to return the offer post. So now we have a bunch of things on this user like ID and et cetera. So we can say constPosts equals await db select from. We can say table.posts and we can say where. So we can use this equals function from drizzle. And of course we can say table.posts offer ID where it matches the user ID. So we're going to return only the offers posts. Awesome. Now we can return the posts and that's it. As you can see, that is how simple authentication is. So whatever route includes this remote function which require off is going to automatically become guarded And if you use it inside of a layout then the entire route becomes protected So be careful when you using it in nested routes because if you only use it in one part of those nested routes, that isn't enough. You either have to use the function in the layout of that entire route, or you can use hooks.server.ts. Alright, and in all of my excitement, I didn't even register this error. So what does this say? Property users does not exist on type localhost. did you mean user? Why yes of course. Oh my bad. This is just user. There we go. Alright so let's go to the home page. So we can go to source slash routes and now we can fetch all of the posts here. So let's remove this placeholder. We can use await at the top level of the script block or inside of the template. So we can say await get posts and that's it. How beautiful is this? And now instead of slug here we can say post and check this out. This is all typed of course. So we can say post slug and then instead of title we can say post title that's it but of course we don't have any posts yet so next let's work on the admin section all right so we can go to the dashboard and this is the route that we want to protect if the user isn't authenticated we want to redirect them to off slash login and if they don't have an account they can go to the sign up page but as you can see here in admin, this is just a simple dashboard with a nested layout. So if we go back to our code, we can see admin here, it has two simple routes, create and edit. And if we open plus page.swealth, we can see here is the admin text and the welcome message with the sign out option. And here we have our main plus layout.swealth. So this is what we want to modify. As you can see right now, this is just a placeholder. And this is a perfect place to use our guarded remote function. so we can go here and remove this we can say await offer post and that's it so now we can go here we can remove this placeholder we can say post log and we can do the same for the title we can say post title all right and now since you're not logged in if we go back to our home page and we can see no post found which is great so let's say that someone stumbles upon admin oops, they can't go here anymore. As you can see, that was really simple. And because we used the guarded query in the layout itself, the entire route should be protected Alright so let take care of the login signup and the logout functionality So we can go back to our code and now we going to work in this section off So here we have a login and signup route. Nothing special. Here we have a simple form. Now we just need to create a remote function. Alright, so going back here in our sidebar, let's create a new file which I'm going to name off remote TS, and this is going to be responsible everything off related. alright so first let's create the signup function so we can say export const signup and now we can use the new form query from cell kit and as you can see this is really interesting by default it requires you to pass a validation schema but if you're prototyping or have your own validation you can just pass unchecked and then you're going to get the data from the form in our case this is going to be user and we can even make this async but in this case i'm going to import a schema i already made. So I'm going to start typing signup schema, and this is going to be imported from lib slash schema slash auth. And if you go to the schema, you're going to see it just uses ZOD. But you can use any validation library that supports the standard schema. So you can use ZOD, ValleyBot, and so on. And it's just going to work. As you can see here, we have this name, email, and password fields. And now that we validated the data, this is completely typed. You don't have to do that form data dance or use some utility function it just works so in this example we can use the better off to register the user so we can say await and we're going to use their server api so we can import all from lip server off and if i go here you can see it's just that simple this is just their client and then you can say off api sign up email and then we have to pass this body so let's see what it accepts we can see that it accepts email name password and since the user already matches the shape we can just pass user that's it and now we can redirect the user and let me just import it from cell kit and we can say 307 and now that the user is registered we can redirect them to admin so let's say slash admin and of course you can also return whatever you want from this form so you can return banana and you can have whatever here. And then on the client, you can say from this function, signup.banana, you can check for something, whatever you want, and that's how that works. But in this case, we're just going to create two more functions.

 We have sign up and let's create login. So this is going to use the login schema. Again, we're going to get the user and we can get their information from the request. So we can say const request equals get request event from CellKit. And now instead of sign up email, we can say sign in by email. So we have to pass the same value in the body, which is the user. And this also requires a header. so we can say headers and we can get it from the request so we can say request headers that's it and this is going to be 303 and we can also redirect to admin alright so let's also implement logout let me just copy this over so let's name this signout in this case we don't require any schema so we can just omit this part and we don't have anything here alright so now we can remove this line and we can just sign out the user so we can say off api sign out and then we can just pass what's required so in this case it requires scatters so we can say request scatters there we go and we can redirect the user to the home page and that's pretty much it for the validation when it comes to forms and i'm also going to create a function to get the user data betterof has an API for that but it's honestly kind of broken I don't know it's really simple to do your own so we can just say export const get user this is going to be a query we can make this async even though I don't think it's required alright so we can just get the user information if they're logged in so again we can get locals from get request event and then we can actually do the same check so if there isn't anyone logged in we can just redirect we can say 307 and then we can say off login and then if they are logged in we can just return their information so we can say locals user boom there we go let's do a bit of formatting and honestly that's it that's how simple that was all right let me show you how cool this is so let's go to the login route we're going to open plus page.svelte. And now the only thing that you have to do is spread login on the form. So we can import login Let import it And that it So now this is going to spread all of the required attributes on the form And not only that but this is progressively enhanced out of the box So whenever it can, it's going to use JavaScript by default. But if JavaScript isn't available for some reason, it's going to still work. So if we go to our login page here, let's open the developer tools. And now we can inspect the form and we're going to see all of the required attributes are on the form, such as the method and the action. So you don't have to think about that. but it gets even cooler. In this case, we can treat this like a regular form. We can just pass the type ourselves and the name, and that's going to be fine. If we go back to our function, this is where we're going to receive it. Here we have the user. So we have all of the fields, email, password, and so on. But SvelteKit makes this even more type safe. Instead of doing this, we can actually spread the fields. So let me show you how that looks like. So we can remove this. We can use the curly voice. Let's say login, fields. Now we can pick the field that we need, which is going to be email and we need to tell it what type it is so we can say as email and this is really cool and now we can also show the issues by just looping over them so let's use the each block and we can say login fields and we can pick the field if you want to show the issues there can be multiple issues for some fields so we can loop over them so we can just say issues and we can invoke that but of course this can be undefined so let's specify a default value which is going to be an empty array and then let's say as issue all right so now you can just create a paragraph tag we can say issue and then we can say issue dot message that is how simple that is of course you can repeat the same for the password field so let me just take this for sake of convenience so you can just spread the type here instead of email this is going to be password and the type is also going to be password. So we can also copy and paste this code and instead of the field being email it's going to be password. And of course I forgot a curly boy here. Alright so now if I save and format everything should look great. Alright so let's do the same thing for the sign up. So we can go to sign up. Let's open that and we can do the same thing. so we can use the curly boys let's spread sign up that's it so now we can do the same thing to the fields we have username email password alright let do that quickly so we can just spread signup fields we can pick the field it's going to be name, as, now we can pick the type, which is going to be text, and let's loop over the issues, so we can say signup, fields, name, issues, we need to invoke this, and again let's set the default value, and we can say issue let's create a paragraph tag with an issue class and then we can say issue.message alright so let's actually copy this for all of these fields this is going to be email let's copy the issues and again you can probably make a snippet or a component out of this if you find this tedious so we can also say email let's also copy over this it's going to be password and let's copy over the issues alright let's format and save and it should be it alright now we should be able to register and log in to the dashboard Alright, so back on the login page, let's sign up for an account. So we can enter a name, whatever you want. Let's enter a bogus email, example.com. I'm going to copy it as the password, don't tell anyone. Let's sign up and we're going to see everything works. Now we're logged in as admin. Alright, so let's display the user information and let them sign out. So we can go back to our code editor. Let's start typing admin and it's going to immediately give us the plus page.self file. so let's open this and now we can use our get user function so we can say const user equals we can use a way to directly here and we can say get user which is going to be imported from lib slash api slash off remote and that's it this is how simple it is to create your own functions we don't need to rely on some library and of course in this case instead of hard coding name we can just say user dot name. And for the signup, we just need to import signout and spread it here. So you can do that. And that it So now you can save this and you can see here is our name And let see if we can sign out the user And awesome now it works It redirected us So now we can see if we go to Swell Tricks There no post Let's go back to the dashboard. We have to log in. So we have to provide our email, which is example.com. And don't tell anyone about my email. Let's see if we can log back in. Beautiful. All right. So now we can focus on actually creating the posts. Alright, so let's go back to the post remote.ts file, and here we're going to create two remote queries. We're going to create one for creating the post, updating the post, and deleting the post. So let's say export const createPost, and then we can say form. So this is going to use the createPost schema, and as you can see on this schema, we have the title, slug, and the content. Nothing special. Alright, so let's make this async, And we're going to get back a post. Of course, we need the user information. So we can use requireOf. So we get the user information, such as the ID. And then we can say await DB. And then we can insert this value into post. So we just have to say table.posts. And the values we want to insert. So as you can see, here are the values that we have to pass. All right, so now we can spread the value it already expects, which is going to come from the post. So we're going to do that. and then we can pass in the author ID. So that is going to come from user ID. Alright, so after we added the post, I want to redirect to the editing view. So we can just use a redirect. So let's say redirect from cell kit. We can say free or free. And now let's use backticks. So we can say slash admin slash edit slash the post slug. And that's it. So now we can copy this over. We're not going to reuse a lot of it. So we can just rename createPost to updatePost. The schema is going to be updatePostSchema. So you can see on it we have ID, title, slug, and content. And here I'm going to destructure the values that we need. So instead of post, let's say ID, title, slug, and content. This is going to be easier to pass to drizzle. And we can actually delete all of this inside of here. Alright, so let's say await DB update. We want to update the posts. So we can say set. And now we can just pass the values. So we can say title, slug, and content.

 and then we can say where, we can use EQ from Drizzle, alright, so we can say where table post ID is equal to the ID that we passed. And that's it for updating the post, so we can actually copy this over, so instead of updating the post, we're going to say remove post, and this is going to share the same schema, because it's going to be the same form with a different action, and instead of passing all of these values, we only need the ID, So let's remove these values. And let me remove this line. So we can say away DB delete. Table post where. And then we can use equals. And we can say table post ID equals to the ID that we passed. Alright, and then we just want to redirect. So we're going to say free or free. And we want to redirect to slash admin. And that's pretty much it. These are all of the queries that we need for creating, updating, and deleting posts. Alright, so if we start typing create, we should see plus page.swell for the route that we need, so we can just open this, and we can see this should be the create new post form. So let's do the same thing as we did before. So we just need to import and spread create post. So we can see it's imported for us at the top. And now we can just spread the fields and loop over the issues. So let's go here. and we can spread create post fields, so we're going to pick the title as it's going to be of type text. Alright, so now let's loop over the issues, so we can say create post fields, title, issues, let's invoke it and we can just say issue. Alright, so let's create a paragraph with issue, and then we can just say issue message. alright so let's also set a default value here and then we can copy this over and yeah it will be probably easier to copy the entire block but whatever and then instead of title this is going to be slug let's just copy over these issues this is also going to be slug and beautiful now we have this content here which is just a text area so let's again copy over this part no big deal And let copy over the issues Boom that it And we can also optionally show a loading indicator. So since I'm using PicoCSS, I can just use the aria-busy attribute. So for example, I can say aria-busy, and then we can set it to the pending value. So we can say createPost, this is the query, pending, but it's not happy with this because this isn't a boolean. This is going to be a number, so how many of these queries are going to be pending? What you actually want to just check, hey, if there's any pending query. So we can turn this into a boolean. And the easiest way to do that is using the double exclamation mark. And this is going to happen too quick, so let's actually add a delay on this query. So we're recreating the post. We can just say await, and let's import delay. This is a helper function I have from utils. And then let's set it to 300 milliseconds. And if you're curious, this is just a simple promise. As you can see, it just returns a promise that we resolve after a certain duration. Alright, so let's create a post. So here we have our create new post form. So we can say example post and then we can give it some bad slug. For example, let's see if our validation works. And then let's say for content example post. Alright, so if we say publish, we're going to see we have an error here because our validation works, thankfully. so we can make this a proper slug and then we can publish it and as you can see it's going to redirect to the edit route but of course we only get these placeholder values because we haven't done anything with this form yet so let's do that alright before we go to the edit route I'm just going to copy and paste this delay here to this other query so we can show the loading spinner and that's pretty much it so now we can start typing edit and we can find plus page.svelte so we can open it here and we can see this is just a simple placeholder and this is just a simple form with a title slug content and here we have a hidden input so we can send the post id and we also have two actions here one for updating and one for deleting so we're also going to see how that works all right so let's think about what we want so when we go to the edit route slash this post slug we actually want to fetch the post information including the id so we know what post to update so how can we do that well we need to create some query in this example we're going to create a get post query. So back in our editor let's go back to post remote.ts and now we can create our get post query somewhere here so after we fetch posts So we can say export Const getPost And this is going to be a simple query And we can also reuse this query when we go to the post slug in the other route. And this query also accepts a slug param. So we can just create a simple schema. If I press Z, we can import Z from Zod Mini. And let's just say Z string. So we don't need any fancy schema. And then we're going to get back the slug. alright so we can say const pose equals await db select from table pose and now we can say where equals so we can say table pose slug is equal to the slug that we passed and then let's return pose and now we just want to show you what is being returned alright so the first thing we need to do is get access to the params so we can destructure params from props. So here is how that looks like. So let's just log it in this way so we can say params. So now if you go to the example post you can see here we get this log example post based on the URL. Alright, so now we can use this to fetch the post. So we can come here and we can say const post equals we can use a derived because we want to update this post each time params updates. So we can say await get post which we're going to import and then you can just pass params slug. And it's really interesting it's using .js for this. I think it's really important. I don't know why it did something goofy like that. And we're going to get rid of this in a second but let's just say post and then we can log it here. So I'm going to show you what it gives us. Alright, and as you can see now we get this array from drizzle. But in our case we're only interested in the first result. So let's go back to post remote and then we can just the structure the array and we can just get the first post. That's it. And now we can return this. And let's also use a check here. So we can say if there isn't a post we can use an error from cell kit. So let's import error. Then we can say 404 post not found. And that's pretty much it. So now we can see even if you refresh we're going to get the single post from drizzle. All right so now Now going back to our code we can now remove this placeholder since we no longer need it And this is no longer post this is singular post Now we can remove our helper here Alright so now when we go to our example you can see it already works So let say for example if we go to SwellTricks back to admin, here we're on the admin page. Now when we go to edit the post, we're going to see the fields are populated. Alright, so let's update the form by importing update post and spreading it on the form. Alright, so now we're going to do the same thing as before, but in this case, we're actually going to leave this value here alone because we actually want these default values to be present. But here we can just spread updatePost. And we can say fields, title, as text. And let's loop over the issues. UpdatePost. Fields, title, issues. As issue. And now we can go here. We can say P issue. Not is. Issue. Interesting. we can say issue message alright so let's repeat this for the slug practice makes perfect right alright so we can go here leave the value as is this is going to be slug and it's going to be text alright so we also need the issues alright so let's see what else do we have here we have content same as before alright let's take this and let's paste it here. So this is going to be content, and let's copy the issues. That's it. All right, so the hidden field is a bit more interesting. In this case, instead of using value, we're going to use a more type safe API. So we're going to spread updatePost, fields, ID, and now we can say as and the first argument is going to be hidden and now we can pass post ID. Alright, so now we're going to get type safety because it's complaining that this doesn't expect a number. So we actually have to convert this to a string and we can do this in many different ways but I'm just going to say to string and that's it. Alright, so let's add a loading spinner. Alright, so let's also add aria busy and we're going to say update post pending let's do the same thing as before now we can copy this over to delete. But we also want a different action here. So to do this we can spread a different query

 So we can say remove post and we're also going to import it and then we can say button props. All right so let's see if we can update the post. Let's set an exclamation mark and then let's hit update and as you can see it works but SwellKit reset our form which is really interesting. That's not what JavaScript does by default but SwellKit tries to emulate the default behavior of forms. Unfortunately in this example this works against us because you can see if I refresh the page everything works as expected. Alright, so how can we fix that? Well, we can actually control the behavior of the form. So if I go here where we have update post, we can go here and we can use this enhance method. So we can invoke it and we can pass a callback function. So let's see what do we get here by default. So by default, we get the data, form, and the submit method. And this is actually what we want. We actually want to use JavaScript, but it's not going to reset the form by default. So we can just invoke submit here. And later we're also going to look at how we can use Enhance for optimistic UI updates. But in this case, let's just save. And now when we go here and update the post, let's see if it works. Hit update. And as you can see, now the form doesn't reset. And also if we go to SwellTricks to our homepage, we're going to see now we see our posts. And if we go back to admin, to our post, let's try deleting the post. And it works as expected. All right, let's also fix a couple of issues I noticed. So we didn't even specify a default value here. So let's do that quickly. We're just going to set this as an empty array. And I think we also need to do this for the content here. Awesome. Let's see if there's anything else wrong here. I noticed something weird when we deleted the post. So this is remove post. Okay. All right, this isn't update post. This should be remove post. so let's actually see if we create a new post let's just say test now we should see our loading spinner here where we press publish let's say if we update test we also see a spinner here and we should see a spinner when we delete it alright we fixed that but in a real project you probably want to set a minimum duration before you show a loading spinner because if it happens too fast then it's just going to flash and it's going to look janky alright so the last thing that we have to do is actually show the post when you navigate to it so for example if we create a post titled remote function slap and let also create a slug remote function slap This is a post about why remote functions slap Alright, so let's publish it. As you can see, everything works as expected. When you go to 12 tricks, you can see our posts here. But when you go to the post itself, this is just using placeholder content. Alright, so let's work on showing the posts, liking the post and leaving a comment all right so back in the editor we can navigate to slug so we can go to source slash route slash slug and this is going to be very similar to the admin route all right so first let's replace this placeholder content so we're going to the structure params from props and then we're going to create this post variable we're going to use a derive so this post updates when the slug does so we can use away directly inside we can say get post let's import this and then we can pass params slug and that should be it so we can even use our old trick here let's log post so we're going to see we get our post all right so we can remove this instead of title let's say post title and here you can use markdown if you want but i'm just going to say add html post content all right so if we save this and we look at our post now we're going to get the content alright so let's see if we can get more easy wins we're going to leave the liking the post and comments for later but I think that we can just use posts here alright so we can go here we can say await get posts and that's it let's import that and now we can replace these placeholders we can say post slug and then we can also replace the title with post dot title and we can see that it works alright so let's go back to our code now and now we're going to work on liking the post. So let's go to postremote.ts and let's find a cozy spot here. All right, so first we need to get the post likes, which also means that we need to pass the post ID. So let's create a getPostLikes query. So we can say export const getPostLikes and we can just use a query and let's just say z number and then we also get access to the ID and that's pretty much it. Alright so we can say const likes because drizzle is going to again return an array So let just say away DB and let make it more legible because this is going to be a longer one so we can say select and in this case we only going to select the field that you interested in which is going to be likes so we can say likes and then we need to pick it from the table so we can say table post likes and then we can say from table close and then we have to say where so we we can say equals table pose id is equal to the id that we passed and then we can return the likes so we can say return likes and if this is undefined then we're going to return zero so let me actually show you this so here where we have our likes we can just go here let's create a new line. So we can say await and now we can import get post likes and then we can pass the post id. But this isn't going to work because of course it's going to return some array. And maybe we can even log this. So let me actually see if we can do the same trick here. Alright so let's do this and you can see it returns this array with likes. So we just want to return likes and nothing else. So let's actually go back to post remote and then we can do the same trick as before. We can destructure these likes by using curly boys and then you can just say likes. Alright, so now if we go back here you're going to see we only get the likes back. Awesome, so let's add liking the post and for this we're going to use a command because we don't need a form in this case but of course you can use a form if you want and this is what commands are useful for in cases where you don't require a form but you want to write some data to the server and keep in mind the benefits of forms is progressive enhancement so they're going to work regardless if you have JavaScript or not alright but in this case let's just say export const and then we can say like post and this is going to be a command so let's import that and this is going to be a number and we also get an id so we can say away db and this is also going to be lengthy so let me use a new line so we can say update we want to update post and then we want to set the likes in this case and we have to use this special SQL function from drizzle so it makes it easy to just increment this field so we can use backticks and then we say table post likes and we can say plus one so we just doing a raw SQL query And then you have to say where equals table pose id, the id that we passed. Alright, so now let's actually use this query. So let's remove this and we can go here. So let's add onclick and let's import like post. And of course, we need to pass in the post ID. Alright, so let's save everything and let's see if it works. Let's refresh for good measure. And I'm going to see nothing happens. And that's because we have to be explicit when we're using commands what queries need to refresh. By default, when you're using a form query and it does a successful submission, all of the queries are going to update. But in this case, we have to specify that manually. And you can even use the same trick on other queries. So let's actually go back here and here's what we have to do. So what is the query that we want to update? It's getPostLikes. So we can pass in the ID and then we can invoke this special refresh method. So that's well known to invalidate this query. Alright, so we can save and you already see if we refresh the page we get the data back. But now let's see if we can like the post. As you can see, it works as expected. Alright, so let me show you how we can do optimistic UI updates. And if you don't know what it is, let's say for example that it takes a while to like this post. So for some reason, maybe your server is slow, I don't know. So let's say await, delay, and this can be 2 seconds. So let's say for example that your user is on this page and they try to like a post. And now it looks like nothing is happening, they're getting frustrated, They click like and they're like, oh, what is going on? Let me just click a thousand times, right? You've been in that situation probably. In this case, we can use Optimistic UI updates, which is using JavaScript to fake that this happened instantly on the client. So you can do this trick with commands and forms. And if it fails, we can revert to an older value. And let me show you how easy this is with remote functions. So back in our code editor, let's go to our post. And now here where we have this query, let me put it on a new line so it's more readable. We can use this special method, updates. And let me also make more space so it's readable. And now we can specify the query that is going to update by liking posts. So we can say get posts.

 likes, we can pass the post ID, same as before, but now we can actually use this special method where we can override the result. So this is going to temporarily override it. So we can say with override, and now we get access to the result, which is going to be likes in this case. So the only thing that we have to do in this simple example is say likes plus one. That's it. Alright, so now let me save and format everything. And now remember, we still have a 2 second delay, we didn't change anything, but we're using optimistic UI updates so it appears instant. So let's go back to our example and let's see what happens when you like the post. As you can see, it happens instantly. How beautiful is this, friends? This is the power of optimistic UI updates. And if this looks ugly to you, keep in mind these are just functions, you can just abstract this. the beauty of remote functions is in the name they're just functions so you can compose them like regular functions alright so the last thing that you have to do is add the ability to fetch comments and post comments so inside post remote TS we can just create our two queries alright so let's say export const get post comments and we're also going to require the post ID to get the appropriate comments so we can say query and we can say that this is going to be a number and of course we get access to the ID. Alright, so let's say const comments equals await db select from table.comments and we can say where equals table comments post ID is equal to the ID that we pass and we can just return comments. In this case you're not going to use authentication for the comments or anything like that but maybe you can do that as an exercise alright so we just need to add the ability to post comments so you can say export const post comment and of course this is going to be a form query And we can use the post comment schema So this is going to give us the post ID, offer, and comment. And we can make this async. We're going to get back the comment, so we can insert it into the database. And let's say await DB, insert in the comments table. and we can just insert the values which is going to be the comment and let's also add a delay here so we get a spinner so we can say await delay 300 milliseconds and that's pretty much it. Alright so let's go back to the comments markup and here we have this placeholder so now we can say await get post comments so we can import that and of course we need to pass in the post ID and now we can replace these placeholder values and we can also put an at here. It doesn't do anything special, it's just decorative. Alright, so now where we have the form we just have to do the same thing as we've done before. We can just import and spread post comment and then we can leave this default value here which is going to be anonymous so we can just spread the field here. Post comment fields offer as text. and we can loop over the issues. So let's say post comment fields offer issues as issue. And let's also use a default value. Awesome. So now let's say p issue and we can say issue.message. Alright, so let's copy over this issue here and we're going to copy this field. So this is going to be a comment and let's say comment and comment here also. And this is going to be the same thing as before Let spread post comment fields post ID as we going to make this hidden and we need to pass post ID. But of course this type doesn't match because we need to turn this into a string. Awesome. And then let's add a spinner here. So we can say aria busy and then we can say post comment pending. Alright. So now back to our post. Let's see if this actually works. so we can leave a comment as an anonymous user. We can say, hi, let's post the comment. We're going to see our spinner and the comment is going to be left. Awesome, but there's one problem. You notice that the field reset. So we have the same problem as before. But in this case, I want to keep the name field and I want to reset the comment. So that is actually very simple to do. So here where we have the form, again, we can use the method. We get a callback. And now we can use submit again. and it's not method, my bad, it's enhance, and we can just invoke submit, but there is also another API that we can use. So we can get the values and set them using this special SwellKit API. So in this case, we can say post comment, fields, comment, and then we can set it. So we can just reset the field. And that's pretty much it. Alright, so a bit of formatting, and let's actually look at it, so we can see anonymous, let's say test we can post the comment as you can see the comment field clears but we leave the anonymous name all right friends we're almost done there is just one more thing i want to talk about you're probably wondering with remote functions when would you create a dedicated api route well there's actually two cases so one case is where you want to expose your remote function so let's say for example that you want to expose this post to the entire world where you can create a dedicated API endpoint using plusserver.ts. So in this example, we're just importing getPost and then we fetching them inside of this get function and then we turning them as json so for example if i go here to the website and i go to slash api slash post you going to see we get back our json response and of course you don't have a lot of posts but as you can see it works so this is one example where you would create a dedicated api endpoint another example is when you need a custom response such as an RSS feed. So here in rss.xml in this plus.server.ts file, we're importing getPost, and then we're creating this RSS feed. So we get the post, and when we're done with all of this, we can just return an XML response with the appropriate headers. So again, now if we go to the API, and we go to RSS, now we're going to see, since I'm using Vivaldi, it's going to use its built-in RSS reader. But I don't want to blind you, so let's go back. Alright friends, so I hope that makes sense. And that's basically it. I also want to remind you that remote functions are experimental and you can expect breaking changes. It seems like the majority of the remote functions API is locked down, but there's still some experimentation going on with things like forms. So based on this pull request, it seems like button props are going to be removed in favor of this improved more type safe API. So if you have multiple actions on a form, now you no longer need to create multiple form queries. You just need one. So instead of saying register.buttonProps, so you spread the same query and say dotfields.action as submit, and then you type the action. So in this case, this is register. So now instead of having this extra register function, where you have this login form, now you have this payload.action. So now you can check what action the user submitted, and then you can do whatever you want. And the Svelte team is also cooking on some exciting features such as streaming live data from the server. So expect changes and make sure to read the documentation. Alright that's it, if you like what you've seen, don't forget to like and subscribe, and I'll catch you in the next one. Peace!