 Hey friends, today is going to be a fun one. We're going to make a swell typing game. And you can go here in the post and you can load the example if you want. You might want to enable cookies in your browser since it's using StackBlitz, but yeah, I gave it a second and it's going to load in. But by the end of this post, we're going to make a speed typing game if you're familiar with something like MonkeyType. And as it loads in, I'm going to show you. And so the words are going to load in. You can say, and start playing. And we can skip words. next line and you can continue. But I'm really not interested in the game itself but all the other things you're going to learn around it and that's why I'm going to take more time in this one to explain my thought process and show you how to approach problem solving and if you just want to make a quick game to add to your portfolio or whatever, feel free, you can just read the post and you're going to be done in no time. If you're watching the video try thinking about the problem beforehand and challenge yourself and that's really how you learn. And of course this is a cooking show so everything is prepared in advance, but if you're a beginner or feel overwhelmed, I already have an unfair advantage over you because I already spent the time solving this problem. But yeah, I'm excited to get started. To set up the project I'm going to start a new SvelteKit project with TypeScript which is optional and Sass for styling which is also optional. And if you're afraid or don't know TypeScript, you can just ignore the types, so just remove it from your code because valid JavaScript is valid TypeScript. And as always, you can find the project files on GitHub or you can open StackBlitz and you can even develop this on StackBlitz if you go SvelteKit.new. So let me just show you a quick tip. If you don't want to use an ID, we can say SvelteKit.new and this is going to scaffold a new project in StackBlitz, which is really awesome. I'm inside an empty project and I'm going to use PNPM, but if you're using NPM, just follow the post. But for myself I'm going to say pnpm create svelte. And then we're going to go for some options. So we can say blank so it starts in a new project. Going to be an empty skeleton project. Of course I want TypeScript. You can add eslint if you want. For this one I'm not going to use eslint or Prettier. So I can just say no to all of these options. Now we need to install the dependencies because it doesn't do it for you. And now it's going to take a second. But yeah, let's also install Sass, which we're going to need for styling. And that how we set up Sass It as simple as that We basically done And also run the development server So you can say run and then it going to be available at localhost 5173 And this is the default SwellKit project. So let's continue setting up the project right here. We're going to create some global styles. So I'm going to close the terminal and leave it around it. And inside on the left, we're going to go to the source. And now I'm going to create a new file so we can create a new folder. I know it's counterintuitive, but we can create easily a folder. so we can say styles. And if you say dash, I can say app.scss and this is going to create a folder with the app.scss file inside of it. And let me just close it. So I'm just going to import the Google fonts and you can get this from the post if you want. And let me just copy over this CSS reset. So we're going to reset the margin padding and some people are allergic to this, but haters going to hate. I'm just joking. And then let's just define some CSS variables. So we can say primary is going to be tomato. And this is how I like to name a variable. So we can have foreground 100 and the other one is going to be 200. Instead of being specific with some variable names and etc. So let's do that. So I'm going to say foreground 100. I prefer using HSL, but you can use whatever you want. And we can say 98. And let me just copy over this line. So we can say foreground 200. It's going to be the same. this one is going to be 80 and then we can create background 100 hsl again 20% and 14 and that's all of it for our css variables now we're going to define the height so we don't have to use viewport units so i'm going to say html body and app which i'm going to add in a second so i can say height 100% and then for the body we want to specify the font family to be Roboto Mono which MonkeyType uses and Monospace and then for the color we can use Var Foreground 100 and for the background color let me just scroll in we can say Background 100 and then let's add some default styles for the button and when it's hovered so you can say Button and this is a really cool trick so you don't have to say font size, font family inherit, you can just do it in one line of CSS and then I'm also going to inherit and say background none border none opacity and let give it a transition So you can say all three seconds ease This is default. You don't really have to say ease, but I like to be explicit. And then since we're using SAS, let me just, yeah, we're in a SAS file, so this is going to work. So we can reference this element. This is basically the same as saying button hover, if you're not familiar with SAS. But yeah, we can just say ampersand hover, I want it to be cursor pointer and opacity 1. And that's basically it for the global style. So we also need to make sure that in our app.html, so you can press Ctrl P, get the command palette in VS Code. You can start typing app.html or you can use the sidebar, but this is quicker. And I'm just going to copy over this file because basically we just need to add the ID here, but I also want to change the favicon. So really nothing special. And now we're going to go to our project and refresh. We're going to see the favicon change, but now we need to include this. So if we go to routes, we can close app.html, close the sss file. And now inside routes, we can create a new file. And we're going to create a layout. If you're not familiar with the layout, this is what's going to be applied to every page in your CellKit app. So for example, if you have a repeating header, footer, etc., you can include it here and it's going to be shown on every page. So basically, this is where you're going to include the global styles. So I'm going to say script and then import. And this is a level above. So we can say app, CSS. Now let's change the title of the page. We can say Swellhead. This is going to complete. And let's see title, Swelltype. And yeah, now we can just create a layout. I'm using Emmet. So I can say .layout and then I can complete it or you can even press tab if you want. And the same way I'm going to add nav, H1. and Emmet is built into VS Code if you didn't know, so you don't have to go out of your way to include it or whatever. But let me just copy over this. After the navigation, we're going to have the main section and everything else that's on the page is going to be placed into this slot, so this is where our game is going to be, even though we're just going to use one page.svelte file. But yeah. So let's add some basic styles. I'm going to say style, and now you have to say that you're using SAS, or in this case, SESS, which with syntax, it closer to CSS And I use it mostly for nesting which is coming soon to CSS so I don have to use SAS anymore which is great Font family and now we can say Lexand Deca which is the title font used by Monk in Type also and I also found out that's on Google Fonts which is nice. So you can say font size 1.8 for the color we can say foreground 200 and for the letter spacing we want 2 pixels and then let's specify a layout so you can say height 100 and this is why we had to set up the height previously and include the app id because otherwise this wouldn't work and now let's say display not gird but grid very important grid template rows so i'm going to say auto whatever that's going to be the header right and then i'm going to say 1fr whatever is left use it for a game Then I'm going to say align items center and let's just give it a padding. You can also place this on the body if you want. And let me just go here and I'm going to save it and you're going to see things change. So this is basically it and awesome. And now we can press ctrl p so we can start typing page and this is the only page in the project. We can remove it and awesome. Now we have a blank canvas for our game. Let's think about the problem before we continue. I know you're excited to make this game, but I think a lot of tutorials make this mistake where they just tell you code and you really don't learn anything by the end of the day, right? Before we make the cardinal sin of just jumping straight into code without knowing what you're actually doing, let's first examine monkey type. How does it work, right? So we can start a game and we can see, huh, this is really cool, right? And it seems like you're typing in values, but let's start to dissect the site, right? So if we go here, and let me just pull down this over, and let's see how this is even constructed, right? Hmm, so, okay, so here is a word, and then you have some letters, right? Ah, that's already interesting. So it's making some guess, right, what the current letter is typed or whatever, and then it's going to put a class, correct or incorrect. But how does the input work? And you can really find this out. Let me just restart it. If you go above, and here should be an input. Ah, so, okay, so here is an input. Let me just open this. And okay, let's show the input, right? This is kubidoo, right? We can just unveil the mask from the person. So we can say opacity, oh, and here is the input, right? So this is how we pilot this game, right? Because this is some input which is hidden and we're typing in this input, but the game is checking what we typed

 pairing to the letters. And there's also, of course, all other things here that look intimidating, like all of these options, but this really isn't important. The most important part, what I would do first, when I'm trying to figure something like this, I wouldn't even open VS Code. I would like go to the spelled REPL or whatever, ColdPen, and I would create an input and some text, and I would be like, hmm, how can I drive the state of this through this input, right? And this is the first thing I would do to make a proof of concept, right? You need to break down problems like this step by step until you get to the final result. So if I go back to the post, I encourage you to inspect MonkeyType yourself and see what you can find out about how it works. Does it work how you thought it worked? Does it match your mental model? And despite me being horrendous at math, problem solving in coding is very much like math where your goal is to know what information you have and try to come up with a solution. So for example, remember Pythagoras theorem or whatever, if you have A and B then you can find out C and etc. It's the same in coding. So if I go to a scalig row where I have an example here, here is how basically monkey type works and we just really looked at this right now. So we have some hidden input and it compares the first letter and then it's going to say if it doesn't match okay it's going to be red else it's going to increase the opacity because the letters by default have a lower opacity. And that's how it works. And then we can also notice that it only has three lines so hmm later how are we going to solve this? So we just have three lines right this is really interesting. And if you pass a line here, it's going to update the lines, which is also another problem that's very interesting to solve. And then we also have the case of the caret. No, not the caret, you silly rabbit, the caret or cursor symbol. So how does that work, right? Really, we're not typing text or anything. So this is just CSS, and it basically gets updated for every word, and then it changes position. So we also need to solve that problem. And once you start breaking down these things, you're going to quickly come to the solution, or slowly. And because you broke down the problems into all of these separate pieces, now when you need help, you won't sound ridiculous when you go and ask someone for help and then you're like, hey, can you help me solve this entire game? And that's like a lot of ask for someone. But if you ask for a small part you're trying to solve, like, how would I solve making a cursor like this? Then someone can be like, oh, I have an idea, you can do this and that, and you can be like, oh, okay, that's great. So again, let me just open that Rappel code pen or whatever, let me try just recreating that part then you can go back to your game and start implementing it like that But yeah that basically it Having a rough idea of how the game works always finding helpful for the next step to think about how to drive state using a data structure So for example, if I go here in XcallyDraw, let's think about how we can represent this state, right? So how can we play this game? Or as I like to say, how can we drive the logic? So for example, let's say we have this sentence over the quick brown fox jumps over the lazy dog. How can we represent this? Well, the simplest thing we can do is just say split, and then we can turn the sentence into an array, and now since it's an array, we get all the indexes from 1 to 8. And now we can pilot this game. So we can say words at the index, and we can get the specific word fox if we say words, and the index tree. So now we get that, and since we have a string, we can also use index to access certain letters, or you can even turn it into an array which is redundant, so you don't have to do it. And now for example you want to say okay what's the current letter and then you can say words word index we get the current word and then we want the current letter the letter index. And now if we have some variables in our application to drive this we can always know the current word and the current letter. And now we can derive or do some other logic from that. Is this word done? Is this at the word start? Is this at the word end? And now we can say hey if this is correct then we're going to update the class or whatever on that letter element. And yeah, once you start breaking things down, it's really not that scary. But instead of doing the mistake and jumping straight into code where you're like an artist looking at a blank canvas, just try thinking about it for a second. Try to diagram it, draw it out, use a pen and piece of paper, whatever. You can talk to someone else and when you see the data structure behind the problem, it's going to be a lot easier implementing the solution, whatever you do, be this a game or whatever application you're building. Let's tackle solving the words and letters logic. Before I do that, let's talk about game state. What most people do is they define some booleans, right? And you have for example game started, game over, and this is great. But this can get you into trouble because game started and game over can be true both at the same time and you can run into impossible states. And if I learned anything about learning about state machines, using explicit state is really awesome and you don't have to be a genius or know or use state machines to use it. So what do I mean by that? Instead of using Booleans you can just use a string or explicit state You can say letGame and then you can use other states So you can be waiting for input game in progress or game over This means that your game or app can just be in one state and it's impossible to get into an impossible state. This is what I'm going to do for this game. So let me just close the calendar and let's get back to coding, right? So let me just open page.swell and here we can start. So let me just define script tag and I'm going to define a type game. If you're not using TypeScript, just ignore it. You can say waiting for input in progress and game over. So you get great auto-completion. Then let's just define the type word, which is going to be a string. And now we can say let game. Let's give it our type and now we get great auto-completion. So if I already press here, I already know whatever I can type. And this is maybe more risky if you're just using JavaScript because you really won't get auto-completion here. So you can type something invalid, but there's a solution for that too. You can just create an object like const states or whatever, and you can just place it in, and then instead of using a string you can just say states dot whatever. And then let's keep the track of the element we're going to bind, so we can say typed letter, we're going to start with an empty one, and then just bring this back, we can say words, which is going to be word and array. And let's just use a placeholder for now. Remember, start simple. The quick brown fox jumps over the lazy dog. And we can say split, so we can turn it into an array, so we can split it by a space. And that's really it. It's really nothing complicated. So remember how I told about piloting the game? Now we need those values so we can pilot it, right? And I'm going to say let word index. So by default, we're going to select the first word, the first letter and we're going to keep track of the correct letters. So let's say let letter index. We can say zero, correct letters, zero again. Now we need some reference to elements and I've done this a couple of times before but I found the easiest way just get to reference to the element and then we can use some html methods and etc to get the current word or current letter. So we're going to need one for the words element itself. That's our container. Again this is TypeScript html div element. Then we want a reference to the element itself, so we're going to set this element, so we always going to know what the current letter is and we can use it And then we need the input element mostly because I going to use focus so we need a reference to the element so we can say HTML input element And I going to define two empty functions that we going to use in a second so I going to say function update game state, which is going to be empty, and function handle key down. And this is basically where the entry point of our application happens. We're going to listen for a key, and then we're going to start the game. So this is of type keyboard event and let's add HTML. So here we can say game. And this is another tip. Instead of later having to do something like style and then you can do some logic here to apply classes for whatever etc. Or using the svelte methods like class or whatever. And you might not have some of this logic available so what I prefer to do is use data attributes for styling. So we can say for example data game and then we can set it to our state and now in our CSS we can say hey this element data game attribute is currently for example game in progress then apply the style for this element in this way and that's really an awesome way to style your elements. Now let's create the input which is going to be type text and I'm also going to give it a class input and let me just get this over like here so we can bind this to the input element which we just created. We want to bind the value itself to the type letter so we're always going to take the currently typed letter and compare it if it matches the current letter and we're going to clear it always after so it's always just one letter so the user is going to type for example a in the input is going to compare it then it's going to do the logic and then it's going to erase it right and that's the game loop basically and then we're going to need on input so this is going to do the validation so we can say update game state and we need on key down to listen for key events so backspace space and etc so you can say handle key down another thing you can do instead of using on input you can use a reactive declaration in svelte so you can say for example if the input changes, so it's type letter, you can say update game state, and whenever the type letter updates, this function is going to be run, but for some reason I prefer to use onInput in this case, but just so you know. Let's just remove this, and then we're going to loop over these words, so remember,

 In our example how the typing game worked, we can just go here, just create some space, move it up, and then we can create a div words, and we're going to bind it. Bind this so we get a reference to the element. Yeah, now let's loop over the words so I can say each, and now we can get the words, his word, right? So we're going to loop over each word as word, and then we're going to add a class, which going to be a span so we get it on the same line it's going to be the class word and now inside the word word up we're going to say each word as letter and that's basically it you really don't need anything fancy and then let's create a span again you can also say span letter and this is going to give you a much better result right span class letter and then we're just going to output the letter and that's it. Letter and before I save it let's just go here and now our line should be output here and again starting just basic right let me just zoom in if you have trouble seeing this I think this is fine right. So for example if I now inspect this we basically recreated the basic typing game. So if you see here here is words and then you have one word and then these are the letters T-H-E and if I collapse this you can see all of the letters are like this and this is how you start step by step. Just do the minimum requirement. Even if you're struggling until this point, just do the first thing. Hey, how do I make the logic so the game started? How do I detect that the user is typing something in, right? And let's try this. So if we go here and then we can type here and we're missing that logic. So as you can see here is our state. So data game is waiting for input and now we can style things based on that when it changes and etc. So this is really awesome. So let's also add the code for the handling of the keys. So we can say handle key down. And then we can say if event code. And this is more human readable to me. So we can say space. And then we want to event prevent default because I didn't save this yet, right? So because I can just use a space here, but we really don't want to let the user use space because we're going to use space later to go to the next word. So we can just say prevent default. And now let me just save it. So if I go here I can type but I can't press paste because it prevents the default behavior. So that's really awesome. And now since you using explicit state this is really simple So you can say if game equals again awesome auto waiting for input we can start the game And that it So now we just need to add the logic to start the game right And start game should update the game state. And I'm going to create a set game state also to set it just because it's nicer to use. And this is what being a developer is, creating free line from one line. Awesome. Get paid. So just above, I'm going to create a function, start game. and then we're going to set game state, which we're going to create. We're going to say in progress, and you can also just use a variable, but this is nicer to use in my opinion, so I can say function set game state. We're going to accept the game, which is going to be the game type, and we can just say game equal state, and that's it. So now if I even remove this set game state, I'm going to get awesome autocoppilation, so you can say in progress, and now if I go here to the game, Remember how we have our data attribute here. So now once we start typing something, it's going to change into in progress. Each time the player inputs a letter, it's going to run update game state that should set a reference to the letter element. So we need to know the current letter in the DOM. Check if the type letter is correct, and then we're going to go to the next letter and clear the input because we only want to compare the current letter. So this is how it's going to look like. So in update game state, we're going to include some methods. So we're going to have set letter, which we're going to invoke but we also need to create it then we're going to need check letter then we're going to need next letter and then reset letter let me just comment this out and let's go and set the letter so here's the code for that and the one thing we need to check if the current word is done by checking if the letter index is higher than the length of the word and of course this might seem like I know this in advance and of course because I've done it But the point is that you wouldn't know this in advance, right? You would just make this then player game or whatever, test things out. Then you'd be like, oh, this is happening. How do I solve it? And then you just go back and implement this logic, right? So that's really also important to stress out in this type of cooking show. Yeah, so let's just define the function. We can say function set letter. And then let's say is word completed. We're going to take the letter index. is it higher than the current word, which we get by saying words worth index, and we get the letter. And here is one annoying thing or I mean it not really annoying but it annoys me So for example if you have an array one two three and the way you would usually count an array or when you working with arrays in JavaScript it's like zero one two right but if you get length here it's going to return all the values which makes more sense right this is more friendly and because of that since we're starting from the zero index we have to say negative one or minus one so you don't run into an issue and go out of bounds. But yeah, just a small pet peeve of mine. Let me just close this. And now if we go to the next line, I can say if the word is not completed, then we can say the current letter element is going to be words element. Now we're reaching for the DOM itself. And it's really useful because it has a children method. And we can say word index. We can get the current word. and then we can go deeper. We can say, hey, give me the next Glearn. So those are the letters. You can say letter index. And that's it if you're using JavaScript. But for TypeScript, we have to cast it as HTML span element. So it knows what it returns. And that's really awesome. And let me also show you that. So for example, when you go here, let me just select this. Let me just say current. And let me just console log. Go here. For the console, let's just start typing something. and use dear. Let's look at this in Chrome. It's dear. And then you can say the letter. So now if you go here, let me just search for children. You can see here are the children. And if you go here, here are the letters. So if you go even further here, you can see this is T. Yeah, here it is. So basically that's how we do it. And let me just clear it out. We can close it and we can clear this. And we can just continue. And let me just remove this. So again, this is the reason why I wanted to reference the words element previously. Using the children method it's easy to either get the word element or the letter element. And I'm going to compare the typed letter to the current letter and you can get the letter from the words array or words element using inner text on the letter element. And I'm going to show you how I do it here. And instead of setting a class like monkeyType, again, I prefer using data attributes because it's really cool. You don't really have to worry about overriding classes even though that wouldn't be hard because you have that API class list add, right? So it's not going to screw it over, but it's way nicer in my opinion. So the type letter equals to the current letter, I'm going to increase the score and set the data attribute data letter correct or incorrect on the span element for styling And I also show you here how we can do it using a class You can say class list add correct And now let uncomment this one and then let just add it So you can say function check letter. And let me just go here. We need to get the current letter. So we can get the current letter by saying word index. Again, letter index. And we're not getting this from the DOM, but from our application, right? Because the words that we split previously. And I like to name things like this, so it's really obvious what we're doing. So this makes a lot of sense when you're reading. So if the type letter, what currently the user has typed, if it's equal to the current letter, so if A equals A, for example, then we can say the letter element, which we have a reference to because we set it, we can say dataset letter. You can say that it's correct. and then we're going to say increase score, which we're going to add in a second. And then I also prefer to be explicit. Also another pit people I really hate if else because it's really a mess to read. So I prefer to write it like this. It's super clear when you're reading code what it's doing. So if it's not, current letter, just make it more readable. Then we can do the opposite. We can say letter element, data set, letter, incorrect and we're not going to do anything and let me just close this and then we can say function increase core again we're getting paid for that three liner that could have been a one liner 10x developers easy game yeah now we can say plus one let me just comment this and now we We can see if this works if we go here. Let me just inspect this element. And now when we start typing, I'm going to type the lower case i, so this should be incorrect. And it's incorrect, then I'm going to further type d, but it's not going to work because we need to go to the next letter in the post. So if I go here, we need to set the next letter and we're going to reset the input. So again, here is our game state. next letter and if I go here let's see increase score we can just say function next letter again that brilliant Freeliner plus equals one and then we just want to remove the letter or clear the input reset letter

 type letter, and this is going to clear the input. So let me save that, and now let's inspect this for good measure. Also, let me try to, yeah, so we get a clear view. Let me again type it incorrectly, so I'm going to lowercase t, incorrect, and now we should be on h, and this is correct, e, and awesome. We solved the first part. Now we need to solve how we can jump to the next word. But before we do that, let's just style the words element itself. The simplest solution I found to having a specific number of lines, for words, if you remember, in monkey type, you can have three lines at a time, and then it scrolls up when you pass the middle one. And I found out the simplest way to do that is multiplying the line height with the number of lines you want. And you can do some fancy math and JavaScript, etc. You can create sentences based on the width of the element, and then you can say, hey, what is the current sentence? And then if the current sentence is above the middle one, then you can scroll up. But this approach is way simpler, trust me. So let's go here and let's add some styles. So we can go to the bottom and I can say style. Remember, you have to say that it's Sass. So we can just say words and then we can declare a CSS variable. So you can say 1 amp, so it scales properly. And then I'm going to say lines free. And now we can give it styles. We can say width 100. So this is where CSS variables are. We can say calc. So you can say var, the line height, and we need to multiply by lines. And it's going to have the correct measurement because you're using m's. But if you don't have an m and want to have a specific unit, you can just multiply by one m. And then you're going to get that unit. But in this case, I just need some extra padding because I found that this works great, this number 1.42. And yeah, we can just go to the next line. So I'm going to say display flex. and I also want to wrap the words so you can say wrap. I found out that 0.6 works great. We want it to be position relative because we're going to use the caret later and it's going to place it to the left. And then for the font size, I want 1.5 ram. For the line hide, we can again use the variable and then we want to hide the overflow. So let me just keep this for now and go here. and if I save it everything should work properly Let me just zoom out remember I zoomed in before And now we can try this out If you go to the top just go here and copy the sentence a couple of times So you can say one. Yeah, just go here. Let's save it. And because we don't have overflow, you can see it's like this. If I go here, line height, flow hidden. And as I told you, problem solving one by one. and this works no matter how much you scale the window and etc. And then we also don't want the user to be able to select the text so something that can happen on accident. We can say user select none and then let's style the letters. So here's where we're going to see the data attributes come into play which is really awesome. So we have nesting. Then we can say the default for the letter. We want it to be opacity 0.4 transition 0.3 seconds ease and now here's the interesting part so we have to say, if I can type ampersand yeah, so we can do it like this, so we can say ampersand and then we can say data letter, but since Svelte doesn't know about these classes, it's going to remove them from the final bundle because it purges CSS classes for you that are unused, so we have to say hey, this is global or it exists so Svelte is going to include this class so we have to say global and then we can say data letter if it's correct then we're going to just increase the opacity to 0.8 and then for the other one you can also say global data letter in case it's incorrect you can say color var primary which is going to be tomato and then we can just say opacity and then let's just save it everything is going to Formware because I'm using Prettier. And now when we go to the game, let me just type the T wrong. Oh, now it's an error. And you can see here it is. Game is in progress. So you can also type cage, correct? And now it's going to increase the opacity. And we can see this works great, which is awesome. And let's go to the post. And I mentioned here that I love the subtle but beautiful transition for the color and opacity, which you can tweak to your liking. And this is That's really the beauty of CSS and data attributes. Let's work on going to the next word. To do this, we need to increment the word index and reset the letter index. For example if the word index is zero we can just say plus one so it goes to the next word and then we say the first letter so letter index is going to zero And this also comes towards the words per minute score so we going to score the player for pressing spacebar And you can abuse this, I think, but letter, I also have assignments for you, and this is one of those things that you can try fixing yourself if you want. But in this case, the player could skip words on accident, so I want to make sure it doesn't happen on the first letter at least, and also take into consideration if it's a one-letter word. For example, I, because it's going to skip the word. And also remember I have the unfair advantage of doing this before, so I know the issues I run into. And remember, this is the cooking show. And thanks to using explicit state, I can make sure this only happens when the game is in progress. So in our game logic, if I go here, let me just see next letter, reset letter. I guess I can put it here. Let me just put it in the middle here. So you can say function, next word. And then we can give it some conditions. Again, I prefer readability over everything. so you can say const is not first letter so you can say letter index is not zero and const is one letter word we can say words word index length if that is equal to one and now we can use a conditional if is not first letter or is one letter word we can say word index plus equals one and then we can say letter index is going to be one and we're going to increase the score. Awesome. And now, as I said in the post, you have to go to handle key down, which is here. Yeah, it's here. And when the user presses space, we want to do that, but only if the game is in progress, right? And thanks to using explicit state, this is really simple. So you can say game in progress. Next word. And that's basically it. So let's give it a try. And also it helps if you type it correctly, because I forget the round boy here. And let's go here. So let's just see. So let me type he. And now we should go to quick. So nothing should happen if I type the letter. But if I press space, we're going to go to the next word. Quick brown fox jumps over the lazy dog. And again, and you can continue typing. So awesome. This wasn't that bad, right? We got here step by step. Let's talk about how we can update the line. As you type and pass the middle line, the old line should go up. The simplest way I found to do that is to take the y position of the words container and check if the current word y position is greater To get the measurements I using getBoundingClientTrack which gives you the size and position of an element relative to the viewport and is useful for many things A picture is worth a thousand words so I want to explain it like this. So here is using the getBoundingClientTrack, this is your browser viewport so you can use getBoundingClientTrack and this is our words container so we can get bottom right the x and the y so we're going to get the y from the top right for the container itself and then for the word if it passes a certain threshold we can say hey scroll into view and that's basically the simplest way i could find to do it it works most of the time but yeah let's see how we can implement it it's really nothing bad and this is something really useful to have in your tool belt and I absolutely love the get bounding client tracked API and it's even a great achievement for someone mathematically challenged as I am. So we're going to get a reference to the current word element and the y position for the words as I mentioned before and then we can compare it. So here where we have update game state now we have update line so we can place it here. Let's just place it here. We can say update line and we can just add the function. So let's go before we reset the letter. Let's just go here. We can say function update line. So now we first need to get the word element from the DOM. So we can say const word element. So we have the reference here. We can say children, remember? And then we can say, hey, what word? We have the word index, right? and then we want the words y, so the container. So you can say words element. Remember, not word element, but words element, the container itself. You can say get bounding client rect, and now we can get all these properties from it. So you can say y, and now we can say word y, and now we're going to use this one that we got a reference here. So you can say word element, get bounding client rect. We're going to get the y of that too. And then let me just, before I do this, let me just console log it out. So let me do it like this. We can say words y, word y. Let me just save it and I can close this college room. And now we just open the console and I was going to focus the input. And let me just type gibberish so you can see the word y. So now we pass the first line so you can see

 is the same. And now we're going to go to the next one. It's a bit different, but we're going to say, hey, next time check it. If we go to the third line, and then it's going to change. So now it's 252. And this is really a good way to move to the next line. I'm also going to show you another neat trick. So if I go here, let me just make space. I can say, remember, word Y, if it's greater than words Y, we can use a cool API. We can say for the current element that matches this criteria, we can use scroll into view, which is really awesome. So let me just do this and let me save it. And again, I'm just going to type gibberish until we get to the line. And you can see it's starting to change. And I'm just going to do another thing because I wanted to scroll the center, which is really awesome because we don't really have to do any math because this would be a lot harder. So you can say block and then you can say center. So let's save this and you can check out this API yourself if you want in the MDN. And now I can go here. Let me just clear everything and I'm going to again type gibberish. I just want to skip words. So I'm typing a word, skipping it. And let me just see these. So we can say quick brown fox. And now when we go to the next one it should jump lazy dog and let me just jump over a couple more words and then when we go to the next one it should also transition so that's really the simplest way I could find out how to do it and it works most of the time it's time to add the carrot and I know what you're thinking but it's not a carrot you silly bunny carrot is another word for cursor but to be honest they almost sound the same or maybe it's a carrot I'm going to add the carrot element inside words and absolutely position it with a neat blinking cursor animation, which is really cool, and I'm going to show you how that works. And moving the caret is going to be simple as updating the top and left position of the element. So you can say style.left, etc. I already have the reference to the letter from letter element, and it has some useful properties, such as offset top and offset left and offset width, among others you can use to move the caret. And let me show you how that looks like. So for example, here is going to be the offset top. So whenever we change the line, the offset top is going to change and then we're going to transition the caret to the next line. And to transition it to the next letter we can use offset left plus offset width. This is why it really useful to look at MDN and read the documentation to learn about all of these properties So for example if I take this line here let say this is a caret by default it going to be absolutely positioned to the left And then when we transition to the next word we can say offset left which is going to be right here, right? But we can also plus offset width, and then it's going to go to the next word, and then to the next word, and then when we type the last one, and then that's it, basically. It might sound complicated, but it's really not. And let's look at the implementation, right? So let me just close Excalibur. And then we can just go to our application. And for update game state, let's just find that. As the last one, we're going to say, hey, move caret. And we also need to do it for the next word. So if we go to the next word, when we increase the score, we also want to move the caret. And then we can include move caret, which is two lines of code, basically. Yeah, so let's do it after we reset the letter, I guess. Yeah, so we can go here. Let's say function move caret. So the first value is just an offset I'm going to show you in a second why I've done this. So we can say caret element, and we have a reference to it, right? I think, right? Let's say caret element. Oh, I guess not. So I guess we need to include it. I guess, did I do it here? Oh yeah, I did it right here at the top. Yeah. So let me just go here. And here are our elements. So we can just include it. We can say let caret element is going to be a HTML div element. And then we'll just go back since we now have a reference to it. And we also need to add the element itself, right? So let me just say, let me go here, caret. We can say style top. And we can get that. Let's use a string literal. Get it by saying letter element. offset top, right? And we need to include the pixel value. So let's just say caret element style left. Again, let's interpolate it. You can say letter element offset left plus letter element offset with. And that's basically going to be, don't forget the pixel value. Also, if you want, I guess you can destructure it. So you can just go here, say const, and you can say offset left offset top offset width from caret element And then you can just go here and start removing these values So I guess it's more readable if you want it that way. So let's save this. And remember, we have to add the elements. So we're going to jump to our words. Let me see words. And after the each, or before we end the div, we can just say caret. We can add it. And then we'll just say bind this. caret element. And we're also going to need some styles. And we're going to add it here. And now we have words. We have the previous styles and we have a letter. And after the letter, here we can just include another one. So we can say caret. We're going to position it absolutely. We're going to give it almost the same height as the line height, but it's not the same. So we really can't use the same value. We can say border right one pixel primary so we're going to give it a tomato and we're going to use the animation caret one second infinite so it just smoothly blinks. And then for all the other transitions, this is our left top CSS properties, we can say two second ease and then let's just define the keyframe. And you can define it at the end but since we're using it in one place and in specific to the caret I'm going to include it here as nested. So this is really cool. So we can define a keyframe. We can say at 0, right? We can say opacity is going to be 0. And at 50% is going to be opacity 1. So instead of going from 0 to 100 being 0 and 1, so it would just blink rapidly. but really want to go from opacity 0 to 1 at half point and then we want to again go to 0 and then it's going to create a more pleasing effect so to do that after 0 let me just save this and see if it works yes it shows here and you can see it looks weird so we can just say as I have it in the post we can just say 2 so this is going to say hey after this go again to 0 and it's going to just repeat because it's infinite and let me say when you should get a smooth caret animation. I did a silly mistake because of course here where I was trying to be smart and use the structuring here we have to reference the letter element instead of the caret element So you can just say letter element and now this should be correct And if I save this and go back I'm going to say the great brown fox jumps over the lazy dog and whatever. As you can see let me just restart this. Pay attention to the cursor so it starts bigger and then it shifts slightly right This is because of the offset from the top. Just found this out by playing with the value. So I just have it in the post. I'm just going to define an offset. So I can say const offset. I'm going to say 4. And then offset top. I'm just going to say plus offset. And now when we start the game, let me just zoom in. So if I go here, you can just see its move. Say fox jumps over the lazy dog. And that's basically it. So enjoy your blinking carrot. To uphold a healthy keyboard environment, I'm going to make a game last 30 seconds, which is also reflected in the words per minute equation. So it really doesn't matter if it's 10, 20, or 30 seconds, the equation is going to take that into account. So you don't have to smash the keyboard for entire 60 seconds, which is awesome for me. Remember the start game function way back. I'll meet you there. So let's go to the start game function. So I can start typing start game, which is really awesome. And inside of here, you want to start the timer. So we can say setGameTimer and then below it we can just say, actually let me just go here, setGameTimer. And then to make things more readable, first I'm going to do it like this, let's say interval, we're going to use setInterval. We're going to pass it a function which we're going to create and we're going to invoke it every second. So we can go see function game timer and let's have some conditionals let's be really explicit if seconds are higher than zero so if it's not over we can say seconds minus one which we also need to include here because yeah here it is so we can go up and let me just see yeah i'm going to include it here here we can say let seconds 30. And let's go back where we were. So defining the game timer. I can go here and let's be again explicit. So if the second is higher than zero, let me just make more space here. It's more readable. And then if game is equal to waiting for input or the

 the seconds are going to be zero. And this is the case we want to restart the game. So the timer hasn't reached zero. And you're going to learn this the hard way like I did because when you restart the game, your timer is just going to go quicker and quicker because it's like stacking on top of each other and it gets crazy. So in that case, if the game is waiting for input, then you can say clear interval and we can clear the interval. And in case the game is actually really over, so if seconds is equal to zero, we need to update the states and we want to get the results. So we can say setGameStateGameOver. And we haven't created it yet, but let's just say getResults. And then we can just comment it out. So we can just save this. And we also need some styles. So now we just need to add the timer itself and some styles. So if I go here, let me just see where we have our game. So we can search class equals game once it starts getting out of hand like this. So where we have our input, Let me just close this. You can just add it here. So I named it Time, not Timer. And then here we can say seconds. So this should be visible by now. Awesome. But what we want to do, we want to hide it by default and then we want to show it when the game starts. And in our styles, let's see, inside game, so we haven't even added it yet. I'm going to absolutely position the time element. So for the game we're going to need position relative and then for the time element I want to position it absolutely and then these are just numbers I found to work great. For the font size I want 1.5 rem. For the color I want to use that juicy tomato so let's do that. is default going to be 0, and again we're going to have a transition, I'm going to say all 0.3 second ease, and again here is where data attributes are so awesome, because now, remember this isn't on time, but on the game itself, so we have to say, and now we don't have to use global, because Svelte knows about the styles, because let me just scroll up, data game, and Svelte reads it, and it's like, okay, oh, this is all the possible values that it can be, so it's not going to give a warning, and it's going to include the styles, So you can use ampersand you can say data game in case it in progress And then what do we want to style time right so you can say time just bring it back to life and now we can save this and everything should work if i go here you can see there is no timer here and let me just focus the input and now we can start typing and we can see the timer and now if it runs out we just have to trust it's going to be game over when the game timer runs out the game state is updated and get results is involved i'm going to define our words per minute and accuracy variables using a tweenswell store to interpolate the numbers for a nice animation. I'm going to show you what it means in a second. To get to words per minute, I use an equation that considers five letters as a word because longer words should have a higher value and then it gets divided by 0.5 minutes since the game timer is 30 seconds. So it doesn't really matter how long you type because it's going to take the game timer into account. And the The accuracy equation is simple as taking the amount of correct letters and dividing by the total letters to get the percentage. And here in the code I even have a link to where I got the equation from if you want to look at that. So let's implement some code. So we can import the tween store from Svelte. Import tween from Svelte. Motion. And now I'm going to add the values, words per minute and accuracy. So let me just find a cozy spot for that. This looks great. We can say words per minute. And again, there's nothing wrong if you just do it like this. Accuracy 0. But what I want to do is if you have 80 word per minutes, I want to animate the 0 going from 0 to 80. TweenStore is really awesome for this. And if you want to learn more about animation, you can watch my animation with Svelte video where I cover everything I know about animations in Svelte. So we can say tween, we can say 0. And then I want a delay and a duration. And then again, we're going to say tween for accuracy, zero. And I want it to happen after the words per minute animation. So we can say delay, 300 milliseconds higher, and then one second. And that's basically it. Nothing complicated. And now let's implement the logic. So we can do it right here. So we can say function get words per minute. My biggest annoyance when I see code where it uses magic numbers that I have no idea what it means so I really love being explicit about these values So you can say hey five letters is a word and minutes is going to be 0 and then we just return math And we want to round the number and we can say correct letters divided by word. And I can put parentheses, but really you don't have to and Prettier is going to change it anyhow. So I can do this by minutes, but if I press save, you see it's going to be gone. But yeah. So this is how we get words per minute and it works great from my testing. So we can say function getResults and now we need getAccuracy first so maybe we should include it here. It really doesn't matter. We can say getAccuracy. Again, we want total letters and this is another function we're going to need. So let me just say getTotalLetters. We're going to pass in the words, which is our variable here. We're going to need this in a second, and then let's just return again mathLore. We're going to say correctLetters divided by the total letters, and then we need to multiply it by 100 to get the percent. Just comment this out, save it, and it formats it correctly. let's just say get total letters and this is just using a simple reducer so you can say function get total letters is going to accept the total words which is remember the type word but the race so we put the square boys here and then we're just going to return words reduce and basically the short version of what a reducer is is going to iterate over each value but basically a reducer is like map filter and those other high order array methods combined. So we can just go over each word and then we're going to increase the count by the word length. So basically here is the callback and then we can just have our logic whatever and then we can say starting value is zero. So this is basically the previous value. So prev and or we can call it I guess the accumulator and then is the current value. But in our case we can name it whatever you want. So I want this to be the count and we're going to go over the word and how we're going to get the count of all the letters We just going to increase the count by every word length and this is going to give us the total letters So the reducer is really awesome And I rarely get to use it because it always feels like over But in this case, it's even the most simplest solution and the easiest to understand. So we can go back here. And here's where we can get the total words or the total letters, which I should update. And I also need to get the results. So remember where we define it. Let me see. Get results. So now we just need to update the values. And if you're not familiar with swell that much, we have to use a store. And we do it by using the dollar sign per minute. So we can say get words per minute. And we can also get the accuracy. And this is going to get called. So don't forget about this one because our code isn't going to work. So let me just find it in the code. It should be where our timer is, right? So get results is called somewhere here. even commented it before, right? I think I have to go up. Let me just see. No, no, it's definitely here. Let me find you. Where is the timer? Yeah, here it is. So when the timer reaches zero, we update the state game over, and then we say, hey, get the results. And then we can save this. And then back here in the post, we have to use state to show what we want to the player. So again, explicit state usually also. Now we can just say if game isn't game over, then we can show our words and etc. And then we can also add results if the game is over. And this is why explicit state is so awesome, because you don't have to juggle some booleans and get into impossible states. Yeah, so let's get to the markup, and let me just find it. So here it is class game, right? And then you can just open the curly boys. You can say if game, not equal to everything else that is game over. And let's just find where it ends. So it's right here. Then we need to close the if. and all is good. And now we can just add the results section. So if I go here and say if, and if the game is game over, then we can say results. I'm going to have a div that's going to have, let's say P title. So words per minute. And then we're going to have P score. and we're going to use math truncate so we can round the number else it's going to look funky so you can say words per minute

 And now let me just copy over this part. Let me go here. So this is going to be accuracy, and the score is going to be accuracy instead, right? And then we need to add some styles. So this is going to be completely new. So not in game, not in words. Just go here. If you see here, this is like type to words. So we can just create a new style. we can say results, title, font size 2rem, color war, foreground 200, we can say score, font size 4rem, and I just yoink these tiles from MonkeyType. Yoink, my styles now, primary. Let's also play top one ram. And also, let me just save this. And I'm going to go to the top. And let me just set this to 10 seconds. So I can go here. And let's see. Quick brown fox jumps over. See dog. The quick brown fox. Look at the awesome animation, and this is all thanks to the tween store. And we also need to add the percent sign, let me just check. Where is it? Accuracy, here it is, so don't forget to add the percent here. And if I do it again, not here, here. Let me just wait for the timer to run out. And everything should look great. Wow, what a great score. Our game is looking great, but let's create our own words API. This might be complicated, but it's really straightforward using SvelteKit. Because SvelteKit blends the line between frontend and backend, so I guess you're a fullstack developer now? Congrats! going to take a JSON file of 1000 common English words I yoinked and create a standalone endpoint in SwellKit to get randomized words based on a limit. So you can go to this link and you can copy over this file, you can press raw and ctrl-a, ctrl-c and you can copy over the words. And now let open the sidebar so we going to add the JSON file first So inside routes press New File So I going to say API and this isn convention You can name this banana or whatever you want I just wanted to make clear to myself and others that this is something I can consume inside my app or even expose it to the outside world. But you need to set up course and other things. So you can say API WordsWrite. and then we can say English and then inside English we can say English JSON. It's going to create an API folder, words, English, English JSON. Let's just copy over the words and this is PG so nothing racy here. So we can close this file and let's collapse this folder and inside words we're going to create the endpoint so we can say plus server TS actually. So this is going to create a standalone endpoint you can return whatever you want from here. So if you're familiar with something like Express this is basically the equivalent to that where you can create your endpoint simply. So we can collapse the sidebar and now I'm going to import the JSON helper. So you don't have to set the headers yourself for a JSON response. Say cell.js kit. I'm going to import the type quest handler from types. And then let's import English from English. And then we can just specify our handler. So this is going to be a get request. We're going to watch for the URL. Remember, we want to pass in a limit so we can get it by using search params, and then you can just slice it using the limit and then randomize it. You can use a better randomizer than this, but this is quick and easy. So you can say export const get, you just use the type, request handler, like this, and again, also auto-completion, if I type here to destructure the props, just say URL, and then let's define the limit. We can say limit its URL search params get, and the name of it is going to be limit from our URL, right? And then we need to turn it into a number, because it should be a number, so you can just cast it like this. And then let get the words so we can say English words because that the key Slice from 0 to the limit so 0 is what we going to use and then we want to sort it and the sort is simple as 0 negative math random and that basically it and now we say return json words and let me just save it and now for example if we go here let me just go to the api words and now we can say if we don't pass it anything it's going to return empty but you can return a default if you want and now if you say limit is 100 it should return 100 words and it does which is awesome so now if i go back to the post let's use this in our game and i truly do love the simplicity of swell kit it blurs the line between front and back and it just wrote back and code and created an endpoint so i guess you're a full stack developer now congrats let's Let's use our new power and replace the placeholder text. You need to do it when the page loads though inside on mount if you want to fetch something. But I also mention here is that if you're unfamiliar, you could also pass the data directly to the page in SwellKit from the server by creating a plus page TS endpoint for the page itself and receive it from export led data. But this is what I chose to do here. So let me close this and I can start typing page and this is the only page in our application. So here we just need to remove our placeholder and just give it a default of array as I have it here. So we're just going to reset that. We're going to need onMount from Svelte. So we can go here. Import onMount from Svelte. And now we're just going to go to the bottom where you might have some helpers. You might move this to a separate file or whatever you want. let me go here, and right above this we can say async function get words. Remember we want to pass it a limit, and now for the response we can await it, and since this is the endpoint inside AustraliaKit app you don't really give it the full url, you just give it the endpoint api words, and let's turn this into a template literal api words. Remember this is our api, and I just want to say for the limit to be whatever limit we passed in and that's how simple that is. So we can set the words, we can say await response.json. So when the page loads, we're going to get 100 words and then this is going to set the words where we used the placeholder before So now we just need to use it and we do that by I guess I can do it right here This is the first thing that going to happen anyhow We can say on mount async I guess we don't really need to do that. Just remove this because we're just doing it inside another function and we just want to pass it the limit. You can say 200, 100 and let me just go and close this. And I'm going to save this and let's just go here and now it should work. So if we go here, awesome, it fetched all of our words. And you can give it more or less, for example, if you want 10 words. Up to you, right? So this is really awesome how we made a simple API. I want to give the player a way to reset the game if they don't like the words or want to play again. I'm also going to include a toggle reset so we can use a key block in a second to play a transition when it happens. So I'm going to use the blur transition from Svelte and we're going to blur the text when we restart the game or if we go to the end game screen to our results. So let's first start by importing blur. So we can go here and let's just say import blur from Svelte transition. And now here after all this we can just say or let me just go here let toggle reset going to be false. And let's just define the function here for resetting the game state because why not. So So we can say reset game. And now we can say total reset. We're just going to flip it like a light switch. And then we can say set game state waiting for input. And remember in our timer, we're also listening for this. So we're going to clear the timer if a reset happens. And then we again want to populate the word. So we can say 100. Now we need to reset the seconds to 30. the typed letter to nothing. Let's just do this. And the word index, again, the zero. The letter index should be, again, zero. We just need to reset the correct letters. And we're going to reset our twin stores. So you can say words per minute zero. And we're going to say accuracy is zero. And of course you also might want to consider doing

 doing all of this on the server side, which you could easily do in Svelte because anyone can mess with these values in the client, so maybe you have some leaderboards and etc. This would be something that people could easily cheat in, but if you have these values on the server then no one can mess with it. So maybe that's a fun to do for you later if you want. So now we're going to find the markup where we have our game. It's already starting to get long, so we can go here. where I have the words element bind, we can create a keyed block. Just see, we have to type it. Let me just say key. So you can say toggle reset. And then I can go here. And we just see key. Oh, but it's right here. We can just move this up. Now it should be happy. And now we're going to say when it transitions in or the component gets mounted, it's going to be in blur. Then we're going to use a local property. We're going to say local. Because we only want this to happen for this component. Otherwise, this would get blurred when our component above gets added or removed. So we can save this. And let me just see something. So this is our entire blur. So now let's add the reset button. So we're going to need it here. And I'm just going to say reset. And I got this SVG from Heroicons. But you can just copy it from the post. and let me just create a button first. We're not going to have any text inside, so I just want to use an area label. Reset and on click. I want to reset the game and here we're just going to copy the SVG. You don't even have to use an SVG. If you don't want, then just use the text. So I can do it like here. Let me save it and now when I go here we can see it here and we need to add some styles So that what we going to do after we also add the blur to the game over so let see results i going to have in blur and it going to be simple as that and here in the styles let's see we have game and we have already time So we can go here, we can say reset with 100 display grid justify content center margin top is going to be 2rem. And that's basically going to be it. Let me see what it's complaining about. Oh, also I'm forgetful. Of course it's complaining about a new selector results and play when we have to add it right and I think I forgot about that so yeah when we need to go here and after this div we're just going to add a button going to have a class play play again on click recent game let's save it and let me just wait for the end screen So wait 3 seconds and everything should work. Also play again, so we press that, we get this and we can reset it again. And that's it. Alright friends, we're almost done. It's time for some finishing touches. I'm going to hide the input since you no longer need it and I want to focus the input when the page loads. So to do that let's go where we defined on mount which is a long way down at this point. So we can go here and I guess it would be appropriate to define it somewhere here. So we can say function focus input, making that one line of code into three. Beautiful. So we can do this and then after we get to words, we want to focus input. Yeah so we can see if we go to our page and I going to save it and it should auto autofocus Just see Awesome that works And that basically it So we can also hide the input because we no longer need it So if we go to our styles for the game, we can say dot input position absolute. We can say opacity zero. We're not going to see it, but it's going to be there. And that's how our game works. So let me just save it. And now if we're here in the browser, even if we just start page, now we should start playing the game. Let me just increase the timer to 30. And now we can just play the game if you want. And you can also press tab to focus it if you lose focus. And then you can just type your heart out if you want. And let's just see if everything works. We go to the next line. And it really looks awesome, right? And of course, I'm at a disadvantage here. Let's go. And also, now we get our score and everything works great. if you press play again and we can also reset it. And that's basically the game done. Hey, congratulations on making it so far. I encourage you to take what you learned and improve it because there's probably some bugs. I would be happy to see your improvements if you at me at joyofcode dev on twitter. And here are some ideas. Right now the input focus can be easily broken if you press a random key when the page loads, so make sure you keep track of the focus and notify the user to click on the area for focus, just like monkey type does. For example if this loads and if we press whatever randomly somewhere around this game won start because we lost the focus and now you need to press tab We only know it because we made the game right the user or the player doesn even know that there an input here and then we can start playing but make sure that this game can only start if it a letter and that you don't randomly lose focus so that would be really nice and then let's look at another one and then as i said you can start a game on accident by pressing any key but you could use regex to make sure the input is a letter so that's really not hard in itself here is a more challenging one see if you can add the logic to be able to go back to the previous letter. And you can do that by listening for the backspace key in the event listener. And then you just need to play around with the indexes going backwards, right? And see if you can figure out that logic. And let me just talk about some other ones. You can underline the skipped words the same way monkey type does it. So that's an interesting one. And here is the one that sounds like most fun to me because so far our code is very long, so we should make the code easier to manage by breaking it into components. Use Svelte component events to send events from child to parent. If you need it, I wrote a Svelte state management guide, or you can just read the tutorial to learn how that works. So for example, let's say that you have a game component, so you can have all your logic maybe in that file or in separate files. On the game component, you might have event listeners like on start, on stop, and etc. And this is really a great use case for component events. If you need more ideas, have a look at monkey type where you can get inspired like implementing a replay feature. What? That really sounds interesting to me. So I really don't know how would I do it. You would just have to log what the letters user type write in some data structure and then you could loop over it when the user requests the replay. And that's how I think you can make that work if you're interested. Hope you learned a lot because I surely have. And despite not having a lot of experience making games, I learned it can teach you a lot about problem solving and coding concepts in general. So thank you for watching and catch you in the next one.