 I'm going to have to click around occasionally on this, so I have to look into this little itty-bitty monitor to do that. So if you see that, that's what's going on. Hey, what's up? My name is Scott. I am talking about real world local first today. And when I say real world in this context, I don't just mean like writing local first code, but like the practical implementation of all things local first. Because as I'll get into in a second, local first means a whole lot more than what some people might know. And not all of that is super practical all of the time. So, real quick, I'm the co-host of the Syntax podcast. If you need a web development podcast in your life, check us out. We've also been doing a ton on YouTube lately, where we're playing coding games or releasing 12-hour-long tutorials, just a massive amount of stuff. I'm also an executive producer over at Century, where I get to work on Syntax full-time. And yeah, you can check us out at syntax.fm. I'm S-T-O-L-I-N-S-K-I on every bit of social out there. So these are not my slides, but this is a compendium of all of the links of stuff that I'm talking about today. So if I mention something and you think it's interesting, it will be on here. So you don't have to go through the slides to find it. Also, this QR code is made out of a bunch of little plus signs, which you know we love at SvelteKit, right? All right. I will have this QR code available at the end, too, just in case I say something and you want to check it out. So, really quick, because I did a talk on Local First, the last Svelte Summit. We've already heard Local First mention today. uh in 60 seconds i going to tell you the seven main concepts of like real true local first which is one oh man i clicked the wrong i clicked the one on my here we go hold on one sec It a counting down on mine All right Let go down here Hey there we go Okay No spinners. Stuff loads really super fast. Not that you don't have a spinner, but that you do not need one. Your work is not trapped on one device. You can pull it up on your phone, your computer, whatever, and it should load the same data. Three, the network is optional, as in not just the stuff works offline, but the stuff works in low network conditions the same way it would in real network conditions. Seamless collaboration, basically multiplayer. People can use the same stuff at the same time. The long now, which means that if the servers go down, the app still works. Like if you were to download this app, the servers disappear, the app still works. That's a crazy concept in 2025 with, you know, like a video game you bought last year, the servers might go down. Security and privacy by default. Already spoken about today, but super important, right? And then seven, you retain ultimate ownership and control of your data. You can take it with you if you want. You can download it. And, okay, I made this in like two seconds, so negative one. Well, so that last one's interesting because you don't often think about that as being part of local first, right? But it is. And sorry, I need a quick water break, a quick dance break. I battled this guy when he was eight years old, and he beat me. That's why he's a pro. All right. So local first-ish. And that's more or less what this talk is about when I say real world, because those seven ideals are incredible, but they're also like ideals. That's like the best way you could do it. But it's not practical for every application we're building. And I would say, you know, many of that stuff should be something you're aiming for when you build this. But not all of those are always really possible. So when I'm talking about local first-ish, what I mean is that these are the things that you might want on a wider range of applications. Things like local data for extreme performance. The data's in the client, you would not believe how fast this data loads. A great offline experience. And with a great offline experience one big thing is that you on the train It goes underground or something Your signal cuts out A lot of times what happens is you have like two situations You click a button, and it just does nothing. There's no feedback, or maybe it eventually submits, and then that feedback comes, you know, half a second later or even, like, way too long, right? Or they've implemented optimistic UI, which will give you that immediate feedback, and then potentially fail a minute later, right? And then have to undo itself. Because those aren't great. So like in a great offline experience for this stuff, like I want, if my network is down for a minute, I want to be able to keep clicking as many buttons. I want it to keep submitting and saving that stuff. And then when the network comes back, I just want it to reconcile. Reconcile offline, reconcile with my local device, reconcile with my tablet or my computer. and that's very possible. Real-time. We use a lot of real-time apps. Dotion, Figma, whatever. I don't have to list all of them, but real-time is one of those features with local-first software that is often sometimes you would really want out of this deal. Backup and sync to a remote database because you can have everything on your local device. It's really painless to save everything to IndexDB and then load it, right? But when I save it, I don't want to just save it on my machine. I want it to, in the background, sync to a database. The problem with that is you get into conflict resolution. If I hit something on my tablet and something on my phone, even if I'm the same user or different users, how do those things resolve? And you often hear of these as CRDTs, conflict-free replicated data type. But ultimately, we just want apps that feel native, right? We want apps that feel like your phone's app. And like when you take a picture with your camera, it doesn't automatically take a picture and send it to the cloud. It saves it on your device. And then when it can, it syncs it, right? You really want that type of experience. And that type of experience is really possible with web apps. And I think a lot of people it not that they don know that it not available to them but I think people are just fine with optimistic UI They fine just having that it works fast local host therefore it works fast when I in a low network condition One of the things that I do is I go and dance once a week and it has terrible network. And I had made this app for myself, and I used it all the time at my house, where I have a great network. And then I took it to the dance studio, and I was like, oh, oh, what the hell, this sucks. And I was instantly like, I have to redo this in a local first or at least a local data sort of flow because I knew that network was not going to happen. So what are your options really in this space? And I do want to say, if you go to localfirstsoftware.dev, the URL's in my link, and it was talked about earlier, but many of these things act like React is literally the only way that people make UIs, which is wild. So the options are you can implement everything yourself from the sync layer, the conflict resolution, the local database. I've done it, and it's not a ton of fun. There's different like really naive ways you can do that, that syncing or even the conflict resolution. The last thing that was saved is therefore the last thing that should be written, right? But when you get into software that maybe a lot of people are touching or there's a lot of data being thrown around. It gets less and less fun. There's also Electric SQL, which is a big player in this space. They've done a lot of really cool stuff. But I've got to say, I'm just straight up too dumb to use Electric SQL. I've read the blog post, the version one, the version two. I've read all of their stuff. And for some reason, it just is like, there's too much resistance there. And then you go to the framework section. This is not shade against Electric SQL. It's great tech. But you go to the framework section and it's like, what frameworks do we support? And it's Next.js, React, and TanStack. It's like, I'll just say React. If you support one framework and it's React, like, just say that. Because we all know React to framework. And there's InstantDB and Firebase, right? These are actually really great options if you don't want to have control over your data. Like instant DB is such a buttoned up experience, but if you wanted to export your data, you're writing that exporter yourself. You cannot take that data with you. And it's just not like an open platform that you have control over. And a lot of that, there's a ton of other options that are really just odd. Like one of them,

 I think it's Triplet, their authentication, I think it might be them, there's a whole bunch, Evolu or Triplet or one of these, their authentication system gives the user like a 20-digit passcode. They don't have a user account, they don't have a password, they have this 20-digit thing that you generate and you're expecting your grandma to be able to know how to save that in her phone. She'd write it down on a sticky note. But there is one platform that I think personally has really landed for me. And I've tried a lot of these. That's kind of my mission with all this stuff, is to give all of this a whirl. And Xero. I talked about Xero a little bit at the last Svelte Summit, specifically because it wasn't quite out yet. It's still early days, and it's still alpha. But it is very usable alpha. In fact, I ship production stuff with it, one of which of those things is currently down right now. So that doesn't hold up super well for me, but it was supposed to be in my talk, and I was like, ah, screw it. But why do I like zero? What's this about? I'll talk a little bit more about what zero is, but first and foremost, why do I like zero? It feels like working in any sort of TRPC or ORM just on the client. You're dealing with really simple queries, really simple mutations, that sort of stuff, and it doesn't feel complex. You don't have to get in the weeds with it. It gives you full control, so it's not actually adding any columns to my database in my data, and if I were to look at my data before adding zero and after adding zero, it looks the same. It just is a layer that sits in front of Postgres, so it doesn't affect my data in the ways that could be troublesome to me, right? It's open. You can view the source. There's a big community about it. It's not like a service that I'm signing up for to say that you will hold my data forever. It's fast as hell. It is crazy fast, and I will show you just how fast in one second. It is absurdly fast, and some of that has to do even with when they're mutating or when they're loading data. If they're sending data that's not on your local device, it's being sent through patch messages that are tiny. So you're not receiving massive amounts of data unless you need the whole bit or whatever you want, and then you can get into preloading and stuff It scales The team behind this also built Replicash and so they familiar with building systems that scale I don have that many users so I don need it to scale but I'm assured that it does. It's also reactive. So one of the coolest things is that if I were to make an update to my database even, like I go into, and I'll show you this in action, in my database, and I manually tap save my database in the UI, instantaneously updates. And that's pretty sweet. I actually, I'll talk about this in just a little bit, but I built like just a demo of an AI chat, and it's streaming, and as it's streaming in to the server, I'm just writing as little bits as I can to the database and updating it as I go, and you can see that it actually take place in the UI too. It looks like it's streaming directly into the UI, but it's actually streaming into the database, and then zero is handling that update. So I'm gonna see if I can bring my actual mouse in here. There we go. Okay, so this is their demo. This is built in React, but you could just as easily build this in Svelte using stuff I'll show you in a bit. But this data is loaded. there's a couple things about this data. It's loaded locally, and there is, not everything is being prefetched. When we get into this page, a lot of this is prefetching, right? But when we get into these, there is relational data in here that is not being prefetched out of the bunch, because there's just too much. So I'm gonna hold down my keyboard, and you can see just how fast it goes through between all of these records. This is loading these. This isn't like, these aren't all preloaded because they all have that. It's crazy. So like, yeah, even like the reactions and stuff like that, these are all coming in from the database. The reason it can be so fast is that it just lives on your local machine. And I think the Xero folks were mad when I did this on YouTube because they were like, if you speed up your keyboard time, it would go even faster. Like, you're pressing Holt. They're like, you're not showing it as well. I'm like, it's pretty impressive. All right, let's go back. Let go back to that Sorry finagling with the mouse here Okay cool So I alluded to this How does this work Well you have your app which does need to be a server app, mostly just because you are handling some server-side stuff, but Xero doesn't need to be really heavy-handed on the server. It is mostly handling just the client-side things. and in fact, typically it's all done through CSR, right? But if you want like SSR landing pages and stuff, it makes sense to have it be an app. You have the sync layer, which is like really the big part of Xero. It's the sync layer that runs as just a node process. And then you have a Postgres DB, which you can manage all of this with Docker and have it be really super simple if you'd like, or you can just spin up three separate things. And the cool thing about this when we talk about hosting is that if you know how to host these three things, like two Node apps and a DB, there's nothing more to it than that. You don't need to pay a special host to host this stuff. You could throw it on a Coolify or something like that, or you could throw it on AWS. So this is kind of what it generally looks like. With this, you need a schema, and this is really a client-side schema. With any of these things, you probably have 800 schemas already, and this one looks very similar to most schemas that you're writing. And this schema is really letting zero know what needs to exist in the client side. So not everything in your actual database needs to be exposed to the client. A lot of things should not be exposed to the client. So with your schema, you're basically letting it know, hey, this is what the front end of your application needs to worry about in terms of data. And if you are sick of writing a lot of schemas, and you already use Drizzle or Prisma, there's packages that just, you just swoop your Prisma or Drizzle schema into it, and then you do not have to write another schema. You just tell it which of the fields in particular you'd like it to keep track of. And because this is like the client-side schema, Xero doesn't handle any server-side migration. So either you write your migrations by hand or you use an ORM tool or a migrations tool to handle those migrations for you. But for the most part, zero just picks up the changes. Permissions Yeah it does permissions super easily You basically one it locked down by default So because it locked down by default that means you're not getting yourself into situations where you're allowing functionality on data that you're unexpected, because by default, nobody can do anything with it. You have to explicitly open that up. But you're basically passing in zero, a JWT for your auth. Zero knows how to decode that, and you get access to your user data directly in a function, and you just say, hey, I just realized all these say nobody can, but you pass in, instead of nobody can, allow if user is self. I think I accidentally deleted that line before I got up here. But either way, you get access to this sort of permission system. Now, the coolest thing about this for me is not just that it does permissions like this, but this handles permissions in two ways. It handles them on the server side and it handles them on the client side. So meaning that you get the security of server permissions and the UX of client side permissions. Because it fails instantly, right? You're not having to wait for that server trip for it to fail. Like anything, you create an instance of it in the class. You pass it your sync server. By default, that's the port. But usually you're just passing it a server. you're passing your schema, the user ID, you got a zero instance. Nothing there. And then from there, it functions... Oh, why did it go to that side? Oh, okay. My slides are blank up here for some reason. I don't know. It's loaded blank. I don't want to refresh it. So, Svelte. What about Svelte in this? Well, zero wrote a React and a solid version, and they asked me to write the Svelte version, of which I did. So at zero Svelte on GitHub is the Svelte bindings for zero. And what's so cool about these is that it's really simple. You just create the zero instance like normal, you turn off SSR for anything zero touches because SSR and zero don't play super well together. And so like that, you'd probably want to have your landing pages SSR'd on a different route, a different layout. Like I said, it's kind of got an ORM like syntax. You use that z instance and you query it. So to do dot where, where the user ID is equal to

 page.params.id, and then you pass that into a new query class. And that is part of zero svelte, and that makes that to-dos reactive. So anything that changes, that gets saved reactively. You mutated. Wow, same thing. z.current.mutate to-do update. Hey, there's an absurd in a create and all that stuff as well, but like, this is super easy. And if you've ever used any of the other local-first platforms, you will know that it is not a one-liner for most of these things. Like for instance, in Zero's precursor, Replicash, when I did any mutation, sure, I'm writing the function that sends it to Replicash, right? But I'm also having to accept that on my server, decode which version of which field I'm updating. I have to make the updates. I then have to see what's changed, and then I have to manually create a patch message and send it back. It was, I kid you not, like a 12-step process that I had to list out for both pushing and polling of data. So this is just straight up it. And then likewise, you just show it. To-dos.current, sorry if this is not big enough. Let me, oh yeah, whoa, here we go, cool. To-dos.current, becomes fully reactive, right? And you run that toggle to-do and everything just fully works. It's crazy how easy and nice. All right. So I mentioned hosting. Again, you can host this stuff on anything. The way that I tend to host these is with SST on AWS because you could just put everything in one spot. But again, any time you can host a Postgres database, whether or not you're using a service like Neon or any of these things, you just need a connection string. You need a sync service. Is a Node app hosted somewhere? You just need that string. And then you have your app running wherever. So there's nothing special about any of these things, and that's why I like it so much because a lot of these other ones are these whole-ass platforms that you have to deal with. This is my app that broke. So I'll be showing you the local host version of it because it is not broken. But what's cool about this app and what makes it uniquely positioned to be a good local first app is that I'm dealing with a ton of data. So if I have a habit that I'm keeping track of, I might be keeping track of 40 different habits. and there a check mark for every single day of the year I wanna be able to load all of those I to be able to not worry about how much I loading at any given point whether that is through charting or just showing it all in one big giant table or anything like that. And so it makes it a really good candidate for something like this. It's also an app that you very well may use in different situations. So like you can see here, when you click these things, they update. And they update instantly, there's no lag time, and it's not using optimistic UI, which is typically how you get that type of speed, right? And that's what makes it really feel great to use is those types of things. And this isn't zero itself. To me, this is like the local first way of doing things, is that when you save things, it actually saves. It doesn't send off a message, right? And what's cool about this is that this is all saving it to, oh, Where is this? Okay. It's all saving it directly to a couple of databases in here. And these contain the patch messages and the data. So if I delete both of these local databases and then refresh, it comes back. It comes back that fast. So that was saved at the database level. It came back, and then it rebuilt the databases that quickly. So, yeah, that's pretty sick. And again, because this all functions as like a small layer and it just works as a sync engine with your database and all that, I'm not like having to write the code to make sure that that reconciliation happens between the client and the server. It really just happens. And to also show you this in action here, I'm going to... No, no. There we go. All right. I'm going to change this one, and I have tables plus open right up here. And I'm just going to, you'll have to trust me on this because it's not letting me drag it up for some reason. Oh, there it is. Okay, tables plus. All right, this is not a faked magic trick. so if i want to uh have a bad time i'm going to have a bad time uh and then i'm going to hit command s instant yeah i not trying to throw tables plus sorry let let do that again i going to change bad back to good you You see bad right there Have a bad time When I hit command S it going to change to good So that happened instantly, and just like the database is updating. So again, it's super cool that, like, you don't even have to think about that on the back end. It's listening, and it's just updating it all with WebSockets. Super duper cool. Yeah. All right. There's the AI chat app as well. And this thing is interesting because like I mentioned, really what we're doing is I'm just streaming data in. And as I'm streaming data, I'm just throwing it right into my database. These are showing queries right now, but I'm just throwing it right into my, oh yeah, update chat. There we go, update, update, update, yeah. So I'm updating my messages, whatever, as this data's coming in and it's going to look instantaneous. This demo isn't online anywhere, but you can download this code and run it locally if you would like super fast. super easy and it will work i think it should work all right i'm gonna get a water break nothing special about this guy he's just cool he did not beat me all right cool yeah so um i wanted to show or at least talk about something that i'm working on because I've been working on this for a little bit, and I come from the world of Meteor.js, and for me, Meteor had so many cool things that haven't come back into Web Framework world. Yeah, it had real-time, it had fake client data queries, and you could pretend like you were querying data on the client, but some of the cooler aspects of Meteor that I think have gone forgotten about are that it gets you set up with obviously real-time, but it also does a lot more for you like auth and auth templates and just templates in general. And some of these things are really lacking, I feel like. Yeah, we're throwing in our components and our whatever. We're stringing together this auth package and whatever. But oftentimes when I get started with things, I want to get going past that stage. so I've been working on something that I'm calling a starter kit plus it called drop in it very skateboard themed all the packages are named after skateboarding things yeah pass is like your season pass to the skate park That one a leap So it a starter kit with packages So it comes with auth and login templates And that means that like, yeah, when you fire up the starter kit, yeah, sure, you have a login, you have authentication and everything tuned to work with Xero. But like, if I'm not happy with that, I can just throw that actual template in my code and modify it, and it's going to work the exact same way. So, yeah, it takes care of all of the authentication routes as well, and it does throw through a SvelteKit hook. You're just dropping that in there, and it brings in all of your routes, whether that's the forgot password or any of that stuff. It just intercepts those routes and handles the auth for them, and then it uses the templates in the ramps package. There's also email which is connected into auth and login. Meteor also had email. Yeah, you can throw in an email package of your choice. One thing I really liked about Meteor's email, and I'm not saying others don't do this, is that when you didn't have any credentials set up, it just output to the console. You didn't have to think about it. This does that. A lot of this is modeled after the way of doing things in Meteor was. It has some global config which becomes available via plugin. There's certain things that become available globally so that they can be used inside of templates and outside of them. You don't have to pass them as props, but it's mostly things like app titles and things like that. Nothing crazy. Not a crazy amount of config globally. It also includes a base CSS layer, which you can just delete it if you don't want it, but it's a nice, simple CSS layer with variables, and it is somewhat opinionated, so if you don't want it, it's easy to just nuke out. but overall it remains unopinionated on CSS frameworks because one thing that, it doesn't like bug me necessarily but it will turn me off from using a package. If here's a whole library but it means you have to be opted into this other whole library, like I will kind of avoid doing that not because I don't want to be opted into this ecosystem but I want to do so by choice. I don't want to be do so because I'm forced. So it is unopinionated. If you want to throw Tailwind or Uno or whatever, you can do that. nothing's stopping you, but it also doesn't make that choice for you. You just bring your own database connection, and even that you don't necessarily have to bring because there's a Docker file

 you all set up. And there's even like AI rules with all of the Svelte stuff and all of the zero stuff and all of the drop-in specific stuff. This is not available. Well, it is available to use today. It might not work. I've been tweaking it nonstop. But it's also in alpha or even pre-alpha since zero itself is in alpha and this uses zero. But if that type of thing sounds interesting to you, if that sounds like something you might like to have a hand in or help in, yeah, I would absolutely love ideas or help on this thing. It is pretty far along. I've built several sites with it already. It not working might just be due to version changes here or there. Because that's the one thing about Xero right now today, is that a version change won't necessarily sync you because they aren't really changing a whole lot. But there is sometimes Sometimes little API shifts, so you have to be kind of comfortable with rewriting your stuff. Or potentially having it not work when you're about to get on stage and do a talk about it, which is not ideal, right? But yeah, you can check that out. It's on GitHub, sTalinski. DropIn is the package there. Again, here's the QR code if you want to check any of this stuff out. Again, it's just available on my website as well. And yeah, I don't know if we're doing questions, but if anybody has any questions, you can just find me afterwards. I think I'm good on time. So yeah, I'll be around all day tomorrow too if you want to ask me about any of this stuff. So thank you so much. Thank you.