 Hi, my name is Nicola Davis and in this talk I'll try to break down Svelte's CrossFeed function. We'll discuss what it is, how it works, and an example in the wild. But before that, let's talk a little bit about the appeal of modern frameworks like Svelte, React, or Vue. The first thought that comes to mind is that modern frameworks organize your code around components, each with its internal state and encapsulated logic. However, the bigger advantage is that you can write declarative code. What I mean by that is that you merely describe how to translate your state to DOM elements on the page, and the framework takes care of keeping the view in sync with the app state as it changes. There is more to be said of course, but this should suffice for the purpose of this talk. Let's take a look at a simple example of moving a box from one position on the page to another at the click of a button. If you wrote this using vanilla JavaScript, you might do something like this in the click handler. Basically you're grabbing the actual HTML from the container on the left and stuffing it into the container on the right. Here is what it might look like in Svelte. You just store the position of the box as part of your app state and a simple update to that state causes the box to render itself at the new position. Looking at these two examples you might be thinking to yourself that the declarative version is better because there's a single source of truth and the viewer layer is able to update itself automatically in response to that. But the imperative version actually does have one advantage over its counterpart and that's the fact that it gives you full control over the code that's executed when the app state changes. This allows you to perform things like transitions quite easily because you can just trigger the transition manually in response to an event that changes the app state The declarative paradigm suffers a bit from lack of control over how the state change flows through the app all the way to the view layer This is by design because the update is supposed to be automatic Svelte transitions are one way to get a bit more control over how elements on the page react to a change in the app state. You can determine how an element transitions in when it is created or transitions out when it is destroyed. The crossfade is a peculiar type of transition that coordinates the transition of an element from one location to another. Two things are happening here. The element is destroyed at its old position and it's created at its new position. The crossfade function generates two transitions, one out transition for the element that is destroyed, and one in transition for the element that is created. Both these transitions are played simultaneously over each other. The default implementation fades out the first transition and fades in the second transition as the two transitions make progress. So at the start of the crossfade you're actually seeing the element that is transitioning out and at the end of the crossfade you're seeing the newly created element that is transitioning in. Sneaky but useful if the object assumes a different size or color at the new location. Back to our earlier example, this is all you need to do to enable a crossfade transition. The crossfade function returns two transitions that you can attach to elements transitioning in and out. The key attribute just lets the crossfade function know that this is the same element at both locations. And there you have it, a crossfade. Let's take a look at the internals of the crossfade function now. When I first came across the crossfade and Svelte, I thought it was some, you know, internal compiler magic thing, but actually it's just a simple function that you can write in your user land code. So off the bat you'll notice that it has two maps over here and these maps store the keys of the elements that are transitioning in and out and you notice at the very bottom it returns the two transitions that are the send and receive pair that you would use in your code Now, all it's doing is it's consulting those two maps. This over here basically asserts that there is a corresponding element that is transitioning in as the current element is transitioning out. But the most important thing to note is this. So in Svelte, a custom transition is usually created by just returning an object that has the properties of the transition, like a duration and so on. But this transition returns a function, which then returns the transition. What that means is that this transition is deferred. And so this allows Svelte to run both the transition of the element transitioning out and transitioning in in the same micro task, so it can batch them together. And that's basically the only bit of magic over here. Everything else is fairly straightforward. And the actual logic of the crossfade just involves getting the rectangle of the element and then basically performing a translate to move it to the new location. And if it's a different size at the new location, it can also scale it. That's basically it. Now for some real world examples. This is an app that I work on called Board Game Lab. It's basically a board game simulator that allows you to prototype and playtest board games with people over the internet. So if I go here to the layout editor, I can edit the layout of a component, a card in this case. This is just a full blown SVG editor written in Svelte. Let me add an image over here Now the key idea in BoardGameLab is that you can connect data to layouts and so I can very quickly spawn multiple instances of this card and then customize the image as well as text on each one of them by just entering stuff in these fields so let me just go ahead and do that now if I come to the play tab I have all these cards that I just created and and click them to move them around, move them into my hand, and all the usual stuff that you might do in a card game. Then I can also group them, shuffle them, so on and so forth. Now the crossfade comes into the picture when we go to the multiplayer mode. And for that, I just need to share this link, copy it to another browser. So if I move a card for the player on the left, you'll notice that the card animates smoothly for the player on the right as well. So the player on the right is just receiving a state update from the network stating that this card moved from location A to location B, but it's able to animate it smoothly because of the crossfade. And you'll notice that the crossfade works fine even if I move the card to the other player's hand, despite the fact that the card changes size when moving to the hand area. So that's one of the uses of the CrossFit function. Hope you found it useful.