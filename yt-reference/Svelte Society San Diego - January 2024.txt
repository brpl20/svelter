 Hello and welcome to the January meeting of the San Diego Svelte group. Today we're going to do a deep dive into SvelteKit and then also do an update on both Svelte5 and SvelteKit2. So regarding Svelte 5, for those of you who've been following, it was released into Alpha. It's publicly available for download. It was originally targeted to be released in 2023. However, it's still a work in progress. And really, I'll get into a little bit more details in a second. But the team is really taking the time to get things right. They really want to make sure developers kind of love the experience. And so they've made some adjustments, which we'll go over. And it's currently looking like a early 2024 release. So some of the changes since Svelte 5 was initially announced, and there are a handful of changes, most of them kind of smaller, either smaller or kind of things under the covers. But a significant change is this concept known as proxy state. I'll go over that in another slide. They also introduced a new rune known as the inspect rune. I'll go into that in more detail. And then for anyone that's actually followed the preview site, they just um have continued to make tweaks and adjustments and so you know there's there's more going on and what i'd say for everyone um if you're if you're interested in trying out go ahead and try it out if you're wanting to wait for something a little more stable by all means um svelte 4 works great um you can wait for a stable svelte 5 release and i'm sure once that is announced, kind of everything will be very locked down. And that would be a great time to jump into it. Having said that, there are a fair amount of people using Svelte Live today, testing, giving feedback to the team et cetera Another change is Svelte Kit 2 was actually released in December That was a very under the radar change And really it it just a small incremental release And and really it seems like it's just paving the way for sort of Svelte 5. So there's not a whole lot there that you'll see that's different. And SvelteKit 2 is, is available today. Um, they did introduce one, feature known as shallow routing. I'll go over what that is in a second. And then just one other item. So in a prior meeting, we went over kind of NPM downloads and basically measuring how a spell growing, how is it compared to other frameworks. The quick summary, it's number four, you know, Reacts, basically number one, followed by Vue, then Angular. And Svelte is kind of gaining territory. So roughly speaking, and I'm not going to go into all the details, but roughly speaking, Svelte has more or less doubled in terms of NPM downloads over the last two years, which is a pretty healthy growth. Definitely the other frameworks are not growing at that rate. And then just comparing, this slide has comparing October and December numbers in January is basically in the same ballpark. These are NPM downloads per week. So back in October, I don't have the exact week, but I think this was middle of the week or middle of the month, rather. There was 765,000 downloads per week in October. December was 850,000 downloads. So that's a pretty good growth rate, almost a 100K increase. And in January, it's more or less kind of in that same ballpark. I think it's maybe a little bit like 830, 840, but tremendous growth. And really not that, you know, being the number one use framework is the most important thing. But I think as someone that really likes Svelte and hopes to be able to use it more and more in kind of the professional environment And I certainly use Svelte as much as I can but a lot of clients I work with are you know React I love to see Svelte get into the territory of basically challenging Vue and Angular which are two and three respectively. Those, just off the top of my head, those are both kind of in the three to four million range. So, you know, maybe another year or two, I can see Svelte kind of being in that space. But I guess we'll wait and see. But, you know, I guess the one good thing is Svelte 5 is, as I mentioned earlier, the team is putting a lot of effort into getting Svelte just fine, just right, getting the optimal experience. Our previous meetup, we went in all the details of Svelte 5, so I'm not going to do that right now. But, yeah, just be aware that it's coming out soon, and there's a lot of great things coming with that. Okay, so what specifically are some of the things that changed in Svelte 5 just in the last month or so? Okay, so there's this concept of proxied state, and if you followed the state rune and some of the talk that was going on about the state rune, there were some specifics about how you needed to handle objects and handle reactivity. And I guess the short of it is that it's been all greatly simplified. And I'll show an example. This also applies to arrays. I'll show an example here comparing Svelte 4 and 5. But the bottom line is you can mutate whether it's an object, an array directly, you can modify them and don't have to do this special reassignment syntax. So just to demonstrate that, let me show an example here. So this is now Svelte 4. So you can see I have this array of donuts. It's kind of a silly example, but I'm just going to add, here I'm going to say vanilla. Cherry is probably not a donut flavor, but you get the idea. And what's really interesting note here is in this increment function. I have this array and if you if you worked in Svelte 4 or worked with other front frameworks like React you usually see something like this You basically create a brand array and you assign that to your reactive value So what you don't do is you don't just update the array directly, whether you push it or edit its elements. You have to kind of create this brand-new array in assignment. And that's just kind of due to how frameworks work and comparing objects or comparing two different things. So simple example, but let me just show the equivalent in Spelt 5. So it's really the same thing. I'm, of course, using the state rune. But the other thing, so I'm just going to add, please. Oops, vanilla. Okay, so you can see here, I don't have to, I'm not doing any sort of reassignment. This is straight up, excuse me, altering this array via push. And so that saves me, and I'll let me go back this well, for example, that saves me from having to do this reassignment. And just to kind of prove the point, let me redo this example. Again, trying to just push, and I'll put in glaze. You see it doesn't actually, the donuts array doesn't actually reflect that. So on the surface, it's not a huge thing maybe looking at it, but you can just mutate your objects directly, whether it's array, regular traditional objects. At one point, if you're following Spelt 5 and dealing with objects, there was this alternate syntax that you're going to potentially have to do. They got rid of that requirement. So it's very, very simple, very straightforward. If you're curious about how it works behind the scenes, remember Svelte is a compiler. And as a compiler, it can basically infer certain things that you can't with a, say, traditional framework. So behind the scenes, Svelte is using proxies and so it can see what you're doing. It sees, oh, okay, this person is, or this code is updating an object or it's updating an array. I know what that means. I know it's trying to be mutated, so let's make this reactive.

 So it's doing a little bit of, you know, work for you, essentially. This does come with a very small performance cost. Now, I think most of you probably know this. Svelte 4 already has really good performance. It performs better than most of the major frameworks. Svelte 5 really is exceptional performance. So while there is a tiny, tiny penalty for this, it's so small, it's not very noticeable. And with Swelt 5, the performance is really on par with the top performing frameworks, which React, Angular, and Vue are not. So so it gives you kind of that that. Yeah, gives you a much better user experience and you still get great performance. So, yeah, that's what proxy state is. And I guess the key takeaway is it's very simple to utilize state. OK, so there's another room that I should say a new room that was introduced. It's a very simple one, and it's known as inspect. So the basic idea is it's intended for debugging purposes. So it basically allows you to watch a reactive value, and then will execute a function when that value changes. And you can specify basically the second parameter is an optional parameter. If you specify the second optional parameter, it's just a function, an anonymous function that you can call, or it can be a predefined function, but you pass it a function, and it'll essentially do whatever your function does. Technically, you can do whatever you want. You could even call it an API if you wanted to. Really, that's not kind of the intention. It's more for doing something like a log. And if you emit that second parameter by default, it will do a console log. So, yeah, you could go nuts and do all sorts of stuff with it. It's not intended for that. It's really intended for debugging. So let me just show kind of a quick example here. Okay, so you can see I'm calling inspect. In this case they actually slightly modified the syntax So now it not a second parameter It just with console log but you can see let me expand this as you can see each time I click it it going to give the a value the very first time even without clicking it gives you the initial value and it just says in it and then every subsequent time it's changed it's update and it has the actual reactive value now if I omit this, we'll get the same exact behavior because it is a console log, but you could do console.trace just to give another example, right? And if you're debugging something, maybe this is helpful, but you could do something very, you know, sophisticated here. So let's say I believe it's value and type are the two parameters that you're given. And then I can't think of anything to. Here, let's just do a console. I don't want. Again, you can do anything. You could be as sophisticated as you want. Right. Okay. So you get the idea. You can do whatever you want here. All right. So let's move on. Okay. So then SvelteKit 2, as I mentioned, it's a pretty straightforward release, very under the radar. The only real feature that they made mention of is this concept of shallow routing. And so to understand what this is, first, we have to talk a little bit about what SvelteKit, how it works in terms of routing. And so I'm going to do a deep dive into SvelteKit in a second, but just know that SvelteKit has built-in routing. And so at a very high level, what that means is if you navigate in your SvelteKit app and go from link to link, you're essentially going from one route to another. So you might, if you're navigating through blog articles, you might see slash blog in the URL. And you might see after the slash a number indicating the ID of that blog article Each time you click around in your app the URL is updating and SpellKit says okay, he's at the slash blog route. I should render the content that corresponds to that. And so not only is the contents of the browser updating, like you're seeing new content, but the URL is changing, of course, respectively. Now, there's an instance where the URL doesn't change, and basically this shell routing is giving you more control over what will actually update the URL, and you can basically have the URL get updated in instances where it traditionally wouldn't. So as an example, and this is the most commonly used example when discussing shell routing, is you can create, of course, a modal. Now, modals usually don't change URLs. They are essentially JavaScript just running on the current page. However, using shallow routing, there's this push state API. You can make it so that the URL actually changes when someone opens a modal. Why do we care about this? Why would you ever want to mess with the URL? Well, because the URL changes the back button, for example, now works. So one way to dismiss that modal would be to use a back button. Well, do people ever want to click the back button to dismiss a modal? Generally speaking, no. However, if you're on mobile, remember, you can use swipe navigation. And so, again, the very typical use case is, well, you can swipe to close because essentially swiping is navigating to close a modal. And that's, you know, talking about mobile and functionality, that's an experience a lot of users are familiar with swiping to dismiss or close something. So that's kind of what shallow routing is. I don't have a code example available, but I think you understand that concept. Okay, so per request of one of our users, today we're focusing on a deep dive into SvelteKit. You know, I see a lot of people just going on Reddit, on Discord. I think people understand what Svelte is. It's, you know, very easy to understand. Hey it just a front framework component front base framework What is SvelteKit And so at its heart it a full stack framework for building apps with spell primarily web based apps. And so it's, it's including both code that runs on the client, but also code that runs on the server. That's what we mean by full stack. As I mentioned earlier, it's file based routing. So you go to a particular route, which I'll show some code examples in a second. I actually have a sample project that I created, so we'll be able to demonstrate some of these concepts. But essentially, a route in the URL corresponds to a folder in your SvelteKit project, and that folder will have a page.svelte file. and basically the URL corresponds to a folder and that determines how you navigate. I guess there's a one-to-one mapping of your project's folder structure to your URL structure, your routes and your URL. That might be a little bit confusing, but I'm going to show the code. It'll make a lot of sense or show the project. But why do we even care about a full stack framework? Why do this when we have these single page apps and single page apps are great? Why are we bringing backend back into things? So just to give a little historical context, you know, when single page applications first came out, I want to say roughly 10 years ago, or at least when I first started using them, They were great because it gave us the ability to do a lot on the client side, give the end user a very rich experience. We didn't have to go back to the server, re-render content, et cetera. Now, the downside to all that, one major downside really was search engine optimization. So imagine you're selling products on your website. If you went from a traditional server-based website or web app to a single page app, all of a sudden, just to go in a brief overview how search engines work, they have crawlers that go scouring the web for websites and automated websites.

 bots that are going and trying to read the contents of those various websites. Now, those crawlers don't necessarily know how to interact with a bunch of JavaScript. So when they see a website, and that website is basically just a shell of a page, right, your typical spa, you're usually downloading some basic HTML and JavaScript, but really all the functionalities being loaded dynamically, right? So these bots, these crawlers, they just see basically an empty shell with a spinner and think, okay, this is what's here. They maybe don't necessarily know how to process all the JavaScript. All that to say, it doesn't work very well. Traditional spas don't work very well when it comes to search engine optimization. Now, the bots, the crawlers have gotten better handling things, but at the end of the day, if this is your bread and butter, if you want people to be able to find your products and this is how you make money, okay, this is search engine optimization is very important. And so by SvelteKit offers this and certainly other frameworks, if you're familiar with React, React has Next, for example, or Remix. Those are another example of these full stack frameworks. But they all offer kind of similar features. And by doing server side rendering, so the very first time you go to a website, the content is generated on the server side, then you don't have to worry about, well, will this come out well for search engine optimization? So that's a huge plus. And then you also get an extra benefit of a little bit better performance for that initial page load. Yeah, and it might sound a little bit confusing at first. The nice thing is these frameworks kind of handle all these details for you. So I know the first time I was working with SvelteKit, I was like, I'm worried. How do I do things? It felt a little confusing. You don't have to worry about too much. The framework is going to handle it for you, and specifically SvelteKit makes it pretty simple and straightforward. In addition to the benefits of better performance and search engine optimization there just enhanced developer experience And generally what that means is you going to see some examples where you can get a lot more done with writing less code So just like I feel like Spelt makes your life easier compared to other frameworks where you don't have to write as much code. And SpellKit falls into that same category. So generally speaking, when you write a lot of web-based apps, you spend a lot of time writing APIs. You work with forms. And there's just a fair amount of boilerplate code you have to do for those things. SpellKit really helps eliminate that. Now, you can still call your own microservices or third-party APIs. You're still fully capable of doing that. But you can also just take advantage of what SvelteKit offers out of the box and not have to write a bunch of boilerplate code. And so you'll get a very similar end user experience. OK, so with that, I'm going to go ahead. This is that's a very high overview. I'm going to go ahead and introduce this demo project that I created. And then I'm going to kind of jump back and forth between the slides. So I have created what the system is known as the time tracker. So just to give you a little bit of context. So I work with clients and I need to bill my time to various clients. So I created a little app for myself to keep track of what projects I'm billing my time against. So I'll just give a very brief, brief demo. So I'm going to go ahead and sign in. Now, this particular app is is very. This is more of a demo app, so I'm not using, you know, the necessarily the best practices when it comes to security, but it's it's adequate for for demonstration purposes. So you can see I can select the project. I can specify a day, a number of hours and some notes. and so this is a test and I submit it and it's good now I'm gonna go ahead and log out and you gonna see if I try going to the same page I was in before it kicks me back to login so that just at a very high level Now we go through some slides and go through some code All right So as I mentioned before it is a spell kit is file uses file based routing So every route in the URL translates to a folder. Now folders can have different types of files. um and this i think this part for people brand new to svelte kit maybe is the most confusing but the idea is um so svelte kit is very very much um convention based so um if you're just doing regular svelte development you can call of course components whatever you feel like to utilize svelte kit's routing system and folder and routing system you have to follow these specific conventions for specific types of pages. So if you want to go, in my example, I had a slash login route. So if I want to go to the essentially login page, I have a folder called log in and then within that folder I can have these and I do have most of these files so it's a might be a little bit odd to some people but there's this plus and that's just part of the file name I don't know exactly what the the reasoning is but every every file has this plus prefix now the most common one you see is plus page dot spelt and it can be a dot js or a dot t meaning you can have both JavaScript or TypeScript. This is where you put your traditional code. It is running on the client side, but because it's SvelteKit app, the code potentially can also run on the server side as well when it's doing that initial render. So I guess we'll go in more details, But if you need to have code that only runs on the client side, for example, you might want to put that in an on mount function. But the page file is generally speaking code that runs both on the client side and server side Now you can also have code that runs 100 on the server side number will run on the client side and that a plus page file and again those can be JavaScript or TypeScript, and this is where you put exclusively server side code, so things like loading data, maybe you're making a call to a database, or you have what would be your traditional API code. Now you don't have to have this file. You don't have to have a page.server file. Um, especially if your app is, let's say you're using, um, some exclusive view using external services. You don't have to use this, this file at all. Um, but you can, and especially if you're going to have your own backend code, that's where you call it. Um, now there's a slash, sorry, a plus layout file. Now, imagine you're working in a website and you have a header and you have some side navigation. So maybe you don't want to have to replicate that logic over and over for each page within your app. So in your root or at a root level or even a subfolder, you can have a layout.svelte file. and also a layout.server.svelte file. The layout.svelte file, essentially, like I said, it's where you put your kind of high-level layout. So you can have your header, your side nav, and then the layout.server is the same concept, except for it's for the server-side code. So if you have logic, backend logic, that's kind of specific to your layout. So maybe, you know, you want to show the user's profile, their profile picture. If that's part of the layout, well, then you very likely do that on the layout.server file. So a lot of files, but let me let me go and show an example here. My sample project is going to close a couple of tabs. Yeah, let's leave that. And OK, so this is now my sample project and I am not sharing it. so let me make sure i am properly sharing it um give me one second while i reset the screen share

 Okay, great. So now you should be able to see my spell kit project. Now, I guess I'll collapse it down, everything, just to make it clear to you kind of how it works. So really what you're most concerned about is there's this routes folder. And under routes, again, let me collapse. You can see I, just like I mentioned in the slide, I have a page.svelte. I have a page.server file. and then of course I have the layout files as well. Now I happen to have content in the root of my site so this page dot here let's take a look at the layout first. You can see I have logic here for the logout button. The logout button is part of the the layout and then you can see I have logic here for what we call the header of the app. And this is using fragments and slots, which if you're not familiar with, are standard kind of features in Svelte. But you can see I have my title. If the user is logged in, I show the logout button. So I have a little bit of logic here. and again this is basically showing me hey this is this is the the header for the app this app just has a header doesn't have a side side now but if I did this is where I'd put it and then I mentioned I have some server side code associated with this actually I don't remember what I put in here and yes yes there's some server side logic I'll come back to exactly what this is and in the future when I go over a future slide. And then I also have just this is just the page, which if you recall, after I logged in, I saw I had the ability to enter my time. So I have this basic page here where I show the projects you select your date your hours your notes you submit a button pretty straightforward And then you can see if I successfully submit my form I show a little success message Let me go ahead and go back to my slides. I think there's a little give me one second while I adjust the slides. Okay. Give me one second. I have to stop my screen share again. Okay, back to the slides. All right. So I showed you kind of the general folder structure and I'm going to go into a little more specifics now of some of these files. OK, so you might have noticed it, maybe not. But each file has the ability to have what's known as a load function. So generally speaking, unless you're dealing with static content, every page you usually want to load something, right? Like typically on a more traditional, I guess, single page app, right? You execute some JavaScript and you'll probably call some sort of either a RESTful API or even GQL for that matter. But you're going to make some external call. And so you have to have code that when the page is first loading to make a fetch to some external API. Now, SvelteKit kind of, and you can still do that. There's nothing to restrict you from doing that. But if you want, you can take advantage of a feature that SvelteKit options, and that is what's known as a load function. Now, a load function behaves similar to calling, say, an external API. The difference is it just eliminates a lot of boilerplate code that typically you'd have to write. So it kind of connecting server logic which is loading data with the content of the client side Again I show the code in a second and so when we talking about page files you can have what known as just a load function And you can do whatever you need to do. So, for example, call a database and make a query. And then whatever that load function returns will be available to the page. And then, of course, the page can display however it wants. So you'll see when we get to the code in a second, but you're avoiding, you know, anytime you write APIs, generally speaking, whether it's REST or anything else, you know, there's a fair amount of boilerplate you need to handle. You need to think about security. You need to think about validating inputs. There's just a fair amount of, if you're using microservices, you always have to deploy them. And so there's, you know, just a fair amount that can go into what can traditionally be kind of straightforward. Like maybe I'm just calling a basic query, but I have to write a fair amount of code just to make that happen. And, of course, on the client side, you also have to make a fetch call. So we don't have to do that anymore. So I'll eliminate that for you. So I'm going to go back and I'm going to show for my my default page. I'm going to go to the page server and you're going to see I have a load function here. And really, this is all I need to get the load function to work. I'm happy to use TypeScript here. So if you're not familiar with TypeScript, don't get too caught up in kind of the typing. But really, at the end of the day, all I'm doing is I'm calling is get project function, which is just making a database call. And then I'm returning the projects. On the page side, I basically have to expose this data property. And Svelte does kind of the magic to wire these up together. And then you can see here, I just do iterate through the various projects. And I have a data.projects object. And so that's just a one-to-one corresponding to the return value here. By the way, I could have done more with TypeScript. If you see squiggly lines, it's because I haven't kind of done all the typing I could have done. But it illustrates the points. Like, this is very simple. I now have data. I don have to write code in Express or whatever I want to potentially so this this is just very trivial to wire things up okay so we also talked about forms and so that's another thing you deal with a lot web-based apps so if you remember the app do I have it still open I basically had a form I submitted the forms everyone Everyone knows how it works. So if I go back to the page here, page svelte, not the server one, you can see I have an HTML form here using method post. And then I specify an action. And this concept is known as form actions. um now if you don't specify an action there's a default action or you can name your actions um i went ahead and just named it save um so when we go to this page.server of course buying page.server you're going to see i have under my actions i have um a function associated with save and so that's that's basically when someone clicks the submit button it again spelt kit It wires this all up for you. It calls this save function. And as you can see, I have I have multiple things available to me, including the request itself. So I can get the form data, but I also have access to cookies and some other things as well for that matter. But you can see, again, this is typically something you to use an API for. I'm not using an API. I'm extracting the data. you know, I probably should do some sort of server side validation of the data. I'm not just because this is a simple demo, but that's just general best practice. But as you can see, I get the data and I pass it to now a function that's just basically saved to the database. So very straightforward. And then I just return a payload of whatever I want. In this case, I'm just returning success true. And then in my form, you probably saw this. I also have, sorry, in my page, I rather I have this form prop. And then because I return form true, it checks to see, hey, is it a success? And if so, I basically say, hey, congratulations. So that's it in a nutshell. So a lot, I guess just

 Having worked on a lot of other sites, especially if you're doing full stack development, there's a lot of code sometimes you have to write for simple APIs. And so this 100% eliminates the need for that. And again, you can still have your own RESTful APIs or GQL or whatever you want. This doesn't restrict you anyway, but it's basically this opt-in ability to save a lot of time for that code that goes for initial load and then for any sort of form-based actions. Okay, so hooks. Hooks is another concept in SvelteKit. It is no way related to, if you're familiar with React, has nothing to do with hooks in that sense. And basically what hooks are, it's allow you to put logic that basically happens kind of on every page render. And so, which really, you can do a lot of things potentially. You also, in the hook itself, you have access to cookies, request object, response object, what's known as locals. So, things that you can do. So you can do things like security. So you can check cookies and protect routes like hey is this person signed in Are they allowed to access this route we can check the cookie just you know however you wanted to set up your authentication but we can check and these are just be clear these are HTTP only cookies is this user logged in do they have the ability to access this particular route but you can also do things like modify headers and then so just as an example if you have some sort of caching mechanism for the data in your site, maybe for, I don't know, particular content that you might want to have a caching duration on. You can put that â€“ you can modify the headers to specify that directly in your hook. There's also this concept known as locals, and it's a way to share data across multiple pages, so you can preload data in your hooks and put them into locals. and basically locals are just kind of a store. And then you can also do things like logging, like, hey, people are going from navigating various pages and maybe you want to log that and you can also put some error handling in there. And really there's more things you can do. But let me just show you how I use it in my demo object. So in my root I have a hooks file And then I just showed you the login page earlier So this is kind of simple but essentially I get the username cookie because the user if they logged in I specify that the username and the cookie and then you probably wouldn't do this in real life but just because it's such a basic app there's one route that i protect this admin route that's intended for for admins and so i store this also in the cookie and again it's htp only cookie so no one on the client can actually modify this um and then i check to see hey if you're not on the login screen um route is where you're navigating to and you're essentially not logged in, there is no username cookie, redirect the person to log in, right? Once you're logged in, of course, this won't apply anymore. And then also, if you're on the admin route and the user is not an admin, redirect them to basically the root of the site. So kick them out, right? Now, I could do a bunch of stuff like I mentioned before. you know, the docs go over some other scenarios. But just think of it as an area that you can put kind of centralized logic and kind of handle common things And I think security is a really good on these things for that Let see what else Okay So that is that is all So that is kind of SvelteKit in a nutshell. And just really to kind of wrap it up, it makes things easier for you. It also helps with deployment. And for people that are like, I just want to use Svelte by all means, You can create a SvelteKit project, just use the Svelte concepts, and you're not forced into doing anything in kind of a SvelteKit way, or maybe you're not comfortable. Hey, I haven't learned SvelteKit well enough. I would still recommend building using SvelteKit and the SvelteKit CLI. And over time, as you get more familiar, you can utilize some of these more advanced features. And really, they're not that hard to pick up. I know it seems confusing at first. Hey, what should I run on the server? What should I run on client? Maybe get confused. Don't let that stop you. You're going to save yourself a lot of time just by creating a project, utilizing self-kit. And again, you can take advantage of as little or as many features as you like. So that is it. So thanks, everyone, for your time. Hope to see you soon. Bye.