 Hi everyone, my name is Henry Lee, glad to be back at Svelte Summit again this year. Today I'll be talking about the mystifying client and server rendering in SvelteKit. Let's get started. First of all, update about me. I live in Tokyo, Japan. I'm working at a company called Henge. We're building cloud security solutions for companies using cloud services such as Google Workspace and Microsoft 365. So first of all, what is SvelteKit? I'm sure everyone is familiar with Svelte. Svelte is a JavaScript framework for building UI components. SvelteKit is a meta framework that wraps around Svelte and provides a lot of tooling to build build a complete performance web app, such as routing, server-side rendering, preloading, all that good stuff. It also supports a number of rendering strategies to cater to different needs. And so you might be asking, what are rendering strategies exactly? You might have heard about MPA, SPA, SSG, CSR, SSR. Like, what are all these alphabet soup, right? And there are also some highly technical words like pre-rendering or hydration. We'll get to that shortly. But first of all, I'd like to go with a bit of history of the popular rendering strategies over the years and how it evolved over time so that we can understand how it came to be as it is right now. So first of all, in the beginning of the internet, we have what we call the multi-page application paradigm and also static site generation. To be more precise, it's not really generation back then, is like authoring static sites. And this is the era where the internet and the user's devices were slow. So the user's devices were so slow that it is practically impossible to ask the browser to build a JavaScript application and render HTML based on what the data that we have sent from the server. The server has to help the client devices render the final HTML so that it can just render it in the browser. So the web were mostly showing static contents Interactions are done through links and forms but both of them causes full navigations So there are not much that you can do without going to the server to request for a new page. An example of this technology of using MPA would be PHP, ASP, JSP. And they are still in use right now, but they are quite a bit different from what SvelteKit is doing. This is how the MPA and SSG sequence diagram looks like. When the client requests for a page, we first check if the client is requesting a dynamic root or a static root. If the client is requesting a dynamic root, then it goes with the MPA approach, where it first goes to the database or API, get the user-specific data, and then return it to the user after it combines it with the static parts of the HTML. Whereas if the user is only requesting for a static root, usually the pages are already pre-rendered beforehand. So the server can just return that static HTML to the user. And every time the user interacts with the page, since there are no client-side scripting, it will require a new page navigation and all this flow will be repeated again. As you can imagine, these have a few drawbacks. First of all, full page navigation is quite inefficient. Pages are disposed of and redrawn every time. Every time you switch between pages, the browser will dispose the previous page immediately so that you can select a wide blank page while waiting for the new page from the server to arrive. User interaction options are very limited. links and forms are probably the only ones that are supported without using JavaScript back then. It's also quite hard to reuse code because pages are authored individually. That means that if you have common elements like headers or sidebar, they will be duplicated in these pages. And you can imagine that if you need to update one of them, you need to update all the pages that has that common element, which is quite troublesome. After a few years passed, we can see that the users' devices are getting more powerful, they can actually start doing something, and there is a need for more interactivity on the web The biggest case would be form validation Previously without any client scripting form validation has to be done on the server So if the user makes a very small mistake like for example they didn't fill any required fill, or they put in an email address but the format is slightly incorrect, nowadays we can just tell them directly in the browser that, hey, you did something wrong. But back then, since we didn't have any JavaScript, the request has to go to the server. server, the server say, okay, that's wrong. And then it redrawed the previous page, but it couldn't save the user's data. It couldn't re-render the user's input that they have put beforehand. So the user has to manually input the forms one by one again, which you can imagine is very, very troublesome. Other than that, client-side scripting is also useful for showing dynamic content, think of things like hover menu, animating elements, and JavaScript allows us to do that, but the server is still responsible for rendering the page. This is how the sequence diagram looks like now. The top part is for the first page navigation, and it's still pretty much the same as MPA, but the difference is that when we need to update only a small part of the page, We can create an asynchronous request with Ajax or asynchronous JavaScript and XML. It's what we call fetch nowadays. Back then, we need to use a different API called XML HTTP request. And back then, we use XML for response. Nowadays, we use JSON format for our fetch responses. So with this, we can add a lot more interactivity to the page. the user only needs to go to another page when they want almost the entirety of the page to change. But if we want to have a hover menu, we can just do it directly from the browser without contacting the server again. This approach already sounds better, right? But there were a few setbacks. In the beginning, there were browser wars between Netscape and Internet Explorer, and they each have their own JavaScript implementation. There were no standards, so what works in IE doesn't work in Netscape, and vice versa. So libraries were developed to abstract the differences. For example libraries like jQuery Moodools And JavaScript was not really designed for building complex applications The code is very tied to the page it not very reusable and due to its imperative API it can be quite hard to maintain and debug in a very complex application. Imperative here means you have to tell the browser exactly which element you want to to update and what action you want to add to that element. And we can see later that we don't have to use this imperative API anymore with modern JavaScript frameworks. So fast forward a few years, smartphones became popular. With it, the user expectation for interactivity has increased. They're used to native apps that are very smooth and interactive. This ushers in a new era of JavaScript frameworks, which were developed to build complex applications. So the entirety of the web app can be bootstrapped purely on the client. And communication with the server are no longer for rendering the HTML pages, but they are mainly to only get the specific data that the web app needs. So they can be communicating through APIs only. And the client-side JavaScript would be the one that is responsible for updating the page to reflect the changes. Examples of these JavaScript frameworks including Svelte, React, Vue, Angular, and so on. And it also popularized the concept of components to reuse code across the app. This kind of reuse is quite powerful because, for example, if you have a very similar common element that has very minor differences between pages, you don't have to create a new component every time, but you can use things like props to make it accept an input and render slightly differently. This makes JavaScript code modularization much better. This is how the sequence diagram looks like for single-page applications. Left one is for the first page load, and the right one is for the subsequent page loads. In the beginning, it's a bit slower. you can see that the first request to the server only returns a shell HTML, which is like a mostly blank HTML. And it also includes the framework JavaScript, which are returned to the client. The client parses the JavaScript, runs everything

 It renders the shell page, which is mostly empty, right? But if the page happens to require a user-specific data, since it's not included in the initial request, the client will need to make another request to the server get the user-specific data. And only after it receives a response from the server can it finalize the render of the first page. But consequently, like for subsequent page navigations, we don't have to go to the server to request HTML anymore, we only request for the data specifically that has changed. And the server returned to data not as HTML, but as JSON now through APIs. And so the client JavaScript is the one that is responsible for rendering the new page, which is not really replacing the previous page, but it's reusing most of the reusable components in the previous page. Think of common elements like sidebar, header. those can be reused and only the main part that has changed will be replaced with the new data. And this is what we call client-side routing and is very useful to give a very interactive user experience. So SBA is already quite good, but there are still a few drop-backs. Since JavaScript runs on the client, weaker devices might struggle to run it. They're also not SEO or search engine optimization friendly. Initially, initial response is just an empty page, so the web crawlers are not able to go to your page and index what is inside. And JavaScript also becomes mandatory with SBA because everything is done through JavaScript. This makes your application less available. Maybe your user is in an environment with weak network connection, and that causes the JavaScript to not become available. Additionally, SBA causes the initial page load to become slower because it has to go through the intermediate step of sending the client JavaScript first from the server with the empty HTML. So now you might say like, Henry, you've been complaining about all the different rendering strategies available on Earth. It sounds like every single one is bad in its own way. But maybe there is no one-size-fits-all solution after all. The truth is the web is getting more diverse and different sites require different technologies Like nowadays we use the web for a lot of things like for web apps for blogs for corporate sites for wiki even for games And so there might not be one rendering strategy that fits all these requirements. So different JavaScript frameworks approach this problem slightly differently. But they all agree on one thing, which is that we don't have to rely on just one rendering strategy. This brings us to the modern era with hybrid rendering. This model is also called transitional apps. This is a term coined by Rich Harris in his talk Have Single-Page Apps Ruined the Web. I really recommend having a watch at this talk if you haven't because it really goes into much detail about what is wrong with SBAs and what SvelteKit is trying to do to fix the issues that SBAs have. This approach allows for a mix and match of static and dynamic content in the same app. And in SvelteKit, rendering strategies can be configured on a per-root basis. So for example, some roots can be server-side rendered or we abbreviate it as SSR. Some root can be client-side rendered or CSR. Some roots can even be pre-rendered if it only contains static data. Now, SvelteKit's default rendering strategy uses both SSR and CSR. It expands upon the SBA concept by introducing a server to handle some tasks. Like, by default, it is only used for the first page load because it causes the first page load to be much faster than the SBA approach. But the difference is that since JavaScript runs on both the server and the client, a step called hydration is necessary to sync the data between the SSR-generated HTML and CSR-generated HTML, and also to attach event listeners to your DOM elements. So after that, the subsequent page navigations are done with client-side rendering, just like an SPA. This is how the sequence diagram looks like now. The left part for the first page load, it looks very similar to the multi-page application or the static page SSG diagram that we have earlier. But there is one small difference which is that what is returned from the server is not only the page itself but also the framework JavaScript The framework JavaScript is returned together with the HTML so that the browser both render the page that is already generated by the server and also run the client JavaScript hydrating the page making sure the data actually correct and attaching the event listeners But for the subsequent page loads, it enjoys the benefit that SPA have, which is like we send very little data through the network, and we only need to update a small part of the page instead of doing full page navigation every time. So when do requests go to the server in this case? The obvious part would be on the first page load of the session, but also like on subsequent server load functions and also form actions and API routes. Now these terms might be unfamiliar to you and I'll go through each one of them. So first of all, SSR on the first page load. This brings us the benefit of running load functions on the server first. This means that the initial backend request that required round trips to the server in the SBA model can be made directly from the server. The results are then sent to the client so that any fetch calls immediately resolves. This results in a big improvement in perceived performance as we can see in our lighthouse score. We can see like mainly the largest contentful paint score will be better. It also has the SEO benefits that the search engine can easily see the content of the page without running any JavaScript. With subsequent server load functions, by default the pages are all client-side navigated and client-side rendered after the first page load which helps us prevent having full-based navigation each time since hydration isn't free. However, some routes can be configured to run server-only load functions, like from the layout or page.server.js or ts. These are useful for load functions that needs server secrets like third-party API keys or load functions that need to make multiple API calls so so that they can be batched together in one server load function. The next case is for form actions. Form actions are used to progressively enhance forms so that they can work without JavaScript. In modern JavaScript framework, we usually use JavaScript to submit forms, but the web standard allows for forms to be submitted without using JavaScript at all, and this tries to mimic that behavior Inside the form actions we can add code like server validation input sanitization to make sure that the data is correct because we cannot trust only client validations before committing the changes. And depending on how our app is set up, we can either call the database directly or call an internal API from these form actions. And SvelteKit's fetch makes calling internal APIs easy because it does a few extra steps like inheriting the credentials from the client. And lastly is about API routes. These routes are endpoints that declare HTTP verbs like get, post, put, delete, any verb that is used for fetch, and they are declared inside plus server.js or ts files. They have a lot of use cases, but one of the most interesting use case for this is to proxy internal or any external third-party API to the client code. So traditionally, if you were to access a third-party API from your client code and they're both deployed in a different origin, you might encounter a course issue or cross-origin resource sharing. And by proxying those APIs in the same origin as the front-end code, which is by serving it through SvelteKit's API routes, you can fix this issue completely. You can also wrap several API calls into a single endpoint so that the client only needs to make one round-trip request to the server. Now, speaking of SSR, we can also talk about pre-rendering, which is a good fit for sites that are mostly static. Since everything is static, we can render it ahead of time, which in SvelteKit's case, it runs during compile time. So when you build your application, SvelteKit will try to crawl the site from the main page looking for links and try to pre-render any one of them that are explicitly marked as pre-renderable. We can also selectively pre-render only certain routes. Like, for example, this is useful if you have a blog which has, like, say, hundreds of articles. But normally, like, people only visit the latest 50 pages. So instead of having to pre-render, like, hundreds or thousands of pages, you can specify to only pre-render the recent ones, and then ask SvelteKit to server render the old ones as usual so that you can save on the build time. And this is done with an option called prerender auto.

 So with this abundance of options, you might think, which one should I choose for my project then? The answer is, you can mix and match them depending on your use case. SvelteKit allows us to use different strategies for different routes. So for example, we can disable SSR if we want to build an SPA, we can disable CSR if we want to build an MPA, or we can also use pre-rendering to render only static pages and have it automatically generated for us. Even with pre-rendering, we can choose to disable CSR if we want to, if we don't want to send any JavaScript to the client at all. These are configurable on a per-root or a per-root group basis, so we can combine different root groups with different rendering behavior in the same project. To illustrate the concept, I would use GitHub as an example. If you were to build a project like GitHub, we would have the marketing pages, like the homepage, the pricing page, the about page. These pages are mostly static. They don't contain any user-specific data. And they also doesn't really change that often. So we can pre-render these pages. And we can also specify CSR false so that we don ship any additional JavaScript to the user And the content pages is like the repo pages the organization page the user profile page So for these pages, we do want the benefit of SEO. We want them to be discoverable. And we can also benefit from giving the user the first initial load. We can also benefit from progressive enhancement. And therefore, we can use SvelteKit's default behavior. This is like the perfect example of the default behavior working well, because we can get the best of both worlds. And for the internal pages, what I would call the admin pages, this would be like an internal dashboard that the GitHub employees use to configure GitHub. These pages usually require a lot of interactivity, and the users are GitHub internal employees in a controlled environment, like in their own office with good network, with powerful device. So we can be more like SPA, like more client-side rendering heavy, and SSR would be optional in this case, because these pages doesn't need to be indexed by the search engine. This is an example of how we can configure the SvelteKit project to build this kind of app. So first of all we have the marketing root group The word marketing here won be part of the final URL So for example the homepage would be served from github from the plus page that filled in this folder So in that case, we need to make sure to wrap the marketing word in the folder name in a parenthesis so that they won't show up in the final URL. So the about and the pricing pages can also be here. In the layout.ts file in this folder, we can specify a prerender true and csr false so that these are all pre-rendered and we don't ship any JavaScript to the client. Next one is what I call the org or user root group because in github.com, you can go, for example, to slash Svelte.js to go to the Svelte organization. You can also go to my user profile, for example, github.com slash Henry Lee. So that's why we have a double name in the root parameter. And with this example, we can use the default behavior, which is SSR true, CSR true. We get the benefit of both worlds. And for the admin pages, for example, like the settings page or any internal pages that I'm not really familiar of, since they are like the internals of GitHub we can serve them for example from github slash admin or this can also be rerouted to another domain like for example admin With these pages they more interaction more like an app, a single-page app, so we can set SSR false in the layout.ts file. So a final note is about deploying the app. If your entire app is pre-renderable or the entirety of your app is a single-page application, you can use SvelteKit's adapter called Adapter Static to generate static files for the entirety of your front end so that it can be deployed to a static hosting provider like a CDN, for example. You don't need any server part at all if your app fits into this category. But if you require to render some dynamic pages, you need some code to run on the server, then you would need to deploy to platforms that support Node. SvelteKit provides platform-specific adapters for popular platforms like Vercel, Netlify, Cloudflare workers. There are dedicated adapters for that, but if you want to roll your own Node server, you can also use the adapter node that SvelteKit provides. And that's it for today. Thank you for watching. I hope this is useful and enjoy the rest of the talks.