 All right, so we're gonna kick off by having this talk by me. And it's gonna be a small introduction as well as a deep dive into actions and also a bit about stores. Let's see if I can get this working. All right. So let's begin. Yeah, so yeah. Yeah, and we're gonna start by talking about what Svelte is. So much like React and Vue, Svelte is a web framework that lets you write web applications in a more declarative way. But there are a number of differences that makes Svelte really shine. So let's first talk about what is common among these frameworks. frameworks. Like in React and Vue, you construct components and you snap them together much like Legos. But where Svelte differs is in how it wants you to build these components. There are a number of useful frameworks that are built into Svelte. And this also makes the framework a bit more opinionated. So here's a small Svelte component. Can you, is the size okay? It has to be because I can't do anything about it. So, yeah. So in this case, this is just like a regular small profile image component. Has a prop, an image. Takes like a URL. And then we pass that in. Let's see if I can get the mouse over here. Yeah, we pass it in here, and it has a script tag. It has a style tag, and then you just write the HTML just straight in the component. And what's good with Svelte is that it automatically scopes your styling, so you don't have to worry about mucking up other parts of your application when you're doing your styling. So you can just style an image tag like this without affecting any other image tags. And you don't have to use this order. You can put the HTML at the top you can put the style at the top whatever floats your boat And yeah so it a single file component framework which means you write one component in one file. It has built-in features. Sorry. Yeah, so it's, like I said before, it's somewhat opinionated in how it wants you to handle certain things, like styling, state management, transitions, animations. And these are things that you can use, and you just import them, and then you start building things. But if you want, you can probably, like, diverge from these opinions. It can be hard, but you can do it. So why would you actually want to use Svelte? For me, the biggest pro is in how easy it is to actually build things. You don't have to muck around with webpack or roll-up, unless you want to do more advanced stuff. You always have to touch those things, I guess. And I think this makes it perfect for juniors, because you actually build things very quickly without any boilerplate. So, it's simple, it's fast, and it has a great developer experience. How does it work? So, Svelte has no virtual DOM like React or Vue, which means that instead of shipping a large runtime, it just gives you a smaller set of functions that it uses to display your content. It can do this because it compiles the code into a more optimized version. So this also means that Svelte surgically changes just small parts of your application rather than re-rendering whole components like React or Vue. And also these features that are built in that I were talking about like the animations the transitions and so Since it a compiler it knows if you actually using them so it can just get rid of them It doesn't have to put it into runtime, because it knows beforehand what it uses. All right, so let's look at some features of Svelte. So the first one I was thinking we should have a look at is the bind feature. And Svelte has this concept of a two-way binding to things. It's really nice if you're working with a lot of inputs and you want to sync values between, like if you want to show something and you want to change it in an input. and you simply just bind to it like so. You declare a variable and then you just bind value to the variable and then you're off. You can basically just start writing it and you display it instantly in the component. All right. And this is where people get a bit angry with Svelte, maybe. They don't like the syntax sometimes. It's kind of mustachey if you've worked with that. So this is an example of an if block. You conditionally show stuff. It's pretty basic. So let's see what happens if we click on this thing. Like you would expect this, I guess. All right. So it also has an each block. We just solved the if block, this is an each block. It works like you would expect. Here we've decided to destructure the each and take an ID and a name instead of calling this a cat and then doing cat.name or cat.id or whatever. And it, like I said, it works as you would expect. Loops through the array. And here is where we get to a more interesting feature. Svelte has an inbuilt way of handling promises which is called an await block So this means that we can very easily display like a waiting component or a data component or an error component just by using this So when the problem is resolved, it shows the data. When it rejects, it shows the error. And while we're waiting for it, it shows the waiting. So you can see how this is quite nice to have. Build in transitions. We just import the fade function from Svelte transition. We conditionally render a div. We put the transition on the element that we want to transition on, and then we just, and we're off. It's that easy. Super neat. All right, let's talk about actions, which are the feature that I found more interesting when I learned a bit more about Svelte. It wasn't the thing that really got me into Svelte, but when I've learned more, this is the cool stuff, for me at least. So some of these actions can be a bit complex, but I'll show the examples and I'll link to all the examples after if you want to look at them in more detail. So actions are simple or more complex functions that are called when the HTML elements are created. These functions will receive the HTML node, where you can, for example, attach listeners and do other things like effective styling or move them or whatever you want to do. And you can use these to enhance your tags with extra functionality that can be reused in more than one place. We're going to take a look at a few examples to understand when and why you would want to use these. So this is basically what an action is. It's just a function that receives a node and it returns a destroy function that runs when the element is removed. So this is where you would, for example, remove your event listeners if you have any. All right.

 So let's say you have like an input field wherein the text is selected when the user clicks on it. This is like a perfect use case for actions. So let's see how it looks. So some functionality like this. Pretty neat. You might want to reuse it. And yeah. Not very advanced, but still something that you might want to reuse in an easy way, right? You want to extract it. So we can start by looking at our component. It has some text. So this is the component that we just looked at before. It has some text, as well as some styling. And, let's see, two input fields. And if you look closely, right at the top, we can see that we're importing two functions, select text on focus and blur on escape. And these names, to me, are very declarative and tells us pretty much what is going to happen when we apply them to our input elements. So if you look at line 8 and 11, if you can see that, You'll see right in the middle, there how we use these functions. We simply write like use colon select text on focus and that's it. And you have that functionality on your input element. So how do these functions actually look? So these are two of the functions. functions at the top, you have the select text on focus, and then you have the blur and escape and it gets the node. It does some logic to check if it like the handle focus. So, so yeah, sorry. So first we add the event listener and once we click or the focus event fires, we run the handleFocus function. Very simple. And then on destroy, we remove the event listener. And then it's basically the same for the blur on escape one. Okay another example Maybe we want to add a tooltip when we hover on an element for example That's also something that actions could help us with. Now, this is not a very beautiful tooltip, but you get the point, right? So how does this code look? Our action is conveniently named tooltip and looking at our headline tag in the bottom, we can see that this time we're also passing along an option object and in this case, we're passing along an actual Svelte component. And much like the last action, we're adding some event listeners and a couple of functions And, yeah. And again, the return function simply makes sure that we remove the events. Here's another example. Maybe we wanna build something like a modal where we can click outside the event. We're not strictly required to only use the node that we get passed in. We can also use the document itself. So with some logic, we can actually build something that fires on when we not click the node, if that makes sense. So this time we have conveniently decided to call the action click outside. Pretty self-explanatory. And the observant of you can probably spot that we're also using another feature here that we haven't seen before. If you take a look at line 10, we are using Svelte's way of doing things on events. So in this case, the click outside event. This could be like any of the inbuilt browser events, events like onClick, onHover, et cetera, onFocus. So let's take a look at the function. Oh, sorry. As usual, we have the event listeners on line 12. And then we also have a handleClick again, which runs on the document. You can see here we attaching the event listener to the document rather than the node So and then we do some logic in here to check that we actually clicking outside and not not inside the node Yeah. And so when it, when we click outside, it detects that we're clicking and it runs the function. And inside we're dispatching a custom event, which is the click outside. and we're passing along the node. So this is what we're also listening to on the same element in the actual component. All right, so that was actions, and now I'm gonna talk a bit about stores. And like at times you might wanna access state in several different components, or even in a JavaScript module if you want. And in Svelte, the solution to this is to use something called stores. So what are they? Simply stated, stores are just objects that have a subscribe method that allows components that want to be notified of updates to listen to value changes. So they're global in the sense that they can be imported pretty much everywhere. In components, in JavaScript modules, wherever you want. So what does it look like? So in Svelte there are a couple of built-in stores. We have a writable store, we have a readable store, and we have a derived store. And on the right here you can see how we're instantiating a store, which is simply just this second line. You import a writable and then you instantiate it on line four. We're starting with a value of zero and then we're logging and updating the value. So this set method is something that's built into the writable store. And notice also the dollar sign before the count variable here. This is Svelte's way of auto-subscribing to a store. Rather, you can also manually subscribe to a store, but it a bit more verbose and you usually don have to do that You would have to do that if you want to subscribe in like a random JavaScript file somewhere where you want to listen to it. All right, so first example for stores. We are building a small application that has a red box and a blue box with some text in it. And we have a button on top that updates the store. And you can simply work with the store in the same way as you would work with any other variable and then it will update in the other components as well. So this is the whole of the number.js file. It's two lines of code. And then the... And then the red dots felt or the blue dots felt. So these are just dummy components that we display the number in. And so you can see that we are not passing down the number here on line 12 and 13, but we're importing the store in the actual components. And so this is how it looks. And you can see that they're synced up, and once you double the value, it changes in the red and the blue box as well. So this is obviously a super basic store, but probably gets the point across. All right. So you'll probably get very far, actually, just using the built-in stores. But you can actually build... So if we think back a couple of slides, I said that a store was simply just an object with a subscribe method, right? So this means that we can pretty much build our own stores pretty easily, actually. And where we can do specific things. this might be a bit unclear, so let's look at an example. So this is a small application that has a store that shows us a value. So the zero. And the store also has a couple of methods on it. But before we get into details, let's check it out.

 So we can reset the number, we can increment, we can decrement. Nothing fancy. All right. Okay, so here's the code. First off, we're importing a couple of methods from the writable store. So the subscribe, the set, and the update method. These are all on the built-in store, so you can use those if you want to. And then we're just returning an object with the subscribe method and three more methods that we call increment, decrement, and reset. And in those, we're using the built-in methods from the writable store. So when we're actually using those in the application, we can just call the methods, and it will update the store accordingly, like you would expect. So we're calling the increment in one of the buttons, and decrement or the reset. All right. So if you've ever worked with observables, you can probably see some similarities with Svelte Stores. And it turns out that you can pretty much use RxJ as observables, for example, just like you would use Stores and Svelte. So let's see here. Yeah. So this is an RxJ as observable. That is just an interval that updates every second. And let's see how it looks. So this is how we would use it in Svelte. We would just import the observable. So I've, I should have named this observable probably rather than store, but anyway. And so this is how the store file actually looks which is just an observable Pretty neat Right So we talked about actions and we've talked about stores. What if you could combine them and actually use them together? So this example is a bit more advanced, but we can at least look at it. So in this case, we have an input field and we have a paragraph and then, uh, something that shows if our input contains a valid email. And so that that's not very amazing, I guess, but let's look at the code. You can imagine this being something other than an email, like a complicated, uh, I don't know, credit card number or whatever. So in our validator.js file, so that's the one to the right, let's see if I can get all the code up, we have a function that returns, so we have, so this time we have a function that returns both an action and a store. So you can see at the bottom it returns just a subscribe method to the writable that we imported online for here. And then the action attaches an event listener on text change for the input or wherever we put the action, I guess. And then it just updates with a true or false depending on if it passes the regex. And on the left, you can see that we instantiating the store and the action here So we passing in an email regex So the regex file just contains like a regex for checking email nothing more. And so the is valid is our, is our store and the valid date is our action. So on the input field, we just put the action and then we just show if it's valid or not. Pretty easy. Alright, so... So, in summary, there are lots of built-in features in Svelte, and they don't cost anything if you don't use them. Actions are advanced functions that you can reuse, and they are pretty neat. are used for state management. And yeah, I guess that's it. That's all for me. Thank you. Thank you. Any questions? No? Yeah. Yeah. So that's just a conversation. convention when using RSJS. So I could have skipped that, I guess. Probably a bit more clear. Yeah. Sorry? My least favorite part. I kind of like it. I mean, I'm biased because I run the meetup, right? So, but I don't know. There this one thing that you kind of need to know the structure of your components beforehand Like in React you could probably generate some weird component on the server somewhere and then just pass in the function and then render it You can't really do that in Svelte in the same way. But for me, that really is like... That doesn't happen very often. But if that's something you need, you probably shouldn't be using Svelte. TypeScript is another missing thing. A lot of people like TypeScript. If you need that, then you probably shouldn't use Svelte. Yeah, other than that, I think it's great. Yeah. A question about stores that have three methods, I guess. One of them was set and update. Yeah. What's the difference between set and update? So set basically just sets the value of the store while update gets the previous value. And so you use the previous value and you can increment it for example. Can you implement some sort of time travel to shift back the value and see the values? Yeah, I'm sure you can. I think actually it wasn't, Trister was, yeah, he was gonna talk at the first meetup, but he got ill, so we missed out on that. But he was, yeah. So that might be an interesting talk next time. Who knows? All right, yeah, anything else? No? All right. Then I'll give it over to Matthias.