 Thank you. Hi Svelters, my name is Jacob and I'm here to give you a peek at our upcoming Rally Fight 3. It's still a work in progress, so the final product may diverge a little from what you see here. So to get started, the first thing we need to do is create a new app. There are a few different ways to do this, but here we'll just use the CLI. Once we've created a new project we are going to open it in VS Code. Before we can run our app, we need to install our dependencies. We're also going to add a plugin called indexByName. This plugin lets us arrange our files by a number which we assign them, but more about this later. So we are now ready to run our app. To avoid getting caught up in CSS classes and styling, we are going to add PicoCSS, which handles all that for us. Next we are going to create a few pages. We want these pages to be ordered correctly, as they will be the basis for our generated navigation later on. The plugin you saw earlier will internally strip the number from each file or folder and assign the number to a meta property called Order. In Routify, meta is a collection of data assigned to each individual route node. To verify that our folders are working, we are going to create an index file and visit it on slash home. A module file is the same as a layout file. Often when helping users build modules, such as admin, account or products, the most effective advice has been to think of layouts as modules. These modules handle everything within their scope, such as guards, shared data and layouts. A module can of course still contain a layout, but the name should help suggest that there is no tight coupling between the two. Before we continue on, we are just going to copy-paste a few utilities to handle GitHub data. freeze the video or visit the repo for this project to see what the file contains. Next we have build time metadata. In Rarity Fight 3 it is now possible to generate metadata at build time. This is done by creating a meta.js file next to the component file. Here we are going to pull data from API and store it locally. Our fetch repos function is a small axis called to GitHub and below we have a function that converts MarkTam to HTML Lastly we have a function that converts relative image URLs to absolute URLs To consume our build time metadata, we are going to import the Meta Helper. The Meta Helper is a pseudo store, so we need to prefix it with a dollar sign. The URL Helper converts file paths to browser addresses. For dynamic pages like the project page we are about to create, we can provide slugs and query options in the second parameter. As you may have noticed, we are creating our project index in the module instead of in a dedicated index file. We are doing this because we want the project page to be a popup that overlays the project index. Before we create our project page, we are just going to create a slot to render the page in. For our project page, we are going to need a few helpers. The Node helper gives us access to the parent module, which then gives us access to our stored meta. To find the correct repo, we are going to find the repo that has the same name as our project. The project name we can find in our params helper. To make sure our project is placed as a popup, we are going to copy a small bit of CSS. We are also going to create a link to the parent page, which we disguise as a close button for a better popup feel. Now a common concern with pulling API data is costs and limits. In our case GitHub has a rate limit of 60 requests per hour. To get around this we are going to persist our data by calling fetch repos from our persist helper. What it does is store the return value as JSON on disk. On subsequent calls it will return the stored data instead of making new calls. Since we don't care about stale data in development, we are going to tell persist to update only on production builds. We can see our stored data in the persistent folder. Depending on use case it may make sense to commit this folder to GitHub. The concern for our built-time data is size. On a large scale project it would make sense to split the data into smaller chunks. We can do this by using the split helper. Here we are going to split the readmes into separate modules. Since we are using native server-side rendering for this example, we need to handle our dynamic imports in a module script. We do this by moving our logic into the module Since we can import component specific helpers outside of components we are going to get the current node and parameters from the callback instead Lastly, we are going to return our result readme to the component. Since our readme was converted to a dynamic import, we have to call it to resolve it. We can then access the readme through our component context, but we could also have use the helper. If we then go to our networks tab, we can now see that each REGME is imported on request. The last vital part of our small app is navigation. We are going to create a navigation file and generate our links based on the children of the module that imports it. To see if a given link is active we are going to use the isActive helper. We then need to create a module where we can import our page and navigation. After that we have working auto-generated navigation with active route highlighting. The last main feature in this video is multi routers. While Routify can have multiple routers share the same address bar simultaneously simply by creating a new router component, we are going to have only the active router use the address bar in this example. This gives us a cleaner URL while providing us with the benefits of multiple routers. To accomplish this we are going to use InlineNab instead of our usual router component. InlineNab returns the children of the current node as well as the index of the active child route. Since InlineNav is going to show all routers on the same page, we are going to organize them horizontally. We are then going to use the index to position the canvas at the correct page. As you may have noticed, clicking the Projects link brings you back to the Projects index. For certain use cases this would not be desired, and we would instead want to persist the router state. We can solve this by passing the nested pages to our navigation component We then add a custom function that returns the active route of each router You will now see that our navigation links to each router's active page rather than its root. The last thing we want to add to our app is a small progress bar that shows on page change. For this we are going to import Pending Route, which is a store that contains the loading route. If there is no route, the store is empty. Here we reset the progress to zero whenever there is a new pending route. We are also going to hide the progress bar whenever there is no pending route. After that we just need to import our loader in our main module. And of course since we don't have any slow endpoints, we're just going to simulate one. So there you have it, a peak preview of some of Rarify's new features. At this point I imagine some of you are thinking, does this work with server side rendering, what did it have to do with KID, and I didn't get half of that. So it turns out that covering some of the new features of Rowdyfy was far more time consuming than predicted, even if we only covered the tip of the iceberg. Rowdyfy follows a lego approach where everything is composable and replaceable. We aim to ship with healthy defaults, but under the hood you can extend almost any part to make it your own. So to circle back to KID, you can right now put your routify project inside of KID by creating a catch-all route and redirecting it to routify. We can do this at different endpoints for a multi-router solution, or we can do it at the route index, like we're doing here. As you can see, we're pre-loading a route in KID's load function. This ensures that our route is fully loaded for server-side rendering. In the near future, it may be possible to use routify in KID without having to use catch-all endpoints. this is something we're looking into with Ben. As for server-side rendering, Routify 3 supports both native SSR and third-part solutions like Spazer. If we disable JavaScript, you'll see what that looks like. So to wrap this up, thanks for watching and thanks to everyone supporting the Svelte community, and a big congratulations to Rich on his new job with Purcell. We will be showcasing new features on Discord and Twitter and we hope to see you there.