はい 今日私が話すのはそうですね X-State っていうライブラリーのことです皆さん Svelte 使ってる時ってどういう風に状態管理してるのかなっていうのがなんか View とか React だと結構ね これ これって決まってるけどSvelte ってあんまり決まってないからそれぞれいろんなやり方してるんじゃないかなっていうようなが僕の実家なんですねSvelte だとストアがやっぱりすごく優秀だし状態管理にもすごく使えるからストアだけで大体できちゃうからやっちゃうしそれでいいんだと僕は思ってます思ってるんだけども一つの代替案として今日ご紹介させていただくのがXステートXステートっていうのがステートチャートで状態を可視化すると状態っていうのがどうなるかっていうとこういう風な形で見えるようになるわけですねこれはまさに今日作ったやつなんですけども泣き虫赤ちゃんっていう存在というか機能をステートチャットにするとこうやって定義しましたこのチョーンって始まってるこのおしゃぶりここのおしゃぶり状態からスタートするんですねおしゃぶり状態の時に取り上げるっていうイベントをもらうとこれがピンってガンナキの方に行きますおしゃぶりなくなって泣くわけですねガンナキ状態の時におしゃぶり上げるとおしゃぶりに行くしお乳上げるとお乳に行くその間眠気カウンターが上がるとお乳もらっている状態に取り上げるというのはおかしいですけど取り上げるとガン泣きに戻って貸し付けた時に眠気カウンターが十分あればおねんねんに行くしなければ何も起こらないよっていうそういうのがこういうのがこういう形でですねエンジニアじゃなくても分かるような形で見えるようになりますそれを実際にどうやって定義するのかコードを見てみるとすごくさらっといきますけどもXステートのクリエイトマシーンというやり方でですねさっきのガンナキとかおしゃぶりとかお乳とかこういったステートをこういう形で定義してその下にオンっていうプロパティでイベントハンドラーを定義しておしゃぶり上げるガンナキの時におしゃぶり上げるとおしゃぶりに行くよっていうというような形で定義されています寝かしつけるの時さっき見た通り寝かしつけるとき ガン泣きで寝かしつけるを押したら眠気があるときだけおねんねんに行きますねそういったのはコンディション 眠気があればターゲットおねんねんで 例えばこれアレイなので コンディション何もないときはじゃあ例えばターゲット その他何かっていう指定もできますけど今回何もしてないので コンディションが満たされないときは何も起こりませんXステートで可視化するっていうのがコード内では可視化できてないただこれ見るだけでもやっぱりどういう状態の時何が起こるとどうなるっていうのが有限な形で見えるのである程度状態は把握しやすいんですけれどもXステート VS CodeのエクステンションをダウンロードするとOpen Inspectorっていうボタンで自分が作ったマシンが可視化できますで おしゃべりからスタートして取り上げるとこういくよとこういう形で色々遷移できるんでこの辺がいいところだと思いますこの可視化はベースコードだけじゃなくて彼らのサービスでやってるところもあって無料で使えるのでそういったところで非エンジニアでも使用を共有できるっていうのが一番の強みだと思っていますはい で こうやって定義したものこれをですね マシーンと言いますステートチャートではなくてステートマシーンなんですね この段階で一応ステートマシーンがその下に子供のステートマシーンとかを入れ子状態で作れることができるんですねそうなった時にこれをステートチャートって呼ぶんですけどもこのマシーン一つ一つはいわゆるマシーンと言います赤ちゃんにマシーンはちょっとあれなんですけどそういった概念ということでこれをどう使うのかっていうとですねこのマシーンを翻訳して扱うアクターというものがいましてここでXステートのインタープレットっていう関数を使ってこのアクターを作成して これをエクスポートしていますそれをスベルトファイルでインポートしてここでですね 例えば このアクターっていうのがサブスクリプション サブスクライブメソッドがあってスベルトストアと同じような使い方ができるんですねリーダブルストアと同じ使い方ができますなのでこのドラーサインのベイビースイッターとバリューが例えば今ガンナキだったらガンナキっていうストリングになりますこれを表示していますこの下に眠気この状態の中にさらにコンテクストっていって無限に状態を保存できる倉庫があるんですけどそれをコンテクストといいましてこれにアクセスして 眠いがTrueであればMaxと表示してFalseだったらなしって表示しているとこれ後で実際に画面でお見せするんですけどもさらにこのイベントイベントを全部E1でさっき定義したイベントがあるんですけどもそのイベントごとにボタンを作ってそのイベントの名前を入れていますこのイベントのボタンを押すとベビーシッターというこのアクターにsend これがメインのメソッドになるんですけどもここにイベントを送りますよとこのイベントっていうのは実際にはイベントネームなので例えばおしゃぶりあげるとかお乳あげるみたいなのがここに入りますさらにbabysitter.canイベントこのステートマシーンで今あるステートにこのイベントを渡すと何か起こるっていうのをcanで中かfalseを返してくれますがんなきの時に取り上げるっていうイベントを送っても何も起こらないですね何も定義されていないですその時これはstate.canはfalseになりますけどもおしゃべり上げるっていうイベントであればステートが変わるのでここはtrueになりますつまりこれを押した時に何か起こるっていうことが時にはリングちょっとテールウィンド使ってるんですけども外にアウトラインが出てきますということでじゃあ実際にやっています見えますかはいまずおしゃぶりからスタートしてますねで取り上げるが今使います取り上げるを押すとガンナキに行ってで お乳をあげると お乳に行きますこの時 お乳あげるあげても 押してももう何も起こらないですで 取り上げる 寝かしつける 大いなる目覚めみたいなこういうような形で使います今のがXステートのですね 説明ですで 僕 去年 スタートアップの方で一つスクラッチからサービスを作った時に状態管理がかなりややこしかったのでX-Stateを使いましたSWELTと一緒にそれで実際に使ってみたところですね使い勝手やっぱりいいとこもあるんだけどもSWELTストアでもうまくやればできるようなとどちらにせよ難しいんですよねどちらにせよ難しいんだから頑張ればSWELTストアでも同じぐらいのことはできるかなっていうような風に思いましたその場合パフォーマンスは当然SWELTストアの方が良くてやっぱり一つ一つマシーンにメモリ使えるのでどうしてもね 無駄であればできれば使いたくないけども やっぱりこの可視化できる状態管理っていうのはすごく有用なシーンがあってその後 機能追加するときにこのステートに新しく1個追加してそこに遷移するためのイベントリスナーとかアクションを定義するだけで機能追加できたりすると他の部分に全く影響を起こさずに安心して機能追加できるっていうのがやっぱり1つ良かったです先ほど言ったXステートとスベルトの関連性どうなっているかというとマシンを扱うアクターがいて 今こういう状態ですよという時にUIでボタンが押されたらそのイベントを送りますそうするとこの大泣きから このイベントでおしゃぶりの状態に変わりましたよとUIのスベルトの方ではこれにサブスクライブしているのでこの変化に対して適宜更新されるよということですね先ほど言いましたけどもこれすごくいいライブラリーでいいやり方なんですが使うか じゃあ皆さんにこれから作るアプリに対してX-Stateを使った方がいいかって言われると僕は手放しに使った方がいいよとは言えないですさっき言った通りの理由なんですけれどもただ一つそれより先の可能性があると思っていてそれがどういうものかっていうと最近僕が色々調べてやろうとしたのがこのモデルドリブンデベロップメントですモデルっていうのがまさにこれですね流れとして先ほどプロダクトマネージャーという話が出ましたけどもUXデザイナーとかプロダクトマネージャーがやっぱり仕様とかを作ることが多いと思うんですけどもその仕様が長い文章に書かれてた時にいろんなエッジケースとか書かなきゃいけなかったり なかなかうまくできなかったりするのでそこで誤解とかも生じたりじゃあ実装する人はそれすごい読むのかっていうと 僕みたいにちょっと怠け者だとあんまり読みたくないなって言ってちょっと流し読みして適当に作っちゃったりするっていうことがあるのかどうかわかんないですけど僕の場合あるんですよで UXデザイナー プロダクトマネージャーの時点でステートチャートとして 仕様作成するっていうことができますこれは実際にコードで書くんじゃなくて今まさにXステートのスベルトキットレベルのこの結構日進月歩の状態なんですけどもノーコードでこういったものを作ってそこから先ほどのJavaScriptのXステートコードに変換するっていうようなサービスを今まさに作成しているところなんですねこれができた時には彼らがどういう風な形でそれが実現されるか分からないですけどもエンジニアなしでこういったものを作れるようになるわけですよそこに対してですねコードレビュアだったりリードの人とかだったりがテストを追加して実際に実現可能なのかっていうのをコミュニケーションを取りながらテストとかを追加するX-Stateにテスト用のライブラリがありましてそれはちょっと後でGitHubのレポジトリ見ていただければそれも実装してあるので見ていただけるんですけども例えばおしゃぶりっていうステートがここにある時にはさっきの画面上の真ん中のとこにおしゃぶりって表示されてるべきですよねそういったテストのコンディションを一つ一つステートごとに定義することができますそれで実際にこのイベント取り上げるだったら取り上げるっていうのがあの画面で何をすることなのかっていうことをアクションとイベントを結びつけることを定義することでXステートのライバルが自動的に全ての状態から全ての状態への遷移がうまくいっているかみたいなものを生成してくれるこれがモデルドリブンのテストって言うんですけどもあんまり人気ないというかあんまり知名度が高くないんですけどもやっぱりテストも面倒くさいのである程度自動化できるよと実際にはやっぱり結構定義してるんで半分自動みたいな感じですけども1回ここさえ定義しちゃえば結構もうちょっと楽にテストが作れますここの人がそうやってテストを追加して最後にそれを実装者に渡すとそうすると実装者の人はですねやっぱりこれを見てどういう機能なのかっていうのも分かりますし最終的には彼が実装したテストが通れば最低限の第一目標は通過っていうことがはっきりしているので実装しやすいよとさらにこうやって実装した時には最初に仕様を作っているので認識のそこが起こることもないですしその仕様がみんな分かりやすい視覚的に分かりやすい言語になっているので例えばカスタマーサービスとかそういったところにも共有することだったり後でドキュメントを書く必要が結構減ってくるかなっていうここに魅力を感じていて最近こういった研究をしています以上です興味あったらぜひ一つ面白いライブラリだと思いますこれからどんどん人気出てくるんじゃないかなという気はしています以上ですありがとうございます本当に分かりやすい説明で助かります赤ちゃんのレアはまたに誰でも分かると思うのででは質問はありますか誰か濵地さんすごく面白い発表でしたこの状態管理のところ自分も最近迷う場面が多かったのですごく参考になりました1点少し気になったのがこのライブラリの名前がXState結構何というか抽象的な名前もしかしてスベレット向けってわけではなくて他のフレームワーク問わず使えるタイプのライブラリなのかなって思ってもしたんですけどその辺ってどうなんでしょう結構スベルトにガッツリ寄せて作られてる感じなんでしょうかはい 全く寄せてませんX-Stateはあらゆるライブラリで使えるようにしようとしていて一番使いやすいのはリアクトだと思いますたださっき言った通りアクターっていうものがドラマークで簡単にアクセスできるからそれだけを取ってX-StateとスベルトはMatch Made in Heavenみたいな 最強だよなみたいないうような言う人もいますが それは間違いですドラマークでアクセスするのは 今デモだからやったけど基本的にはやらない方が良くてアクターそのものにサブスクライブしちゃうとイベントを受け取るたびに更新されちゃってページ全体が更新されちゃうってことが起こるんですねなので特定の部分だけに毎回毎回サブスクライブしてそれでページで使うっていうのが大きいアプリではパフォーマンスのために大事だと思っていてだからほとんど結局プロダクションではその機能を使わないので特にスベルトと相性がいいってわけでもないですただ悪くスベルトがやっぱりスベルト自体がすごく融通が効くというか特に何でもできちゃうようなライブラリなんで特に悪いわけでもないですそういう意味でとX-Stateは全てのライブラリに対してうまくやろうとしているのはいいとこなんですけどそのせいでいろんなやり方があるんで落とし穴もちょいちょいありますのでその辺はちょっと気をつける必要がありますありがとうございますありがとうございましたそうですねスペルトのストアもエクステイのアクターもたまたま両方ともObservable Contractを使っているのでそれで使えるんですねドラのそうですね他に質問ありますかなければ私はあります。最近、スペルトFSMっていうライブラリがあったんですけど、それはアプリ全体的じゃなくて、一つのコンポーネント内の状態を、そのまあACTORMODELでモデルする形なんですけどそれについてどう思いますか?あのやっぱりあの全部エクセイテやったらちょっとスペルトっぽくじゃなくなる場合ありますねあのコンポーネントだけコンポーネントの状態だけFSMで管理してたらそれがなくなるのかなって思っていますありがとうございますそのSphereとFSMっていうのは別にXStateを使ってるわけでもなく自分の独自のインプレメンテーションでっていう感じですか?そうですねすごく簡単でXStateのFSMに似てますけどそこまで似ていませんはい それちょっと興味ありますFSMっていうのはfinite state machineっていう意味で有限のステートマシンここに これまさにX-Stateもそうなんですけどもこの状態の時にこのイベントが来ないとこっちに行かないっていう無限の可能性を排除したものがFSMステートマシンでそれがいいところなんですけどもX-StateとSvelteの相性があまり良くないんじゃないっていう良くないんじゃないっていうか 良いわけじゃないっていうのが今テオさんも多分僕のお手伝い 去年してもらってすごく思ったと思うんですけれどもスベルトっぽい書き方じゃなくなる部分が やっぱり多々ありますそのスベルトFSMがそれを解決して いい感じにするんであればいいと思ってて すごくいいと思ってて最初僕も去年やった時にこのアプトとスベルトの このコンポーネント自体をアクターにしたいとかそうしたら いわゆるこれアクターモデルって言うんですけどもオブジェクトオリエンテッドプログラミングのお父さんというか元になったモデルですアクターに対してはさっきチラッとしか書いてないんですけどもアクターっていうのは自分で状態を管理しててそこに対して他から関われるのはイベントを送ることしかないんですねメッセージを送るとそれに対してここで定義された通り何かしら起こるとそれだけっていうことをいろいろ制限したのがアクターモデルって言うんですけどもスベルトのコンポネントをアクターモデルにするっていうのはやっぱりちょっと夢があるなとは思っていましたただそこまでしなくてもいいかなというところで僕は落ち着いたんですけどもSVET FSMのちょっと興味ありますね後で見てみたいと思いますただ何ですかねX-Stateの結果的に一番の魅力は僕は外部への共有最後にいった部分になってくるかなと今の時点では思っているのでこの可視化の部分だったりそうですねそれでテストを作成できるかとかそういったところになってくると使い分けにもなるかもしれないですねテスト部分だけ仕様とテスト部分はX-Stateで作って実際の実装はスベアとFSMでもいいかもしれないですしなかなか面白そうだなと思っていますすいません 長くなりましたけどありがとうございます 本当に勉強になりました