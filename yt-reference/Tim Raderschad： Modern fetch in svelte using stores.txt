 Hello there Swell Summit, my name is Tim Radarschat and I'm a full-stake web developer from Cologne, Germany. Alright, don't worry, there are no technical difficulties here. But that little thing we just saw right there is going to be today's topic in my talk, Modern Fetch and Swell using Stores. and I personally associate two things with loading spinners. The first thing is being on a train in Germany and trying to watch a Netflix movie and the other one is single page applications. And even though most of you hate loading spinners or find them annoying, they're actually an improvement to what we had before. So before we created and used single page applications websites consisted out of out of plain HTML and maybe a bit of JavaScript so when you switch from page 1 to page 2 everything had to be downloaded from the web server and the only way of knowing whether your website froze or your connection is just slow was the loading indicator which is provided by your browser in modern SPA's we are able to switch between pages on the client which means we don't have to download a new page when we switch from page 1 to page 2. So because the skeleton of the page just stays the same and we just download the data which will change between page transitions we're able to provide visual feedback to our user. Which is great! Research has shown that the user's attention starts to wander after about one second of waiting. But it also It also has shown that displaying spinners for actions that take less than one second will make users feel insecure about what happened because something just popped up on their screen and they don't know what that flash just was. But I personally think that completely avoiding loading spinners is the best approach. So there's a technique called Stave Viabilabilitate, which we are going to apply to data fetching in Swell today, and it looks like the following. First of all, let's have a look at this slide here. So first of all, it's the first fetch and we're gonna start off as a user going to example.com. We're gonna visit the slash products page. While we visit the page, the server or the website will check its internal cache, whether there is already some data. Because there is no data, it's the first time us visiting the website, it's gonna display as a loading spinner. Meanwhile, while we see the spinner spinning, the website is going to fetch some data from the slash products endpoint. After it successfully got the data, it then sets and updates the cache. And after it updated the cache, it will display the news data to the user. Well, to be honest, this kind of looks like a regular fetch request, right? Except we have some overhead of getting and setting the cache. So let's see where it really shines. So this is a subsequent request so basically the second time us visiting example So here we go again Example we visit slash products Now the page is going to check its internal cache and it will get a hit because there was already, the cache was updated and we visited a page. So now the app will display the news data. No loading spinning required. And the user, like we are right now, able to just play on the page and work with the data. But in the meantime, there have been some background magic as I call it. The page fetches the newest data from the product's endpoint and then sets the cache. After it set the cache, it will update the data on the page. So it will just swap out the stale data, which is like old, and it replaces with the freshest data. And this is great because the user doesn't have to wait at the beginning, also has the news data after a certain amount of time. And I totally understand if you don't see the advantages of using this right now. So my approach of showing this is just to see some code and fiddle around. So let's get started. Okay guys, enough theory crafting for today. Let's get into the practical exciting stuff. So I created a small example, which is really simple yet in my eyes. eye-opening. So I created this endpoint which just returns the current date and time after a second of delay because in the real world there will always be a delay and when you develop on localhost you may not just see the loading spinners and experience the pain which real users will have. And then for the front app to implement our new feature I just created a small single page application which has two basic pages. One of them is the old fetch, the old way of data fetching and then if we switch the page it's the new fetch. And as you can see as soon as I load the page it then goes off and requests the current date and time from the server but we're only going to display the time so we can actually see the data changing but we will get into that later on so let's take a look at the code so first of all we have this old fetch page right there and I chose the await way because I think the evade syntax is really really clean and swelled and is really easy to read so we have a response here while it's loading we're going to display a loading spinner if then we got some data we will show the current time so the date is parsed to to date time spring and if there was an error we're just going to display an arrow and the way we get the data is a nacing function up here which just fetches the newest data passes the body as json and then returns the data we then have a local variable right here called response which we then assign the return value from this function as easy as that But let have a look at the new fetch So the new fetch right here is basically the same except we don't have the getData function in our component. We refactor it to the Fetcher.js file. And I think that's the exciting part as well. So let's have a look right here. So as you can see, it's literally the same function that we had in the old fetch component, a part that we get the URL in here as a parameter. And now let's refactor this code because we want something new, right? And my approach is to use stores. Stores are an easy way from Swell, which allow PubSub, which allow to work with the PubSub pattern. PubSub is short for publish and subscribe. This means that a component can subscribe to something and then we can publish events. So for example, one event would be, I started loading. The other one could be, I got data. Or another one could be, I got an error. So let's do that right now. First of all, we're gonna import writable from Svelte slash store. A writable is a store which can be rewritten. and there's also a readable store, but we actually need to update the data. So let's create a new store in our function and we need to initialize it with a new promise. And in this promise, we need to make an empty executioner function because if we just leave it as it is, it's resolved instantly. But we actually want this to have the loading state at the beginning. And we also need to remove the async part right here. Because we're not going to return something except the subscribe function. So there's no waiting for the data in our application. And instead of returning the data here, we're going to return the store. So now let's have a look at the new fetch file. So as we can see here, the response is now a writable promise. And to subscribe to a store in Svelte, we need to use the $ syntax. So let's replace the response here with the $ response. And if we now switch to the new fetch page, there should be nothing, which is right, because right now our store is just empty. So let's change that by creating a local function called load. We're going to mark this function as async so we can use the clean await syntax in here and just avoid callbacks. So let's move the data loading part up here and now we can use await in here again. So now we got in our load function we're actually loading the data and parsing it again. What we now need to do is to update our store using star And now we need to return a resolve promise so Svelte knows that the loading is done and we just got data and then we're gonna return the data. Now we only need to call the load function and if we now visit the new fetch page it actually works just as before. Let's wrap it up again. So we created a local load function which is async and so as soon as we enter our page we call this load function and in there we are asynchronously getting our data and parsing it and as soon as it's done this could be at any time we're going to update our store. So as long as the data is loading there will be a loading spinner and yeah that's basically the same as before but but with a bit of overhead. But let's make this really mind-blowing now. First, I'm gonna create a new map in here, which I'm gonna call cache. Well, technically, it's a map is basically just an object, so it's a key value store, but it offers some really nice and easy syntax to work with it. And if you remember the diagram I had in the slides before, we need to in here we need to do the caching part so right here we're gonna check our cache whether our cache has something saved so we're gonna say cache dot has and then the URL is the unique key and as we had in our diagram if the cache has data we need to return it so if there's some data we're gonna update our store and we're gonna do that with a resolve promise again and right here we to get the data from the store so we're going to say cache.get and then the URL. Okay this should still work and nothing changes obviously because we're just checking if there's something in the cache but we never said something in the cache so let's do this here as well. Right here we're going to update our cache after we successfully get some data. So we're going to say cache.set and then we need first we need to provide the key which is the URL and then the data. And now let's have a look. We're going to go to the new fetch page and it's loading. Now we're going to do the subsequent request and see the magic heaven. Boom! There wasn't a loading spinner. Why? Because we instantly returned the data from the cache and we didn't need to fetch in the first place. And if you look closely at the time, if I go back here again, you can see it updates after a certain amount of time and that's the revalidation while the data is stale and then updating the data it's great right and there's no need to use any other syntax or not use the cleaner weight we can just use it as it is and just update our workflow by using fetch thank you very much for listening and for giving me the chance to have this talk right here I wish all of you a great day and bye bye.