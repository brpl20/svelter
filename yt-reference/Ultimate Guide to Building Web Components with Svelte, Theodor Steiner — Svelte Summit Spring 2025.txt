 Thank you for being patient. So actually last night we had this speaker dinner. And this being my first ever conference talk, I was like asking for tips. And everyone was like, don't put too much code on your slides. Obviously Suffet and I didn't get the memo, so I put up this QR code. So if you have trouble with eyesight and want to follow on your, I don't know, smartphone or small screen, just copy this and follow along. I hope it's big enough. Otherwise, we're going to zoom in and try to make it work. So I titled my talk The Ultimate Guide to Building Web Components with SELT. If you've ever been nervous about giving a talk, try putting Ultimate Guide into the title. really ups the game a bit. Yeah, but before you're going to get to watch me crash and burn, I want to get a bit madder for a second and talk about why you even want to build Svelte, build web components in the first place. Since most of you are probably like devote disciples of his, I thought we could maybe get Svelte's, I mean Rich's opinion on this, but obviously I'm afraid of live interaction so I scoured the interwebs for quotes from Rich to get him to sort of endorse web components and hype you up to use the platform before we start. So let's see, what do we have here? That's kind of anti, isn't it? Surely Rich must love web components. I mean, Svelte 3, the API was modeled after web components. So maybe there's like a different quote. What do we have here? If I could build someone for the time I've spent working around web components, I'd be a rich man. You're rich indeed, but you're not as pro-platform as I thought. Come on. The right answer is don't use web components and you never have to think about this madness? Damn, that's some disgusting anti-web components propaganda right here. But of course Rich would say something like that I mean look at his lizardy face He is one of them Big JavaScript They want you to send bloated bundles to your users so they can feed on your bandwidth So let's get somebody else to, like, endorse this. Use the platform. Where are my Web Component fans? Come on. Yeah, yeah. So who am I, you ask? So my name is Theo Steiner, and I'm a software engineer at LY Corporation in Tokyo. For my day job, I get to work on Line Messenger, which is the most popular messenger app in Japan with over 150 million monthly active users. I'm also a Svelte ambassador, which basically means I'm a certified Svelte stan, and have been for years. Svelte was actually my introduction to web dev, and I owe a lot to the framework and the awesome people behind it. So to give back, I try to help organize meetups in Japan. If you're ever in the area, feel free to hit me up and join our meetups. And of course, I work with web components on a daily basis, hence this talk. And also, I can't believe I have to say this, but I'm totally not a JavaScript-loving reptile in disguise, I promise. So now that you know that my opinion can be trusted, Let's undo the damage Rich has done with his statements and look into my tweets to sort of get the record straight on web components. Pretending web components have soft front and is just so disingenuous. Wait, what? That one must have snuck in there by accident. I thought we wanted to be positive here. Building accessible web components is the kind of task that makes maintaining COBOL mainframes look like a dream job? No, this is getting worse by the minute. Okay, I give up. Big JavaScript won. I have to admit, web components are not the silver bullet some folks hope them to be. It's true, in most cases you probably shouldn't even use them and stick to a modern frontend framework like Svelte. But while they might not be the future of all web development, they do have some nice properties that make them invaluable for certain specific use cases. So please don leave the room just yet So an ultimate guide to building web components would not be complete without giving a primer about what web components even are The name web components actually is a sort of umbrella term for a collection of APIs that allow us to build components that is reusable pieces of UI using native browser features. While we're normally confined to using only HTML elements in our templates, the custom element spec allows us to extend HTML with elements we can implement ourselves. So for that, we have to extend a base HTML element class, and once mounted to the DOM, those elements we implemented ourselves will get notified about state changes via lifecycle methods. In order to compose with other HTML elements, the spec allows you to define holes in the markup. If you've ever used Svelte before version 5, you're familiar with the slot element. And the last API that is part of the web component standard is this thing that has way too cool a name for what it does. It's the shadow DOM. Simply put, it allows you to encapsulate your components markup and styles. So they're not affected by outside CSS, JavaScript whatsoever. And this encapsulation is precisely what makes Web Components so powerful and worth using, in my opinion. While they might not be the best choice to base your stack on in a vacuum, in practice, things are messy. And we don't always get to work with nice unified tech stacks. We might have varying tech stacks across products, or even ship our code to third parties where we have no control over what technology they are using. like they might even be using React for this stuff. And this is the use case where web components most shine. Not like the name suggests as components that help you organize individual units of code, but rather as an encapsulation tool that lets you distribute individual pieces of UI without having to worry about compatibility. For example, at Line, we use custom elements to share reusable UI components between different products. That way, even if the frameworks or framework versions differ across products, we can still share an implementation. And another use case that comes to mind is like sort of this widget kind of use case where you have small self units of code like let say a checkout UI or something that you can just drop onto your page or like on the customer's page and it just works out of the box. Now, this is the slide where I thought you might have problems reading. Is everything okay? Okay, I see some thumbs up. So I first wanted to go over how you would build web components using vanilla JavaScript. While the code on the right side looks a bit convoluted, this is actually just like half of the code needed to build a simple counter component where the value of the counter can be changed. Like the value of the counter is incremented by can be changed. So, oh, missed 42 by one there, off by one error. But we can, like, just increment this, and this is a web component. To Safed's wife, web components don't have to be ugly. I just couldn't bother to write CSS for this. So let's go over the code and look at what we're doing. So in this example, we subclass HTMLElement, the class I told you about earlier, to create our own MyCounterCustomElement class. and to register this custom element we need to use one of the APIs I talked about earlier. We call customElements.define to register the constructor for the custom element with the custom element registry and after we call this with the tag name we can now use myCounter as a tag in our HTML elements and it will be treated as a native almost like a native HTML element. And upon creation, the elements constructor is called, and so for example, if we call document.createElementAPI, the element is instantiated, and the properties you see right now are like instantiated, and to actually, like after calling createElement, to render our element, we need to attach it to the DOM somehow, for example by appending it to the document body. And once we do this, the connected callback lifecycle method is called. And this lifecycle method is telling us that our element is now part of the DOM. In the example, we create a button element and append it to the shell.

 shadow root of our custom element. We also set up an event listener for the buttons click event, and you can sort of think of this connected callback as the equivalent to a Svelte Components on Mount Lifecycle Hook. Except that since web components don't conveniently render for us, we have to do the rendering manually, and we're doing this in the render function below. So how do we get updates when the DOM changes? While our component is connected to the DOM, we are notified about changes to the attributes of our element via the attribute change callback. Please note that since attributes are always strings, we need to convert attribute values to numbers before storing them in our components increments property because we want to increment numbers. By the way, this is not a safe way to convert something to a number, so please don't try this at home. and then we recall because we also don't have reactivity in vanilla JavaScript we recall this.render to reflect the change state in the UI and the last lifecycle method I want to go into is the disconnected callback this one is called whenever the element is removed from the DOM and this lifecycle callback is for cleaning up stuff we added like added events, global event handlers or something, we should clean them up in this component lifecycle hook. So quite a bit of code for quite a lame component. As you know, with Svelte, we don't need nearly as much code. It's always nice to see how we went from, I don't know, 40 lines of code to 10, less than 10. Yeah, so if you don't want to use, want to write imperative spaghetti code, use Svelte. And how can we get this to turn into the same custom element though? So we have this nice declarative piece of code. Wouldn't it be nice if we could produce the same functionally, the same component from this? And literally all we have to do for this to work is adding custom element true to the compiler settings in our web config. Thank you for coming to my talk. You can... So if we turn the setting on and we build our project now an element property is newly added to the default export of our Svelte component And this property contains the constructor you need to register your custom element with the custom element registry So we can once again use custom elements.define to register the component with the Windows custom element registry. and once we've registered it, all that's left to do is use our tag name and voila, you have it. Our SvelteBit web component is ready to be used within any context, be it vanilla JS or another framework like ReactorView. And in fact, I know it's a sacrilege, but the slides right now, they are built with using Vue JS. And as you can see, a SvelteBit custom element is being rendered seamlessly. within the slides. But there is one issue with the code we just wrote. Like, tip of mine, always try to test your code before you ship it, because if we try... Oh. Okay. This is... I mean, it's breaking, but it's breaking in different ways than I anticipated. So on the slides I see in front of me, this is not synced for some reason, using slidef. So what's happening is the one is appended to the zero rather than added to it because it's a string and we forgot converting it. So on my screen, I promise, a one is being added like every time I press add. So it's 0, 1, 1, 1. It looks like I'm telling you something. I'm telling you that my slides are broken in binary, basically. So instead of adding numbers, what we seem to be doing here, or what you trust me to be happening here, is that we're concatenating them instead. And this is because we pass the increments prop via an attribute to our custom element. And as I told you earlier, attributes in HTML are always strings. And Svelte has no way of knowing which types we want to use to convert our attributes to props So it just doesn do anything and we pass the string right along and obviously it the wrong type for the prop here So what we need to do is we need to give Svelte a hint. And we can do this by using the custom element attribute of Svelte options. So if you've ever seen the Svelte options element, it's like an element to provide additional configuration for your component, and it has a custom element attribute where we can set configuration for our custom element. And it has a props property, and that allows us to specify what type conversion we want to run for each prop. Now, values pastoral component via the increments attribute will be converted to numbers, and everything should work as expected. You have to once again trust my word for that. While we're at it, we can also add a starting value to our counter. And while props are camel-cased in Svelte, HTML attributes are case-insensitive. And I was trying to tell you how you can get Svelte to know about how you want to convert your props into attributes. And since attributes are normally kebab-cased on the web, we need to somehow convert our camel-cased props or tell the Svelte compiler about how we want our camel-cased props to be converted. And for this, we can use the attribute property of the props property. And then there's also reflect, which allows our attribute values to be reflected back from our component state. And there is a whole range of other settings we can pass to Svelte options. I don't find myself using them very often. For example, the name property or tag property allows us to skip manually defining the custom element with the element registry. However, since registering the same custom element multiple times throws an error, I prefer doing this manually checking for existing registrations beforehand. You can also use the shadow property to opt out of using the shadow DOM. And finally, if you really need fine-grained control over the custom elements, you can use the extends property to modify the base class of the custom element. And since event handling was overhauled in SWAT 5 and we no longer use create event dispatcher but rather pass events down as component props we sort of also need a novel way of dealing with dispatching events from web components because obviously we can pass down event handlers via attributes And what we do instead here is we use JavaScript's native way of dispatching custom events, and for this we use, inside our component, we use the host rune to get a reference to the host element, and then we can call the dispatch event method of the host element to dispatch an event that we want to dispatch. Oh, yeah, it's showing up in the slides as well, the custom event dispatching. So exactly how is our Svelte component turned into a web component, you might ask. And you might think that Svelte as a compiler could generate code along the lines of the vanilla web component I showed you before the power dropped out. And in fact, up until Svelte 4, it actually used to do something along the lines of that. But that approach came with quite a few issues and gnarly edge cases. So maybe I can do this without slides. So Svelte is like trying to employ this sort of wrapper approach where it's like a matryoshka where you have like a empty, bare-bones custom element on the outside. and inside the custom element you have a Svelte component. And the custom element on the outside is basically just an empty shell that wires up the lifecycle of our Svelte components on the inside. So on creation, once again, the outside wrapper creates the shadow DOM and registers all our props as attributes to be observed. And when our Svelte built element connects to the DOM, our wrapper components waits for a microtask for reasons you have to ask Simon. I don't really know why it does that. And to ensure all children are mounted. And then it simply mounts our component as a regular Svelte component to our host Shadow DOM. And whenever an observed attribute changes, the wrapper will use the converter specified in the Svelte options to convert the new value to the correct type before then passing it on down to our thread component, the type converters we just specified on the slide earlier. And finally, when the wrapper is disconnected from the DOM,

 it once again waits for a microtask. This time I know why it waits for the microtask. It's to ensure that we're not just moving places in the DOM. And if the web component is actually not reconnected to the microtask and not moved inside the DOM but actually removed, the nested cell component will be unmounted and effects will be cleaned up. And sadly, this is, I think, why Rich tried to sabotage our talk. Building web components with Svelte is not all sunshine and rainbows. While SvelteKit comes with a package mode that allows you to easily build Svelte libraries, that mode actually doesn't allow you to compile your components before bundling, so if you want to ship web components, you have to set up your project from scratch. While this is not a blocker per se, it does mean you have to do a bit of footwork to get started, and you need to know your way around build-tos. Another issue is with configuring your attributes through the Svelte options element as I showed before the power drop-down. For this, you have to manually add Kebab case attributes and type converters for all of your props. And if you have a large Svelte component you're trying to web componentize, that's quite a lot of boilerplate. And especially if you use TypeScript, it would be really neat if the compiler could just automatically set the right converters and keep up attributes for you. And credit where credit is due Vue I not paid I not paid chill I love Svelte Orange gang But Vue handles this beautifully and they leverage the information provided to define props to automate this step entirely. And finally, the last point is more of a web component issue rather than a Svelte-related one, but there is currently no way to render your Svelte build web components on the server. And as you can imagine, this is a huge blocker. Like, if you're using SvelteKit and you want to, like, SSR your components and the web components can't even be rendered, and even worse, like, if you import them, they might crash your server, it's not ideal DX, to say the least. And Google's lit library, they provide an experimental way of rendering lit built web components on a server, but since web components are a browser standard, for now there is no, like, universal way of doing SSR for them on a server, especially outside Node.js. And I'd hate to end this talk on a negative note, so I'm happy to share that I was working on some userland tooling. While it is still far from production today, I would like to announce the alpha release of Swap Components. And it's basically a collection of utilities that aim to improve the problems I just talked about. and widen the possibilities of building web components with Svelte. So I set out to tackle all three issues I just talked about. First of all I wanted it as easy as possible to get started building web components with Svelte I wanted it to be as easy as starting a new Svelte project So to solve this, I created a template project that you can just dig it off of GitHub, and I hope you should be good to go. I actually built this last night at 2.30 a.m., so if there are bugs, it's not big JavaScript, it's me. and also dig it. That's a nice blast from the past, from old Svelte days, right? So the second issue I wanted to tackle was all the boilerplate you need to write to turn your props into attributes. And since Vue does this so beautifully by leveraging type information, I tried to do the same and wrote a roll-up plugin that does just that. So if you use TypeScript, it should just automatically infer all the correct settings for you, and you don't need the Svelte option element. And that's included in the template. So if you do get that, you should get it. And finally, this is very experimental. I know Svelte people are really, like, early to adopt stuff and push it to production. Please don't. So, yeah, this is very experimental, but I took a shot at implementing the element renderer registry API that is proposed from the lit team, actually, to facilitate Node.js rendering of web components on the server. It comes with many, many moving parts, and it's quite the rabbit hole, so you probably would need an entire talk without power issues to explain this but basically it allows our authors of web components to provide an element renderer, and that can be used in server-side JavaScript environments, like Node, to render web components, and I also created a way to build those element renderers for Svelte build web components. For that, we need, as I said, quite a few moving parts, We have a Vee plugin that lets us manipulate custom elements inside our Svelte templates and some server-side runtime JavaScript that we need. And also we need to modify the build output of our Svelte build custom elements. So we don't want to actually run something like JSOM on the server, so we just want to concatenate strings. For this, we have a special SSR entry point into our custom elements to do SSR. And if you're interested in any of this, please play around with the template and let me know what you think. But please don't ship it to production. Like, I haven't thought about security implications and SSR is like a cross-site rendering minefield, so don't. Don't. And, yeah, that's everything for today. Thank you for listening. Thank you for fixing the power outages. Thank you. All right.