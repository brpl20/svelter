 Hi everyone, I'm David Hunt. I'm here to talk about behavioral testing with a gherkin, or cucumber as it's sometimes called in SvelteKit. Now I've long time been a fan of behavioral testing and Gherkin syntax in particular and I'm excited to share some of that enthusiasm with you. Hopefully ten minutes from now you'll have a good understanding of what Gherkin is and the two important points about it and the two devious problems that it helps to solve and how to get it setup with SvelteKit using Quick Pickle, which is my new baby project on GitHub, and then how to use it for testing your websites and or components. So I'm going to be using the Svelte demo app that comes with the npm create Svelte at latest, and we're going to be looking at the Svirtle game. So hopefully you're familiar at least a little bit with that, and everything that I do today will be available on GitHub. So let's take a look at the Playwright tests that the demo app ships with. Here it is on the right and on the left is the same test in Gherkin. Note the keywords like feature, rule, scenario, given, then. These are the things that most people associate with Gherkin syntax, but as you'll see later they're not really that important. What I would like you to understand is that this file runs as a test. So if I do pmpx vitest, then this will run, and you can see right there that our frontpage.feature file is passing. And it does this because behind the scenes, these steps are translated into step definitions. Here's the first one, given I am on string. And then that code runs as the tests run. And these step definitions can be reused across all your tests and even across projects. So if we wanted to add another rule that says that, uh, the site must function without JavaScript, we could copy this same test under a tag that says to turn off JavaScript. And then in the future if someone devious should change our sites and break it so that it doesn work without JavaScript when we have this test it run again It'll show us that our site doesn't work without JavaScript. And then that test is failing. So even in this brief overview, you can see the two most important points of Gherkin syntax. You write your tests in natural language, i.e. English for us or whatever language your team speaks. and you write reusable discrete step definitions with minimal code. And taken together those two key points, Gherkin mitigates the two biggest problems in integration testing, which for the purpose of being memorable we'll call the fingers pointing at an imaginary moon and who tests the testers. Alright, so the first problem, fingers pointing at an imaginary moon, you probably recognize that it's a refer to a Zen Buddhist idea that words are like a finger pointed at the moon. They can't hold the essence of an idea but are mere tools that we use to approach a truth that is inherently greater. And your functional requirements are like this, except that the moon doesn't even exist yet. You haven't built the product. So it's incredibly difficult to reach a common understanding of the essence of your project, i.e. what does this do? And Gherkin helps with this because it gives you a common language, a common lexicon that everyone can use to both describe and verify the most important aspects of your application. And then the second problem, who tests the testers? So imagine for a moment that your testers all perfectly understand exactly what you want. I mean it can't happen in real life, but you know imagine it and they're working hard to make that every time code is created or changed it gets tested. The problem is ideally the test code then should just never change, but functionality changes all the time. So if your integration tests are written in code then they're changing with the functionality and if they're changing then you should test them and before you know it you have two projects. One of them is your original project and the other one is the project that you use to test the original project and very quickly integration testing becomes simply unmanageable. So let's take a look at how this works in real life by using Gherkin to test this fertile game. And for this purpose I drawn up some functional requirements and we going to convert them into tests both in Gherkin and also in Playwright And in Gherkin this is as simple usually as just deleting all of these bullet points and typing the word scenario. And then you have the basic of your test file. Now, I was going to set up some sort of a coding battle where I would work in Gherkin and Claude Dev would work in pure Playwright, but we were both so bad at writing the steps and tests in Playwright that it was too painful to share. So that was quick. Yes, so what we have here is two separate files, one on the left for our Gherkin feature and one on the right that is the same thing in Playwright but doesn't quite work because only the first four tests work. And both of these run, one of them with Playwright through the test integration, and one of them with Vytest. Now let's take a look at these two files, starting with the Gherkin feature on the left, and right away to me this looks very clear and comprehensible. Here are requirements. Typing letters should work with JavaScript enabled, and the steps are very clear. When I type the following keys, T-I-T-L-E, then row one should be title. You know, in my consulting work, I don't interact only with developers. I talk with project managers, business analysts, subject matter experts, grandmothers and parents, marketers, all kinds of people, and I'm confident that I could show them this file and a picture of our app, and every one of them would be able to contribute to a meaningful conversation about what our app is doing and what it should do. And for this last scenario here, letters and guesses should be highlighted. Well, we have some visual requirements for how they're highlighted maybe, but I don't have to worry about what exactly those are. I could just say the screenshot Svirtle should match, and then when I run the test, it'll take a picture of that in a PNG format, and the next time it runs it, it's just a quick visual regression test to make sure that our design requirements are met with every release. All right, now looking over at the Playwright file, Oops, there's the playwright file. You know, there's no way that I could show this to most of the people on my team. It would just be unreasonable for me to expect it to interest or engage them at all. And instead we probably end up talking in circles or in separate conversations where important ideas about our product could simply be lost because there no way to capture them like fingers pointing to an imaginary moon So this is good, but then in real life there will be bugs of new feature requests, like people should be able to choose easy, medium, or hard mode with different numbers of guesses. And right away, I can sketch this new rule in Gherkin, and this is what people mean when they say behavior-driven development. Here's the test before we have the feature done, because AI might be terrible at writing playwright tests, but it is really good at parsing natural language like the ones in our Gherkin tests. So I'm just going to ask Claude, in the feature file, there are some tests for the new feature that are marked with the to-do tag. The new feature is to allow people to choose easy, medium, or hard mode. Please change these files accordingly so that this is possible. Bear in mind, you will have to change the structure of the cookie, which stores the game state, and you'll have to add buttons which should look reasonably nice. Just like that, and we'll let Claude work away over here in the corner while I show you how to install and configure Quick Pickle. Quick Pickle makes Gherkin features run in Vitest, while Quick Pickle Playwright provides test frameworks for the browser and a bunch of step definitions. You'll always need a step definition file, and you should always name it something.steps.ts or js. In this file, you import or set up your world variable and import or write your step definitions. Add QuikkiPickle to vite.config.ts and make sure that Vitest recognizes your feature files and your step definitions. If you have multiple environments, you can also use a vitest.workspace.ts file. Finally, for tooling, do not use the top result for Gherkin. Try the official Cucumber plugin for VS Code. Then configure the CucumberGutGlue setting to get some code completion, which is why you should name your step definition files consistently. And we can see that Claude is done, and if we remove those to-do flags, the tests mostly pass except for a couple of the original ones. So there's stuff to fix, but if we go to the site, we can certainly see the new functionality, and we know it works, because those tests already pass. And crucially, none of the actual code has changed. So you never have to ask, who's testing the testers? Well thank you very much for letting me talk at this summit. I hope you've got something out of it. I'm David Hunt. Quick Pickle lets you run Gherkin Features with Vitess, so give it a try and hope to see you in person next time. Thanks.