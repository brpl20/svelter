 Hey friends, welcome to SwellKit Endpoints. Today we're going to learn about SwellKit Endpoints and when you should use standalone endpoints and when you should use page endpoints or cases for using them together. So let's get started. So first let's get reminded what are endpoints. So an endpoint is a way to interact with another machine on the internet that returns a specific HTTP response to a HTTP request. Let's say for example you wanted some placeholder images in which case you could use the json placeholder api that provides some data using a fake rest api so the url for that would look like json typeco.com slash photos and it turns out json response as key value pair so if we go to the api response you can see it here and i can even zoom in so you can see it better so yeah really nothing special and as always this is just some json response you can consume on the front end and loop over it and display the placeholder images Using a backend framework like Express, you can create an API input where you can get data from anywhere and have complete control over what you return. So for example, here is a code example and I already have it here inside this Express folder, so here it's nothing special. I have just installed Express Node Fetch. If you're using an older version of Node, native API fetch support isn't supported. So if I just close this and open the code, we can see I import Express. I import fetch and we just really initialize express and then we just have the API here and then we get the photos and then we just get 100 results right so this is really awesome and you might be thinking why are you just returning the API response and the answer is because now you have your own packet you own it right so you can even parameterize these photos as I mentioned in the post you can say for example photos question mark amount equals etc and you can really build your own API around this or whatever you want or you can do something else like for example you're using an API for tv shows and maybe you're making a tv show tracker etc so now you're building an entirely different thing on an existing API and here I have it express so I just have to say node. this is going to start the index file and then this should be at low cost and remember it's photos. So we have to go to the same URL and then you have to say photos. And then we going to return the JSON response which looks like this Yeah So this really isn that different than what you get from the JSON placeholder API right So that really interesting But yeah, let me just close this. So let's talk about SwellKit endpoints. Instead of having a separate backend and frontend, SwellKit combines them together into one cute package. So for example, instead of specifying a photos endpoint like in the express example in SwellKit, you can just create a photos.json.ts or js if you prefer javascript file in your routes folder that becomes available at example.com slash photos and as explained in documentation endpoints are just modules written in javascript or typescript files that export request handler functions corresponding to http method so that is get post patch and delete and etc this has multiple benefits from being able to talk to a database or reading from a file system because it runs on the back end which wouldn't be possible on the front and SwellKit endpoints work by exporting request handler functions that correspond to HTTP request methods so you can see here is an example of that so you can export post put patch delete and etc that has an event and you can do whatever you want so the job of this function is to return a response that includes the status headers and body of the response and using a modern web framework like SwellKit your knowledge is transferable because you're going to spend more time learning web fundamentals on MDN than learning framework specific abstractions. So let's talk about standalone endpoints. In SwellKit you can create a standalone endpoint like in the express example that you can expose to the world or consume it yourself. So standalone endpoints can have an optional file extension like photos slash index json ts making it available at example.com photos.json and it could be also other things such as xml or even images and this is neat because it can set the proper response headers for you we're using something like photo slash index ts is directly available at example.com photos but both methods are great so there is nothing wrong with either one and we're going to learn what's the difference right so let's look at the same express example in swell kit if i if i scroll over here so on the side i really have this folder and here is nothing special this is just a source folder i have routes here here is a layout it just has some styles really isn't important and if you want at the start of the post I have a link to the repository and you can even open it on stack blitz and play around with it yourself but yeah let just really start with the example so we can create a photos folder right Just as we had it before And then we can create for example index And then I can close this. Let me just copy the code over. Yeah, and that's really it. So this really isn't anything special. And let me just open the Prettier file. and we're going to say the print width should be 60 just so you can see everything and really nothing special this is the same thing as before as we see in an express example so if i start this up we can go to socket and we can just say pnpm run dev but of course if you're using npm it's the same yeah so we can go here at localhost 5173 the new port is really awkward or you can just open it and I have nothing here but if you go to photos we're going to see the same response if you go to photos.json that is yeah and you can see that this is really the same what we've seen before right so let me just close this terminal because we don't really need it but yeah now we have that so anyone can use the api at example.com slash photos.json if that's what you want but we can also consume it on the front end using the load function that runs before the page is created and returns the page props. So in SwellKit, pages are just components. So we need to somehow run the data before the page or component is initialized so we can server-side, render it, et cetera. And also just personal preference. If we go here, we can just, oh, not like this. I can go semi, no safe, false. And here's an extra tip. Now that we can stop this, and we can run pinpm run format. and this is going to lint all of your files. And then just let's run development. Close this. Boom, bam. Thank you, ma'am. And this is it. But yeah, so now, for example, if we have this file, let me just copy over the code where we consume the API. So inside the photos folder, we can create an index. That's well. Let me just close this file and I'm going to copy it over. So the types, if you're interested, come from here, types, which really isn't important if you don't care about TypeScript that's fine because it's really optional and I'm just going to close this going to save everything and now if we go to photos because that our URL right now we should get some photos which is really awesome and also let me open the network tab so you can see what going on and let me just see everything is all right here yeah so that looks perfectly fine let me just this over so you can go back to the post and really nothing special here is our load function so here we import the types here's the old function so we're just which is fine because we might be using this in other pages. So this is really great. And then we get the photos from it and we return it as props. And inside the script tag, we expose it as props. And now we can loop over it and we can even put prefetch on it. So it fetches all the data for the page in advance when you hover or click on the link, right? Which is really great. And it just displays it in a neat grid. And this is something that you would done in the past. Maybe you're familiar with it, et cetera. But if you think about it, this is just really boilerplate because you already done this job once. So why are you doing it twice, right? So using load to fetch data from an external API is great, but we can't talk to the database or read from the file system because it runs on the server or client. So these are some drawbacks that you have to think about. And it's pure boilerplate, as I said, if you already wrote the same code inside the standalone endpoint. So let's talk about page endpoints. So in the previous example, we created a standalone endpoint that fetches some placeholder images and shows them when you visit the photos page. If your goal isn't to create a public-facing API to be consumed by multiple pages or sources, and the only thing that cares about the data is your page, then you should use a page endpoint. So here I have a nifty diagram. So the SwellKit Endpoints Guide, do multiple pages use the data? Yes, then use a standalone endpoint. And here's an example where you have the same photos. JSON API, right? And multiple pages can consume it or whatever else source. And if the answer is no, then use a page endpoint. So you have slash photos and then you're just going to fetch that for the page. And that's all you need, right? And the only change you have to do is rename the index.json.ts file to index.ts to convert a standalone endpoint to a page endpoint and remove the redundant boilerplate code from index.svelte, right? Yeah, so if we look at here, let's go open our sidebar. And we just have to rename this folder from index.json.ts to index.ts. And just like that. And we can go here and just move to the side. Because it's just boiler.

 place right we already done this job once so there's really not a need to do it anymore so we can really delete this code and look how much nicer it is and let me just look yeah this is it and it should work the same right if we go to photos and if i refresh for good measure i'm going to disable the cache let me just hide this so we have more room and yeah here are placeholder images and everything is working great so now instead of having a load function we return props anything you return inside the body here is going to get turned into page props and you can even return errors and etc this way but that's really a topic for another video right so as you see here is the example we just removed the code from above and everything is great so this is really awesome but this is just the start of it page endpoints are powerful because they enable progressive enhancement for forms because now your form has its own endpoint among other things so this is just an example because forms deserve their entire separate video so if you want to play around with this you can open the swell kit default example when you start a new swell kit project you can play around with this where you have the progressive enhancement example with the to-do list so if i just show it here for example in this example we just have a form and then we import the enhance form action from actions form let's say for example and then we use it here use enhance form where the method is post and we didn't really even have to define the action attribute on the form because it shares the same endpoint right so how awesome is this so if the javascript on the page fails for whatever reason it's going to work the same which is awesome because it's just going to use the regular endpoint and if javascript is available on the page it's going to use progressive enhancement and it's going to use the action and it's going to do what you would do by default is going to prevent default and really do the equivalent of calling an on submit function right so this is really awesome and here in the end for this example you can get inside your page endpoint post request right so you can get the form await request dot form data and you can get the user thanks to the name attribute so you can get it from user and that really awesome so you can do whatever you want here and etc so as i said if javascript is available on the page the form action is going to be used but if javascript fails for whatever reason is going to work like a regular form there are situations when you would want to use both together though you learn when to use a standalone endpoint and the page endpoint but sometimes you want to use both so for example i want to be able to show a single photo so let me just close this and i'm going to close this so to do that we're going to go to the photos folder we're going to create a parameter id so that's going to be our endpoint let's just copy over the code and then we're going to copy over the markup So we're going to create the same thing, id Svelte. And if I mention it already, when you're creating a page endpoint, the file has to have the same name as your Svelte component or page, right? So that's how SvelteKit knows it. It's a page endpoint. So here we have just a simple example. Here is our endpoint. Just move it over. Yeah, so here we're just calling the API, which is a param ID. So if I take this and copy it over. So if I go, for example, here and I just say photos one or photos two, we can now parameterize this and we can get the individual photo when we click on it. And since you have prefetching, it's going to start loading the data in advance. So yeah, so we return the photo back and then we can catch it in the component. So here is the photo using the type I showed you before. so we get the photo title photo url and yeah that's lovely so now when we click on a photo we should go to the individual photo but there's one problem if you notice it if i go here when i press on a photo pay attention it happens quick so maybe you're going to miss it the photo is going to flicker because it's not loaded yet also let me just clear this and if i hover over this you can you see it flickers and then it loads the photo right So we can prevent this by using the load function So you thinking hmm how can we use both and the answer is rather simple we can pass the props from the page endpoint to the load function and then from the load function we can load the image before the page is able to navigate and that's how we can fix the flickering which is really awesome so in the post i really show you this here and here is the solution so if we go to the photos id.svelte we're in the same file right and i'm going to copy over this bad boy yeah and then really this is nothing intimidating this is just some couple of lines of code so we can pretend for example that this is coming from some utils folder where we have load image type script and here is a function a synchronous load image that takes a source it's just a promise that has a resolve reject it creates a new image and then assigns it the image source right and then we just add event handlers on top of it we say image dot on load hey resolve when it's loaded so the page is going to navigate otherwise it's going to block so nothing's going to happen and then on error we're going to reject and show the user an error and the rest really is the same we're just checking if this is the browser and then we call the function load image props photo url and this is really awesome so i can just close this and to see this in action let me just go back here and I'm going to refresh everything and I'm going to clear and instead of disabling the cache because we really want this to be cached as the normal user would use the site right so we can do that and now when I hover over the image it should start to load the image so you can see inside our network tab everything is already loaded and now of course our user isn't going to hover like this for a minute we can go to the image and a more regular use case would be let me just refresh again and then our user is like hmm what is this photo you can just click on this and boom it's like this so yeah if you go here just do it again this is already cached this we can go back here you can go to another image and this is going to only load when the image is loaded so this is really awesome i even mentioned this and you can see this in the network tab and now the flickering problem is solved and I also want to show you another example that I use on this page itself so another example I have for you is setting cache control HTTP headers for the page so I made this mistake when I started learning this I thought that setting the cache control headers here would set it for the page but you have to remember this is your page endpoint so you're just going to cache the data that you have here. So in this example where I have the endpoint, I'm just returning some data 1234 and I set the cache control where it's going to be fresh for 60 seconds and this is going to get cached by your content delivery network CDN whatever. But this is not how you do it. So you would set the cache control header on the endpoint if you wanted to cache the endpoint. So you would for example do it like this and then you would set it here. But this really isn't what we want, right? So we can go here and then inside your load function where you have the props. Yeah, here are the props already, right? So we have everything, right? Which is really awesome. So again, this comes from here and then we can set the cache here. Where are your props? So let me just do it like this. And so we have props and then you can set the cache. You can say maxed age 60 seconds again and now this is going to cache your document and use this method for the page you're reading and i encourage you to open the network tab if you aren't you can see it in action so if we go here and let me just open the network tab and i can even refresh the post and that was quick so you can go to the cell kit endpoints and then if you go to the headers you see date yeah public max h60 because it's a fresh post and i even have it so that when the post is older than a week then it should basically cache it forever but Vercel unfortunately doesn't respect your cache control header so the cache lasts at most a couple of hours but yeah that's a rant for another day I hope you learned about the difference between standalone endpoints and page endpoints and know when to use each one or both if you need it so thanks for reading and catch you in the next one