 yeah hello everyone um thanks for inviting me to svelte vienna i i hoped i could make it uh in person but sadly it didn't work out this time but um that that doesn't mean that it will never happen i mean i'm basically just around the corner in in germany so i'll definitely make that happen sometime and then we can see each other in person yeah so for this time um i'm going to talk about spell five and why did we do that or to put it in more uh dramatical um put on a more dramatical picture so five why the hell did you do that that that may be uh the reaction some of you may have had when first seeing the new syntax. And in this talk, I want to go a bit over what is the reasoning behind these changes and to hopefully shed some light on the thinking decision behind this. So when Svelte 3 came out in 2019, it took the front-end role by storm. Rich Harris gave a great talk, Rethinking Reactivity, about it and showcased a compiler-centric approach that can lead to simpler and more efficient code. I remember how fascinated I was about just needing to write let statements and they were magically reactive. But over the years, cracks have appeared in SELCIS-8, so to speak. Especially with larger and more complex applications that were highly interactive, it became difficult to keep track of of the reactivity model or inconsistencies in the reactivity model showed up. And generally, the fronted world has evolved significantly since then, like five years of, that's almost an eternity in the JavaScript ecosystem. To put that into perspective, 2019, that was still at my previous job when I wasn't working at Vassal yet. many developers, including me, had to still support Internet Explorer 11. That's the time back then. So a lot has changed. Browsers became more capable of doing things but expectations have also risen But Svelte itself hasn really changed much in that time And so now five years later with three of us working on the front framework full a big thriving community with great meetups like yours, it was time to fundamentally review Svelte and consider what is really core to it, What do we need to keep to keep the spirit alive? And which things can we improve upon? Or to put it in the words of Rich Arrow's talk title, Rethinking, Rethinking Reactivity. And the result of these considerations is Svelte 5. And now let's take a closer look at those and the decisions that came up to those. So first up, runes. Why did you do that? The dollar sign, or beloved dollar sign. Svelte 3 had the idea to repurpose the completely unused but valid syntax of labeled statements to create a new kind of reactivity. And this was a great idea and a big part of why Svelte felt so concise and elegant. But over time, it became clear that it's not without its flaws and limitations. And so let's explore some. Can you spot the bug? here. We're reading double eagerly on the first render in line four, but it's not defined by then yet. This will print undefined. The double will first be evaluated right before the template runs. And this can also mean that you're reading stale values when you're in the middle of an update. So for example, in line nine, you will, after you have incremented the count, the count will be the new value, but double will still be the old one. This is something you have to be aware of when using this. Here's another bug. Let's assume you have an actually very complex computation, not just count times two, and you move that into a function because you may want to reuse it or it makes the code more readable. But now, the reactive statement in this case, it just doesn't rerun anymore when count changes, because it doesn't know that it depends on count. You have to manually tell the compiler about that dependency because the compiler only looks at the reactive statement itself and doesn follow functions or imports or something So what many of us did in that case is to then pass in function arguments that the function doesn't really need or any other kind of workarounds. So in a sense, you end up in a situation a bit like with useEffect in React, where you have to pass an array of dependencies. And then there's the expectation problem. Svelte in the tutorial teaches you reactive statements as being rerun when their dependencies change, a bit of like an Excel cell. But that's not actually true because they only rerun once per tick. So in this example, you don't end up with the count being 10, you end up with the count being 2. Because of this, Svelte also does static analysis to automatically order reactive statements in the most optimal order so that they run once but in the right order. And since dependencies could be hidden, as we've just seen, the order could be wrong. And this happened to many people. They were starting with a few reactive statements, added a few more, reflected a bit, and suddenly the chain of reactive statements broke. something didn't update anymore or something suddenly ran before something else. And this was very hard to understand why that happened. All these gachas are not obvious when you start your journey into Svelte. It feels very simple, but really it's not when you look closer. People have built very elaborate, complex applications with Svelte and then they work fine. Until then, they run into one of those issues. At that point, it's probably already too late. They've coded themselves into a corner, basically, and then have to refactor a lot of code. There are several issues on the GitHub tracker where this exact thing has happened to people. There's also the whole refactoring story and the two worlds problem. As long as you're at the top level of components, you can use all the svelte niceties and shortcans. Let, dollar colon, and so on. But as soon as you start to refactor your code into functions, you're out of luck. You have to switch to the more verbose API of stores, which is a mostly cumbersome and tedious refactor process and then you end up with code that is a lot less declarative and nice to read than before I mean, in this example, it's still a lot, very readable, but imagine this was a more involved example than just a simple counter. Because this refactoring was a big undertaking every time you had to do it, the incentive to refactor code out into reusable functions or to share code, this incentive was a lot lower. And so people ended up with more stuff in their components than what should probably be in those components. And that hurts maintainability over time. And then there's more reasons besides that. For example, it doesn't play nice with TypeScript. Our tooling needs to jump through some hoops to make the script contents actually type checkable. If you declare $colon double equals count times two, that doesn't actually mean that double is now a declared variable. You have to hack around that and tell TypeScript behind the scenes that this is actually what we mean. It also needs additional API you have to learn to work around some shortcomings. For example, the export let to declare a property that only works with one identifier at the time. So if you have a component that says, I also expect any other properties you give to me, you need to use $$REST props or $$ props for that, which is API, which we had to invent because there's no other way. And if you want to rename a prop, for example, you want to expose a class property, you have to use this very involved export as syntax, and you soon don't know really what you're doing there anymore. So these reasons is why we ultimately decided to switch away from the dollar sign, export let, etc. to more explicit API runes. It's a bit more code to write in simple cases, but we also believe it's easier to read. And I mean, that's what Svelte is optimizing for in a lot of cases. Reading code is much more common than writing it. And if you're a newcomer to Svelte or a newcomer coming to a Svelte project, you have a much better time understanding what's going on there by reading keywords like states, derived, effect, compared to just

 dollar signs or let's statements. Also, all the other things are handled by these changes. So TypeScript, for example, does understand this much better because to TypeScript, we can just tell that dollar props, et cetera, these are global functions. So there's less hackery involved. We not only switched the API, we also switched how it's interpreted. So the reactivity is no longer based purely on the compiler. The dependency graph is created at runtime. Under the hood, we're using signals for this and the result is more predictable and less error prone reactivity that also works better in edge cases. I think there's like 30 issues or something on the GitHub tracker, which are just fixed by changing the reactivity model to a more runtime based approach. And it also fixes all the shortcomings I've shown earlier. Now, if you console log double, you will always get the latest value, no matter where you are. When you write the revations, the runtime will automatically figure out which thing to call first in which order. There's no more reordering necessary, so to speak. So there can be no possibility of something missing. Also derivations and effects rerun whenever their dependencies changes. So you cannot end up in a situation where something runs less often than you would have thought it does. And the thing is also what this opens up is an entire new world for us because reactivity is now more explicit. We were able to make it universal. So you can now use the same reactive primitives inside and outside of the top level of components. This wasn't possible before, as I've shown with the story factorings. And that was a pain point for many people because they like to stay in stealth land. Now you can do that. All you have to do to make this little counter reusable is to extract it into a function. The highlighted code stays exactly the same. You just need to wrap around the function and then you need to return the things that should stay reactive using getters so that the reactivity is preserved These getters this is nothing related to Svelte This is how JavaScript itself works and how you can also make in regular JavaScript keep things alive across boundaries, so to speak. In that sense, runes are just a tiny wrapper that gives the compiler hints which things are then actually reactive to which the spelled runtime needs to react we tried this approach with more implicit syntax like use reusing dollar colon or let and we we implemented some of these approaches and they all ended up being very hard to reason about you would end up with infinite loops all over the place. You had no idea how to actually reason about your code, which things were reactive, which things weren't. And if we had to keep the $colon syntax, we also wouldn't be able to move this code from Svelte files into Svelte.ts or Svelte.js files, where these runes can live now too. because in these files, the TypeScript in Telesyns is the one telling your editor what is valid. And we can't just make dollar colon statements that happen there. So we explored how it would feel to keep the old API, but it just wasn't working. And so we traded a bit more code to write for a more explicit, easier to reason about API. Okay, that's its four runes. Next up, event attributes. Why did you do that? So in Svelte 4 and 3, you mainly did events using the on colon syntax. On the surface, this looks nice because the colon is a clear indicator that this is an event listener. It also feels kind of correct that events are special, and so they deserve their own syntax. But on a closer look, these design decisions were against Svelte's simplicity. You had to import createEventDispatcher as a function, as an import from Svelte. Then you had to call that function from which you get a dispatch variable And then you had to call that again with the string of the event name and these events when you could pass payloads to them but the payload was on a detail property on the on the object because what actually was dispatched here was custom events so it was all a bit boilerplatey and more code than you need to write and when you were looking for what events a component emits, you had to scan the whole file to find the creative end dispatcher calls to see, okay, what events does this actually dispatch? Alternatively, if you use TypeScript, you had to type the generic of the creative end dispatcher function, but that meant you had to type even more. And when using the component component, even if you were using TypeScript, you still wouldn't have perfect type safety because the nature of creative event dispatcher is very dynamic. You don't need to invoke it only. You can invoke it anywhere as long as it's during component initialization. So any import could potentially hide the creative event dispatcher invocation. And so for IntelliSense, it was never certain to know, okay, there are no other events besides the ones and spell file. So if you mistyped an event name, you wouldn't get the reds quickly in your editor. You also wouldn't get a runtime error because of the way Svelte subscribed to these events. You would just get a silent failure and that's not good. It also meant that there's two ways to doing component events because you could also use properties to define these events like callback props. But since that wasn't as idiomatic and because you were already using on colon as syntax to listening to DOM events, no one really was doing that. It didn't feel encouraged to do that. Another thing is you couldn't just forward events. If you wanted to forward an event from a child component to a parent component, you had to manually forward each event one by one. So if you wanted to forward multiple events, that meant on click, on hover, on double click, on key down, whatever. Many things you needed to write out. And if you using a third component library which didn forward the event you interested in then you out of luck Some component libraries worked around this either by inventing their own syntax for passing arbitrary event objects, which meant even more inconsistency in the ecosystem, or they hacked it to smelt internals, which is no good because internals are not like under subject to the center because yeah, it's the internal runtime, so it can change at any time. There were even some libraries who for this reason, they would have liked to support Svelte also, but they just couldn't because there was no way to really forward all events. And so all these outcomes were not ideal and against like Svelte's slimificity. So this is why we implemented event attributes in SaltFive. Instead of having a special syntax for events, we treat them as attributes. So in other words, the colon disappears. Instead of on colon click, you write just on click. And that means because events are just attributes now, we can get rid of create event dispatcher because we can now just treat events as callback props. And that removes a lot of boilerplate and also makes it easier to reason about the component because you look at the dollar props rune and see, OK, these are the things, the properties and event this component has. And because events are just attributes, we can also spread them now, meaning the limitation of having to forward each event separately is gone. And generally, the flexibility of this approach is much higher. And once you used it for a bit, you'll notice that the syntactical separation between events and attributes starts to feel a bit arbitrary, or rather, you're not really missing the colon, really. I mean, in JavaScript, if you want to get notified of something, you pass a callback into a function. It's the same principle And you don't have any special syntax there either. So why should you install? This also means you have to learn less concepts when getting started with Svelte. So it gets easier going with it. And so that's why we did Eventress.

 attributes. And lastly, this is the last time you have to see my face making silly YouTube thumbnail reactions. Lastly, we look at snippets, which unlock both new possibilities of composition and reuse, but also serve as a replacement of slots. So we're going to discuss now why that is. To recap, slots allow you to define a placeholder in your component that can be filled with arbitrary content by the parent component. In this example, we have a button component and we can fill the button with any UI from the parent, any text we want. Now the question is, what's wrong with this API? Why does it need changing? And to be frank, in this example, nothing's wrong with it. It's simple, it works. But as we've seen with the other APIs by now, it doesn't stay simple, and so problems start to arise. The main problem comes from the fact that we can pass data from the child component back up to the parent component. That's a powerful feature, which, for example, allows us to create generic lists where we can pass in a slot that then is rendered for each item, as in this example. We have a list, we pass it some items, and then we use these let directives to get back the property. And it's these let directives that are really confusing to reason about. When I first learned Svelte, this was giving me the most headache. And it took me a while to understand that let colon item creates a variable. And if you rename a variable, you can do that. But that's even more confusing because then you write equals, phrases open, to do, phrases close. And so that means you can use the to do variable, which is the item slot prop. But that's like really backwards because all other directives and all other directives, that means you pass a reference of to do into some directive. And this time it's like completely the other way around that this defines a variable. So it's really confusing. And there's also the scope reasoning problem because if you look at the code it looks like the variable of the default slot is usable within the empty slot but of course it isn because the item slot prop is used for each item in the array and if there are no items then i show the empty slot so it cannot be that this is available in there but it looks like it. Also, is the variable, that item, is that thing available on the component itself or just on the sub children? It's not clear at all what's going on there. Also, when you have named slots, you may have to add the slot, you have to add the slot attribute to the elements to say, okay, this element goes into this named slot. But maybe sometimes you don't want to have one single element that goes into a slot, or as in this example, you don't want to pass any element into the slot. You just want to pass text. So we had to invent this spelled colon fragment special element to work around this. So that meant more API service area. And there's even more API service area with $dollar slots, which that tells you is the slot set or not. So it's more and more API around shortcomings of the initial API. And snippets solve all these problems by being much clearer to reason about. You define a snippet within a component boundary, which means it's passed as a property to that component. You could also write it outside and then actually pass it as a property. But this is like syntax sugar. Each snippet defines its own scope. And it's very clearly visible because that's the hash snippet opening and then the slash snippet closing. And you know, okay, in there, the things that are passed to the snippet are defined and only in there. Snippets, in a sense, they look a bit like functions. and that's also how you can think about them. They're just variables that you can pass around and when invoked, in other words rendered, they show up somewhere. And because snippets are just variables, they are also again just properties. And together with event attributes which means components properties can also be events that unlocks a powerful end state that the public API of components is now entirely defined by its properties So there no more scanning the component for slots, create event, dispatcher, invocations. You just look at the dollar props rule and look what's in there to know what this component is capable of. Yes, in the simplest case, this may be a bit more to write, but it'll save you on readability and reasoning big time. It also makes them more powerful because snippets are just variables, so you can pass them around via context. You could even save them into some global state and then render them somewhere completely else. The possibilities are endless. So to summarize, snippets are both more clear to a way to define UI placeholders, and they are also an entire new way to compose or transport UI elements somewhere. All the while, you have less concepts to learn at the same time having more power. And so that's why we did replace slots with snippets. If there's one thing that hopefully became clear from this talk, it's that Svelte 5 is now simpler than ever. The simplicity in syntax was magical in Svelte 3, but you had to keep a lot of implicit knowledge in your head and read between the lines to not fall into one of the various gotchas and traps. Svelte 5 avoids that with one clear and consistent reactivity model and the overall more focused and explicit API. In case you didn't know, you can upgrade to Svelte 5 without having to rewrite all your code. The Svelte 4 free syntax, that still works in Svelte 5. So you can upgrade one component at a time if you want to. We even provide a migration script, which you can use to automatically convert a lot of the things to the new syntax. So I hope you're excited as we are about the future as felt. And if you were previously put off by the syntax changes as the faces in my thumbmates were, then hopefully we give it another try now or at least you can understand but better why we make these changes and with that i say thank you thank you very much simon i don't know if you hear us yeah i can so maybe just before the audience have a question when is it released it's it's it's uh it's weeks rather than months let's let's put it that is oh so we're close i i'd say the biggest um thing standing between us and the release is the documentation side and the tutorial so we need to rewrite all that and update that to the latest syntax so that on day one you you get proper documentation and so on. Nice, okay, thank you. Some of you have some questions maybe? Yes, no. I have a question. I don't know if you can hear from there. Let's see. Let's see, try. If you can hear me, have you guys looked a little bit into how bundle size changed between cell four and cell five? Does it decrease or decrease? Yeah, we did. The bundle size, the baseline is a bit higher because more things have shifted to the runtime. So if you have a Hello World component, that's a bit bigger, but no one just writes a Hello World component. You do actual stuff with that. And so after a few components, it actually starts to get smaller, the bundle, because the component of the code that is outputted per component is much smaller compared to cell four. So if you have a modest app, then you will see bundle size savings for sure. Nice. One question. When it comes to snippets, what was the inspiration? Is there something existing that you kind of took or is it actually your invention? We looked around and thought about what can we do there. Originally, we thought about how can we re-render certain snippets of UI within a component. So it didn't start out as a

 replacement for props. And as such, it was basically invented on our own, so to speak. So there was no clear blueprint from anywhere else. And then we realized, hey, this at the same time is also a perfect replacement for slots because it makes things easier to reason about and the more complex cases. So it actually, we found that it, yeah, we can kill two birds with on stone, so to speak. Yes, tell me. So for how long will we still have the Svelte 4 syntax portion? Like, is it going to be gone in Svelte 6, or are there any plans? So right now, there's no plan as to when we will remove it. We may remove it at some point. I think that's clear. But we're not talking, like, a few months or something. we're talking more like years. So we will closely monitor how many people have upgraded to the cell five version, how many people have upgraded to the new syntax. We will monitor these things to then make a decision at which point we will remove the old syntax. But we will definitely give people enough time to migrate at their own speed. so like going forward it is recommended to use like snippets instead of slots and basically all sorry i didn't hear that last part so going forward it's do you recommend to use the rooms instead of slots and the old syntax like just to be sure not to have to rewrite things in the future yeah you going going forward if you on Svelte 5 and you writing new components it recommended to use the Runes API to use snippets, to use event attributes instead of slots or the on directive or the old dollar colon syntax. Yes. And that's also how we're going to... Basically, in the tutorial, you will probably not even see the old syntax anymore. We're just gonna teach the new concepts, the new syntax. And of course we will have in the docs call outs like in Svelte 4, you would have done it this way and we will have a dedicated Svelte 3, 4 syntax page. But the recommended way forward is the new syntax. Yeah, so I have a question about classes and regarding the slide where you explained the native JavaScript get set syntax. I was writing my code like how you wrote it initially until I realized if you, and I suspect But if you refactor that into a class, your line count would decrease. I think Rich explained that classes will automatically create getters and setters. So I've started writing classes a lot more than I'm used to, including classes that just have two members or something, or one member even. Is that going to be kind of common? Is that what you're expecting? Is that normal I think that class is gonna be a lot more common and you right that I could have written that example using classes as well refactoring that into classes. It just didn't, like, show that you can keep the exact same code you have and move it into function. Like, I wanted to show that you don't have to change anything in the core at all. But yes, you're absolutely right that probably in a lot of cases it makes sense to refactor things to using classes. Because I think we in the Svelte team think that classes have like a bad reputation. some kind in some ways it is justified because people from the diehard object-oriented programming world with extents and deeply nested hierarchies, that gets really confusing. But on its own, classes are really useful for encapsulating a piece of state or behavior and associate methods with it that change the state that they control. And so we think that's why we added support for classes the way we did so that it's very ergonomic to use them in that way. And so, yeah, it's totally, totally correct that you're using classes. That's totally fine. Perfect. Maybe a last question, yeah? Yeah Thanks for the great talk Simon and also thanks for the work you do I have a question about after the release of Svelte 5 will you and the team at Vercel be working on Svetkit or will the team be different people We will be focusing more towards Svelte kit after the release that's for sure. First we want to see how's the reception, maybe tweak some documentation, maybe there's a bug that needs fixing. Maybe we have a feature request that needs our attention. But I think that soon afterwards, we will transition back over into SvelteKit to then see, okay, what use can we make of the new capabilities that we have? Because Svelte 5 is also laying the groundwork for a lot more things we have in mind with regards to how you do data loading, how you compose your components and so on. And through the new runtime and the API, we have some ideas there. And those also are directly correlated to SvelteKit. And so we'll definitely focus on SvelteKit more. Cool. Sounds great. Thank you very much. And thank you. We'll let you go, I think, Simon, and then we'll continue also on our talk on our side. I don't know if we do a small break or you can proceed directly. We'll just refill water here and more than just water and then we continue in five minutes. Okay. Thank you very much, Simon. Bye. Have a nice evening. And next time you can come here. Yes. Yeah. I hope to make it. Thank you. Bye.