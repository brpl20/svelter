 Yo friends, what's up? Today we're going to talk about how to talk between components without props and events in Svelte. So today we're going to learn about Svelte's context API, and not only that, but we're going to implement it from scratch to understand how it works. And we're going to cover some other things how to pass reactive state through context and so on. Alright, but before we get started, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support. Alright friends, I created these four components named A, B, C, and D, and I'm importing this parent component A inside plus page.swell, but I have a huge banana problem because for example when I define this prop here named banana, I'm just passing a simple banana, but the only component that cares about this banana is the D component, right? And no other component cares about it, but unfortunately we have to pass this as a prop through every component. So in the component A, we have this nested component B, so we have to pass the prop here. And then in this component B, we have to declare a prop and we have to pass it again, right? And the same is true for component C, just so that the D component can get the banana prop. And if you look at the result, we can see that we have our beautiful banana here. But as you can see, this is very tedious, so there has to be a better way. Alright, so let's pretend that the Context API from Swell doesn't exist. Can we solve this problem on our own? Yes, we can. Here's how. Alright, so I'm just going to close everything here, and I made this special file named Context at Home, because why do we need real context when we have context at home, right? And I was debating if I should really do this, because it's really complicated. For example, we have to define a context first. let's use a map and then we have to export a function to set the context right and then we need another function to get the context and i mean this is all super complicated i don't even know if i should be doing this uh wait we're already done uh never mind then but jokes aside this is how swelt actually implements context under the hood it actually uses a map and a couple of simple functions all right but to set the context we need more we need a key and we need the value and the key can be anything, and the value can also be anything. Or you can just type this as unknown. That's completely up to you. And in this case, we can actually just pass a generic T here, even though we don't need to do this. And then we can just say context set. It has this nice method, which accepts a key and a value. How convenient, right? Wink. And then we just pass the key and the value. All right, so how do we get the value from the context? Well, we actually want to pass a key, and then we can return. context get it accepts a key that's basically it and the context api has two more functions so we're going to define as context going to pass a key and then we can return context as key and there is another one that exports the entire context so we can say export get all context all right and this is just going to export the context that's it all right so let's open component a and this is where we want to set our context all right so let's go here and i'm going to say set context let's see we're going to have context at home how beautiful is this right all right so we're importing context at home and let's just set the context of course we're going to pass the key this can be anything key banana let's just name it key and we can pass any value and in this case we can just pass prop. Alright, now let's go through every component one by one and remove the prop. So I can remove the prop from here, because now this is just a reactive piece of state. Alright, so let me save this, let's go to component B, we don't need to pass a prop anymore here, how beautiful is that? Let's go to component C, yoink! And let's actually go to component D, and now we no longer again need this prop here, because we have context. okay let's remove this and let's say get context so we're importing context at home all right so we just need to pass the key which is going to be key and now this is going to return banana and we can even say once prop all right so now if we save this let's actually go back here i'm going to refresh to prove to you that i not lying we can see we got our beautiful banana and of course instead of prop we can actually get the entire context So we can say get all context But of course to do this we actually have to spread this into an array. We have to say get all context. Let's invoke it. I'm going to save it, and you're going to see it works the same as before. Now we have our key and our value inside. And we can also check if the context exists, of course. So let me just actually console.log has context. Let's just import this function. and let's pass it the key. Alright, let's save this and see what we get. So we're going to get back true. So this works as expected. Alright, so far we've seen that this is just regular JavaScript, right? We haven't even used Svelte's context. But before we do that, I actually want to talk about passing reactivity through context. And this is the danger of not understanding JavaScript because then you're not even able to understand the framework you're using. So in this example, this isn't some black magic. This is just a map under the hood, right? but I think the problem is that people don't understand this part with state so they think this is some magic, they have to do something special so this can be reactive but that's actually not true and you can even watch my recent video on sharing state in Svelte to understand how this works but in this case, for example, prop is already reactive because we're passing an object here so Svelte under the hood is going to use a reactive proxy is going to turn all the properties on the proxy into signals I can just use input text and let's bind the value of the prop. We can say bind value prop banana. Let's save this and now we can look at the result. Alright, so now we have this input where we bound the value and now we can change this. And you're going to see it's reactive. But let's say for example that you're not passing an object. I'm just going to copy this over. Let's just say that this is just a humble banana. It's not an object. It's not reactive. Well, of course, this doesn't change how JavaScript works, right? now you have to somehow pass a reference to this you have to use a function use the getter and a setter so for example instead of passing this reactive value right here you can pass whatever you want you can for example say get banana and now you can return prop boom easy peasy lemon squeezy like that right this is nothing special if you don't want to use a function of course you can use a getter and a setter you can say get banana then you can return prop you can set the banana if you want and etc right so we can actually just do this and now we can actually set prop to v and that's basically it so this really isn't some magic right repeat after me svelte doesn't change how javascript works we can just pass a primitive value like a string and expect it to be reactive because we're only going to have that value at the time it was created and this is why things like proxy state are so awesome because they at least make this simpler all right there is one more important thing to talk about and that is using unique keys now let me show you why would you want to use unique keys so let's go back to plus page.swell and let's say for example that we're reusing this component so i'm just going to copy over this component let me save this i'm going to go back here refresh for good measure right let me just zoom out just so we can see everything all right so for example we're going to actually have some kind of weird bugs. This isn't even reactive like what is going on. If we try typing it here you're going to see both of these components are going to update. How can we actually solve this? Well we can solve this by using a unique key. So let's go back to component A and now we can create a unique key. So we can say cons key and we can use whatever. We can use an object or a symbol and let me actually show you why that is. So for example if we go back here let's for example compare key to key, right? This should return true, as it should. But objects and symbols are always going to be unique, because for example, if we compare an object, it looks the same, right? This should return true, maybe you're thinking, but it's always going to return false, because they're not the same. And the same is true for symbols. We can use symbols, we can pass in a key, we can compare another symbol, and it's also going to return false. So you can use either one of them, but in most examples you're going to see people using symbols. So we can just say symbol key and now we can pass this key. So this is going to be unique each time. Alright, let's save this. Let me refresh the page. Now when we go to this component and we start typing hello you going to actually see it just going to update this first one and when we type hello here it just going to update this second component So you going to have unique state And this is why unique keys are so important So if you want your state to be unique between multiple component instances, use a unique key. All right, so the only thing we have to change is update context at home to use Svelte's context. So we just need to change the import. I'm going to say Svelte. Then let's go back to our D component and we're going to use Svelte here also. And the API is the same as I said. and we no longer need this because it's unique anyhow this should work the same we should get all the context let me remove this and if i go back here we're going to see everything works the same as before so if i go back here i can type hello world and you're going to see this works even better than our example because we had some weird things before like the double context here and etc all right but swells context actually works a bit differently all right so here is how Svelte's context API works. Basically, when you set context in the parent element, it stores that information in the component tree. So you can imagine that as some object, it has some information about the component, right? So maybe component.c for context, and then it sets the context on that component. And that is so the state is scoped to the component. So for example, in the d component here, when you say get context, it actually just goes up to the parent component that has the context, and it returns the context. And some of you might be asking, why not just use global state, it looks the same like context, right? So it looks just like an extra step. But the reason for that is because using global state is unsafe, especially in the context of the server. We already seen the problem that we have when we created two instances of the same component, how we shared state on accident, and the same is true if you're using global state instead of set context. So this is why global state is not the answer. It only safely works when your global state is only used client-side, so when you're building a single-page application. because if your state ends up being managed and updated on the server, it could end up being shared between sessions and users causing bugs. And it may give the false impression that certain state is global when in reality it should only be used in a certain part of your app. And this is a topic for another video because if you read the Swell docs, they actually tell you why that is, why you shouldn't use global state, right? And why you shouldn't even use state on the server. And they have this entire section on using stores with context on the server. So if you're using server-side rendering, this is the only safe way to do it, because you can leak your user's information or worse. And I'm going to put all of these links in the description. Alright, so we learned that context is scoped to the component, but what does that actually mean? Let me actually just show you. And of course, this isn't black magic. We can look at the source code. We can actually go to the definition of setContext. We can actually see this function setContext. It accepts a key and a context, and it's initialized in this variable contextMap. use this function get or init context map okay what does this do? let's just go to the function okay this isn't important ah this is something interesting so it literally has this thing component context dot c hey if nothing exists on this create a new map get the parent context with the context that we passed in so we can actually see it searches through the parent until it finds the context that's basically it and the component context is actually at the top here let me actually search for it component context there it is, boom it's just a regular variable all right so in what component context are we in okay this component assign this context to it that's it and it's no different for receiving the context so we can say get context pass in a key and if we log this value we're going to see we're going to get this proxy but that's not important let's actually look at the code so we can go to the definition get context it accepts a key again it's creating this context map using this function get or init context map and in this case it's going to use context map get with the key that we passed in and it's going to return the result that's basically it so yeah it's really nothing intimidating this is just regular javascript all right so now we understand what it means that the context is scope to the component. Regardless if we define the context here or here, it's just going to be scoped to that parent and its children. And then when we want to get the context, it's just going to walk up the tree, the parents, until it finds the nearest context. And of course, this isn't React, it's not going to re-render everything and etc. It's just going to set or update the value in its place Alright but you rarely going to see people use setContext at getContext directly And that mostly because it hard to type so even the swell docs have this nice section on encapsulating context interactions so i just going to copy their example i created this context file in lib so i just going to open it and i'm going to copy their example all right so i'm going to rename user key to banana key you can name this whatever you want of course let's just say that this is banana i'm going to actually create a type banana. So what did we have? We had an object, we had a banana, and it was a string. So you can easily type your things here. And now this is going to be banana. Same here. Alright, so instead of set user context, you can name this whatever you want, of course, set banana context. And we want to get the banana context. And of course, it's not user, it's going to be banana. Great, so now we have great type completion and if we go back here instead of using set context we can say set banana context and we can just pass in the value right if you pass in something that it doesn't like it's going to warn us it's going to hey this doesn't match banana right so we can just pass in our banana we don't need set context anymore we can remove this and now actually i think this is going to work yeah we can refresh and we're going to see everything works because we just fetch every context possible. But of course, if we go back to D, we can go here and we can just say const banana, get banana context, and we can just log the value of banana. All right, let's log this, and we're going to see we get back a banana. And of course, if I look at the type information, we're going to see that we have types and everything. All right, friends, before I go, I wanted to show you a practical example of using Soil's Context API. In this example, I have a simple canvas component and a child square component. I'm creating 10 columns and 10 rows and defining the size x, y, and the fill style using this helper gradient function. And then I just pass the props as usual. But we already see the ugliness of using this approach because, for example, we need to bind this component instance canvas to this variable canvas just so we can pass it to square, right? And let me actually show you how this works. If we go to canvas for example, here we have just regular props, nothing special, a reference to the canvas, and items is using a reactive version of set. So Svelte has reactive versions for map, set, date, and so on. And for example, here we have an effect where we get the context for the canvas, and we clear the canvas each time items gets updated. And how this works is that we have this addItem function, which accepts a draw function, and then we just add this function to items. And because it's reactive, it's going to rerun this, and it's going to run every draw function, and it's going to redraw everything. And the only reason I'm using this effect inside addItem is so it can run the cleanup when the effect is destroyed. And you can see that we can export functions from a module like this, and now when we get a reference to this module using canvas, we can actually invoke addItem. So let's look how square works. We can see that we have some props here like canvas, x, y, size, fill style, and stroke style. And then we have to use this effect when everything is mounted then we can say canvas.addItem and we can pass in this draw function and the draw function is really simple it just accepts the context and then it checks if there is a stroke style or fill style and then draws the square so let's fix this by using the context API so for example let's go back to the canvas component and now instead of exporting this function we can say set context let's give it a key canvas and then we can just pass it the add item function. That's it. We don't have to do anything else. Let's save this and let's go back to the square function. Back here we no longer need this effect because we can just say get context. We can get the canvas and then we can say add item and we can pass in the draw function. And this is going to complain about the type but I have this type right here so I can just pass it like this. So this is just a generic and then we can remove this effect. All right let's save this and now we no longer need to pass canvas we no longer need to bind this value and we no longer need this and this is complaining because i forgot to remove the type so if i go back here let me just remove this let's save everything and now when i go back here and i refresh everything is going to work and that is the beauty of the swells context api if you like what you've seen don't forget to like and subscribe and I'll catch you in the next one. Peace!