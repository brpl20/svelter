 Hey friends, what's up? Today we're going to learn how to manage and share reactive state across multiple components in Svelte. But more importantly, we're actually going to learn how JavaScript works instead of being a JavaScript framework Andy, right? So that you have confidence regardless if you use stores or signals that you understand that they're almost the same thing. Otherwise, you're always going to struggle trying to keep up with the latest changes. But if you understand JavaScript, you're more resilient to change. you're going to develop a passion for your craft and have a deeper understanding for the things you're using. Alright, so before I get started, don't forget to like and subscribe, and you can also support me by becoming a patron. Alright friends, so here I have a simple counter example. I want to be able to increment it, decrement it, and reset the value. And here is how it looks in code. So the problem here is that we have this counter example, which I'm importing here from lib, and I want to be able to increment it, decrement it, and reset it from any other component, right and i want the value changing to be reflected here so how can we do something like this and the problem is that javascript by default isn't reactive right so even if i'm exporting this value i always like to challenge my beliefs so what would even happen if we try to reassign the value of an import right we can say counter 10 and then we get an error right it says cannot assign to counter because it is an import all right so now we've learned that imports in javascript are read only well that was a nice try but maybe as always we can turn this into some function then we can return some values and etc but wouldn't it be great if anyone interested in counter updating can be notified about this by subscribing to counter so how would that look like so here we have counter which can be anything right so now when this value updates is going to notify this subscriber this subscriber and this subscriber and a subscriber can be anything from your component to a regular javascript module and then when we subscribe to this value we can use Svelte reactivity and each time this updates if we subscribe to it we can just reassign this value to the count inside of the Svelte component and thanks to reassignment in Svelte is going to update the UI. Alright cool so how does that look like? Well let's first create a function createCounter we're going to pass it an initial value so first we want to keep track track of subscribers and then we want a way to add a subscriber and then we want to notify the subscribers when it updates all right cool so how do we do this well first we need a way to keep track of the subscribers so you can say con subscribers we can make it an array but i prefer to use a set because we can only add unique values so we don't have to think about that and then how do we subscribe we just create a function subscribe and we can pass in a subscriber that's how simple that is and then we can say subscribers add subscriber that's it so how do we notify the subscribers well let's create a function update so each time we update the count value we're going to run the subscribers and notify everyone that subscribed so we can reassign the value of count by resolving the updated callback and we're going to pass the count so now we can say subscribers for each subscriber which is just a function right we can invoke the function and pass it the count value and i'm also going to disable type script warnings because types are important here so we can focus on what's important all right so now we can create it we can say export const counter we can say create counter and pass it the initial value and this works thanks to closures and closures are something that you use all the time but you're not aware of it and people like to over complicate closures but the only two things you need to know about closures they only happen when you create a function and a closure in javascript just means that this inside function where you have subscribe and etc has access to the outer scope and what is the outer scope well is the inside of this function right and not only this it's even the arguments because you mostly see something like this. Let current value equals count. And boom. This is a closure because these inner functions have access to the outer scope. And we don't even need this because closures also work with arguments, right? Because they have access to the outer scope. And that's all it is to closures. It's nothing complicated. And we should also return this. Subscribe and update. let's also create a set function because why not so we can say function set so we can set the value directly so when you reset the value or whatever else you want you can set set and it accepts a new value so we can say count equals new value and now we can also run all these subscriptions and you basically doing the same thing as in this update function right So we can use the set function So we can go like here So we can say set. And then we can pass it updater with the count. Cool. So let's save this and let's see how it works. We can subscribe to counter. Let's go counter. Subscribe. And now we can get the value. We can log out the value. and nothing happens if we go to this example here go to the console so when we go here and even if I refresh nothing happens because it only runs the subscribers it notifies the subscribers when the value updates right so let's update the value somehow so we can say counter set to 10 now we can go here and you can see here we have 10 so each time the count updates all of the subscribers are going to get notified and to make this reactive in Svelte we just need to create a count variable and now we need to reassign this value here. So we can say count equals value. Let me just remove the set here and we can just set it to count instead. So now inside increment here we can say counter update. We get the current count. We can say count plus one. Let's save this. Same for decrement. Say counter. and for the reset function we can just reset it say counter set to zero alright so let me just refresh and let's see if everything works so now when we increment this value how beautiful is this right so now this is reactive across multiple components so now increment here we just increment it here this doesn't really care where this count is located because we're importing this counter here which we created here so now when this gets incremented this subscriber here is going to run this callback which we pass the count value here to this callback and now it's going to run and because in Svelte reactivity is achieved through assignment we say count equals value and now this is going to reactively update and let's see if reset works it does, how beautiful is this friends you might have noticed something else if we go to our counter example We named it createCounter but there is nothing inside of here that's specific to a counter. So we can make something more generic We can rename this to something like Writable and then we can press Ctrl D Let select all of the instances of Count and we can name its initial value but I'm just going to name this value. And now we can rename CreateCounter to Writable. And now we have something more generic we can reuse for anything. And additionally, we can return a cleanup function from subscribe. So we can say return, and we can say subscribers, delete the subscriber. And that's it. So basically here is how you would use it. You would just say const unsubscribe and if you have onDestroy method or wherever you're doing the cleanup, you can just invoke unsubscribe. Let's just see. As you can see, we unsubscribe, so nothing logs. But, if we comment it out, and it should work the same as before. How beautiful is this, friends? and we can also reset the value. And that's basically it. And what you just implemented is a Svelte store. And it wasn't that complicated, right? And if you want to see the typed version, you can find the link to the blog post in the description. All right, but what is the point of all of this? It looks like complicated if you see it for the first time. And basically, I tricked you into learning the observer pattern. I know, the worst kind of villain, the one that makes you learn. So you can see here, observer pattern. This is awesome site, patterns.dev. So use observables to notify subscribers when an event occurs. So you can see their implementation looks very similar, except they're using a class. But you can see they have subscribers here, they keep track of it. They have a separate unsubscribe method and they notify the subscribers. And why is this important? Well, basically, you just implemented a Svelte Store. How simple was that, right? It wasn't that complicated. And this is important because the only way to be resilient to any change is to understand how JavaScript and the tools you're using work. Because even signals are observable. And let me tell you, signals aren't that different from a Svelte Store. the only major difference is that signals automatically subscribe for you when you use them. So when you constantly think about these things and how these things work under the hood, you're going to be more resilient to change. If a framework is the only thing you know, then you're not going to understand how things work, right? But if you ask questions, you're going to develop a passion for your craft and a deeper understanding of how things work under the hood. Alright, enough foreplay. What is a Svelte Store? A Svelte Store is just an object with a subscribe, update and set method that allows it to manage and share reactive state across multiple components. So instead of doing this yourself, you just import Writable from Svelte.

 So let's just delete all of this code. And we can just import. Writable. From Svelte Store. And now if I save this. Just go here. So we don't unsubscribe right. I'm just going to remove all of this code. And everything should work the same as before. So nothing changed right. Except we're now using the official Svelte Store. And now if we go to our example here. Always like to refresh for good measure. And now we can increment the value. and everything works like before. So let's learn more about stores. A store also accepts a second optional argument which runs only after the first subscriber and returns a cleanup function when there are no subscribers anymore. So let's see how this looks like. So here I'm passing it a callback. And I'm thinking, why would I do something like this? Well, we're going to look at another example later, but for now, if you have something that you want to initialize, like a connection to some service, you would do it here and then you can do a cleanup when there are no subscribers and that's really simple and elegant. So you can say console.log got a subscriber. So this only happens once when you get the first subscriber. And now we have also a cleanup function so you can say console.log no more subscribers. And this is only going to happen when your subscribers go from 1 to 0, right? And we should have one subscriber because we subscribed here. under subscribe and now this runs only once so you can use this to initialize whatever you want and then for example if you go back to your component maybe you can do this inside on destroy or whatever if you need to do a cleanup but again let's just do the same thing as before unsubscribe and we can just involve unsubscribe and now let's see just say got a subscriber no more subscribers because we unsubscribed awesome so let me just remove this code and i'm going to save this and the other thing you can pass to this callback is a set and update function the same ones we implemented before right so we can set the initial value to 10 and even inside of here we can subscribe right so we can say count and then you can say console.load count which we could have done here it would work the same right but i just want to show you that you can subscribe even inside the regular JavaScript module Alright so now this should log once because we subscribing to it And you can also run update You can get the previous count And then you can do whatever you want if you need the previous value. So you can multiply it by 2 and this should log 20. So let's save and you can see 20 if I refresh it again. And you can see it also initialized the count to 20. So it works the same as before. How beautiful is this, friends? and besides writable stores you also have readable stores so let me show you so we can also import readable so if you have a read only value and you don't want someone else to overwrite it on accident you can just create it here for example let's create let count readable zero and you can already see thanks to type script that you don't get any other completion other than for subscribe so you can only subscribe to a readable you can't actually change it because there's no set there's no update method on it and again let's just see let's say count subscribe so this is a different store right so let's give it a value like 10 and now it locks 10. all right cool so let me show you when you need to derive some values you can use the derive store so let me just remove all of this it's not confusing so we have a derived store And a derived store is useful if you need to create a store based on the value from other stores. So let's see how this looks like. So here we have this counter, but maybe we want to create a doubled value. So double count. We can say doubled. And we can use the derived store. Now we can pass it the store, which is going to be counter. And now we have a callback here. We have access to the value inside. And you can name this whatever you want. And you might see something like this. It says a dollar sign. And they name it like this. but this dollar sign actually has no special meaning. It's actually really confusing to use this in the docs because this syntax has actual other meaning which we're going to learn about later. And now we can just say count times two. Cool. So now we can subscribe to the double value. We can say subscribe and we can say count and we can console log it out. Cool. So now it's zero and we're going to get zero. So now it's going to log again. If we say counter set and let's set it to 10. So now because this is doubled, it's going to run doubled and this is going to log 20. Cool. So now we get 0 and 20 And you can also pass in multiple stores I just going to pass in the same store But this is how we do it You just pass it inside of an array So I can say counter counter And now you can get the values here. You can say AB if you want. So you have to use an array. AB. So now you can get those values. And now we can go here and use the values from both stores. So you can say A plus B. Cool. And let's save this. And now we get the same result as before. and i also want to show you if you need to retrieve the value from a store and don't want to subscribe to it you can use the get method so the get method is going to subscribe read the value and unsubscribe from the store for you let me just go here i'm going to remove all of this and let's give it an initial value of 10 so we can say const count we can use get and we can pass in the store now let's log out the value of count it should be 10 so let's look at this even if you refresh it works as expected so if there's ever a situation where you need the value from the store but don't want to subscribe to it you can use get let me just remove all this code i'm going to set this back to zero and as you can see swell stores are awesome but they can get really tedious to use right so we've seen here not only do you have to subscribe to the value you also have to think about the cleanup. And this really isn't that bad, but imagine if you use multiple stores, then this boilerplate would get out of hand quickly. And thankfully, Svelte is a compiler, so you can write the code for us. So we can take advantage of auto subscriptions, and we can use the dollar sign prefix to subscribe and unsubscribe to a store for us. So let's see how this looks like. And this is the best part, because we get to delete code. So check this out. We don't need any of this junk. Comp, boom, gone. This subscription, boom gone okay what do we do now well we just use the dollar sign prefix and swell is going to the sugar this syntax so dollar sign counter and now this is going to work the same as before we go here when we update the value plus and also decrement reset all right so now let's update our other components side of increment here we don't have to do this so we can just remove and we can just say counter plus equals 1. So we can go to decrement. Instead of doing this, we can say prefix counter. We can say minus equals 1. So we decrement the value. And in our reset function instead of doing set we can just say dollar sign counter equals 0 and let see if everything works how beautiful is this friends and we can reset the value and this $ syntax only works inside of Svelte components because Svelte doesn't change how JavaScript behaves in regular JavaScript files so you can do something like this here and if you ever use stores in a JavaScript module then you have to use those other method sets to describe, update, and etc. But if you're using a cell component, this is how simple and beautiful using stores can be. And you can also bind the value of a store. So I can create an input, and I can say bind value, and you can pass it counter. So it goes here, and now you can see the value is going to be bound. So stores are really beautiful. And this is possible because Silt is a compiler, and it does sugars the $ syntax into the code you wrote before, reducing the amount of boilerplate. Let me show you another awesome thing, which are custom-swelled stores. And basically, custom-swelled stores allow you to encapsulate related logic within a store and expose a clear and specific API. So instead of having all of this increment, decrement, and reset logic in these components, we can put it inside of a single store. And this is going to look familiar. So let me just go here, and we're going to create a function, createCounter, and we're going to pass the initial value which is going to be count, again familiar same as before, but now we can destructure certain values from a writable, right? Let's pass it a count and now here we can get subscribe, set and update. So Swell basically exposes to us these pieces so we can compose our own custom stores and to have a valid custom Swell store, the only thing you have to do is return the subscribe method and that's it. so now you can do any logic inside of here so let's go here and we can say function increment and remember because you're inside of a javascript module you can't use the sugar syntax you have to say update say count plus one so let's just copy over this function we can name it decrement you can say minus and then we also have a reset function so we can say set to zero and this is how simple this is so you can do really anything and now we just need to return it so we return the subscribe so you can get the value right and then we return the other methods increase

 decrement, decrement, and reset. Cool, so now we just need to create a store. This is going to be shared across every instance in JavaScript module because we're going to export it from here. So now we're going to say export, const counter, create counter, and let's pass it the initial value. And maybe you want this counter to be unique for every component, in which case you can just create this inside of a component or wherever else, right? and that's how we're going to get a unique counter each time. Alright, so let's update our example. Here we don't have to do anything special. Inside of increment, we no longer need this increment function. We can just say counter increment. We can do the same for decrement. So now it's all encapsulated inside this. Cool, so now we can also go here. Let's remove reset. counter reset and let's see if everything works so let's see we can increment and we can decrement and even reset it and that's it, I can even go here and I can remove this bind here how beautiful is this friends alright friends, so let's talk about using stores on the server so here you have this store we're going to subscribe to the count and then you're like, okay maybe I want to update the count in the store from the server right, so it's going to be reflected and actually this is really simple. Don't use stores on the server. It's simple as that. Just don't. And why is that? Well, because stores are designed to manage state on the client and on the server, each request is handled independently. In the best case, you're going to run into some weird issues and in the worst case, you're going to leak data from users because you're mutating shared state on the server. So in this example, I'm just importing this counter so I reverted it back to this version. So I'm saying update count so your user comes to this site. Let's just go to server here. So your user comes to this site, the count is zero, and you're going to actually see something interesting. Whenever we refresh, it's going to update, but it's not going to even show here. So you're only going to see a flash. And that is because your component gets rendered on the server and then on the client, but once it gets hydrated, back on the client is going to use the original store value. So you're going to run into some weird issues. And then let's, for example, you have someone else that visits your site, and then you're going to also get another value for the store, So you can see this is already a weird issue not to mention that you can have data that leaks like this And if we go to the component here we can see actually that it not updated because we just logging the counter from the store right But if you look on the server, so I'm going to open it here. And let's just open the developer tools here. And close it here. So let's just refresh everything so we can see data, then page data. but now as you see here it's going to log the value because we subscribed to it using count so you can see here it's going to log the updated value on the server so let me just refresh a couple of times so increase the count to 10 as you can see it logs here and then another user can come in and they can get the version from the other person so imagine if this is some credentials or etc it would be a complete disaster because the client and server state is separate and it's so easy to get into this sort of problem when the line between front end and the back end is blurred when using something like Svelte. But it's really simple. Just don't use stores on the server. Instead of that, pass the data to the component. So this can be pretend you can get the data from any other source, fetching and etc. So just return it. And then instead of relying on the store, you can just pass the data to any component that needs it or you can use page.data. So as you can see here, if I refresh this, so now it's going to be 10 again, right? and now we can just pass this data to the component that needs it and why is this awesome well let's say for example you have export let data so we have data count this is great for this component but maybe you have some other component like here and you're like okay now i need to pass this data here and imagine if you have a child of a child of a component now this would get really annoying well thankfully inside every component return from the load function you get the page data from the page store. Let me just show you how this looks like. I'm going to use my snippet pre. So this is the page store, which you get on every request. You can see here it has data, and this is going to return the data from the load function, and you have access to this inside of every component. So you don't have to paste data around like a hot potato. If you need the data returned from a load function inside of another component, just use the page store from SvelteKit. Let's look at another cool example, which is using Svelte stores with other libraries. Because a So, if the cell store is just an observable, it has great interoperability with libraries that use observables like Xstate or RxJS. And this is just a cool example I want to show you. So let go to the interop example and let me show you the code So inside of here I importing a readable from cell store For a maximum import in create machine and interpret which really isn important Here is a simple toggle state machine I just going to collapse it because it not important Here is the cool part. So we can create almost like a custom Svelte store. Use machine, we can pass it in the machine. So here is how we initialize it. We can just say service, interpret, and here's the cool part. So we can say state equals. We can create a readable Svelte store so we can pass it the state. and now we can use the second argument to initialize something when we get the first subscriber. And where do we get the first subscriber? Well, here. We're using this $ syntax, right? So it's subscribing for the first time. And then we can subscribe to the service itself from exit, right? So we can subscribe to it and then each time it updates, we can set the state using set. And now we can pass it the state and that's it. That's how cool that is. And we can also return a cleanup so the service stops when there are no subscribers. And then we just return the state and send. And this is how we can use it. So we can say const, then we can destructure state and send from use machine, just pass the machine, and this is how it's going to work. So we go to our example and say off, on, off, on. Of course, this is a very simple example, but I just want to show you how cool this is. And of course, you wouldn't have to implement something like this yourself because XState already has this for you, and you can use XStateSwelt. So if you need that, you can import use machine from, I think it's XStateSwelt. It's like this. You can just import this and use it as is. Alright friends, let's talk about the future of Svelte. I know I'm going to get at least one comment. What is the point of learning stores right when there are runes which Svelte recently announced or signals? And the point is that it's because you should learn JavaScript. You should learn things regardless and how things work. If you only know JavaScript frameworks, then you're going to see everything through a JavaScript framework. So I'm going to go to the announcement here. Runes, and of course I'm not going to explain runes in details here, but I'm going to show you how this example looks like and how it's not important if you use a store or runes because they not only look similar but they also work similarly under the hood. So let's go to the bottom here and I'm going to go to the preview side just so I can show you the example. To the preview side like this. I'm just going to copy over this custom store that we created and I'm going to show you how similar they are. Let me just go here. And awesome, let me just see if I can indent this. Beautiful. So remember how we had to know that weird rule about stores that we can use the syntax in JavaScript modules Well this is gone with runes Runes or signals are going to be the one universal reactivity in Svelte you have to know This means that you have to know less things and they also going to make you more productive I'm going to remove this because TypeScript isn't supported here. Instead of writable, we use a signal. So we can say let count. You just have to type a couple of more letters. No big deal. And let's just say initial count and I'm going to rename this to initial count. Awesome. So now you don't have to even know about this API. Look how cool this is. And this works in your components and JavaScript files. So you can say count plus equals one. And we can say count minus equals one. And even if we want, we can say count is zero. So now we can go here, same as before. We can say const counter, create counter. We can pass it the initial value. And I'm just going to go here. to say h1 count is now if you say counter is not going to work and you also need to return the values here let's go here i'm just going to return count increment decrement and reset and why doesn't this work well this is just javascript right because the value of count is going to be the same value as when we created this function. So just knowing JavaScript this isn't svelte, right? We can create a function out of this count. And we can return count. And this is why it's so important to know JavaScript. And now we can say here counter.count and we invoke it because it's a function and you can see it works. But there's another way how we can do it. We can use getters and setters. So the only thing you have to do here you can say get count or you can name this value whatever get banana, right? And this is just going to return the value of count. And now you don't need to invoke this function anymore. And this is really important to understand things like this because knowing JavaScript, you don't really care about any of these changes because you know how it works. This is just regular JavaScript. And by the way, you don't even have to do this thing. This is just if you want to use this like a store, right? You want to make this reusable. Like all of this isn't required. The only line that's required here if you want to use just this count in your component is just saying count and declaring it a stay. That's it. This is just if you want to make this reusable and import it from anywhere, right? This is when you have to do this. All right, so now let's just update this.

 example so i can say button so this is going to be on click so we can say counter increment same as before let me just copy this over and let me just make space just to see what's going on we can say minus and we can say reset cool so let's see decrement and we can say reset. Alright, cool. Let's see if everything works. And that's it. Boom. How cool is this, friends? And again, this is why it's so important to learn how JavaScript works. Now you no longer have to remember some weird rules of reactivity in Svelte because it just works as expected. So the greatest tragedy of only knowing JavaScript frameworks instead of JavaScript is mistaking svelte rooms for other frameworks instead of understanding that you can do anything. So let me just really show you how cool this is. And this is why when people look like this, they're like, oh, this is React and et cetera, because they only understand React, they only understand frameworks, they don't understand JavaScript. When you don't understand that you can be inspired and understand that you can do anything. Again, this is the same example. Of course just because this API looks like React this doesn work anything like React under the hood React reactivity works completely different but it not important As you can see we can use the same API count set count because React didn't invent functions. React didn't invent returning a tuple that you can destructure from an array. It just looks like React, but it doesn't, it's not important, right? You can name this useState, useWhatever. You can see it looks very similar. Again, Soli, this is the same example, but in Soli, it's useSignal. And this is actually closer to how Soli does it, because runes are signals. So you can do this. You like view. You can create a wrapper ref, so you don't have to write all of this. And maybe Svelte is going to expose something like this in the future, so it's easier for you. But you can see, here we just use getters and setters. This is just JavaScript. And I hope this inspires you to ask questions how JavaScript frameworks work, and you realize it's not magic. You're going to be more resilient to changes and gain a deeper understanding and passion for your craft. All right, friends, and that's it. If you like what you've seen, Don't forget to like and subscribe and you can also support me by becoming a patron. Thank you for watching and catch you in the next one. Peace.