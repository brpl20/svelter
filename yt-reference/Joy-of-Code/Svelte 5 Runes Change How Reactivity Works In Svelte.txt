 Hey friends, Svelte is changing how it does reactivity. Today I'm going to go through the changes with you and talk about Svelte runes, or signals. So I'm going to show you why they're so awesome and how Svelte is going to be even simpler and more performant out of the box. So I hope you're excited as I am, and before I get started, don't forget to like and subscribe, and you can also support me by becoming a patron. So Svelte just announced today runes, which you can look at here, all the links are going to be in the description, so you can have a look at that if you want. So let's really talk about the current problems in Svelte. So currently, Svelte has two reactive systems. Reactive assignments is the core of Svelte. So for example, here we have account, and then we can increment it, and basically just by using an assignment, it's going to update reactively. And that's it. But now we can also have reactive statements for derived values, so we can compute double like this, and everything works great. you have reactive declarations you have reactive statements you can say console.logdouble each time double updates is going to console.log it out then you also have reactive statements so for example you can track a value if double is higher than 9000 you can get an alert it's over 9000 but there's a problem with this swells reactivity system only works at the top level of components and what does that mean well basically here in this example i have this piece of code and now want to reuse it so how do i do that and maybe you try doing something like this you create a function create counter and now count is no longer reactive and the reactive declaration has no effect and you even get a warning in your editor because these variables can only be cleared at the top level of your svelte component so right now if you want reactivity outside svelte components you have to use a custom svelte store and svelte stores are amazing one of my favorite feature of svelte so So let's look at how stores work. So stores can be used anywhere. In this example, I'm inside of account.js file. I'm importing a writable from SvelteStore and I'm creating a function createStore so we can pass it any value we want, which is the initial value. Now from the writable, we can destructure a subscribe set update. And to create a custom store, the only requirement is that you return the subscribe method That how you make a custom SvelteStore And how easy is this friends So now in the return statement we return subscribe So now for incrementing it we can use the update method and now we can update the count Same for the double method, we use update, and for the reset, we can use set and set it to zero. And this is really great, but now we have to export this. So now we have another system of reactivity. Now inside your Svelte component, you import it here. And here we're initializing count, because if you create multiple components, they're going to share the same store. So now in each of your components, if you create, this count is going to be separate. So now we can use count increment and log out the count value, which is going to get updated reactively. And here we can reset the count value. And this is really great. But what if you had a universal reactive system? So how would that look like? Well, it would look like signals. And Svelte Runes are basically just signals, but they have a unique name, so they're not confusing to people. so let's look at how this works so here we have a classic example where we have a count and a double reactive declaration so let's see how this looks with runes so we have a couple of runes first we can replace count with the dollar sign state rune and of course this looks more verbose at first but we're going to see the benefits quickly so this is going to also help the compiler know to track the dependencies so let's see how we can replace our reactive declarations before we had to say double equals count times two. Now we have a special rune or signal, which is going to be dollar sign derived, and then we can pass count times two. And how beautiful is this, friends? So now you can put this inside of any other file, just like a swell store, so you don't need stores anymore. Here we are inside a random file. Let's pretend we have this createCounter function, so you have count, then you have double, same as before, but you're going to see there's a problem. So if you return it right now, we can return count double and increment there's going to be a problem we can create a counter like this same as we did before but now if you try to increment it's going to work behind the scenes but it's going to log the value of count and why is that well before we talk about svelte this is another beautiful feature of svelte svelte teaches you javascript this is just a regular function in javascript so this has nothing to do with svelte this is just how javascript works we going to create a function createCounter and inside we have this closure which is just a value inside of a function that remembers its value so we can invoke it and it going to remember it. So this is a closure basically. And now we're also returning count increment so we can create count, createCounter, but we're going to see a problem which we also had with Svelte, right? Because it's just JavaScript. So if we say counter.increment it should be one, but if you console.log counter.count is going to be zero that's strange so if you do it again counter.increment it's going to be two but if you console.log the value of counter.count is going to be zero and why is that well it's just javascript because when you use count is going to be the same value as the value when you initialize the function all right so how can we fix that right well we can replace count with a getter and getters and setters are just something that you can define on an object in in JavaScript. So you can just, for example, say get count and then you can return a count. So now anytime we can access count as a value. So let's see how that looks like. So now counter is going to be one and when you log it out, counter count is going to be one. So now if you increment it again, it's going to be two. And how beautiful is this, friends? All right, so now we're back into Svelte. As you can see, there isn't a lot of difference. So now we can update this piece of code. Now we can use a getter for the count. We can return the count. We can even use a setter for the count. So we pass in the value and then we can set the count to the value. And then we're also going to use a getter for double so we can return the double value. So let's see how that looks like in action. So we create again this counter with create counter. And now inside of your code, how beautiful is this? You can just say counter increment and now it's going to reactively update. And same as for resetting the count because we set a setter. How beautiful is this friends? But there's another problem with the current reactive system as well. If we look at this piece of code where we have double double count might have tried something like this where you passed a function to a reactive declaration but Svelte has no idea about this right so we have a double count here then we have double count function but Svelte can't track this dependency for you as it is now so you might have done something ugly in the past if you never done this before close your eyes so you could have done something like this just so that Svelte knows that count is a dependency and to rerun this line of code so this is kind of weird right And unpredictable And you have to know all of these little tricks even though Svelte is great as it is right now but you can run into some of these weird problems. But now instead, using runes, you can use derived, and now you can pass the function directly. And because this is a signal, under the hood, Svelte is able to track it. So now you can say double count, and Svelte is able to track the dependency. This is going to update as intended. So let's talk about effects lastly. And what are effects? Well, effect is a rune, and it only runs in the browser after the DOM has been updated, like on mount. It replaces lifecycle functions, and you don't have to track any dependencies. And I'm saying this as a warning because your first instinct reaction is going to be, this looks like React, but it's not like React because you don't have to do that awful dependency tracking, and it doesn't have the same foot guns as React. So let's look at effects. So this is an effect. So when you want something to happen to something changing like the $column before, you can say $effect. And now you can run something after the DOM updates inside of this effect. So we can log out count, same as we did before, right? And then you can also return a cleanup function. So when the component unmounts, you can do whatever you need. You can also do something that you weren't able to do before. So here I'm using the state rune. And now inside of our effect, if count is lower than 69, and each time we update the value of count, this is going to run. So it's going to get output from 0 to 69. Else it's going to log out nice. And then you can also nest effects if you want. So you can have nested effects. And basically that's it. There's a lot more, but I'm going to include all of the links in the description. So let me know what you think about the changes and just try it out for a bit. and you're going to see you're going to love it. So don't forget to like and subscribe and you can also support me by becoming a patron. Thank you for watching and catch you in the next one. Peace.