 When writing code, state can be one of the most complicated things, especially when you're working on a complex user interface and you're using booleans for state in your application. Today we're going to explore different methods of how to avoid spaghetti code, and the examples are going to use Swell, but this works for any framework and even regular JavaScript. Let's look at an example of a game. It might look simple at first, but there's a lot of hidden complexity behind it. But you probably have something more complicated, like a checkout or a multi-step form. Let's talk about the first thing everyone does. They use Booleans. So you can express your state using Booleans. And this might seem like you have free state because you have playing which is false, pause, false, game over, and we can even have another Boolean which could be start, so if the game is started or not. But this is problematic because you actually have six possible states and not even including derived state. Because a Boolean expresses two states. It can be false or true, and this can get you into impossible states. because you can set playing and game over to true at the same time. And it's really easy to get into this sort of situations when you use Booleans to manage state. So let's look at the state for our game. Here in Svelte I'm just going to have a script tag, I'm going to have emojis, I shuffle some cards, and I'm going to have matches selected and playing and paused. And I'm also going to use some reactive variables, so we're going to match the cards if the length is 2. Also to know if the game is over, we can check if the matches length is equal to the emojis length. So let's look at the logic. This might seem really great. So we start the game with say playing. So we have a select card code. Then we can match the cards. And then we have a play again function. So we're going to reset the game. And now we get into a more defensive programming. So if we handle key down, we check if it's an escape. And then we have to check what state we're in. So if it's playing, then we're going to flip the value of paused. And here is where we set handle key down. And then we're saying if not playing, then we're going to give the player the option to start the game. We can also pause the game, so we can say pause, but now we also have to account if the game is not over, so this is starting to be a bit hairy, right? And this is how we get into impossible states easily, if you don't pay attention. And then we just have this playing, and again if not game over, and then we're going to select the cards. And again if the game is over, then we're going to show the play again button. Bad booleans represent state. But not all booleans are bad. For example, good booleans are derived from state. So as you can see here, if you have some state playing, then you can derive from it is playing if state is equal to playing. So let's talk about enums. And these aren't TypeScript enums. When people talk about enums in this scenario, they mean enumerated values. So this is explicit state. Let's look at the previous example where we have implicit state. So we can replace playing and paused with explicit state. And in this case, I'm using a type from TypeScript. So we can say state and we can pass it the explicit state. And of course, if you're not using TypeScript, you can use a JavaScript object, so you don't make typos, or you can use a TypeScript enum. And this is going to be less error prone in your code So as you can see now we replace state with playing and again here And now we also have defensive programming like before but we can use a switch statement here in case of playing we can set it to pause and then we can reverse it. As you can see now our state is much simpler. Instead of having six or more possible states we only have four. So now if state is equal to start then we can show start game. If it's paused we can show the pause screen and then if the game is in the playing state we can show the cards. And same for the game over. And how beautiful is that? So let's talk about the next step, which are state machines. State machines is event-driven state. And what do I mean by that? Well, we can use state machines to model how a process goes from state to state when an event occurs. And this is probably new to most web developers, but state machines are an old concept and very popular in game development. We can use state machines to capture all the states, events and transitions between them. It's easier to find impossible states and spot undesirable transitions. Here I'm inside the visual editor from Stately, the same people who made Xstate, I turned our card game into a state machine, and you can see how easier this is to reason about because you know every possible state and transition. Not only can you share this with people but you also get the generated code here, which you can just copy into your project. And And XState also has great integration with VS Code, so you can even edit your state machine visually and the code is going to get updated. So let's look at this by simulating it. At the start, we can say click so we all know the possible state. And this click can be named anything as the event. So you can say start, but I just want to show you that this can have the same name and it really doesn't matter because we know what state we're in. So click is going to do something differently based on your state. So we can say click, then we're in the playing state. And now we can select a card. we can go into an intermediary state, check guesses, and now if we have a match, we can do the same again, and if it's not a match, then it's just going to go back to playing. We can press escape, we're going to get into the pause state, now we can go back to playing, and if no cards are left, the game is over. So now when we click again, we're going to reset the game, and that's basically it. So you might be familiar with the reducer patterns, and state machines definitely look similar to the reducer pattern. So you can actually create a user reducer hook in Svelte using a SvelteStore. So we can import a writable, we can create a function useReducer, which we're going to pass the state and the reducer to. Then we're going to destructure, update, and subscribe from the SvelteStore. We're going to create a dispatch function that's going to update the store. Then we're going to return the subscribe function and the dispatch function. So now we're going to import the reducer from the store and we're going to have the reducer function which takes a state and action and then we're going to switch it based on the type so it's action driven. And then in the case when it's play, we're going to return the state and the value of playing which is true. In the case of pause we're going to return the state and the value of playing which is false. But the downside of this again is that we're doing this defensive programming. So we have to check the state. But it very simple to use and collocates your logic So we can destructure state and dispatch from useReducer we can pass it the state and the reducer And now we just need to dispatch the action So we can say type play, which is going to set playing to true, and we can dispatch pause to set playing to false. But instead of using a reducer, let's create a simple state machine. So this is a sort of state machine where you don't need a state machine, but you have a state machine at home. So let's look how we can use a Svelte store again to use it for a machine but this time it's differently because if you remember state machines are event driven so we're going to create a function use machine which we're going to pass the machine and the initial state to so now we're going to have state from the writable and you can also in the case of reducer press your state here but i'm just going to use the state inside the script tag in Svelte and then you're going to create a send function which is going to update the store and then you're going to return state and send Now inside of our cell component we can import useMachine from machine and now we can create a machine which we're going to call gameMachine. We pass in the state and the event and now instead of an action and using defensive programming we can switch it based on the state. And this might look verbose but this is going to give you confidence that your code works as expected. So now in the case when our state is start we can check the event type. If it's click then we can return the playing state. In the case of playing we can check for escape. In that case, we're going to return the pause state. And if the event type is click, then we can select the card, we can match the cards, and we can return game over or we can just return playing. We also have the pause state, so if the event type is escape, then we can return playing. And the game over state, so if the event type is click, we can reset the game and return playing. And by default, we can just return the state. And this is how we can use our fake state machine. So we can destructure state and send from useMachine, which do we pass the game machine and the initial state. And we're going to see later that we don't really have to do a lot when we're actually going to use xState, because it's going to work the same. This is the most beautiful part, we just need to send events and our state machine is going to know what to do with them. And we can also remove other code where we set the state. So for handleKeyDown we can just set event of type of escape. And then you can see our code here isn't that any different, but we're sending an event here to start the game so it's type click but as I said you can name this whatever this can be literally start game or whatever else you want and then again here we can send the type which is click and then we can also pass it some data in this case we're passing it the card same for the game over state on click we're going to send the type click event so let's talk about xstate you probably don't need a state machine library and that is fine Exit is great when you have some complex state, but you probably don't need a state machine library. As I show you in the simple state machine that you made, that is basically what I love to use most of the time because I rarely need the complexity of something like Exit. But let's look at Exit in case you want to use it. And of course, this is a simple example. You might be thinking why are we doing all of this code for this simple game right And of course in your example you going to have something more complicated where these methods are going to shine So if you take anything away from this just don use Booleans to represent your state and you going to be fine So let's look at XState. We can import assign and create machine from XState and then we can import use machine similar to how we created our own custom store. So now we can create again the machine. Instead of expressing the state machine with a switch statement, we can use an object. And we could have also done this for a previous example using the simple state machine, but at that point you're starting to create your own state machine library and really don't want to do that. So we can set the ID, the initial state is going to be start, the context is going to be the inner state of the state machine, so we're going to have cards, matches, and selected. And now we're going to have your states here, so we're going to have the start state, and on click is going to target Inside the playing state we have always which is always trying to run game over and is going to check if no cards are left in which case is going to transition to game over. And then you have other events like on escape we can target the paused event or if the event is clicked then we can say target check guesses so we can go into an intermediary state and we can trigger the action select card. And in our intermediary state check guesses we're always going to target playing with the action match if the condition is max guesses and the target is playing. In our pause state if you press escape we're going to target playing again. In our game over state on click we're going to target playing and we're going to reset the game. So let's look at where we keep all of these actions and guards. This is part of your state machine but you can also place this outside your state machine. So here we have actions. So we have select card. So we use assign to assign the context of selected and the data that we passed through the event. We're doing the same thing for match that we've done before, but now all of it is neatly packaged into our state machine. And now we also have reset game, so we're just going to reset the board. And here are our guards. So we have no cards left and max guesses. And you may be thinking that this is verbose and that is true, but state machines expose all your states and transitions and this code would live somewhere else anyhow. And now the benefit of this is that you can share this and use this with any framework because this isn't swell specific right this is just a state machine and you can also visualize it as you see so even someone who doesn't understand code can see problems in your logic and to use the state machine this looks very similar we can destructure state and send from use machine which to we pass the game machine and that's pretty much it if you like what you've seen don't forget to like and subscribe you can also support me by becoming a Patreon and don't forget to join the Discord. Thank you for watching and catch you in the next one. Peace!