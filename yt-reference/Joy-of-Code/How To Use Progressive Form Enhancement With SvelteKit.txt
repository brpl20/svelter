 Hey friends, let's talk about progressive form enhancement in SvelteKit and how to use it to improve your user experience. You can find the code on GitHub and open it on StackBlitz if you want to follow along, but right now I only have a simple SvelteKit project and nothing else, and I have a basic form with some styling and that's it. If you used a modern JavaScript framework in the past couple of years, you probably forgot how forms work, so let's really talk briefly about that. Here's an interesting question for you. Do you know what is the default behavior of a form? Let's just try it out. So here I have a form. I'm not really going to submit anything, but look, something interesting is going to happen. So our URL is going to send some params by the form, which is our email and password field, thanks by specifying the name, password and name, email. But what's interesting about this to me is that the browser already knows how to serialize and send the form data, which got really completely circumvented by using popular JavaScript libraries and using prevent default, where you have to re-implement this behavior yourself. And I'm going to show you in a second how that looks like. So even if I go here and start typing test, test.com, super secure password, and if I submit the form, it's going to send the data over. So really the default behavior of a form is going to have a method get, but in this case we can also post. And the default action where it's going to do the action is going to be the URL that invoked it. So in this case, it's going to be the same URL. but you can obviously point it anywhere you want. So let's for example, say I'm going to do a post here and action itself. Let's just do it again. And let's just press this. And now since we're doing the post, I'm going to do a get request. So let's look at the network tab. 1234. And we can see some Sveltee junk here. And you can see here is a post request. And you should also be able to see the payload that we sent. you can see that the browser already knows how to do this. You have some form data, here's the email and password, and the preview is just the HTML, right? Let me just show you how you did this in the past. I'm going to close it, but we're going to look at the network tab later. So here's how you would do this in any other JavaScript framework in the recent years. Let's just say I'm going to create an API endpoint, API login in this case. And now we really want to listen to the onSubmit event, so we can say on, submit in SwellKit, We can give it a special modifier. We can say prevent default, and now we can say handle submit. And I can go to the top. I'm going to create a script tag. Let's create an async function handle submit. We're going to take an event, which is of type submit event or type script. And now we can get the form itself. So you can say form equals, you can say this, or I prefer to say event target. And now we need to tell TypeScript what element this is, HTML form element, and now we can get the form data. So we do this by saying const data, new form data, and now we can pass it the form and let's just log it out. So data, and we should just get the form here. So let me just say this, I'm going to open the console, just say test. And we get the form data, which is an object. So we can do something like data get, and we can, for example, get the email. So just say test. And now we should see the email. I also want to mention that you've probably seen this in other frameworks or even using Svelte, that people also did things like this where they bound the values to some variables. So for example, const email, or you can say let whatever, const password. And now people went to the input whatever and they said bind value to whatever, right? Which is also another way you can do this. And then you can use this value when you're going to send it data to fetch, right? So let me just remove this and show you what I'm talking about. And I'm going to remove this console.log. So now we need to ping our endpoint. And the beauty of a framework like SwellKit is that it lets us define our own standalone endpoint, which you can use for the form, which wouldn't be possible using regular Swell because you don't have a server. but in this case we control the backend and the frontend. So you can say await fetch, and now we don't need to specify the URL, but you can pass it the URL from the form you received. So you can say form action, thanks to TypeScript. And now let's pass it some options. So you can say method and you can say post like before, but again, we pass the form. So we really know the method which is awesome And now for the body what you going to send we can just pass it data And optionally you can also specify a header If you want so you can say headers you can say content type form data, but this is really optional and the browser should know what to do. So if you go to the MDN docs for fetch, you can see body and here, let me find where it says, both request and response, and by extension, the fetch function will try to intelligently determine the content type. Our request will also automatically set a content type header if none is set in the dictionary. So this is going to recognize the differences of type form data or JSON even. So in most cases, you don't have to define this yourself. So let me just remove it. All right, so now let's create the API endpoint. So we can go to source and now we can go to routes and I'm going to create new file. I'm going to create a folder API login and we need to create a plus server TS file. That's a standalone input file. And this exposes all the HTTP words that you like get, post and et cetera. And I also want to stress out that API is not a convention in SvelteKit, like it's maybe in Next.js, but API is just something I made up. You can name this banana slash login or whatever. So yeah, I'm going to press enter. So now I'm going to say export const post. We're going to use the post HTTP request method, right? I'm going to give it a type request handler and it should auto import a type for us. Thank you, TypeScript. I'm going to say it should be async and we're going to destructure the request from it. So let me just create a function body. Now we can get the form data. So I can say const form data await. Now we can say request form data, similar to before. And now we can get the data. This is a neat trick. So you don't have to say get for every field. So we can say object from entries, the form data, and now we can do whatever you want. So communicate with your database or whatever, but I'm just going to say console log data, and then you should usually throw a new response. So you can say return new response. And this is just using the web platform. So you can specify here, hello or whatever. But in this case, I'm just going to issue a redirect. So I'm going to say fro redirect, this should auto import from CellKit 303, and we're going to redirect root or home in this case. All right, so let me save this. And since the server is named or the file is named server, we're going to get the log inside the terminal. So let me open that. And let me just shrink this down so you can see what's going on. And now if we go to the form, so remember here we're pointing this to this form, API login. We can even go to this URL, but nothing is going to happen because yeah, we don't really have anything here. So the get method isn't allowed. But yeah, let me just do this. I'm going to say test1234. And now we get what we typed in our form, which is really incredible. And now we leaked our password and username. So congrats everyone, great job. And even if we go to the network tab, let me just clear this out. I'm going to do this again. So you can see here is the login and then it redirects to localhost. So you can see here it sent 303. And we can see here is the payload and the preview is a document. And you can do other things here like return JSON if you want a success state or whatever else. Progressive enhancement is popularized and championed by web frameworks like Remix and SvelteKit where they give you the best of both worlds by having a form work without JavaScript. And then if JavaScript is available on the page, they use client-side rendering. And this is possible because these frameworks combine the frontend and backend and give you complete control over it. As I mentioned before, where your form now can have an endpoint. And this would be really equal to defining an endpoint something like Express. Let me just close all of these things for a moment. And let's talk about Svelte Actions. So by now you might be thinking, okay, this is cool, but this might come tedious to do for every form. And you might chuck this in another file and et cetera, but we can use Svelte Actions so we can have reusable pieces of code in our Svelte application. So in this case, I'm just going to go to source and I'm going to create a lib folder and I'm going to create a file named formts. And we can specify a form action. So we can say export function enhance. We're going to pass in a form as a HTML form element for TypeScript. And now inside of this function, we can say form addEventListener submit, right? And we're going to say handle submit. And I'm going to create this function right now. So I'm going to say function probably async, function handle submit. And let's wait on this for a second. And now we need to just clean it up so we can return a function destroy just do it like this You can say form remove event listener and now we can say submit, you can say handle submit. And the best thing about this, this is just regular JavaScript. So this really isn't anything specific to Svelte. We just get the form element, we attach an event listener, and we also clean it up after. And like any event listener is going to take an event, which is submit event in the case of TypeScript. And now we do the same thing as before. So we have to say event, paren default, otherwise the form is going to do is default behavior. But in this case, we want JavaScript to take over and client-side rendering, right? And then we can just get the data. So you can say data, new form data, and we already have the form pass, so we can do it like this. And now we can do the same thing within that function before. We can say await fetch. Again, we have the form action, And now let's pass it method for method and body is going to be data. And this is basically it. So, okay, how do we use it now? We can go here and now I can remove this code because we really don't need it. Now I can say import enhance from lib. This is a default alias that SvelteKit provides for you. So we can say lib form and that should be it. So we really don't have handle submit. So we can now remove this. And now you can use an action by saying use enhance. We can save it. And now let's just refresh for good measure. And sometimes this complains, but you can just ignore. And now when we do it, so we can just say test. And now we can submit it. And let me just see in the network tab, you can see login. And now we also get the payload same as before and the preview. And let me just go here. And you can see here it's console log, Because again, this is just going to ping our endpoint for our form and we console log it out in our endpoint for the form right here, and then we direct it. All right, so this is a slight improvement, but you also have to invalidate the page data and handle errors. And this is really starting to get tedious. In my opinion, you shouldn't implement these features yourself, but the framework should do the work for you. And thanks to SvelteKit, you don't have to do this work. You can use the web platform instead, and SvelteKit makes this really easy using form actions. Instead of using a standalone endpoint, we can use a page endpoint that's named page.server.ts, that's usually alongside page.svelte. And then we can use form actions, which is really a neat way where you can use functions to trigger form actions. So let me just quickly close this windows and we're going to go back to page.svelte. But for example, let me just close this. And now inside our project, we just close this folder. Inside our routes, I'm going to create plus page server TS. And now let me just close the sidebar. And I'm going to show you what I meant. So I can say export const load, and this is going to be page server load. And we're not going to do anything here, but I'm just going to console log out page svelte load function. And that's going to be it. So I'm going to define some form action so I can say, export const actions, and this is of type actions. And now we can use a default one here, but we can use a named action so I can say login, async, and now I'm going to say request, and now we can get the form data again, form data await request, form data, same thing we did before. And now we can get the data itself. We can say object from entries form data. And now we can do whatever you want, talk to your database or whatever, but I'm just going to log it out and I'm going to redirect everything. So I'm going to say fro redirect. Again, it's going to auto import 303. And that's going to be it. All right, so how do we use this? And it's really simple. So I can go here and remember how we use Enhance here. Wouldn't it be nice if SwellKit just exposed this? So we can do app and we can say forms and that's it. And you also don't really have to change anything here because that's how you use it. You just say use Enhance and that's it. We just really need to change the action because now our form has its own endpoint that uses the page endpoint. So we can just use the name form action. Again the method is going to be post But now for the action we can just say question mark login And now I can save this and everything should work fine So we can say test And let me just open the network tab. And I'm going to open the terminal. And let me just press login. And again, this works and our load function runs. It's going to rerun the load function and update the data on our page that we have. So if we go here, we can see the payload is here. And the preview is the redirect that we got, which is really awesome. You can even see the headers here. So it's known that it's type JSON, which is really interesting. And the page invalidation part is really interesting. So I can even show you this. For example, if I go here and I can go to the console. And in our page endpoint, we can define a variable. And now we can return some data for the page. So we can say return count, count plus equals one. So we're going to increment it every time. And let me just do it like that. So when I start typing here, so now I can press login and we should see this revalidated and we're going to update the count. So each time, well, we should just use it on our page, right? So I have to say export like data and And that is going to be of the type page server data. And now let's just do a reactive variable. We can say data count. Let me just save this. And now again, we can go here, say login. And now you should see the count is going to update. So this runs on your server. So of course we're not console logging it out, but I can go here and I can say, console.count. So it's going to be on the server and on the client. As you can see, every time you submit, it's going to revalidate an update count. And that's how simple it is to use progressive form enhancement in SvelteKit. And of course, we took the long route to explain the history so you understand how this actually works. And SvelteKit also makes validating form errors simple and redirecting, which is a separate video to be honest. But if you go to the docs, form actions, progressive enhancement, basically it shows you everything I did. And even it says here how useEnhance works, it emulates the browser native behavior, it's going to update the form, whatever, then it's going to reset the form fields, and it's going to call goto for a redirect response. And in case of an error, it's going to use the nearest error boundary if an error occurs. And also the best part is that you can customize this behavior. You can provide a function that runs immediately before the form is submitted and optionally returns a callback so you can do pending UI state. So you can see, for example, here you have use enhance, and now you can pass it form data action cancel. That's going to be a callback. And the form is the form element, data is the form data object, action is the URL, et cetera. You can cancel, and here you can even make some custom behavior result update, which you can read more about. So you have apply actions. It even shows you how to implement progressive enhancement yourself, which looks really similar to what we did before. So you can use a custom event listener, and this is really similar to what I showed you before. But yeah, this is really fascinating. And let me just show you. So if I go here, let me just close this terminal and in the console, you can press Ctrl P pointy boy. You can start typing JavaScript. Let's disable JavaScript. And for good measure, I'm going to refresh the page. And now I don't even have styles because I'm using Tailwind from a CDN, but I can say test, test.com 1234. And you should see that this still works. If we go to the network tab, let's just clear it. You can say login. You can see it's being redirected. Here is the payload and I can do whatever you want. And of course the point isn't that your site should work without JavaScript, but before JavaScript, in case something happens or it hasn't loaded yet, the users can still use your form and then you can progressively enhance their experience using JavaScript. So if we go back here, type JavaScript, let's enable it again, refresh. And you're going to see in this case, the page isn't going to refresh because client-side routing starts to kick in. So you can type test1234, you can say login and everything works the same. All right. Hope this was educational. Don't forget to like and subscribe. And if you want to support me, you can become a YouTube channel member or find the link to my Patreon in the description. Thank you for watching and catch you in the next one. Peace. We'll see you then.