 Hey friends, if you haven't heard, BitsUI is an awesome headless component library for Swell, and recently they hit a 1.0 release, so congratulations on that. So what is actually BitsUI? Well basically, BitsUI is a flexible, unstyled, and accessible primitives that provide the foundation for building your own high-quality component library. And BitsUI has over 30 components ranging from an accordion to date pickers and a custom select menu completely tailor-made for your project. Alright, but what is the difference between a a pre-styled component library and a headless component library. So in this example, I'm going to show you the use of Flowbyte Svelte, which is a traditional pre-styled component library. So usually when you're using a pre-styled component library, you buy into their design system and etc. Of course, most of them provide teaming options and etc. But you're fighting against them. And this isn't picking on Flowbyte or any of these libraries, it's just different. If you like their design system, you just want something quickly done, then this is perfect for you. So for example, we can see here how we import Flowbyte Svelte. And here in AppCSS, we can just use Tailwind, and we can initialize the Flowwire plugin, the final variant, including some theming options, and that's basically it. So now you can see we have this wonderful accordion, and that's basically it. But now you're bought into their system, you have to follow their rules, and you're only limited to what you can do. So for example, if we want to remove these rounded borders, we can provide a flush prop. So now we can change the appearance of this very easily. But as you can see, it's really not that flexible. And also notice how the elements you provide are fixed, so you can, for example, swap the title with the arrow on the right and etc. It's really just not possible. And another thing that really bothers me when you buy into some of these UI libraries, so for example, if you look at this select from Flowbyte, it looks really pretty until we open the select, and then we can see it uses the native select under the hood. And that's really not a problem, but that's something that I can do myself. I at least at minimum expect from a UI component library to do this for me. And I'm not going to name names, but there's been one web components library recently that raised $1 million, and when I opened their example and I looked at their select, it was just a normal native select, which is really disappointing. All that money probably went just to convince someone to offer web components Ha Got em But headless libraries on the other hand can get away with that because they actually have to implement everything from scratch and make sure that it accessible So by default you get unstyled components where you have control over every element. Alright, with that out of the way, let's look at the headless UI library approach and how Beats UI does it. Alright, here is how the same accordion looks like in Beats UI. First we're going to import accordion from Beats UI. Then we're going to initialize accordion.root, so this holds all of the logic for the accordion. And then we're going to say accordion.item. And inside of the item we have a header with a trigger. And then we can also include the content using accordion.content. And as you can see, it doesn't look like anything because it's completely unstyled. And if we inspect this element, we can see that BitsUI takes care of all of the accessibility and everything that would be so tedious to do yourself. So now we have a completely customizable accordion. And as you can see, we're in complete control of the contents. But let's give it some styles using Tailwind CSS. How beautiful is that, friends? And of course, you can use the bind directive to get the value or the reference to the element itself. So you can see here we have these four items in the accordion, and we can see which one is selected. And of course, you can use Svelte's function bindings to have more control what happens when you read and write the value. Alright, so let's talk about styling Bits UI components. Styling components might not be your thing and you just want something beautifully designed out of the box. But don't worry because Beats UI has you covered and they have base tiles using Tailwind in every example. So you can see at this accordion example it already looks great out of the box. So you can just come here at the code. You can already see they provide some base tiles and you can just copy this over in your project. But of course, you're not only limited to Tailwind CSS but you can also use other things such as Uno CSS. And if you don't like any of these options you can just use regular CSS. So let's actually look at how you can style Bits UI components. So in the first example, we're using Tailwind CSS, same as before, and you can see everything looks fine. But of course, we can just use regular CSS. That being said it comes with a caveat because you can normally scope these classes to components because Svelte isn going to know that these classes are being used and are going to be removed So you have to define them in App globally And besides using regular classes, you can use data attributes to style elements. And you can also combine data attributes for the state to create things such as these animations. So here where we have content, we just define a height transition, and then we can say when the data state is open, then we can get access to the bits internal variable for the height, and that's how we can animate the height of the element. But if you really want scope styles, then there is a really powerful pattern in Bits UI using render delegation. So instead of just passing children to the trigger, we can actually use this child snippet. So we get the props back, then this is the most important part. We have to spread the props on the element, but you can use any element you want and you're going to have the same accessibility and other things that Bits UI provides. And as you can see, now you can have scope styles because this component is now in the scope of your component. And this pattern is really great if you want to use custom transitions, such as swell transitions, which you're going to look at in the animation section. And if you want to learn even more about styling, the BitsUI docs have even more examples. So let's look at how you can do transitions in BitsUI. Alright, so here I have a Tailwind example, and in AppCSS, I define this keyframe accordion down and accordion up, and then in the theme section, we can define these variables animate Accordion down and Animate Accordion up, which are internally used by Beats UI. So the only thing we have to do when we go to app.svelte, we just have to define on the content these classes. We can just say, hey, apply Animate Accordion up when the data state is closed and apply Animate Accordion down when the data state is open. And now when we've done that, we can see we have this beautiful animation. Alright, but maybe you want to use custom transitions such as one from Svelte, so let's replace these Tailwind classes with Svelte transitions. And this is how simple that is. So we just import slide from Swell Transition, and then we can use renderDelegation, we can just pass the child snippet. Here we get the props and the open state. So if this is open, then we're going to show the content and we going to just use the transition slide So you can see it works the same as before And this is all possible thanks to the force mount prop which is set to true so the component is mounted And of course you can learn more about transitions in the Bits UI docs. Alright, let's talk about how you can create reusable components. Alright, here I have a regular accordion from Bits UI but it would be so much nicer if we can make this somehow reusable. And of course I'm going to leave the styling choice up to you, but in this example, I just want to focus on creating a reusable component. Alright, so let's create a reusable accordion component. For this, we're going to create an accordion item component, and then we're going to import accordion from bits UI. And for the props, we're going to have title, content, and the rest of the props which we're going to spread on accordion item, and then we can just pass the title and the content. So now we have our reusable accordion item component. Next, in the accordion.swealth component, we can again import accordion from bits.ui and then we can import our own custom accordion item component. And for the props, we're going to have items, value and a ref, which can be both bindable. And we're going to spread the rest of the props. And now we can define accordion.root so we can bind the value and we can bind the reference to the element and then we spread the rest of the props. And then we're going to loop over all of the items and give them a unique key by combining the title and the index. And then we can just spread the item props. And that's it. Now we created our usable accordion component. So going back to App.12, now we can replace this with our custom accordion component. And this is the main reason why you would want to use headless components, because they let you create your own components using your own design system, however you see fit. And the Bits UI docs also do a great job of showing you how to create reusable components. But that's basically everything you have to know to get started with Bits UI. And they have some other things such as a Figma design document and Bits UI also provides LLM-friendly documentation. If you like Bits UI, do me a favor and give them a star on GitHub, which is free, but of course, you can also support the offer financially. That's it. You can support me by becoming a patron and you can also join the Discord. If you like what you've seen, don't forget to like and subscribe and I'll catch you in the next one. Peace!