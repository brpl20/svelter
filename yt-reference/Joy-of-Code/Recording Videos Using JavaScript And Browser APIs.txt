 Yo friends, what's up? Let me show you today how you can record video on the web and using an actual video format like MP4 instead of that garbage WebM format. And I know there's going to be some people, but WebM is perfectly fine. It's made by Google and it's open source. I tell that to my editor who has no idea what to do with that format, right? So you have to convert it. You have to do all of these convoluted things, right? And an interesting thing is that I actually made this recording feature a year ago for my slide presentation library, but it actually only supported WebM, so I axed. But I'm glad to report to you today that you can now actually record MP4. And for that, we're going to use the Media Recorder API. But let me actually quickly show you how this looks like. So I can even use this shortcut. First, we're going to ask the user for the permission so they can share their tab, window, or desktop even. Let's say allow, we have this countdown. And then we can record whatever we want, right? So we can actually just animate some things in. And how beautifully this runs, right? Cool. So let me actually just stop the recording. I'm going to stop sharing I can save it here and you're going to see we get that pure MP4 boom it's going to open VLC let me full screen you're going to see how wonderful is that right so we can actually record great looking video in the browser with not a lot of effort right and we're going to actually learn a bit more how video works and etc and it's really simple how it's implemented I just have to import this recorder component as well of course this is framework agnostic it's just JavaScript right I'm just implementing this recorder feature for my library, right? But you can do whatever you want, right? Alright, but before we get started, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support. Alright friends, before we write a line of code, I actually thought it would be fun to take a detour and actually learn some basics about video because video can be infinitely complex, right? But if you understand basics, then you're going to have more confidence working with video and audio. So let's actually learn a bit how video actually works. So let's say you have some video .mp4, right? What is that actually? Well, that is not actually the entire video format. A video is made out of two things, out of the codec, which stands for decoder algorithm. So that is the actual thing that compresses the video, right? So those images, right? and then you have the actual container which can be anything right So in this example here we have some video encoder This is the most popular format probably This is already 22 years or something like called If you go for example here to the wiki let me actually check So yeah initial release 22 years ago And MP4 stands for MPEG4. This came out of the QuickTime format that Apple made, right? But actually, it's really not important, this history, right? But you can actually see how this looks like. So for example, here, where you have your container inside of that container, you can have multiple video and audio streams and other things such as subtitles and metadata. This is basically how videos work, right? And talking about the containers, so these are the common codecs used on the web, right? I took this from MDM, right? But you can see here is the most popular video format, AVC. So this is your advanced video coding. So this is the actual encoder. And then you can have multiple containers that it supports and have this free GP. I think that's for phones, right? Or something, right? So you have MP4s, right? Then you have some other phones which really aren't important. Then the other one you might be familiar with, is this VP8 and VP9, which was made by Google, right? And I think the reason they made this, right, because it's open source and there are some licensing issues with MP4s, right, because they really aren't open source or something. And as you can see, you have this audio or video codec, right? And then you have multiple containers. So you can have, for this VP9, you can have MP4, OGG, WebM, right? And I'm going to put all of these links in the description if you want to read more, but basically it's just from MDN, right? So we can actually go to here. But you can notice that AVC is a proprietary format. So you can see this is probably the motivation and reason why Google probably wanted to make an open source format like WebM. But that all goes out the window when all of the other things you're using doesn't even understand WebM, right? But okay, I'm going to give them points for that, right? At least they're trying, right? If you're interested in this, you can just click on them and you can read more what they do, right? So regardless, X, YouTube, or whatever, you're going to see they expect one format, which is MP4, right? So for example, even if we go here, YouTube has an entire recommended upload encoding settings. They recommend the container that you use MP4. They even recommend the audio code. Again, the most popular video code that they recommend. You can check it out here. And then they have an entire table for the bitrate that you can pass them so your video looks great, right? And actually, let's talk about this more. For example, there are a couple of video quality factors that you can factor in, right? Pun intended. So for example, you have the resolution, of course. 720p, 1080p, right? And I was actually curious what does this P stand for right It actually means progressive scan And this just means how the image is generated before you see it So for example here you had this interlaced format and I actually not a video expert if you can believe it right So how I think interlaced works in the past, you actually had two frames where you had half of the image. So you had these lines, right? It would have even an odd number of lines for two frames and then it would combine them, right? Because the bandwidth for the video or whatever wasn't enough. And then you have this modern progressive scan where it goes from left to right until the image is completed for the entire frame and this is how video today works and maybe i'm wrong you can correct me on this but yeah and then you have fps so how many frames per second so for example you're watching this video at 30 fps because it has really not a lot of motion right so i don't actually have to record at 60 fps but for example here in my slides where i have a lot of this motion i want people to have that buttery smooth experience then i want 60 frames per second right and another important thing that a lot of people overlook so for example they say oh my video looks choppy, like it's blocky, right? You see those blocks, right? And that is because of the bit rate. So for example, again, there's not a lot of motion in this video. I'm recording at 2000 kilobits per second. But you can see the default when I'm going to use the Media Recorder API is going to be 2.5 megabits per second. And this is where that table from YouTube comes in because you can actually look at their table. So these are the recommended upload and coding settings. You have your average frame rate up to 30 FPS, right? But let's actually say, for example, that you're going to 60 FPS, then they have recommendations for you here. So 720p, you can actually use 7.5 megabits per second, or 1080p, you can use 12, and so on. And this table is really useful. But yeah, that's basically a brief introduction to video. I hope this was useful to you, because you're going to have a lot more confidence once you start working with audio and video. And this isn't scary. Of course, you're going to actually see how simple actually the Media Recorder API is, because all of this is done for you. But I think it's actually super helpful to know at least the fundamentals. Alright, so let me actually explain what are we going to do. So it's really simple as this. So first we have to ask the user for permission. So for that we're going to use getDisplayMedia, right? Alright, so now we have their screen or whatever they share with us. Now we have to record the stream of data somehow, which is just a raw stream of bytes. So we can record this into a chunks array using the media recorder, right? And then when we're done with that, we can just download the mp4 we created from the chunks using a blob. That's basically what we're going to do here. It's just these three simple steps. Alright enough yapping Let write some code Alright so here I have this symbol component Again I using Svelte but this is framework agnostic so let me first create a script tag I using TypeScript so let me actually define the props for these components and here we have an optional options object, so we can actually just say options, and then we can pass things like frame rate, which is optional, so we can pass audio bits per second, and we can even pass video bits per second. and let's ask the user if they even want to record the audio or not awesome and now we can create props here using the dollar sign props rune give it this type and voila you're done alright so for the state I actually prefer to be explicit so let's create this type state and I'm going to say ready then I'm also going to have ready countdown and we're going to have the recording state and we're going to see in a second how awesome explicit state is. So let's just create state. We're going to give it this type. Let's make it reactive. For starters, we're going to give it ready. So it's going to be in the ready state. We're ready for recording. And then we're going to have more things. So remember how we talked about the media recorder and media stream. Let's have a reference for it here. So let's say media recorder. This is just going to use the media recorder type. And this is global because this is just a browser API. Let's also say media stream. And then we're going to store the chunks. Let's create a blob array and initialize an empty array. Cool, and then we're going to have the interval. So let's give this type of number. And then here are going to be the seconds. So we want this to be reactive. And let's make it three seconds by default. And my bad, this is not state. let's just rename this recorder because it clashes with the state rune here okay cool all right so having explicit state is awesome for a couple of reasons for example the only thing that we have to do here is use this id block in swell and then we only want to show this when it's not recording right this is why we've done that ready and ready.countdown because we can do something like this inspired by state machines so we can for example say recorder includes boom and only then are we going to show our recorder. Alright, so now let's create our recorder. And here's another awesome thing about explicit state. We can use data attributes to style our application however we want based on its state. So for example, here I'm using data state, and I can just pass in the recorder state. Alright, and inside of this I'm going to have a button

 which is going to have a class record and then on click you're going to start recording. Let's just create a function here. That's it for now. Let's go back to our button. Inside of our button we're going to have our circle and now this is the awesome part, again having explicit state. We can just say recorder equals ready.countdown and I think Tystrap is going to complain because we're actually not assigning it anywhere right now but we're going to do that in a minute. Alright, so if this is the case, then we're going to show the seconds. That's basically it. Alright, so that's for that logic, but now we also want to show the useful information for the recorder. So let's go here. We're going to create an info section. Then let's create an if block. If the recorder is ready, we want to show some useful tips, like the shortcut. So I can say P shortcut. And then we can say shift plus R for recording. Of course, we can detect the operating system and show the Mac icon or whatever you want. And then let's copy this over. This is going to be the description. And then we can just say here to start recording. Boom. Let's copy this block over. So again, this is going to be our countdown state. So during countdown, we want to show the user that they can cancel this or stop this, right? So it's going to be S for stop, very creative. So we can say to stop recording. And that's basically it. The only thing I'm going to do, I'm going to cheat and copy over the styles because we will be here for hours, right? And let me actually explain this to you. It's really not that intimidating, right? So it's really simple. Let me just save things. So here we have this recorder. I'm using CSS variables. Nothing weird, right? And then here, this is a beautiful thing because we can actually style our recorder based on what state it is. So for example, if it's in state ready countdown, we can change the CSS variables. That's pretty much it. Here's just some regular standard nested CSS, right? So we're raw dogging CSS. We're not using Tailwind, right? So actually, now when we go here, and now when we refresh the page, we're going to see here we have our beautiful recorder. But yeah, for example, if we change the recorder state from ready to ready.countdown, we're going to see it's going to be styled like this using our countdown, right? And then, of course, if you're recording, it's not going to show at all. Cool. And this is a lot better than using booleans and getting into spaghetti state and etc. All right, so now we can actually bring this back to ready. And now we can finally move on to the fun part Alright so let create an options object for the video options and we going to then override them with the props the user passed So we can just say const options and the first thing I going to define is a mine type. So we can just say video slash mp4 and if you don't specify it, it's going to use webm for the container by default. Let me actually show you in the MDN docs, I actually explained this in really great detail. So for example, you can actually just pass in any video container that you want. So you can say video slash OGG slash mp4 slash QuickTime and so on. But for example, you can also specify your own codec. And this is a more advanced example. So let's say for example that you want an mp4 container and you want to use AVC or H.264 for the codec, right? You can read this explanation how you can do this, what these numbers mean, right? There's a table you can pick from it you're going to see. Let me actually just show you quickly how would this look like in practice. So you would just copy over the line from the example and then boom, you just have to define the container semicolon, codecs then you have to paste your codec here and then you can also specify your audio codec if you want, so you can say opus here for example but I'm actually fine with the default the default video codec is going to use is going to be VP9 and opus for the audio, which I'm fine with I only mostly care about this container but yeah, that's a more advanced feature if you want awesome, so now we can specify the frame rate let's make it 60fps and then we're going to have audio bits per second so this is going to be 2.5 megabits per second cool, let me just copy this over let's rename this to video that's it, and now let's also enable audio by default and now we can override this option so we can say props options and that's basically it alright, so the first thing we have to do is as a user for permission and I'm going to make this function async so let's just go here let's just create a try catch block so we can actually catch an error since we're going to use a promise and then we can say i don't care let's just say console error e that's it all right so let's reassign media stream because we want a global reference to it and now we just have to say await navigator and again this is the same way how you ask a user for a webcam or whatever else you want but in this case we can say navigator media devices get display media boom and now we can also pass in some options. So we can pass a video option, we're going to specify the frame rate which is obviously going to be options frame rate and then we can also specify audio options audio boom And let actually save this and you going to notice one thing let me just close this. So now actually we can ask the user for permission, and you're going to see by default, it gives you this option, Brave tab, window, or the entire screen if you want. You can keep it like this, but I actually just want the user to record the current tab. And there is actually an undocumented option here, so for example we can pass in prefers current tab true and we're thinking how is this undocumented like because I actually added this type myself so for example if I go here you can see I added it right here so display media option and I added another event listener for the media stream but yeah for example if we go here to the MDN docs let's just say display media current tab this is why it's so important to read docs even if you have TypeScript you can get cocky You can be like, oh, I have my documentation in your editor. Nope, this isn't even in TypeScript, right? Because this is optional or experimental, right? You can see here is prefer current tab. So always read the docs and then you're going to learn a lot, right? But yeah, this is really cool. So let's actually go back here. So now you can say prefer current tab. And now when we ask the user for permission, it's only going to ask us about this tab. But yeah, it depends on what you want, right? So let's just say cancel and that's it. Let's actually see what this media stream thing is, right? let's actually console log media stream boom let me just open refresh boom let me ask for permission i'm going to say cancel actually let's just allow it cool so let's actually say stop sharing and you're going to see here is just this normal media stream object you can see it has some things on it you can add tracks you can see the tracks from it and this is actually something that you have to keep in mind when you're going to do a cleanup you're going to see get tracks. So this is going to be your audio and video tracks, right? And actually this comes from this media stream thing, right? Because it's a prototype of it, you can already see it has these get tracks and other methods on it. All right, so let me actually just make sure I saved. And let me just refresh for good measure. Cool, let me just allow it. And you're going to see it's going to output these two tracks because we have two tracks. We have one audio and one video stream right so this is going to get combined at the end of the day so yeah basically that's how this works and then we're going to have to clean this up in a bit all right so now that we have the user permission we can use the media recorder api to record the stream so let me just go here and we can just say media recorder so we can reassign it and the only thing you have to do is say new media recorder That it And now we can pass in your stream and we can also pass in some options here So for example, here we have the mime type. This is going to come from options. Mime type, then we're going to have audio bits per second. And of course, we're going to have video bits per second. And you can also optionally just pass, let me see, bits per second. and this is going to apply to audio and video bits per second if you want. But yeah, let me actually show you what this thing is so you can actually log Media Recorder. Let me save this, be clear. Let's log something and now we're going to see if we stop sharing. This is the Media Recorder API. It has all of our information about the video inside of here but actually how do we get to this data? Where is this? So we can use this onDataAvailable method. So we're going to start our recording. once it stops, this is going to get called. So now we're going to have some data and then we're going to push the chunks. And you can even see something interesting inside of the media recorder itself. It uses a state machine itself, right? So you can look at this state inactive. And we're also going to use this to do a cleanup in a second. All right, so let me actually show you how this works. So the first thing we actually have to do is start the recording, right? So we can just say media recorder and we can just say start. And of course, you can see here by the log, if we go to the media recorder prototype, you're going to see it has all of these methods on it. So here is start, for example. But yeah, how beautiful is that, right? So we can actually go back here. So now we're going to start recording, but of course we just want to invoke this. So we can say media recorder, on data available. This is going to return this event. We can actually just console log the event. We actually go here. And again, let me just give permission. Allow, again, nothing is going to happen until this is done. Then the event is going to get called. All right, so if we stop sharing, boom, here it is. So here is our raw data of this recording, right? You can see here it is on this data object. You can see here is a blob and it even gives you the type. So the container that it uses is MP4 and for the codec, for the video codec by default uses VP9 and for the audio codec it uses Opus, right? And of course, as I said before, you can change this codec. All right, but now we can just go back and we can just push this to our chunks array. That's it. So we can, for example, say chunks push event data. That's it. And now we can also download the video. So for example, we can say media recorder when all of this is said and done. So we can say on stop and we can invoke this download function. And let's also not forget before we start recording

 to update our state. So we can say recorder recording boom that's it. Alright so let's actually go here and this is going to be very simple. So we're going to say download. So first we're going to create a blob. So we're going to say new blob. We're going to pass in our chunks and then the type is going to be options mime type. That's it. And now we're going to create a link. So we can say document create element a. And now we're going to set the source for the link. We're going to say URL create object URL. And then let's pass in the blog. And we can also give it a name. So you can say video.mp4. And then we're going to click on it and start the download process. All right. And let's also do some cleanup. So when this is done, and we can say chunks equals empty array. We can save everything. So let's see if this works. So for example, we can start recording. Boom, immediately starting recording. That's it. We can stop sharing. It's going to ask us for a video. We can just override this initial video. And boom, let's open it. And let's see. How beautiful is this, friends? We can record MP4s using web technologies. Alright, so there's only a couple of things left to do. First, we're going to create the countdown. Then we're going to handle the keyboard events and do the cleanup. Alright, let's create the countdown. So here I'm going to create a function named countdown. This is going to be very simple So again we need to update our state Ready countdown And that basically it So here I going to create an interval but before that we actually have to return a promise and instead of doing return new promise and etc there's actually a newer API that should be supported in every browser, I think. So we can say let promise with resolvers. Boom. And now this gives you everything you need. This gives you the promise, this gives you the resolver, and etc. All right, cool. So now that we have this, we can actually create a timer. So we can reassign timer. We can say setInterval. Let's pass in a callback. And this is going to happen every second. Alright, so now we can actually check if seconds are 0. Then this is done. So we're going to say clearInterval. Pass the timer. And we can resolve the promise. And we can pass it, whatever. It's not important. Awesome. Otherwise we're going to just decrement seconds. And then we have to return the promise. Let's just return the promise. Yeah, so basically that's it. and then when we have this countdown, we can actually go here. So first we ask the user for the permission, then we can actually start the countdown, and that's basically it. So we can say, await countdown. Boom. Let's save this, go back to our presentation. Let's go to the start. Awesome, so let me actually start the recording. Let's see, 3, 2, 1, 0. That's it, it should be gone. We should now be recording. Let's see if this works. Again, we have to manually stop sharing. It's going to ask us to save the video. Let's replace it. And now we can actually open this video, and we're going to see it looks perfect. Alright, so instead of manually clicking things, let's handle keyboard events. So we can actually just go back here to our call and let actually see where is a good spot We can actually go here Let me create a function candle key down because that the event listener we going to listen to That is going to be an event. Keyboard event, that's it. Let's just use a switch statement. We're going to switch it based on the key. So in the case, if it's R, and then we're also going to have another case, which is going to be S for stop. Alright, so recording and stop. And we don't even need a break case in this example. And again, this is another beauty of explicit state. So now, when we're inside of here, we only want to start recording if the recorder is in the ready state. So we can say recorder ready, then we can just short circuit it. We can say start recording. Boom, that's it. And to stop the recorder, we first have to check, hey, if this isn't in the ready state, then let's say stop recording. and we actually have to create this function another beautiful thing about this is that we can use the same function for the cleanup but before we do that let's not forget to actually add this event listener so we can actually add it to the window by using svelte colon window and then we can listen for on key down and then let's handle key down boom that's it alright so let's add the stop recording function after start recording so yeah here it is we can actually just add this function. So the first thing we're going to do is reset state. So we're going to say recorder is ready. Then we're going to say media recorder. In case it doesn't exist, we're going to stop it. And then if there's any interval, we're going to clear it. And then let just reset the count to 3 seconds But you going to notice one problem Let me just save everything And we going to see now we can use our keyboard shortcuts So Shift R is going to ask us for permission. Let's allow it and let me just record it. Alright, so now we're starting the recording but as you can see, even if I stop the recording like this using my keyboard shortcut we're going to see this doesn't go away because we actually had to stop the tracks. So we can do that by saying media stream and then we can get the tracks and let's just loop over each track and we can say stop. Cool. So now I'm going to go back here, shift R, allow. Let's start recording and now I can just end it. And again, that's the previous one that we didn't take care of. So let me actually do this. And we can immediately end the recording you're going to see is going to go away but you can also do another thing which is again undocumented in this API. So for MediaStream you have this inactive event listener, right? So it's fired when the MediaStream is inactivated. So let's actually go back to our code and we can actually make this really simple. So MediaStream on inactive we can also say stop recording. Cool, now we can save this and we're going to see it works as expected. So now we can record, do whatever we want. Let's stop the recording. Save the video. And let's see if everything works. Awesome! How beautiful is this, friends? If you like what you've seen, don't forget to like and subscribe. Thank you for watching and I'll catch you in the next one. Peace!