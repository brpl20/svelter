 Hey friends, what's up? I thought in today's video we would look at the new Svelte 5 changes and compare them to the older version of Svelte using this component party site. Recently I started to get more into Svelte 5 as I feel the release is closing nearer, but you're going to see based on these examples how awesome the new version of Svelte is. Alright, so without any delays, let's get started. Alright friends, so let's start with reactivity. You probably all know and love this syntax in Svelte 4 we can say let name equals John and then we can use reassignment to update a value in Svelte easy peasy like that but in Svelte 5 oh no what is this dollar sign state oh this looks a lot more complicated right but actually there's a couple of reasons why this is like this so we're using these runes which are just signals and this really makes things a lot simpler and when you write code you're going to see later how awesome it looks like but basically the reason runes exist is in Svelte we had two reactive systems so we had this kind of reactive system in the Svelte component itself and then you probably used or at least heard about Svelte stores so if you're using some code in another file you would have to use a different reactive system and this would get really confusing a lot of things to know about but in this case what you see here is the same way how we use reactivity inside Svelte components and outside Svelte components so this already makes things a lot simpler. So if we go to the Svelte 5 REPL and see here it's really simple same as before count equals dollar sign state and there are a couple of runes you have the derived rune and etc and we can just increment the count here the same as before. Easy peasy like that friends. So we can see the updating state so we can use reassignment here which is really awesome and we can also use reassignment in Svelte 5 so nothing changed here but another thing that these examples don't tell you now in Svelte 5 you no longer have to reassign so in the past if you had something like let's say array if you had something like these numbers and etc and then when you would want to reassign this in Svelte 4 and previous versions you would have to say you have to say array and then you would first have to spread the old values and then you would say new values this is no longer the case in Svelte 5 in Svelte 5 you can just reassign the value and Svelte is going to know to change it. So how awesome is that, friend? So that's really something beautiful. This is the same true for arrays and objects. And this is something I really love about Svelte 5. So in Svelte 4 you probably familiar with this label dollar sign syntax So you say label and double count so Svelte is going to see this and is going to know to update this because it all count here reference right but there's really a problem with this because when you have a function and use these values inside the Svelte compiler can't see this because their activity happens at compile time but when you're using signals this gets a lot easier and everything is so much clearer what is going on because you have this specified rune. So you have state, we have count here, then you have double count, we just say derived and you can use an expression here. And there is another rune where you can do more complex things inside, you can pass a function, but derived just accepts an expression and this is really simple. So now when someone else looks at the code, they don't have to understand this weird $column syntax, they can just see the derived rune and this works as expected. So if you use this value inside of another function, now you have runtime reactivity thanks to signals, so things work more as expected. And I also want to mention that there's some confusion around this $syntax, what this replaces, right? Some people think that they have to, there's this new rune effect. So you can use this, and people think, oh, this is React, but no, it's really nothing like React, you're not going to run into the same footguns. You don't use effect to run updates, you use the derived rune, because actually, how we had this $ syntax, this doesn't just translate to this effect. So for example, how you would say console log value in the past you would use effect for this for example or for side effects the domain etc but when you want to compute some value you just use the derived rune and that's basically it and in the case of console log here there's actually a special rune in svelte 5 inspect you can pass it a value and this is really more advanced and helpful and you also don't have to worry about removing it because this only works in development so that's really awesome alright so let's say for example you have this count component and you want to extract it into a reusable component which you can use inside other files right so let's reuse this increment function I'm going to name this counter and now simply as that we can just move this state inside of this function so we can do it like this and then we can keep everything here let's just rename count to value you're going to see why and then we can just return whatever we want. So I can say return, and then let's return the value, and let's also return an increment function. So this is going to be value plus equals one. And then we have to create this counter So we can say count counter And this is an example You would have this in another file So you would create a or file And you would have the same reactivity system in those files, right? So this completely replaces the need for stores. And now we can just say count. So this is why I named it value. Otherwise, it would be awkward. Count.count, right? And then we can say count.increment. But there's something interesting. This doesn't work. And why it is, and this isn't even related to Swell. This is just JavaScript. We're requesting a stale value from the function. Like this can be magically reactive when we request it, right? So there's a couple of things. We can return this as a function, which we can invoke. So we can invoke it like this, or we can use a getter and setter in JavaScript, right? So this isn't anything specific to Swell. And then we can say get value, and then we just return the value. That's it. So we can go here, and now it's completely reactive. As you can see, this is really simple, but this can get tedious because now you have to use getters and setters and the swell team saw that, saw that problem, right? And they made proxy state, which means that your state is reactively nested by default. So here's how we can fix this, for example. And now we can go here, we can turn this into an object and now we can say, for example, initial and we can pass in the initial value like this, just enhancing the example, right? Nothing special. And then we don't have to even think about getters and setters anymore unless you want more control. So now, because this is deeply reactive, arrays and objects are by default deeply reactive in Svelte 5. So this is just going to work as expected. And let's actually rename this value. So this is going to be value. We're going to pass the initial value. And now let's rename this to count. This is going to be count. And now you can even destructure this and it's going to work. So we can destructure count increment. And now we don't even have to use this. And we can also say count dot value. so it's going to reference count.value here. Oh, and of course, I need to change this count here. So I have to say count.value. As you can see, you don't have to think about this anymore. So there's another thing you can do. You can even use classes in Swellify. So for example, if we create class counter, and here you can also use state. So for example, we can have count equals state, and then you can just use a constructor. So you can use anything you want. You don't have to use classes. You can use functions, classes, and etc. depending how you prefer to abstract things, right? And then we can say initial And then we reference this count Initial or whatever else you want So what the Swell compiler is going to do when you use a class like this Is going to create the getters and setters automatically. So for example if I say. Const example. We can say new counter. And let's just actually see. Actually I don't even have to do this because we can go at the output. Let me just scoot this over. you can see what happens here. So this is what the Swell compiler does. It has this class and it creates a getter and setter. But of course you can do this yourself if you want, but this is how Swell 5 makes your life so much easier, encourages you to use classes and etc. which is really a great way to encapsulate some logic, but it doesn't force you into this. You don't have to use this. You can see we can use a class, we can use a function, we can use deeply nested reactivity here so we don't have to think about getters and setters, or you can use getters and setters if you want more control. Alright friends, so I hope you're already excited about 12.5 because I am, when I think about doing some state, I don't have to do some mental gymnastics, right, with colon equals and I'm like, okay, is this how it's going to work? Is this predictable? No, I just slap a derived or I use the reactive value somewhere and it updates as expected and this is such a joy to work in. Alright, so we looked at the computed state. Here is a templating example, nothing new here. We can look at the styling here and I don't think there's anything different here, right? so is the same as before. So let's look at loops, and nothing is changing here. Good old each loop works as expected, right? So let's look at events. And this is something really awesome in Svelte 5. So if we can look at the Svelte 4 example, we just say let count here. Of course, we're using this good old rune here. And now we can just increment the count, but if you can notice, there's something different. In Svelte 4, we use on, call, on, click, but in Svelte 5, your event listeners, like on, click, and et cetera, are just attributes, right? And this is really awesome because you can just pass this to your component. You can spread your event listeners and this makes things so much easier, not only for library authors and maintainers, but just for regular people that use Svelte, right? This is really so neat. Unfortunately, you lose some conveniences. For example, you might be familiar or use that pipe symbol and then you would say prevent default. You can do that here with this new system. You just have to use it inside the function, but the trade-off is worth it in my opinion. Alright, so let's see this example. So Dome reference, you need to reference a node. As you can see here in Svelte 4,

 We have to import on mount, and then we can reference the element. So we assign it using bind this input element. Boom. Easy peasy like this. But in Svelte 5, this is even better because this replaces the effect. This is what I told you before. Don't think that the effect is just a replacement for that dollar sign column because it does actually different things. This is used for side effects like the DOM and etc, right? And this is even simpler because we don't have to import these runes even. These are just compiler hints, right? These runes, if I didn't told you already. these aren't some functions even they look like functions but they just tell the spell compiler what to do so you can see we didn't have to import anything here we can just bind this same as before now we can use this effect when this component is mounted this is going to run and now we can focus this element so this is basically how you reference an element all right so this might look like a lot of code but i don't know why they made this convoluted example so this is basically just showing conditionals right which i don't think anything changed so this is really there is really nothing different here except this event handler right this is on call on click this is just on click so i don't think there's even anything to look at this example except of course the reactivity here so here we're using this dollar sign and here you just say dollar sign state you say derived boom and you don't have to think about it anymore it's just going to update as you expect all right so let's look at another example so life cycle again so this is actually the example so here the side effects, zone manipulation, right? So here we're importing on mount, we have this variable page title which we're going to update so this is reactive like this, and then we say on mount inside, and then we're going to update the title. But in Svelte 5 we just use an effect for this, and that's basically it, so nothing complicated. And then we can see things like on mount, so for example here we have to import this on destroy, but you can also use on mount in Svelte 4 and return a cleanup function I think. So here is the finding time, here is the simple timer so when this component gets unmounted, we're done, we don't really want this timer to persist, right? So we can use onDestroy, and then we can clear the interval. But in Sveltefy, we can just use this reactive state rune, we can declare the date, and now inside of the effect, we have this timer, and then we can just return a cleanup. I'm not sure why these examples are different, I'm pretty sure that you can just use onMount and return a cleanup function. But yeah, as you can see, this is just an example. So we can look at component composition, so here we're creating this user profile component, there is not a lot different here, I think. Let's see. Yeah, there is nothing different here. I think this wants to show you the props Yeah exactly So we can see here this was a bit weird in Svelte 4 and not because just of the syntax What annoyed me really in Svelte 4 was how difficult this was to type right And you would have to do some weird things if you wanted to type these things all at once. So you'd have to use export let for the props and etc. It doesn't matter. But look how simpler this is in Svelte 5. And we can see instead of using export let for props, there is literally $props rune. And now you can destructure your props. You can pass in a generic here as a type. you can type these things all at once. How beautiful is this? You can get res props and etc. And this is so much better in Svelte 5. So those are props. So let's look at emitting events. So here we have some events. So answer button. So when an on yes event happens, then we want to invoke on answer yes. And on no, we want to invoke on answer no. That's basically simple like that. And you maybe never use this, but this was really something I loved about Svelte 4. And it got even better in Svelte 5. but there was this clunky API, right? Create event dispatcher, then you have to create dispatch and then on click, click yes, you will dispatch this. This is just a custom event listener, right? So nothing special here, but in Swell 5, things are so much easier. So you can see here we have this on yes. I think that's a convention you have to preface the list on yes and on no. They invoke these functions. We don't really have to think about this code. The actual interesting part is here. So look how much simpler this is. We don't have to create this clunky event dispatcher. we can just use the child props. So we can destructure on yes, on no, and then we can say, okay, on click invoke this, on click invoke this, boom, bam, thank you ma'am. That's how easy that is. Isn't Swell 5 amazing, friends, right? All right, so let's continue. So slots are gone, or at least they're going to be supported at some point, but they're going to be gone in the future. So here we have this function, and then you can pass in anything here. So in the past, you would say slot, and that's it. but in spell 5 here we have this interesting render thing so you can destructure children from props and then you can use this render and we have this render because some other features like snippets that you're going to look at later so you can say render children boom and that's how we use it slots are gone and this is such a way more powerful system it's a bit more verbose than the other one because in some instances you have to check if you have children i think if you're using yeah if you don't have children then you have to check for it otherwise you're going to get an error when you could just slap a slot in and that will be it but you're going to see for your use of cell 5 this is so much more better so we can look at this example of a slot fallback so no quantify oh yeah this is the example that was talking about just now So we can see how this looks like So if you have children here you actually have to check if children then you render them else no content found. Otherwise, I think you get an error, right? As you can see here, it's really not intimidating. It's really a great improvement. All right, so let's look at the context here. And context, if you aren't aware, it's just really an easier way to pass some data for your components to avoid prop drilling. So for example, if you have a component ABC, and if you have to pass the same piece of data using prob, that would be really annoying. So you can just define something in the context in the parent or the top component and then you can just use that piece of data, function, whatever else in the child component. So let's see what this example is showing us. So it's showing us how it uses stores here, right? So create user store. Ah, okay. So this is it. So this is something that you also could do. You could use context with stores and then you could just use a store so that it's coped that component. Otherwise, if you just use a store without context, anything else that uses it is going to change a store, right? So you're going to run into problems. So basically, you're using context plus stores to scope into that component, right? So you can see here, it shows us get context users. So here it creates a user store. It creates a store writable. Then it creates this store, right? And then let's actually see create user store, set context. And this is the store that it imports from create user store. And now it's going to put it on this context. because by default, when you just pass a value in context, it's not reactive. So using a store is for this reason to make it reactive. Okay, but let's see how simple this is in cell 5. So again, they're using context, nothing is changing here, right? And you can see there is no store here, and it looks so much simpler, right? Because we can just use the same reactivity system, create user state, boom, there is no store, there is no weird things you have to know about, right? You just use $state, and then you just return, you get username. We can even make this simple. Remember how I showed in this example. you don't have to do this you don't have to set getters and setters you can use this deeply nested reactivity you can use a class and you can avoid having to do this so this would be a lot cleaner if you use what i showed you before so as you can see stores are gone bye bye i love this new reactive system all right so here we have some form inputs and there really isn't anything special here it's just showing how we bind this value of text to input and the only difference is of course here we're using let text equals hello world but here we're using let text equals dollar So basically, that's really it. And we can see, so this is the form input section, we can see checkbox we can also use state like this and there is really nothing different about binding this value and etc It works the same as before So here we have radio buttons and again the only difference is that we using and you can bind the group and etc., which you can learn from the Swell tutorial if you've never done this before. But yeah, you can see the same here with select. You just use $state, and then everything else is the same. So you can use bind value, select color ID, and etc. So yeah, it's really not that different. Sorry friends, so let's look at web app features. and in Svelte 4 everything was a class and this isn't something you should be concerned about because you use with or SvelteKit to scaffold your project so this is just showing we have this app.svelte component so here is how we rawDoc Svelte so we can import this app component we can say const app equals new app and just pass a target and that's it this is how simple it is to use Svelte but in Svelte 5 everything is a function so if we look at this component it's the same as before but inside app.js we import this component and then we import this mount function so now we say const app equals mount and then we pass as an argument the app component and the target and that's basically it. So this isn't anything that we should be concerned about. But let's look at another interesting example. So this example, it shows you how you can use fetch in your Swell component but I don't think a lot of people are going to use it because you're probably using SwellKit and their data loading patterns. You should really avoid fetching inside your component unless you're building a single page application or something. But as you can see in this example here data structure is loading error and data from this kind of like react looking hook thing use fetch users right so it just encapsulated this logic inside so it looks really nice like this so if it's loading then it shows something if error then it shows an error otherwise if they are users then it's going to display them and it's really something interesting so of course this uses stores in Salesforce so you can see it has a writable it creates just this function use fetch user it creates this reactive data error and is loading variables and then here is some function where it fetches the data and then it just updates this live right this is why this is reactive and it just returns them so this is how you would do it in the past use a store like this and that's really neat in my opinion i love stores but in svelte 5 this is even easier right because again we can see this examples use fetch user so this is the same as before you can see not a lot is changed here otherwise it's not using a store of course it's using runes and this example is a bit weird they're using class because I think when they made these examples deeply nested reactivity wasn't a thing but as you can see here they use useFetchUsers and they're creating new user response so they're creating a class here remember how I told you that

 compiler is automatically going to create the getters and setters for this and this is the reason why they're using a class here but you don't have to use this again let's remind ourselves that we can just inside of a function use this deeply nested reactive piece of state we can just use this pass in an object and etc and then we don't have to use a class or anything else so if you're thinking oh i have to use classes in spellfire no that's really not true you can just use this deeply nested reactive state here and then the rest of this is the same as before it just fetches the data and returns the response so now you can use this the same as before this is really great you don't have to know about the syntactic sugar because you can see here this is dollar sign is loading so now you first have to explain to someone okay first listen this is a swell store right and to access this value you have to use this syntactic sugar dollar sign so this is going to automatically subscribe and get the value from the store no none of that in spell 5 this just looks like regular javascript to me which is reactive right so you can say if response is loading then fetching users and etc If you get an error show the error Otherwise show the users How beautiful is this friends and i think that basically it so i not sure why they showing links here for the router link in svelte 4 i guess with svelte kit right but there's really nothing different here there's the same and here is something for the routing but i think there's any changes here but yeah that's basically it friends so when is svelte 5 going to get released and this is just my guess actually so really don't take my word for it there is this site is svelte 5 ready yet so i'm going to link all this in the description if you want to look at it and it's actually pretty close if you look at this test and we can see what's left to be done right but actually it looks really close to release the api is locked and i think there might be some changes right because it's not released of course but actually my prediction is that svelte 5 might be released or the release candidate at least at the next svelte summit which is april 27 this year so you can see it happen in spring. Alright friends, but that's basically it. If you like what you've seen, don't forget to like and subscribe and you can also support me by becoming a patron. Thank you for watching and catch you in the next one. Peace.