 Yo friends, what's up? If you already didn't know, Svelte 5 introduces a new reactivity system called RUNES. So you can declare a piece of state by saying $state and you can then pass a value. We also have the right value so you can pass in a simple expression to $derived so you can say A times 2 and that's basically how simple this is. But today I wanted to actually dive deeper and look into how signals actually work in Svelte, when should you derive value and when you should not because you can do a lot of interesting things with derives, but you can also do some convoluted things if you don't know how they work. Alright, but before I get started, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support. Alright, but how does this actually work? Let's get a higher level understanding of signals first. and first let's actually create a button because right now this isn't even reactive it only becomes reactive when we write to the signal so this is going to get created into a signal if we assign to the signal itself and then we can also read the derives and this is the only time derives run is when you read from them so now we can save this and we're going to see it works as expected so now let's actually go here to the sources to understand how this works I can actually find this file output here and you can see there's a lot of things here where we can ignore most of it. There's only three parts to signals, right? The signal itself, the rise or computed, and effects. So let's look how this works. So here Svelte declares A, and then it creates a signal from it. It names its source, but the name is really not important. This is a signal. And a signal is just a normal object with subscribers and some other things on it. And then it creates this right here, which is also a signal, but it's also a function. As you can see, it always gets turned into a function, but by default, it takes a simple expression just so you don't have to declare a function each time. And then you can see it reads the signal, which is really important. So let's actually understand how this works. So here we can see it created the template effect because we used the double signal or B in our template, right? And this is just a DOM helper to set the text. It says set text, it passes the text. And this is the important part, reading the signal. So first it's going to run this function and it's going to get added to the context. And then when we read the signal inside of it, we're going to check, hey, if there's anything in the context, okay, that's what's calling me. that's the function I'm going to add to my subscribers. And the same thing is going to happen when you go back to the drive We going to run this function we going to push it into the context then when we read the signal inside of it we going to be like okay who is calling me Is there anyone in the context? Ah, okay, this function is in the context, I'm going to add it to my subscribers. And then you can see here at the top, where you have onClick, when we set the value, so we can say set, we pass in the signal, and then we pass the set value, or whatever we do to update the value. We say .get, we always get the freshest value, and then we pass plus one. And the reason we pass a signal is because we're going to probably say a.value or whatever is on that object, and we're going to update it, and then we're going to notify all the subscribers, which are just this function, right? And this is going to run all the subscribers, and that's basically how signals work. It's really simple. And let me also show you something cool. If you watched my previous video on signals and reactivity in Svelte, you probably remember Deeply Nested Reactivity, and this is really what happens when you pass an object or array. You can say value, and let's see, now we have a.value, and you have to update this. And this gets turned into a proxy under the hood. You can see it works the same. But now when you go here to the updated code, you can see this is actually a proxy under the hood. So whenever we update the value or whatever, it can trap those values and do whatever it wants. And this allows some amazing things like in the past in Svelte, we couldn't, for example, just push things to an array or et cetera. Let's say that array, let's say that A was an array. So we had to reassign it like this. We had to say A equals, then we had to spread the entire thing or whatever. and then we can add the new value. But in Svelte 5, you can just say a push item or whatever else you want, and it's just going to work because it uses proxies under the hood. And this also allows for some other cool things. For example, you can export from a .svelte.ts or JS file. You can export something and it's going to become global state because this is a proxy under the hood. Otherwise, Svelte wouldn't know if this was just a regular variable or if this was a signal, right? But yeah, that's basically it. Let me just go back to the default state so we can continue. Awesome. How beautiful is this, friends? Okay, so let's learn more about derives. So remember how this always gets turned into a function? Well, if you actually need to use a function for something more complicated, you can use derived by. And these two examples are equivalent. So this does really the same thing. Nothing special, right? So you can see it works as expected. And you can even, for example, return whatever you want. So let's just go here and then we can return, maybe we want the double value. you can just say a times 2 and maybe you want also to include per Drupal a times 4 we can save and now we get this beautiful object object How beautiful is that friends Now we can say here B double Let just copy over the button and then we can say equal to Drupal. And you're going to see these values are going to be in sync. How beautiful is this, friends? All right, so now the things that you can do that are really discouraged. So this really isn't anything more special than just a regular function. And what are you always told by those functional programmers, bro, that you shouldn't do? So for example, here we have this function t or whatever and then we have some value outside like i don't know let's be these nuts okay so we can just go here and what are you always discouraged by doing well you're always discouraged by doing side effects so you're doing something outside of the function you're saying the math random or whatever and this is also what you should avoid doing when you're using the rise because you can run through some nasty problems and thankfully the swell compiler is advanced enough that it can warn you about this. For example, let's say if we want to modify our signal, we want to say 10, we're actually going to say this, and boom, now we're going to get a nasty error. It's going to say state unsafe mutation, updating state inside the drive is forbidden, I do not condone it. Okay, so now we can actually remove this, but actually, we're humans, so we're smarter than the machines for now. Actually, we can get around this quite easily. We can just return a function from here, and let's just use a getter for laws, why not? We can actually say get value. And then we can assign here. Let's just return whatever. Let's return a self, right? And inside of here, we can actually set a to 10, which is really disastrous, right? So now I can refresh this and I don't get any warning. And now inside of here, I can just say b.value, boom. Now we have this getter and boom. Now you can run into some weird problems. And you're going to maybe be tempted to do some of these convoluted things, but don't, just remember in derives you should just read the value, don't write to values, don't write to external state or whatever maybe you're like tempted by this, maybe you're like okay, since now here I'm inside this function 200 IQ, now I can maybe from here, I can write to local storage each time this update oh my god, I'm so smart, I'm going to do this all the time, but no, don't do this, just use this derive to derive values, right, just reach on them, don't write to things if you can avoid it, right, maybe you can use just a regular effect outside of here you can say effect here and then you can just write to local storage. Maybe if the value updates, because whatever you pass to effect here like value or whatever is going to run So for example let me just say console and what do we have We have A here And let me just remove this so I don look at it We can just say B boom. What did you say? Dobler, right? Okay, cool. So now we're going to see if we refresh this. Let's see. Oh, I left this in. Okay, cool. Let's see. If I refresh this, boom. Now we're going to actually see that our effect runs here because the value of A updated. And there's even other things you can do. So for example, maybe you would run into an infinite loop if for example A was an array, so you say A push, and then you push another reactive value, and then you would get into trouble. But Svelte actually has this thing, it's called untrack. And again, this is a really more advanced example. You don't have to do this. For example, untrack, let's see if it's going to import it. It's really not important, it's just really a regular import, and then you just pass in a callback, and these values aren't going to be reactive anymore. Let's just do this. It's being really annoying. okay fantastic yeah you can do something like this boom and then you can just use the value that you want to make this run right so for example you would say if b and this would make it like reactive and then you wouldn't run into an infinite loop because now a inside of effect isn't reactive and you can just run this whenever b updates but there's also other better ways of doing this which i'm going to show you in this video right oh and another problem that i want to show you so for example here we had dot value and you can do all sorts of nonsense here you can even have effects inside of this and you can run into some problems if you try and do that right you might want to run some things i already said don't use effects inside of here and do that sort of things just use a regular effect outside or the other methods i'm going to show you later but another problem that you can run if you're doing some logic inside of here you're like okay i'm going to keep some state here for example let's count i'm going to have a count boom now i have this closure i'm so cool i'm done with the kids now i have this closure okay boom this is easy peasy lemon squeezy like this now i'm going to increment count oh i can just return count okay let's rename value to count oh my god i'm a hacker oh this is so good this is so good oh so good okay so now we i'm so sorry okay so now we can go here in a template let's just use b count and now actually that we have here let's just return a so this runs right and cool, now when we run this, you're actually going to see count is going to increment, so now we're using closure to have some state inside, but what is actually the problem with this? Now the problem with this is if you have let's see, and you want to do some other derived thing, well now

 Now when you use b.count, you're like, okay, I'm so smart. So now when this updates, this is going to update. And then you're like, Charlie from Always Sunny, you have that ball of yarn board and you're just getting to a disaster, right? So you'll say, okay, b.count times two. Well, now a problem with this is when you run this, let me just put this in effect. So now when you run this, you're going to run this logic. You're going to run into a problem. Well, in this case, maybe you want to increment count, but let's say that you want to modify some state or et cetera from inside of here. now you're already starting to do some convoluted things and this is going to get you into trouble this is why you should always read values and never write to values when using derives all right hope this makes sense okay so let's actually bring this back to baseline so we can talk about more sexy things like microtest queue and etc oh my god i'm so excited about okay so let's just go here i wasn't joking okay so let's just go here and then boom bam thank you ma'am everything is going to work the same as before but one thing that i want to mention is why you should never use effects to write to value so for example this is perfectly fine if you have an effect here and then maybe you're retrieving some value from local storage so you say local storage get item boom assign it to whatever you want when the component now this is perfectly fine but in general you should avoid using effects to sync values and this is why we have derives so you're going to actually have to rarely use effects unless you're doing side effects right but let me actually show you why this is really a bad idea for example i'm going to create state that's it and let's say that instead of the right i'm saying b equals a times two and you're actually going to see you're like what are you talking about this looks good to me ship it and i say hold on wait right there i'm going to call the police on you because let me actually show you this is a really bad idea and to understand why this works so here if you even go to the swell docs here we have this example and they even tell you to don't use effects but they don't really explain why you shouldn't do this so let me explain it so the thing that's going to happen here well let me just take this we're going to create an increment function let's just go here let's just say function increment boom and boom we can just use increment here it works the same as before nothing special right here okay so like I updated my state let me just do something else with the freshest value of my state right wrong you absolute fool Now we can go here and now I going to activate my trap card inside this console log I'm going to log A, B. And now you're going to see something interesting. Okay, so let's log it. One, two, three, four. What is this? My state is out of sync. God damn it. I'm in shambles right now. What is going on? What is this toy language JavaScript? What is going on here? Okay, so you're going to see your state is autosync. And why is that? Well, because effects always run last. When all of your logic is done, when you pop that precious stack in the event loop or whatever the name of it is, then your effect is going to run. And let me actually explain how this works. So in JavaScript or in the browser, there's this concept of a queue microtest. So you can actually queue things that you want to do last when you do all of your work. So this is more efficient for things, it's really not important. it's actually literally called QMicrotest and I even found a cool graphic that explains how this works so actually this is how it works let me just enlarge this and hence, boom so now we're going to see the microtest queue so this is your QMicrotest, async promises, whatever and you have your things like timeouts, intervals, etc. on your microtest queue, it's really not important so this is the event loop so you're going to see when your stack is empty only then the microtest queue is going to run and what is on the microtest queue? its Q microtask, right? Only then your effect is going to run when it's too late. And this is why you run into that problem. So this is why you shouldn't, or you should never use the effects to synchronize state unless you have to, right? And for that reason, I'm out. Okay, so you can say derived and you can say eight times two, boom, easy peasy, lemon squeezy like that, friends. Let me just see one, two, three, four. Now we're going to see your state is going to work inspected because again we learn how signals work under our hood so this is happening real time once you update the value you have always the freshest value which is really the advantage of signals compared to the previous version of cell because you can always be sure that the value is going to be the latest alright so never use effects to synchronize state use derives instead alright so let's talk about something really important when it comes to derives so you might have noticed this yourself and playing around with them let's actually revert to how we had this before instead of increment Let's just pass this inside of a function. Okay, boom. Easy peasy, lemon squeezy. Now we get the same result How beautiful is this friends Alright but you might have noticed something We actually don need derived to derived values So for example we can come here and instead of derive we can just pass in a regular function We can say a times 2 and now, instead of here, we say we're going to get this function body, but we have to invoke it using a function. And you're going to see it almost looks the same. Well, first, the dx, or the developer experience, is significantly worse because now we have to invoke this function, so it looks more ugly, right? But functionally, it looks the same, right? And because we understand how signals work we know that under the hood this is just get a or whatever swell does right so we actually know that the ride really isn't this magical special keyword that can be only used for computing values we learn the other benefits of the ride like in quotes caching because it's just assigned to this value and obviously this is just a function this is just a blueprint for what should happen right so for example if we have a here and then let's just say that we have b here and i'm going to leave it but let's say for example that you have a bunch of b's here right they're complete b's right so we can just increment this value so this is trivial of course this is just a really simple example and we're thinking okay so what is the point of this why is this bad right well you're running let's say this is something more precious on computer resources right you're doing this each time you invoke b compared to using the ride right so for example if I comment this out, find enable derived, and let's just remove this function body. So let's just think about this logically. When we update this value, we only update it once here, and then the rest of the work that Svelte has to do is just update this in the DOM. That's it. There is really no computation going on here, right? It doesn't really how many times this is. It's 1, 2, 3, 4, 5, 6, 7, right? So seven times we had to do the same thing. And this really isn't bad when you have some simple things, right? And of course, this is really simple. We don't even need a derived here. We can just say 8 times 2. We can just use the expression as is in the template. But when you have more complicated things, like a cart or whatever, you're tiling up the numbers and etc., then it really makes a lot of sense to use a derived, right? And this is really important. And if you're thinking, okay, maybe there's some penalty or performance here when I'm using derived, just stop, don't worry about it. You can just use it for everything. You're not going to run into problems. But again if you don want to use the right if you have something simple for example maybe you have like items you have an array one two three four And now when this array updates whatever you can just say items length you not going to go through the extra efforts unless you want to of course for example remaining and then you're going to say derived items length i mean this wouldn't make that much sense right you're just wasting space right you can just say items don't length whenever this value updates here is going to update in a template in this case it's perfectly fine so yeah basically that's why you should just always use derived. If you can, there's really no performance penalty for it. All right, now that we know the fundamentals, we can gain a deeper understanding and appreciation of how signals work by looking at a naive implementation of signals. So inside of here, this has nothing to do with Svelte. I just created a basic signals implementation just using regular JavaScript, right? This is how all of these JavaScript frameworks work that implement signals. So you always have a signal, in this case it's named source after Svelte, and then signals are nothing without effects and this is called a root effect template effect it's really not important in fact your entire swell component is wrapped in a root effect so it's dynamic and in this case I'm just going to say console.log and then we can just use this function get and then we can always get the value and I'm going to go to slash signals and you can see it's going to log 0 alright so now we can use this set method we can pass in the signal that we want to change and we can then pass the update value so 1, 2 in this case and you're going to see if I refresh it's always going to log these values so let's actually see how this looks like so now we can actually see just creating the signal is nothing this is just an object it returns a value and subscription so this is basically useless but here it is here is the magic secret sauce we run the effect first and what happens when you run the effect it accepts a function we set the context to that function right here, right? so we set it right here then we run the function and then we reset the context. And what is the function? Well, inside of the function, we read the signal. And what happens when you read the signal? Well, magic, my friends. So inside of here, where we pass the signal or source, we check, hey, if there's a current context, oh, okay, that's what's calling us, right? So we can add this to the subscriptions. That's basically how easy peasy, lemon squeezy that is, friends. And then we just return the value. And now when we set the value of the signal, we just run the subscription, which are just functions in this case, but it's a lot more complicated when implemented for real, right? This is really naive. And this is basically it. This is the magic of CNIL. So let me show you a more advanced example. Just to save on typing, I have this in my clipboard. So I'm going to save this. And again, I have these buttons

 example, let's refresh for good measure. When we increment the count, it works the same as before, and this output looks really familiar, right? So let's pretend that this is our brand new JavaScript framework, banana, JS, or whatever. So we create this button, we assign it on click, let's get back to this in a second. So we just append it to the body, right? And then we define our signal. Here we have a derives, we're going to look into how it works in a second, and this is the most important part, this effect, right? So we're going to update the DOM by reading the signal, right this is going to get added to the subscriptions we can actually see that we can just use this regular set method we pass in the signal that we want to change and then we just pass the callback expression whatever you want to update the value because we always want to get the freshest value and then whatever you want to do with it right and derives are also really interesting because they're also signals and effects so let's see how other ride works so again this is the same as an effect right we're passing a function to this thing right the right so let's see how it works so here we have a function then we create a signal source right and then we pass it to the effect we say set signal and we pass the function right and then we just return that's it and this is going to rerun this function each time it updates its subscribers and that's basically it that's how signals work all right the rise are super cool but there's one drawback to using them and that is that you can't use them to bind values because derives are read only. So let's go together through the example from the Svelte docs. I'm going to just copy over this example and the first thing is they use this as the first example to tell you hey don't use effects to synchronize state. Remember what we learned about before you shouldn't use effects for this but let me actually just save this to show you what we're working with. So we actually want to synchronize this spent and left when one of the values changes and for example if we wanted to change state to derived. So let's see, spent is total minus left and then we have left which is total minus spent. And that is really great but if we try this and save this we're going to get an error and we can see cannot bind to derive state. Alright, so how can we actually synchronize state? Well that is really simple. We have two methods. We can just use regular functions and I'm going to show you how you can create a writable derived if you need it. So actually let me just revert this to what it was before. Boom. Awesome. Alright, so what did we learn? We don't want to use effects. Cool So we can just use regular functions And let go back to the SwellDocs Here they have an example So easy peasy lemon squeezy we can just use a regular function Update spent We going to accept event Spent is going to be a number E target value. And then we can say that left is total spent. That's it. Now we can copy over this function. And we can say update left. And in this case, we're just going to update this to be, let's see, E target value, and then we can just update spend to be total minus left. And now we can update this instead of binding the value we can just assign the value to spend and we can say on input update what? Spend, right? Boom, easy peasy, lemon squeezy like that friends. Again, you don't really have to overcomplicate these things, you can just use the simplest thing possible. And then we can say update left boom so now we can see that we can synchronize this value and that is how easy peasy lemon squeezy that is friends but of course we can also do something else we can create a writable derived so if we can go here to the docs again and this is really simple we can just create an object with a getter and setter so let's actually use their example right so this is really simple if you want to do something like this if you really need to bind the value or if you just prefer this right there is no right or wrong. Just don't use the facts, right? Okay. And in this case, total is not reactive, right? So we can leave this the same. And then we're only going to have spent, which is going to be the state. And now instead of left, we're going to create a writable derived. Okay. So let's do this using the example from the docs. We can say let left, and we can just use a getter and setter. And we can say, whenever we read this value, we can return total minus spent. Boom. And then when we update this value, We can just assign spent to be total minus the new value that we passed in. So this is the new value or whatever you want to call this, right? That is how getters and setters work. And that's basically it. Now this is, in my opinion, simpler, but that really depends on you what you want to do. If you put this neatly in a function or a class, you can do the same thing. And now we don't need input. We can again just bind this. And we can just remove our input. Let's bind the value. Let's save everything. And again, the only important thing here right now is because we using getter and setter we have to say dot value right So here we have left we going to use this object we have to say dot value because we receiving and setting the value and then we can say here, left dot value, boom. Let's save this, and now this should be easy peasy, lemon squeezy, friends. Let's see if it works. Ah, how beautiful is this, friends, right? All right, let me show you something crazy, but let's just keep this between us, and don't tell anyone else about this, okay so let's just create this script tag trust me this is going to be worth it so let's say that we have celsius we want to convert these temperatures right and we have the freedom unit okay so for example now we have celsius we can say type number and then we can say bind value celsius let me just repeat this for fahrenheit beautiful everything works as expected okay how do i synchronize these two values and of course we learned from before that you can just use regular functions but that's boring to be honest let me show you something truly insane that i'm not even sure was intended but you can do it all right so remember what i told you when you pass an object to this thing that it becomes a proxy under the hood well it's just an object so you can use the getter and setter on it right alright so now in this case let's actually create a private value because we can't use things on the class like pound sign so let's just make it private and then we can just specify get there an set oh my god please don't report me to the police i swear i'm innocent so what we want to do when we read the value well of course we just want to return this dot value and what we want to do when we set the value well of course we want to update Fahrenheit and we want to update this value also so now we can go here we can say this value value and we can also say Fahrenheit is going to be also value and we're going to set it to the new value so we're going to do the same thing here let me just copy over this code oh god forgive me all right so let's see we're going to do the same thing for Celsius, right? Let's actually do this, and again remember, because now we're choosing an object, we have to say Celsius.value, and we have to say Fahrenheit.value. Alright, so now let's see if this works and the values seem to be synchronized but we actually have to use the proper formula So it the new value is going to be times 9 and then we going to divide it by 5 plus 32 All right and the formula for converting Fahrenheit to Celsius, we're just going to say the new value minus 32, and we're going to divide it by 9 divided by 5. All right, cool. So let's actually see if this works. 100 is in FireHeight 212. That looks right to me. And these values are now synchronized. How beautiful is this friend? So let's see. Does it work? Yep. How beautiful is this friend? Alright, but here is something more serious that you would do. You can use a function or you can create a class. We can say temperature. Alright, cool. Now on this class we can actually specify these two things. We can say Celsius. We can use state very easily. and the best part is that Svelte is going to turn these values into a getter and setter under the hood. And you can even specify your own if you want complete control. And I'm actually going to copy this name because I'm insecure. Alright, cool. So now actually instead of letting Svelte take over and create the getters and setters we can just create them ourselves, right? So we can just say get Celsius, not Celsius Celsius, and then we can do the same thing. Copy this over. We can say set what we want to do and let's also make them private otherwise we're going to reference them and run into issues right so we can do this and then we can return this dot celsius easy peasy lemon squeezy and then we're going to actually do the same thing that we've done here right so whenever we update this value of celsius we actually want to set it so we can say this celsius equals new value and again we can update fahrenheit this Fahrenheit equals the new value. Easy peasy, lemon squeezy like that. Classes are really cool, but of course you don't have to use classes if you really want those people that hate classes, just use a function you can do the same thing. You can, instead of getters and setters, you can use functions, but then the user experience is a bit worse, right? And again, I'm going to just copy over this get Fahrenheit flip this, actually we could keep it the same button there and we need to return fire right here. Alright, cool. So this looks great to me. Let's just remove this since you don't need it. Again, don't tell anyone about this. So you would have this in another file, whatever.

 where you can just reuse this. And yeah, basically, we can just say const temperature, new temperature. And now we can just say temperature Celsius and temperature... All right, boom. Let's see, here we have a problem. Yeah, because it can't type. Awesome. Let me just refresh for good measure. and now let's see, and oh, didn't even use the formula ok, we can do this friends, I got this, v times 9 and we can say 5 plus 32 and for Fahrenheit, we can say v minus 32 divided by 9 divided by 5, alright cool let's save this and see if it works, how beautiful is this friends ok, and now if we say 212, we get the same value So this is actually something that you would do for real, right? Instead of this meme, right? But of course, I have no idea what you're talking about. All right, so don't at me. All right, wow, that was a lot. But there's one more example that I want to show you. And it's really more about keeping things simple and how you can easily overcomplicate things. And it's also going to show one more cool thing about the rise. So let me actually start over. I'm going to create a new script tag. And let's say that we want to flip a coin and that we want to store the history. so first we can store the side we can say state and that's basically it and now we can also say history for example and this is really simple right now we can also create a function flip and we can reassign this we can say math random if it below 0 then let just return heads or we can say tails and of course the simplest thing to do is push let's create the button we're going to output the side and if it has no value we're going to say flip or on click we're just going to say flip and then let's just create a history and let's do it like this alright cool and let's actually see what's going on so maybe reduce the size but basically that's it right we can just do this and it's really simple but it's really easy to do something convoluted so for example of course this is a simple example maybe inside of here you have derived and you're doing maybe something else and it's really easy to be tempted to be like oh since I'm inside of this thing and this thing reruns when this other thing reruns oh I can keep some other state inside of here right This is how we get into this silly situation. So for example, let's say that we use this for history. Again, if we keep state in site, and we can of course use closures, let's just say get value, and then we can say history push whenever site updates, and then we're also going to return history. And in this case, let me just say history dot value. Boom. And of course, this might look okay, right? But there's actually a couple of problems. is first we've seen what happens if we just return a value that assigns some state now if you want to derive something from this you're going to run into trouble, right? the next problem you're going to run into is that derives are lazy they only update when their value updates and again, here we have math random if it's below 0.5 it's going to return heads or tails but what if it returns the same value multiple times in a row this thing isn going to run right And let actually see this So we can say console So I going to say flip And then we can also output the value. Let's do the same console.log inside here. And then we can say derived. All right. So now the first one is going to be undefined because there's nothing in. Let me just refresh this. Okay, so now let's flip the first value. So now we get the console.log from flip heads derived heads. So let's see. oh so now we only get heads again right so now only this function ran right this is the problem you're going to run into if you try using the rise like this they aren't like some magical dependency array that's always going to rerun when your value updates and this is what makes signals awesome because they're not wasteful they're only going to rerun when the value updates as you can see if we roll more we got heads three times in a row or four right and then it's now we're going to update. And as I said, if you ever get into a situation like this, just do something simple. You can update everything inside of this flip function, right? Alright, we can also move this inside of a function, so we don't need this anymore. Let's create a coin class. We're going to specify a side. So let's define some state. We're going to have a history. So let's define the array. We don't need a constructor. And we can just move this function in. That's it. Remove this. I'm going to say this side. You can also remove this, let's say this history and we're going to push in the new state. And now we can create it. So we can say coins.coin new coin coins.site and coin history. You don't have to use the value anymore And you going to notice one thing is that this isn going to work because this property is undefined And that is because when you use this method like this it going to point to the button So you can just pass an arrow function and you can invoke it. So you can do this and everything is going to work. Alternatively, you can just remove this. And you can just make this into an arrow function. And this is just basically how the disk keyword works. It depends on the execution context, right? And if you remember the good old days of React, you can even do something like this in the constructor. So this flip, you can say this flip bind the disk key, right? So you could do also something like this. Again, you don't have to use classes, you can use functions or whatever else you want, but yeah, that's pretty cool in my opinion. And of course, you have to decide yourself, do I need actually the derived state? Because for example, let's say that you maybe want to calculate the percentages of heads compared to tails, you can just say heads state same for tails right you can just tell it up you don't need to do some complicated derived here right you have all of this here available right so you can just say if this side heads then you can do whatever you want inside of here and this is really simple compared to using a derived but of course you can use a derived just ask yourself do you need to right and how beautiful is this friend right we don't need to do anything else let's just see Can we flip it? Yeah, nice. We can flip it good, right? And we don't run into the same problem when you use other ride, right? So when it's lazy, this is going to update every time. And if you want to do something more complicated, of course, you can always define the getter and setter yourself. That's basically it. I hope you learned something. And if you like what you've seen, don't forget to like and subscribe. Thank you for watching and catch you in the next one. Peace.