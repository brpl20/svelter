 Hey friends! In this one we're going to learn how you can use context with stores in Svelte and I see this also often asked by people, they're confused, why would I use for example stores with context? Can't they just use stores right? They seem to do the same thing. So we're going to see how they're similar but very different and what they're used for. If you're not that confident in what the Svelte context API is or Svelte stores are, I have an entire video on managing state in Svelte you should check out and in the post I'm also going to link to the Svelte tutorial. Alright, so here I have some simple components. I have a grandparent component, a parent component, and a child component. And this can be anything you want. This can be a list box with items, right? This can be a map component that has child map marker components, for example. So now we get into this weird situation where you have to pass a reference to something, right? Or you have to pass some value. And then, for example, in this component, grandparent, I just have a simple component count, and I'm just using the mouse wheel to change the count value. So if I go here and scroll up, I'm going to increment the number up. And if I scroll down, I'm going to decrement the number. So let's say that you aren't aware of the Context API. What would you do first? Well, in Svelte, we can go here and we can define a value here. We can say let count and I'm going to use this to bound the value. So we're going to get the value of the count from the grandparent. So now we can say count and now we have to pass this component to every component. Or we have to pass the value to every component, right? and every component has this prop now which is going to be count so the parent has it and the child also has the same component and now we're just going to output it so let me just go here I'm going to save everything and now all this value should change and you might be thinking okay but this isn't so bad right okay but let's say that you have more components more nesting and even in this simple scenario what if you want to update this value from the child components up. Now you have to pass some update function or whatever, and now each of these child components has to concern itself with this. So this is really clumsy, right? All right, so now let's look at the first solution, what you might be thinking. Okay, this looks like this is great for stores. Stores are basically a global object installed. You can store anything inside of there, like a team. In general, a store is used to store some value that unrelated components can use, but in this case we have related components but it can still take advantage of stores. All right so let's do that. Inside of source here, inside of lib here I have components, you can open this, let create a new file I can say store ts and I just going to define a store let me just move this over here I can just say const count I can say writable it is This is going to import the writable from the soil store Now we going to give it the default value and that it And also, let's export it. And now we're thinking, okay, this is now going to be easy. We can now remove all of this here, since we don't need it. Let's remove this. I'm going to remove bind. And now we don't even need this here. Now we can go to the grandparent. And now instead of exporting the prop, we can say import count from store. Because we're importing a store, we need to subscribe to it, so we can use the dollar sign in Swell to do so. So this is an auto subscription. Now I can save this, and this should work, but the other values aren't going to update. So now we can go to the other components, and let me just copy this import from here. So we're going to go to parent. Let's replace it with this. Again, we need a dollar sign because we're going to subscribe to it. Let's go to the child component again. Let's replace this. And let's try if this works. And awesome! Now they all share the same count. And if I go back to our page... Anyway, we're thinking, alright, everything looks great. It's five minutes before you're done with work. Time to push it up and enjoy your weekend. But then your boss comes and says, okay, this looks really great. he copies another component. And let me just zoom out. And then he says, oh, this looks really impressive. And then he starts using it. Oh, dear lord. Okay, so this is a problem. You're using a store and the store has a shared value, right? Okay, now you're screwed. But don't worry. This is why the context API exists. So instead of using the store, I'm just going to close the store. Since you're not going to use it. Now you can go inside your grandparent component or whatever, and now instead of using a store directly, we can use setContext. And now we're going to set a context, which is going to be count, and you can even give it a value, right? And this context is only going to be available to the parent and its descendants or children, right? Let me just say here, let count zero. So we're going to define it here, and now we're going to pass count, and also don't forget to import this, setContext from Svelte. And now we're going to see... I'm going to remove this since it's not a store anymore just so it's clear what's going on. So now we have setContext. If I go to the parent, now we can retrieve the value. We can say count getContext And it should be important from say let see getContext Yep this is it So now let remove it So now remember we named it count We're going to replace it here. And now I'm going to do this entire thing for the child component. Awesome. So we can now also remove it here. And you might be thinking, OK, this is going to work, but it's not going to work. You're just going to update for the grandparent. if you look at here. And this is because context isn't reactive. So this is where stores again come in handy. So if we go again to the Grandparent component, so now again we can use a writable, so instead of defining a value here as is, we can use the writable store, which I import from Svelte Store. So let's just move this over here. And now I'm going to set a default value, and again, since we're using a store, we're going to subscribe to all of the values. Save this. I'm going to do the same in the parent since this is a store. So now we get a store. And don't worry about the errors here. This is because of TypeScript, but I'm also going to show you in a second how to type that. So now we're going to subscribe to this. Let me also save this. And now let's try it out. And how awesome is this? Now all of these components have their own separate state. And this is what the Context API is great for. All right, but for the last part, let's make it a bit nicer. So I'm going to go here. I'm going to cut all of this out. I'm going to go to the sidebar, libComponents. I'm going to create context, just so it's a bit nicer. We can do it like this. So I'm going to create a function. Let's export function setCount. And I'm going to have another function, export function getCount. And this is just going to be a way nicer method using the context API, and it's going to be easier to type. So inside of here, I'm just going to open this, and I'm just going to set the context here. nothing special and for the get count I'm just going to return get context and rename the context count but you're going to notice a problem in a second which I've done on purpose so let me just save this and are we thinking this is going to work I'm going to say import we're going to set the context, actually setCount, and we're also going to get the count from context. So now we going to say setCount and now in the next line we going to say constCount and we going to get the count All right And it complaining because all the types are missing So now in these other components instead of doing this we can just say get count. Now we can remove the one from Svelte and let's also go to the child component. We can say get count. Anyway thinking this is going to work but we're going to get the same problem we had when we used a regular store. And why is that? Well, if we go to the context file, since this is basically a module, when you create a new instance of your component, see this is in this scope of the module, it's just going to use the same value, right? So what's the solution? It's really simple. Just move it inside setCount. Alright, so now let's try it out. We can increase or decrease, and we can also do it for the other components, and they don't share state anymore. And how awesome is this, friends? And I'm also going to show you quickly the types. So here you can create a separate type if you want. This is going to say number, and for the get context, this is going to take a generic. It's going to be a writable. So you can say writable. It's going to import it as a type from SvelteStore. And now since this is also a generic, we can pass it what the value is. Number. And if you have a problem with types, you can always say restart language server. So give it a second. you should see it now knows what the type is, so it stops complaining, and now everything works great and you have a tidy and neat API. Alright friends, so I really hope this helped you understand when you would use Stores and when you would use the Context API. A store is really great if you have some data which unrelated components use, but in this case, if you need some data that's specifically tied to some components and its descendants, you can use the Context API from Svelte, and if you need reactive values inside, then you can also pass it a store. And this is only going to apply to that component and its descendants. And I also want to make it clear that this API is specific to Svelte and not to Svelkit, but Svelkit also takes advantage of the context API on the server and that's how it implements stores. Alright, so don't forget to like and subscribe and if you want to support me you can become a Patreon and also don't forget to join the Discord. Thank you for watching and catch you in the next one. Peace! You