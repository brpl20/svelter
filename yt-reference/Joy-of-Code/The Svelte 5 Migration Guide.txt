 Yo friends, what's up? Today I'm going to show you how you can migrate your existing Svelte or SvelteKit app to Svelte5. Alright, so here's the game plan. First we're going to go together through this Svelte5 announcement post. Then we're going to actually look at some of the changes. So what has changed between Svelte4 and Svelte5. And then as the last step, I'm actually going to migrate my own personal site, Joy of Code. It's not a complex site, but I wouldn't say it's trivial either. So we can visit it right here. We can see I have this nice search. You can even go through a post. And you can see here I have some markdown and etc. And most of the complexity here lies actually in how I render this markdown, so I don't have some crazy stores and etc. that other people might have, but you're actually going to learn a lot because I think I'm going to hit almost every use case that you're going to run into. So that's going to be super interesting. Alright, but before we get started, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support. Alright, let's go through the Svelte 5 announcement together. After almost 18 months of development comprising thousands of commits from dozens of contributors, Svelte 5 is finally stable. And trust me, I've been using Svelte 5 since it was announced and it's freaking awesome. The most mind-bending part about Svelte 5 is that it's completely backwards compatible. And as it says here, Svelte 5 is a ground-up rewrite. You're absolutely faster, smaller, and more reliable. And for the newcomers to the framework, there's less stuff to learn. And if you don't know what this means, basically you don't have to know about concepts like stores anymore because Svelte has universal reactivity. You basically learn 4 runes in like 10 minutes and that's basically all you have to know about Svelte. And of course you know me, I like making hour-long movies out of videos, but that's because I dive more deeper into topics, right? But actually if you wanted, you can learn Svelte 5 in 20 minutes. And as it says here, Svelte is completely backwards compatible with Svelte 4. And basically the only dependence you have to update is going to be with plugin Svelte and of course Svelte itself. This is a description of what is Svelte, so here is what changed and why. And this is something hilarious that I constantly keep hearing that Svelte is changing, but Svelte hasn't changed since 2019, so when Svelte 3 was announced. Yeah, there was like a shift to Svelte 4, but that was basically under-the-hood improvements, right? So basically the syntax of Svelte hasn't changed for so many years. And just think about how many things changed in the web development world in that time. And I explain more here. With more and more people building more and bigger applications with Svelte the limitations of some of our original design decisions started to become more apparent And if you build anything more complex in Svelte then you know exactly what this means And they also continue equally component composition is more awkward in Svelte 5 than it should be. And this is because in 2019, right, so 20,000 years ago, it seemed likely that web components would become the primary distribution mechanism for components. So Svelte 3, or whatever version at that time, heavily placed their bets on web components becoming the standards. But there's a plot twist. This was a mistake. Alright, so we're not going to talk about web components today, but actually this is something that most framework authors agree on, so that's really something interesting. And then you probably, just like me, absolutely love the $colon syntax, but trust me, this was a bigger foot gun than effect. People say effect is a foot gun, but man, this thing, right? So they say, and while the $colon construct for reactivity rerunning statements is a neat trick, it turned out to be a foot gun. It conflated two concepts. So this thing was both responsible for deriving state and side effects. And this would get confusing really quickly once you started to write more complicated code. And of course, you had compile time reactivity, but Swell5 introduces runtime reactivity using signals. So you have these runes, they basically look like functions, and you don't have to import them, right? They're just basically a compiler hint to swell that these should turn this into signals. And what is the benefit of this? Well, the benefit of a compiler driven approach. So I don't know if you ever use Vue or Solid, but you know how in those frameworks you have to say count dot value or you have to invoke count as a function. Well, the benefit of a compiler is that count looks and can be used like just a regular value. So you can see here, we can just reassign count by saying plus equals one. This is a signal, but we can just use it like a regular value. This is actually the beauty of a compiler driven approach. And the best part in cell 5 that runes can be used in .js or .ts files since you have universal reactivity, right? So you don't have to learn stores and those other things since runes work the same inside components and outside Svelte components. And then you have other changes like event handlers just being props, which is really awesome and makes things so much simpler. And then some things like Slot are going to be deprecated in favor of a new syntax snippet, which are so awesome and so less mind-bending. Of course, the simple use case for Slot is always going to be nicer in my opinion, but the moment you start to do something more advanced with Slot, it becomes completely mind-bending. And we're actually going to look at some of those examples in a second. And what's really also awesome about Svelte 5, Now you have native TypeScript support, that's right. Now you can use TypeScript in the templates, you don't have to use a preprocessor for TypeScript. First you have to migrate to Svelte 4 so I actually going to post all of these links in the description so you going to go through this guide and now when you done migrating to Svelte 4 then you can migrate to Svelte 5 And as I said because Svelte 5 is completely backwards compatible you don have to update your components immediately. Everything is going to work. So you can just incrementally start upgrading your components. And all your other libraries that you're using are also going to work for this exact same reason. And what you're actually going to use for migration is going to be the Svelte's new CLI, which is sv or Svelte, so we're going to use npx sv migrate Svelte5, and this is going to do like 90% of the work for us. It's completely bonkers. It is something really cool that I didn't even know about until reading this post again, so if you're using the VS Code Svelte extension, you can migrate components by selecting migrate component to Svelte5 syntax, so it's going to convert the Svelte4 to Svelte5 syntax for you. And of course, eventually support for Svelte4 syntax will be phased out. Don't worry, that's going to happen who knows when, Svelte 7 or whatever, who knows. But yeah, this won't happen for a while and we have plenty of warning. And of course, we're going to follow the comprehensive Svelte 5 migration guide. And I already mentioned the new CLI, which is really awesome. Along with the new version of Svelte, we have a new command line interface or a CLI, which is SV. And friends, the future looks so bright. We plan to release a new version of Svelte Kit in the near future that takes advantage of the new Svelte 5 features. So you don't even have to worry about Svelte Kit. Svelte Kit has no breaking changes so far. And this is the part I wish more people understood that runes are just a foundation for many improvements that would have been impossible to build on top of Svelte 4. And I'm so excited to find out what the Svelte team is cooking up next. Alright, let's briefly talk about the new Svelte CLI. We just released SV, a new CLI for creating, enhancing, and upgrading Svelte projects. So the most hilarious thing about the older Svelte CLI is when someone would ask how do I set up Tailwind and etc. Always at the end of every installation, it would tell you that you can use Svelte Add to add your own integrations. So the truth was always hidden in plain sight but i guess no one read that including me so the swell team was like okay we should maybe integrate this into swell and make it more approachable and basically that's what they've done here so now we're offering that functionality via our own cli directly within the project creation screen so this is not just for tailwind this is for formatting linting testing setting up databases of internationalization and more so you can just run npx sv create and follow the prompts so here we have all these options prettier es lint vtest playwright tailwind css Drizzle, Lucia, MD-SWACS, Paraglide Storybook, and so on. And if you want to add more integrations, you can just use npxsvadd. And in our case we going to run the migration script from this so we going to run svmigrate And if you want to see this in action here is a great video from Theo that had Ben on to explain all of these changes and showcase the Svelte CLI. So basically that's really awesome. Alright, so now with that out of the way, we can actually look at the Svelte5 migration guide. Alright, so I'm going to go quickly through the Svelte5 migration guide for sake of time, but if you want to learn Svelte, I'm going to link to this playlist where I have a bunch of videos. So the only video that you have to watch is this Svelte5 guide for beginners. And then if you're interested, once you learn more, you can learn how to derive values in Svelte 5, you can learn about effects, when to use them, and etc. Alright, so let's get started by reading the Svelte 5 Migration Guide. Alright, so the biggest change in Svelte 5 is the reactivity. So for example, you no longer say let count equals 0, but you have to be explicit and say $state. And at first, this might look more robust, but it's actually really awesome because now, when you're explicit about state, it's easier to understand for others what you mean, and not just that, but it's easier for Svelte to understand what you mean, and that is why you have universal reactivity. So you can use this piece of state. You can place it inside of a function, class, or even outside of a swell component, and the reactivity is going to work the same. That means you no longer have to learn about stores. And the best thing about using a compiler, you don't have to unwrap this value like in other frameworks. So you don't have to say count.value or invoke it as a function. You can just use it as a regular value. Alright, so to derive the value, for example, you have count, you want to derive double. instead of saying $ colon, you can just use the derived rune. And you can just pass a simple expression inside of here, or you can use derived.by, and you can pass a function if you're doing something more complicated. And then if you want to react to a value changing, you can use effects. And effect is really great, and nothing like effects in React, where you have that dependency array and etc. Whatever reactive value you use inside of effect is going to get tracked. And in this example, whenever count changes is going to rerun the effect. And this is all possible because of signals. So for example, you might be thinking how Svelte is compiling this to something magical that's reactive. But no, this is just runtime reactivity. The only thing that the Svelte compiler does is compile these runes to signals. And that's basically it. So here is another awesome change. Instead of that awful export let confusing thing that was almost impossible or annoying to type in most situations, now you just have this $props rune, which is really awesome. Now you can use the structuring, renaming properties, and whatever else you want. So for example, if you're using class, you can just use class and then you can rename it and use it as is. So things are a lot simpler. Now we can just simply spread these props instead of using this weird double dollar sign rest props and etc.

 Etc, right? And then event changes are another great change. So in Svelte 4, we were using the on column directive to attach event listeners. But in Svelte 5, event listeners are just regular props. Oh my god, that is so awesome. You can spread them now and do whatever you want. That is really awesome. So another awesome thing is component events. No longer do you have to use create event dispatcher. You can just pass in regular functions as props. And that's basically how you do this. So instead of defining this create event dispatcher and dispatching these things, above and then using on colon inflate and etc now you can just pass these regular functions now we can just destructure them inflate deflate and boom now we can just use them as is right so no longer do we have to use this confusing create event dispatcher it's really that easy and the same for passing events now you can just destructure on click for example and then you can use this as is and as i said before now we can also spread these things that you have so you don't have to use any of these weird things like double dollar sign props and etc now it all makes a lot more sense. Unfortunately, the only downside of this because they're just regular pros, we can't use these modifiers like pipe once and etc. But you can use a function to wrap them if you want the same behavior, but actually you can just call event prevent default or whatever else you want. It's really not that big of a deal. They actually give you this code snippet how we can have this behavior. So you can do something like this, on click, what's prevent default and etc. But actually there's no reason for this. And then you can add modifiers like capture on the end of the event listener. So for example here we have on click and then you can add capture. And then there is more things that aren't really important. You can read more about this. I actually want to talk about something really awesome, which are basically snippets. So snippets actually replace slots and they make things a lot more easier. So basically you have snippets, which are just kind of like a reusable markup. You can use them to reuse the markup and etc. And then you have this render thing, so you can use it to render the thing. So for example, you can destructure children, which you get by default, and then you can just render this instead of using slot. But snippets are actually way more powerful than this, because they kind of remove that mind-bending thing that you're dealing with with slots let me actually find this example here oh yeah this thing oh my god where you bind let item and then you can basically you're pushing the value from the child to the parent using this let colon and how this worked is basically mind-bending but now no longer you have to use this because of snippets you can just say snippets they accept this prop text you no longer have to do this insanity right yes you can just destructure these values and use them as is this makes things a lot more clearer it going to make you more confident about using this because probably a lot of people in the past didn even use this let colon because this looks so complicated and intimidating to use right But now it so easy to pass thing from the child to the parent And of course, let's just touch upon the migration script at the end, because that is what we're going to use here. It's going to bump our dependencies, it's going to migrate runes, it's going to migrate event attributes, and etc. It's going to turn slots into snippet where it can. In other places, it's going to leave a helpful message what you should do, and etc. And then it actually just tells you what it's going to replace. So for example, if it can determine if something should be an effect or derived, it's going to use this run function. And that's basically what it's talking about here. And of course, if you had those event modifiers, it's going to use functions to convert them, so that's going to be nice. And then lastly, it mentions things that it can't migrate, so create event dispatcher, but this is thankfully easy, peasy, lemon, squeezy. And then you have some other lifecycle functions, for example, before update, after update, this is replaced by effects, so you can use effect.pre or just effect, which do the same thing. But yeah, that's basically it. I think we can actually now start with the migration. Also, another awesome thing about the migration script is that it's going to fix your HTML. And what do we mean by that? Well, let's actually look at this legendary issue opened by Rich Harris. Self-partners, HTML, all wrong. So how many of us believe that self-closing tags are a thing in HTML? So for example, we always thought that this div, which is self-closing here, was a shorthand for this, right? So opening and closing div. Well, basically that's wrong because self-closing tags just aren't a thing in HTML. And this is all from this post by Jake Archibald. I'm going to link all these things in the description if you want to read more about this. But basically, yeah, that's actually not how it works, even though Svelte treated it this way, but this is not how it works. So Svelte is actually going to warn you about self-closing elements. And we can actually see that this, at the end of the day, gets converted to something like this, right? So this is actually something really fascinating in my opinion. But yeah, I think that's it and now we can actually focus on the migration right all right so let's start the migration here i have my project open in vsco nothing special in fact i'm going to go into the git view where i'm going to spend most of my time just so it's easy on the eyes right because you're going to see the diff and etc so let me just say ctrl shift g and i'm going to go into the git view all right so now i'm going to go from my terminal and the first thing we're going to do is run the migration right wrong you activated my trap card do you really think that you're going to do this on the main branch wrong well first we're going to create a separate branch of course so let's actually use git checkout b i'm going to name this 125 now you're cooking and later when you're done you can turn this into a pull request on github or whatever else you want right awesome so we just need to run the command npx sv migrate cell 5 This is going to take a minute Alright, so this basically updated your dependencies. We have to install them after this is done. But for right now, let's just say yes to continue. This is going to ask you what folder should be migrated. I only have source. Alright, so let me just select source. I'm going to press enter. That's it. Our entire project has been migrated. Don't forget to update your dependencies. it. In my case, I'm using PNPM, so I'm going to say PNPMI. This is going to install the dependencies. Alright, so now I can start the development server, and everything should work, because again, Svelte 5 is backwards compatible. Alright, cool, so now I can go here, let me just open localhost, and everything should work. Beautiful. Alright, let me just bump the size up, just so we don't have any problems, and I'm also going to open the developer tools, just so we have them. Alright, so now going back to our editor, we can actually see the difference if you look at package json we can actually see that it only updated the packages that it has to and that's basically it everything works as i promised how cool is that right all right so now we can look at every component and see how the migration went all right but before we do that let's actually inspect the site a bit so i'm going to close the developer tools and actually all of this here looks all right to me for example if i go here to this post let's see the sidebar works, this loads, okay, everything looks okay. Again, it's backwards compatible, so I'm expecting it to work. The only thing I'm concerned about, since I haven't updated this in a while, there are actually going to be some breaking changes with selectors, because in the past, for example, when CSS nesting was new, I think you could just use it as is, but of course, when you're using something that's in another component in Svelte, those tiles are going to be unused, so I actually expect some things to be broken. Let's actually see for example does this work. And the first issue I'm noticing it shouldn't be using this color I think it should be using aqua I think but we're actually going to find out when we get to this component in styles. Alright so for example if I open this this looks all right I'm using melt for this but there is another concern I have does melt work properly right because for example if I go here to preference ah okay we can already see something is broken here because of the changes in the selectors so this should be probably an easy fix and if we see here, we can actually use this as is, so Melt actually works perfectly fine. Alright, so let's actually just go back to the homepage, and then we can start working. Alright, let's start cooking. So the first component I going to open is going to be this arrow right icon and if you can notice I have a bunch of these icons right here so what basically the migration script did here was turn these components I guess to use props because you no longer have to use this weird double dollar sign rest props right so basically the only change I want to make here I want to remove this and I want to turn this into TypeScript right and you can see even if I save this it's going to format it right all right so let's actually see this other component chevron double left all right so this looks like the same to me. So basically what I'm going to do, I copy that thing over. I'm just going to do the same thing, save it, and I might speed this part up. I'm going to see basically this looks the same to me. All right, so we're just going to go quickly through all of these icon components and do that. All right, that was the last icon. All right, so let's see if everything works. Awesome, the icon seemed to be in place, so we didn't break anything. That's great. All right, So let's actually continue to something that isn't an icon. So we can actually open this heading.svelte component. All right. So we actually have something interesting here. Again, it's using props. This children actually don't want JS doc here. Of course, you can use JS doc if that's what you want. So basically what we can do here, let's say language type script. And we can actually just say type props. And then we can say children. So we can actually import snippet from Svelte. And then we can actually type these props like this. And you can see this is really cool. so instead of slot we're using children and then we're using this optional nullish coalescing right so you don't have to do something like this for example you don't have to say if and then do a check if children and then place it inside so you can actually just use nullish coalescing like this okay let me actually save this and boom that looks great to me and of course you don't have to do this you can actually just do something like this for example you can say props and then you can say here props.children cool all right so you can do this if you want right all right so let me actually just save this and let's see i think this is wrong i'm not sure why i did this so basically what i can do i can move media here because now we have nesting in css we no longer need this and now i can just save this right so we can just nest media inside here and of course we can also check if this is how it should be we can just open this component and we can see it's just inside of here, so let's actually add some spacing. That's it, right? So now if you look at the side, there's nothing wrong as I can see, right? So if I even go here, more posts, yeah, we can see the styles are working. All right, so let's actually look at the newsletter component. All right, so we can see this state is now converted to use this $state,

 hit rune, now it imported prevent default because it probably can determine... Oh no no, this is for the events, right? My bad. Alright, so this is really cool. So this is using, instead of this modifier, since I'm using prevent default, this is just importing prevent default from Svelte. Really helpful, right? Alright, so what we can actually do, I'm going to rename this to onSubmit, and instead of having to do all of this, I'm just going to use onSubmit. Let me just actually delete this part. And boom, now we can use this just like a regular prop. Cool. And let me see if I have to update the styles or something. No, this looks great to me. Yeah, cool. Okay, now we can save this, and we can actually remove this prevent default, since we don't need this. And yeah, of course, you can just pass in a named function or whatever else you want, but this looks great to me. And now if we go back here, let me just refresh, everything looks great. All right, so let's actually look at posts. alright so we have a migration task error while migrating self code this migration would change the name of a slot alright so we have some problem with the slot here let's actually see alright so it didn't even change this which we can easily do so we can just say post props and here we have this slot title and slot see more okay so since we can't use see more I'm going to rename this I'm just going to say here we're going to accept title and more and I'm going to remove this and let me just create a type props. So we're going to say posts. Title is going to be a snippet and more is going to be a snippet. Alright, cool. So this just imported this thing here. So because we're just accepting a function, a snippet, that's basically what it is, we can actually instead of slot just say at render and we can just call title and we can use Nulish Coalescing. Cool. So now let's actually remove this. I'm going to copy this. Let's also go here. And you can actually say more. Awesome. Let's save this. And let's actually see what it's complaining about. Alright, so let's see. What did we do here? Ah, we need to assign the type. Silly me. Alright, so I'm just going to say props. Boom. Now everything should be fixed. Again, if you're confused by this difference view, let's actually go to the real component. you going to see it really simple so here we have this fade we importing this type from self creating props boom assigning this how easy peasy lemon squeezy is this and now we using render instead of slots And of course, we actually need to fix this inside where this post component is used. Yeah, so that's something that we're going to do. All right, so let me actually go back in this view, and let's actually check if the styles are all right. All right, so everything looks okay to me, and another thing that we don't need, since I was using CSS nesting early, actually they loosen the rules quite a bit, so we don't actually have to use this ampersand either, right? So I think we can just do this, yeah. Okay. I can just also remove this ampersand, also for details, title, and description. Oh, and here I have, oopsie, oopsie. So I have this HTML, I don't even know how this worked before, maybe I was crazy or something. How did this global selector ever work? Yeah, but basically what I'm going to do, in Svelte 5 you have this awesome new thing. We can use global, but if you use global we don't have to specify it for everything. We can just nest everything inside of this global that we want. So for example, let me actually instead of using global here I'm going to just move all of these things inside there. And of course it actually surprised me like that. But yeah, let's actually see. Okay, so now this is perfectly fine. We don't need global for this. This is just going to be a link and we can say I guess Href, so we can remove this. So basically what I'm trying to do, this is the link here, right? Yeah, so now it's gone because it's broken. But when I save this, let me actually see. Oh yeah, we need to fix the slots also. So I actually think the Href is going to be archive or something. We're going to have an archive. Cool, let's actually save this. So now we're going to see that this doesn't still work because we actually need to find the place where we're using this component. so I can press ctrl shift f and let's just say post so now we're going to see where this is used and again we should get some errors here actually just see post data all right so this looks all right it converted this successfully so again it's using a snippet title instead of a slot and we can just turn this into snippet like that I'm going to remove this and then I'm going to say Okay, snippet. This is going to be more since I renamed that right. And then let's just close it off. Snippet boom Alright so we can just remove this slot here And again this is the ref that I targeting so this is href archive so I going to style that so it the same as everywhere else Alright so if I save this, yeah, awesome. So this is how awesome snippets are, right? Let's actually see if everything is okay here. Okay, seems alright. Let's also fix this other instance. So here is another issue, so let me see. Element in place has an any type. Yeah, this is just a type issue because I have these categories, React, JavaScript, Svelte, and so on, and this is a string. So it's complaining, saying, hey, this type doesn't match. So I think I actually have this type, let's see, categories, if I start typing it, yeah, libtypesindexjs, yeah. Because you can see now it's going to import categories. Let me just open this so I can show you. So basically this is what I'm exporting. Categories, key of type of, config categories from my config, right? That's basically what I'm going to do. Alright, so TypeScript isn't going to complain. And now when we actually see what is complaining, ah, okay, we need to make this type optional. And everything else inside of here looks to be converted properly. Yeah, it created a snippet. Cool, let me just save this. Now when we go back here, yeah, this was the issue. So we have posts, which should always be passed, but we actually need to make title and more optional. Cool. So for example, if I save this and if I go back here, you're going to see it's not going to complain anymore because those types are optional. Cool. Or props, I mean. Yeah. We can actually close this. And let's actually check it. Okay, so here is C more post. And even if you refresh for good measure because I'm always paranoid, now we can actually go back here. Everything works the same as before. How beautiful is this, friends? All right, so since we're done with this view, I'm going to press Ctrl-Shift-G and I'm going to go back to the Git view. Okay, so we can remove this because we're actually done with this component. Let's save this. And actually, let's double check the styles because I think I actually forgot to remove things that we don't need. Oh yeah, okay. So again, we can just remove these ampersands. Again, we're just using regular CSS nesting, even though I'm using Sass in this project, which I'm also going to change later, I guess, when we get to the layout, because I no longer need Sass, right? How beautiful is CSS, right? Okay, so let's just remove this. We actually don't need ampersand, kicker title. We don't need it for description. We don't need it even here. Neither in a... Boom! Gone! Go away I don need you anymore Alright let actually see if anything broke right Everything looks alright to me Alright cool So we can actually close this and now we can actually go back to the Git view and we can now actually continue refactoring the code. Okay, let's look at the header component. What is up here? Aha, okay, so this is basically this part, I think. So we can see the header up here when I'm scrolling, it becomes sticky, right? And we have a nice background. Alright, so everything seems to be right here, but actually we don't need to assign a number. We can just say that it should be zero by default and then of course, instead of using $, we're going to use $derive. And let's see if everything else looks alright. Alright, we have header. I think we actually need this fixed here. Let's actually see. If I remove this, what's going to happen? Ah yeah, okay. So in this case, we actually need the ampersand because we're applying it on the same element. Okay, cool. But I know that we don't need this here or we don't need this here actually because it's going to work just like that. Cool. Let's remove this. All right. So I'm going to see everything looks great. All right. Cool. I think another component is done here. All right. So let's actually look at the menu. So the things that change here, again, I'm using melt here. So we can see now event listeners are just regular props. So it's going to update this and then it's even going to fix our HTML. Again, the self-closing tags. how awesome is that? Alright, so I don't think we actually have to do anything here besides maybe update these styles because we don't need all of these ampersands Alright, let me just take care of that Awesome, let's save this and now we're going to see everything works the same as before Alright, cool, so I think we already converted another component, I told you this would be easy peasy lemon squeezy with a migration script alright so let's actually look at the preferences again I'm using melt here and it's using onclick so it converted this successfully converted the self closing thing let's see container toggle let's remove ampersand we need this ampersand right here but we don't need this one I think alright so for example if I go here and actually check this yeah looks good to me alright so let me actually open this index component Let's see, what is this? Alright, so this converted it to this. So this is actually the index for the preference tab. It has themes reading the lexic reset. So I guess this is this thing where I have everything. Alright, so let's actually

 actually see that we have to do anything here. Again, we can remove this ampersand. Remove it here. Options. Ah, so this is the issue. Okay, so we can actually fix this. Because as you can see, when I was saying before how some scoping changed, this is it. So basically, I guess when CSS nesting was new, Svelte really didn't account for this because we're actually targeting some elements that aren't really in this component because we're importing them here. and this worked in the past, but it never should have worked, right? So basically this is the issue that I have here, and Svelte warns us, hey, this is actually unused, because it is, right? So what we're actually going to do here, I'm going to say global, and now it's easy peasy, because I can just open global here. Now I can go here, I can close global. So let me see what happened here. Yeah, okay, let me just do this. So now when we're done here, I'm going to close it. Let's save everything, right? So we just have options, and then we're nesting this thing, you're saying, okay, let's scope it to this options at least, so it's not completely global, right? And let's see, I actually think that this should fix our styles. Awesome, now everything works the same as before. Alright, so we actually fixed one more thing. Okay, and melt is even working properly. And I don't know if I closed the sidebar on accident. But yeah, okay, cool. Oh, and by the way, I don't think we also don't need all of these ampersands right here. Alright, this is my personal nightmare. ampersand. Okay, let's remove this ampersand right here. Awesome. I'm going to save this. Let's go here. Refresh for good measure. Alright, we can actually see everything is actually in its place. Alright, cool. So now we can actually continue. Alright, let's continue and open the reset component. So again, it's changing the event handler. Let's see what this reset is. Oh, I'm using a store here for the preferences. I think I'm going to keep this last because it's going to be actually really interesting to show you how you can convert a store to use runes right so i think that's going to be actually really fun for the end yeah this actually looks okay to me i don't think we're going to touch this yet let's actually open the themes ah okay so now we have this run here because it can determine if this is a derived or effect and in this case if i go here let's see so actually whenever the selected label changes i want to update run. Yeah, and I think instead of run, this should completely be on effect Yeah And if you didn know stores work with runes no problem You can just use them like this it going to rerun this when it updates all right so i can even go to the top let me remove this and i think this is going to be it unless i'm missing something else it even updated this accessibility warning so no longer is this dash it's underscore that looks good to me let's see select and this looks also all right to me if i look here at the project i don't have to change anything, right? So yeah, so that's maybe something I need to change later. And again, we don't need all of these ampersands here. Let me just remove this menu thing. Let me just refresh. Cool. Now we're going to see everything works the same as before. Let's actually see if updating the theme works. Alright, so flashbang warning. Awesome. Let's actually see if I select this. Cool. It persists. Beautiful. Alright. Let's actually convert search. Again, we have this run here. So it converted this to use room state state. Let's see what it's worrying about. Undefined. Okay, let's just say then it's worker or undefined. Awesome, not a problem. Okay, let's see what the problem is here. Alright, so when the search updated, I would actually post a message from this worker. And instead of run, this should be an effect. And the same thing happens when the search term changes or the open state. This should just listen for the change and be an effect, right? And since this can be undefined, let's use nullish coalescing. So it doesn't bother us. And cool, I think we can even remove this. Alright, let's see if everything else looks alright. Yeah, this is just the HTML change. Okay, let's remove this. Evil ampersands. And I think I can even remove this. Let's see. It says unused. Okay, let's just leave it in. I'm not going to argue with it. Okay, let's do this. We definitely don't need this. Ah, we have this mark here. So this is when I open the search, and I search for swell. Yeah, they should use this color, as I said earlier. Okay, so what we can actually do, let's just make this global. So at least it's going to be scoped. okay let me actually search all right now it using the correct color and there is actually another issue I have to toggle Let me actually just finish this off first I don't think we need this. Let's see, do I need this? Looks alright to me. I don't know why it immediately disappears, but refresh always helps, right? Alright, so I can search Svelte. Cool. Everything looks to be great. But there's actually one issue I have that people reported to me. So for example, when I click on this, then it's interactive because otherwise I will get destroyed for the bandwidth. But actually, what I didn't account for, I can press Ctrl K, but it's not loaded, right? So actually, let's fix that quickly. So let's initialize it also when the user uses the shortcut, right? So let me actually find where that code is. Okay, so here, key K. We're preventing default. And we can actually check. What am I using? The name is search. alright if search idle so if it's not initialized we're going to say initialize boom let's just invoke it again let me just refresh now I'm going to press ctrl k we're going to see loading and now we can search alright cool another one in the bag this wasn't that bad right oh and by the way I'm so sorry for mixing these two things up but for example here where I'm using this question mark this isn't nullish coalescing this is optional chaining I don't know why I mixed them up, but basically Nullish Coalescing is where you have this double question mark, right? This isn't Nullish Coalescing, this is optional chaining, alright? When you hear me say that, well, my bad, right? Okay, let's continue. So here we have this layout, everything looks great, so we're using children here, let me check the styles, yeah, the styles look fine. The only thing that I want to change, I actually don't want to use SAS anymore, let me just rename this to CSS, I'm going to save this, I'm going to press Ctrl-Shift-E, so I open this, let me actually go to source, routes, actually, where are my styles? Okay, they're here. So let me actually rename all of this to CSS. Alright, so after I renamed all of these files, now I can actually just change this use. This should just be an import. Alright, so this is just a regular CSS import. Boom! By sass, I'm not going to miss you anymore. Oh, and we get an error because I'm silly. Let me just rename this. Ctrl D, dot CSS, boom, later. Alright cool how awesome is this Let see if everything works If I go to a post for example Ah look at this All right now I free of SaaS forever Let go team How beautiful is this, right? All right, let me actually just close this. And I'm going to go back to the Git view. Okay, let's open the homepage. So this is source slash routes. And I think we already done this one. Yeah, okay, this is the divider. Ah, yeah, we already done this one. So here is a very important post. Yeah, we don't have to do anything here. Awesome. Let's actually move on to the next component. This is going to be source slash routes slash slug. Okay, so let's actually see. This looks all right to me. Okay, so what did the migration script change? Oh yeah, you no longer have to use Svelte colon component. Now you can just say data.component and it's also going to dynamically update. The only reason this existed because previously Svelte uses classes and I don't remember exactly the details but it wasn't reactive, right? But now this thing is reactive so it's even simpler than before. alright so what is this let me actually go to card and when I have preset I only have support and edit oh so this seems to be something that I removed at some point because I don't have a newsletter right I can actually just remove this we don't need this alright so here we have some styles that's basically it let me save this now let's actually open the card component ok so the migration script actually created an interface props which is really interesting it assigned it let's actually see if we have to do anything else this could be cleaned up a bit but actually I don't think we have to do anything in this component I'm just going to save so we get that easy formatting when I refresh, okay, everything looks great let's actually see okay, everything looks alright to me okay but these are the cards, right? okay, so let's actually make sure all of the cards look okay I'm not using cards here but I think I actually have drafts. Let's actually see drafts. Now I'm using this different style. Yeah, so basically this is just these cards right here, right? I noticed some interesting artifacting. I wonder why this is, right? What is causing this? I'm going to investigate this later because right now it's really not important. All right, so now we're done with this card. Let's actually open overlay. Okay, so this is an easy one. We don't need on mount. We can just use an effect which does the same thing so your code is going to run when the component is mounted. Let me actually see, okay, it fixed this. Huh? And I wonder if I'm even using this overlay, for example,

 Go back here. I am. So you can see how things get darker. Well, basically that's the overlay that I'm using here. Okay, so everything works the same. Easy peasy, lemon squeezy, no problem. Okay. Alright, so this is done. This was basically very easy. Alright, so now we have table of contents. It converted this state. Let me actually see what we're using here. On mount. Actually, let's just remove on mount since we don't need this anymore. Cool. Let's turn this into an effect. And we have onclick here, nothing special. Onclick. Some styles. Let's see. All of this looks okay to me. Cool. Alright, so now actually I just need to save this. Let's again go. So now we can look on the right if the sidebar is going to work. Okay, cool. It opens. We can close it. No problem. Great. How easy peasy lemon squeezy is this? Alright, let's open the archive page. This should be the same. So we look at the archive, right? I don't see any errors, right? Yeah. okay we can improve this let's just remove this and result let me save this and now if i go here let me just go to the archive yep everything looks great great so now we can actually go to something else and i think we already updated this one so this was the categories right yeah awesome all right so let's actually go to drafts let's see if we have to change anything here ah so this is the same styles I think ok let's see what is this we can remove this post title and this looks very familiar to before let me just use global here I'm just going to wrap this cool let's save this and what was this again this was drafts right so actually this is my super secret url awesome everything looks the same as before. I should maybe write a couple of more newer posts, right? I'm going to get to it, I promise. But yeah, alright, after this refactor it's going to be easy peasy, lemon squeezy. So I think we only have this component left, and let me see, yeah, we're almost done, and then we're actually going to do the last bit, we're going to change the store to use runes. Alright, so let's actually look at this last component, so this is giraffe slug. So when we go to this post, we can actually see this looks okay Again this change Okay we can remove this This is superfluous right We already learned that And that it That basically it friends This is how easy lemon squeezy this was All right, friends, almost done. Let me just press Ctrl-Shift-E. So let's go back to our project here. And I think I have some files here that we need to convert. So these are the icons. So this is basically the markdown that I'm using. Basically, I wrote just a mini MD-SWACS to format markdown the way I want, right? So I can include components and etc. I think I made a video on this. I'm going to include it if so. Otherwise, yeah, ignore it. But basically, here I have this site. So this is my config. Plugins. So these are my Rehype and Remark plugins to remove paragraphs from images and etc. Okay, so this really isn't important. Ah, stores. Okay, what intarnation is this? Let's see, sound effects. Why the heck is this a store? I have no idea what I was doing here. Maybe I was doing something else and then I changed it and then whatever. yeah let me just remove this this shouldn't even be a store there's like no reason for sound effects to be a store let me just change that and then let's actually just look where we're using sound effects so this is store so I'm probably going to have to change that let me just I have no idea why this was a store I'm very curious to be honest alright so we can actually go here awesome let me just remove this alright refresh for good measure alright, now we can hear the sound effects everything works the same as before alright, so let's go back to the explorer view and let me think, where are my preferences? aha, header, okay preferences, ah okay, here it is here is what I want to change, well basically I have this preferences store, so I have text size text length, text height so let's actually convert this to use runes, which is going to be really easy, alright, so basically how this works, I have these values and then whenever they get updated so basically I'm creating this constructor here and then I'm immediately subscribing to them. So whenever text size, text length or text height changes I'm going to actually save them to the local storage and I'm going to update the CSS variables that are associated with them. Alright, so how do we actually turn this into runes? And that is very simple. So the only thing we have to do because we have universal reactivity we can just say state like this boom, now we can remove writable, we no longer need this. Alright so the beauty of runes in classes for example is that Svelte is going to automatically create a getter and setter for you So for example you going to have automatically this It going to be taken care by Swell So what we want to actually do option number one, we can actually make these things private. And now you can create your own getters and setters. So for example, when we return the value of this here, so we would say return this, and this is text size, right? And when we update the value or we set it, then we actually want to write to the local storage. So for example, we would say something like this. This takes the size. We would first update the value with the new value, and then we would, let me see where it is. Yeah, then we would take something like this. And now when we have complete control over this, we would actually write to this thing, right? We can do this very easily. And of course, let me see. Yeah, HTML is defined here, but you would define this, you get what I mean, right? But actually, I'm going to do something else. I'm going to use effects and I don't know if that approach is better or worse it's more lazier to be sure and it's also going to show us an interesting problem you might encounter using that method and how to solve this so I'm just going to revert all this I'm actually going to use an effect before we do that we of course don't have to no longer use the store methods like set we can actually just say let me actually do it like this I'm going to select all of them we just have to say equals boom let me just remove this cool, that's how simpler that is alright, so here we have these things we can actually just use effects let me create an effect and I can just move this thing here boom, no longer need this let me just create two more effects awesome, so now we can actually take this so we have one for the text size here is going to be one for the text length and again which method you choose is honestly up to you I'm not saying one is worse or better than the other this is a bit more lazier and less code to write but yeah you can use effects easy peasy alright just to make sure we have text size, text length, text height boom now we can get rid of this code we no longer need this the only thing that we have to update here of course we're referencing this text size and we can just say this here Alright. Believe it or not that basically it The only thing that we can do we can destructure these values as is So we actually have to export just preferences Export one preferences Great Alright, let me save this and let me actually see, are we even going to get an error yet? Yeah, the first thing we have to change actually, since we're using runes, we actually have to name this file .svelte.ts. Yeah, that is what we have to do. First, of course, we're going to have more problems, and now let's actually see where this thing is used. So we can go here, let's say preferences. Alright, we can actually see these are the files. So we can actually just the structure preferences. Let's see where this is used. See if there are more. I'm just going to Ctrl D, select them. Delete them. Let's say preferences.textlength. Now we're going to see we don't get an error anymore. And let's see, everything else looks alright here. And I wonder, let me just save this. So we can also do it for this file. So here where we reset the preferences, we can actually adjust the structure preferences. And then we no longer have to do this. And of course we have to save preferences. Alright. So let me actually see, everything looks alright. Let me actually just refresh everything. Actually see. So this is what you're going to run into if you try doing something like this. And this error looks cryptic but it's actually very simple. So it says effect orphan. Effect can only be used inside an effect. And what this actually means is very simple. So let me actually go here. I'm going to go back to our preferences. So the issue that we're encountering here, we're actually initializing this effect outside of the component lifecycle. So this is what's causing the problem because every effect needs to have a root effect. And basically that's just something that wraps your entire SwellTap, but in our example here we're doing it outside the component. And that's maybe why I think that just using getters and setters where you have more control it's also cleaner so you don't have to do something like this. Alright, but what is actually the solution? Where we actually have to create the root effect ourselves. It's very simple. We just have to say effect root and we just have to move everything inside of here. Cool, so now that we have everything inside of this root effect, now when I refresh everything, I'm actually going to show

 you okay no errors let's actually just be super safe go to local storage clear everything and i'm going to see for good measure refresh boom we can change sorry for the flashbang let's go to a post let's actually see if this works so we can actually update the reading size the reading length and in the reading line height we can use a font for dyslexia and of course we can reset all And that's basically it, right? How beautiful is this, friends? Alright friends, that's it. We've successfully migrated to Svelte 5. If you like what you've seen, don't forget to like, subscribe and I'll catch you in the next one. Peace.