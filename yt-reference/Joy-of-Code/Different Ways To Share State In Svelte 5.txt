 Yo friends, what's up? In today's video I want to show you how you can share your state in Svelte. So I want to show you that you're not only limited to access search, so you don't have to use getters and setters if you don't want to. You can use functions, classes, whatever you want. And you might be wondering why we're looking at React code, and the reason for that is because I actually want to first start with explaining how rendering works in all of these different frameworks so you understand when it comes to Svelte when we export values why you have to, for example, wrap or box values, right? Alright, and I'm honestly tired of the people that keep repeating, Oh, Svelte is just React now, Svelte is just like Vue now. Oh my god, I'm so tired of it. Alright, so now that I made everyone upset, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support. all right friends let's talk about react the framework everyone knows and loves so we have this simple counter right here we can go up to four no problem all right but how does actually react work well react is very simple and beautiful to be honest actually don't mind jsx not jsx in but in general jsx is really cool in my opinion so let's actually see how actually react works so we can for example say console log and we can just use a regular value which is really beautiful because in React, when a component updates, since you're using a hook, you state when this updates, this entire thing is just going to rerun. That is basically how React works. So for example, if we increment the count to 4, you're going to see it's going to log in the console because this entire thing reruns, which of course is a source of all sorts of problems. But in my opinion, this is also very genius because you don't have to do things like count.value or you don't have to invoke count as a function. It just works because React doesn't care. There is no fine-grained reactivity. It just says, okay, this thing update, I'm going to rerun this entire function, just like brrrr, okay, just like that, boom. And then on the other hand, something that looks like React, but it's actually nothing like React, solid, which is also a beautiful framework in my opinion. Again, it has this create signal, but this is not a hook. This only looks like React because it has this function that returns a tuple with a value that you can read and write to, right? And it uses JSX for the templating because JSX is really beautiful. Because don't get me wrong, Svelte is really beautiful, the single file component. but when you're making something like that yourself now you have to work on the language tools for that to support syntax highlighting and everything else around it but JSX just gives you that for free right And of course Solid is only similar to React in appearance because Solid actually has no idea of a component right This is just a regular function So we can actually see when we for example let me just say console.log. And of course, we have to invoke count as a function because it's a signal. It's nothing like React. So when we implement this, we're only going to see its fine-grained reactivity, right? It's going to just update that value. This component doesn't re-render, but this is also the part that blows the mind of people that come from React in Solid because they think that this is just React that's a bit different. But that's really wrong. Because Solid doesn't actually care about this state here. It doesn't have to be inside of a component. You can just have it outside. Boom. And now you can also increment this count and everything works as before. And as you can see, this is really neat. But of course, it comes at a trade-off of developer experience because now you have to invoke this count function because it's just a function. So this is how you can invoke it, right? So now you have to do this something like setCount. Then you have to invokeCount, say plus one. Of course, it also has this alternative syntax where you can pass a function so you can get the latest value, but basically that's it. So we can actually look at view next that is very similar to Svelte, right? So we can actually use this ref, which is really just a wrapper. So for example, when you increment this count value, you have to say count.value because you're accessing this value inside of this wrapper, right? And in template, it's very interesting because you don't have to say count.value because you is automatically going to unwrap this value in the template for nicer developer experience, right? so we can actually see that this works as expected. And we can also see, for example, to prove to you that this does a pre-render, we can say console.log count.value, and I have to open the developer tools, because you can see it's 0 once, then if we go to the output, we can increment it, and of course the component is not going to re-render. So view is the most similar to Svelte in this regard. And speaking of Svelte, let's see how Svelte is different. So you can see we have the same example, count we're using $StateRune, this is just a compiler hint to Svelte that it should turn this into a signal under the hood. But what is the main benefit of a completely compiler-driven approach? Something like this is a way better or nicer user experience. As you can see here where we have increment, even inside the script tag in the template, you can just say count. It's treated like a regular value because Svelte is going to turn this into code that you would otherwise have to write yourself. And what would be by that? Well, if you look at the output here, we can actually see if you look at count here, it actually initializes this signal, $SizedState, then you have some code here, right, and then it creates this effect for you. So this is a template effect this is code that you would otherwise have to write yourself like we see it in Solid So Svelte is actually more closer to solid than it is to view Even though view fanboys are trying to tell me that Svelte copied everything from view which is not true And if we go back to result, we can just increment count, and that's basically it. So this is really beautiful because you have things like this. For example, if you have a double count, you can just say derived, and you can just pass the regular value. Like that, you don't have to think about dot value, you don't have to invoke this thing and etc because it's just treated as a regular value. But of course this is no longer true when you have to share this state somewhere we can just export this normal value because Svelte can't know that it's reactive. And this is what we're going to look at how you can export and share state. And this is going to help inform us why do we need to wrap or box values. And all this is going to make more sense once we get to an actual example. And of course we can also log the value of count so I can show you that it doesn't re-render. and we're going to see now when we pull up the console it logs zero once and then we can increment it nothing happens of course you can also supply your own side effects which we can do using effect and of course when you say console.log count now when we increment the count value we're going to also log the value all right with that out of the way we can actually close all these examples and we can go to our own example which is just a simple counter that we're going to increment and then we can start sharing the state. Alright, on the left I have a simple count component and on the right I have a counter.swell.ts file. And this extension is very important when you're using runes in external files because the Swell compiler has to know that this is a special file. Otherwise it would be inefficient and it would scan every JavaScript file looking for runes, right? But because of this special extension now we have universal reactivity because runes work the same inside and outside Swell components. Alright, but you might be thinking for example, let's just take this count and now when we plop it here, let's just export it and let me just say count so we can import it from lib counter.swell. Alright, and if I save it, you're going to see we're going to immediately get an error cannot assign to count because it is an import. And this is the first problem that you're going to encounter. Swell doesn't change how JavaScript works. It can't magically cross this import boundary, right? Even if we look at MDN, for example, let's look at this. I'm going to include all these links in the description if you want to read more. But basically this section on MDN explains that imported values can only be modified by the exporter. So for example, here we have this myValue, we export it, now we import myValue, and when we try to reassign it we get this error assignment to constant variable The importing module can only read the value but can reassign it Basically that the error we run into And this is what leads us to the next part How can we actually make this work Well we need to actually wrap or box this value somehow. And I had a funny comment in my previous video. Someone was upset about that this doesn't work. They were like Oh, I thought runes were supposed to solve this? And I was like confused because in no point in swell history could you just export a normal reactive value using stores or not because for example because for example previously even if you had a writable here and you set it to zero this was also just a wrapper and let me tell you something great you can do the same thing in cell 5 for example you can say state and if you pass in an object instead of regular value this is going to be a proxy under the hood and this is going to work but of course now we have this box value let me just save this so now we get this error here cannot assign to count because it is an import of course we don't want to do that we want to assign to dot value boom we're also going to say dot value here let's save everything and now when we go back here we're going to see our counter works the same and what's also kind of cool about this object here is you can do other things here you can specify methods if you want only i recommend it this is probably just a side effect of how it works but for example we can say increment and then we can reference by saying this.value so we can reference the count and we can just assign it just like this boom and now instead of saying count value plus plus here we can just say for example count.increment all right and because how this is bound in this case we actually just need to do this we can invoke it inside let's actually go back to our example and we can see that we can increment count and this is another great thing about universal reactivity in swell 5 is you can have easy global state. So for example we can actually go here and let's say for example that you have some config object that you want to export. Well that is really simple. You can just pass an object. Let's say for example that you have theme dark and that's great. Now we can actually go here. Now we can import your config and now we can say config.theme for example. And now we can save this. Now we can go back here. We're actually going to see our config. And now you can update the value and do whatever you want. All right but I'm going to undo this. Alright, so now we're at the same point that we were before. Alright, but let's actually say that you had export let count. We didn't just want this regular state. Alright, so now, alternatively, you can also use functions, but you can also use accessors, which are really cool. Because again, it's all about UX and DX. So for example, you can have a function

 function getCount, and now you can return count, and of course you can have a function setCount, with the count, right? You can have this, and let's also, now we need to get the count, we can actually just say count, and let's actually, we don't have to return it, we can just say count equals value, so let's rename this prop. Alright, now it's complaining about the type, which is going to be just a number. Alright, so now we have these things. We can say getCount setCount, let me say everything here. And now again, this is just a worse DX in my experience, but you can do this for sure. So we can actually just say setCount but now we have to say getCount. Again, this is starting to look more like solid. We have to invoke this function because we want to get the freshest value then we can just say plus 1 to increment it and of course we can say getCount alright, let's save this, make sure this is also saved, and of course, before I forget, we have to export these functions, alright, so let's go back here, ah, it's erroring because we're also exporting this, and we can't reassign this, so we're actually going to remove this, cool, now we're going to see it works the same as before, of course, this is an ugly developer experience, but again, this just showcases that you don't have to use accessors, but if you want, you can do something like this. We can say export const counter. Let me just delete all of this. Cool. Now we can specify a get and set method. We can, for example, get the count. We can say return count. Let's create a setter. Set count. We're going to get the latest value. And then we can reassign count. And of course, you can also add other functions. We can have increment here. And we can say count plus equals one or plus plus whatever you want alright cool now we can save this and now we have a much nicer syntax because we can just come here we can say counter and instead of having to do this you can just remove this code you can say counter count or dot value whatever you want we can just reassign it like this this is why accessors are so nice and then we can just go back here and you can say count awesome let's save this you're going to go back here refresh and you're going to see everything works the same as before. And of course we can try using our increment function. So you can just go here counter increment let save everything refresh and you going to see it works just fine Of course this is silly You not going to define state here and then export this object You're going to have a function or a class, whatever, right? So let's actually do that. Let's actually just take everything that we have here. We can say, let's say export function, create counter. Of course, we can pass a value if you want. And boom, that's how simple this is. We can actually just remove this. We only have to return this. And now we can actually just go back here. We can say export counter. And we can say create counter. And of course, this has to be export fonts counter. All right. Now, if we save this, refresh, you're going to see everything works the same as before. And again, let's recap. Svelte doesn't change how JavaScript works. The reason we have to use these accessors here is because reactivity can't magically cross the function boundary. Same as with imports, right? you can't, for example, just return count, or this object count. It just won't work, because you're only going to get this value at the time it was created. And that's why you have to use something like accessors or functions. Alright, so another common problem I see has to do with people not understanding the structuring. So, for example, again, this isn't something that you would do, because you would just take this code instead. So we only care about exporting this, createCounter function. again we can just say create counter and then we would create this inside of our component right so now if you save this it works the same as before all right but now what people have an issue with here they think okay now if i want to destructure count for example and increment i can probably just go here i can say count and increment and of course we have to say increment and count like this all right let's save this and now again if you refresh but let's try and if we do our hardest so you're not going to update the value. And why that is? Well, let's just think about this. We're destructuring the count value and it's no longer reactive. Basically, by destructuring count here, we're only having this count value, which is the value at the time it was created. So this is forever going to be zero. All right, so what is the solution? Again, if you want to do something like destructuring, you have to box this value or you have to wrap it. And again, we can do this very easily. If we pass in an object, this is going to be a proxy. But what's even better in this case, we no longer have to set a getter and a setter because we're using this proxy, right? Unless you want complete control what happens when you read the value and write to the value right And this is very simple So now we can just return count Boom We have a reference to count And we have to change this to be count That's basically it. Now when we save this, and of course we're going to get object to object, because we have to say count.value, right? But everything else remains the same. Now we can see we can easily destructure these values. Let me save this. Refresh for good measure. Now we're going to see if I increment it, it works as expected. alright so another thing that grinds my gears is people who think that you have to use accesses right as you've seen before we can just use regular functions so for example let me just create a regular count and let me just remove this for now again we can just create a read and write function let's just say read we're going to return count let's create a function write I'm going to take the value then I'm going to assign count to that value. And this should be number. Alright, so now we can actually return these things. We can return an object, whatever you want. Read, write for example. But actually now this is very ugly because now when we destructure these values, first doesn't mean anything. But we can take a lesson from React or Solid. We can return a tuple instead. And this is why it's really important to understand JavaScript and how these frameworks work. Because it really grinds my gears when people don't understand this they just see surface level similarity in syntax and they're like oh swelty's react now and etc it's just really annoying because for example right now we can just return a tuple so returning a fixed array this is a tuple right we can actually just return read write and let's actually assign this as cons so type 3 won't complain all right so now we can save this and now because we're returning an array we can actually rename these values to whatever we want huh look how cool this is right so now we can name this banana whatever you want, but let's just name this count and set count. Alright, so here we can actually just set count. Of course, we have to invoke count. Again, this is a worse developer experience, but you can do this. Of course, you're not limited to accessors. Signals are just reactive primitives. Alright, so now we can actually invoke count so we can get the value. Boom. Now this looks a lot more like solid, right? Let's save this. Let me also make sure I save this. So when we go back here, we're going to see it works the same as before. Alright, so you can take a signal which is a reactive primitive and then you can do whatever you want with it. And it completely up to you which developer experience you prefer I personally think that saying is a lot nicer than having to say and then you have to invoke it to get the value and etc It up to you which developer experience you prefer. Alright, but let's go back to what we had before. Alright, awesome. Now we can also undo this. Alright, so if I say both of these things, refresh is going to work the same as before. alright so the other thing I want to point out is that instead of using getters and setters to update the value and functions of course you can use effects so for example if you remember how we had this let me just do this quickly again we can just say count and then of course we can destructure these values we can say count.value but we actually don't need getters and setters to do something when this value gets updated of course we can just use an effect right here for doing side effects right into local storage and etc Keep in mind, effects don't run server-side, so it's not advisable to use them on the server. We're going to talk about this more later, but in this example, we can just say console.log count.value, and this is going to update each time we increment the count. And let's just say here, counter count.value. Of course, it's very simpler. We could just destructure this. Let's say increment, for example. Remove all this. Oh, now we just have count.value. Let me open the developer tools. you're going to see 0 is logged. Now, when we increment the value, it's going to log. Alright, so you don't even need getters and setters and functions, you can just use effects. But I actually advise that you use getters and setters when you update a state, because, for example, you might run into a problem. Here you have this effect, and then, for example, let's say that you're creating a counter in this file. Let's hit this, create counter. Let's just save this. And now we're going to see, you're going to get an error here, which might look cryptic, So, SvelteErrorEffectOrphanEffects can only be used inside an effect, during component initialization. But basically, effects need to be wrapped in a root effect. And you get this error because you're initializing this outside of the component initialization phase. So, to solve this problem, you would have to do something like this, effect root, which might be personal preference, you might find this ugly or not, but this is basically what you have to do if you're going to use this same function outside of the SvelteComponentInitialization phase. so for example if I save this right now refresh you're going to see you're not going to get any errors and there's also another special effect you have effect root and tracking I think but yeah basically keep this in mind if you're going to use effects will

 and you're going to initialize functions and pass them around outside of the swell component initialization phase. Then you're going to run into this weird problem. Otherwise, if you're not going to do this, if you're just going to use this inside of a component, then you're not going to run into this problem. Because let me just save this for example, refresh, you're going to see everything works fine, there are no errors. And of course, using effects can be tempting because these are the tools that the framework gives you. So of course, you think, okay, I want to watch a value and I want to update it. But that's completely up to you. You can use an effect, but in most cases, it's actually better to just use a getter and setter. So when you set the value, you can do a side effect. All right, to repeat it one more time, you don't need getters and setters or functions to do side effects. You can use effect, you can track when the value is changing. In this case, for example, count.value, you can say if count.value, basically that's going to track this value. And then you can do a side effect like write into local storage or something else. otherwise the alternative would be here where you for example set a method so for example setCount value and here where you set the value so you setCount to V then you can do a side effect here. It's really personal preference right? Whichever you prefer. As long as you're aware of these caveats you're going to be fine. Alright so far we used functions to encapsulate our code but we can also use classes and classes have additional benefits like creating the getSet methods for you. So let me actually show you the same example using a class I'm just going to yoink this, let's delete everything I'm going to export a class named counter, let me just paste this in, of course we can't use let here we just have to do this and now everything is going to work the same as before and let's also specify an increment method and I'm going to use a narrow function because how this binding works, so I'm just going to say count value plus equals one, boom alright I'm going to save this and now we can just import counter and now here instead of initializing this function, we can say new counter. And this should work the same because we can destructure count and increment since count is a proxy, right? So we not going to have any problems We can go back here Let me close the developer tools refresh and we going to see the counter works the same as before And of course because we using a proxy here we don even have to specify a getter and a setter but let me actually show you what's awesome about classes. So for example, we can set count to be like a normal value. And of course, we just have this count here. Now let's save this. And of course, we can destructure this value again for the same reason as before. Let's just name this counter. now we can say counter increment and counter dot count also if I save this we're going to see the counter works the same as before but notice how unlike in functions we don't have to specify getters and setters here now let me actually show you what's so cool about this so for example if I go back here to sources let me just make this easier to read let me just open its source so we can look at the compiled output and this is our page component right? But I think actually our file is inside of lib. So this is the file that we created, and this should be the compiled output. All right, how cool is this? All right, so you can see what actually Swell does under the hood. It makes this into a private variable, right? And then it creates the getter and setter for you, right? And you can see it uses this proxy under the hood. And what's really awesome about this is that you can actually go here, and inside of a constructor, for example, you have the same option as before you can do side effects like this you can say console.log count and of course you have to say this count when we go back here let me just put everything back as it was alright so now we can actually refresh everything we're going to see we get zero and now this side effect is going to run each time count is updated but of course this is one option that you have and you can specify your own getters and setters. And how does this actually look like? Well, I removed this constructor. Again, we can do the same thing. We're making this thing private. And now we can specify our own getter and setter. So we can say, for example, getCount. You can say return. You can do it like this, discount. And we can actually specify a setter Cool So we can actually say setCount I going to get the value and we just need to reassign count We can set it to this value and of course, we need to update our increment because it's no longer this.count, it's using this private variable, right? And this is just regular JavaScript how this works. So, as I said before, you have two options. You can use getters and setters if you want more granular control, or you can use effects. But when you're using effects, you need to keep in mind, if you're using this outside the component initialization phase. Then you have to wrap the effect inside of a root effect. But in this case, you can do whatever you want. So for example, you can do a side effect here, or whatever else you want, like logging the value. So you can actually say console.log count. Let me actually save this. Refresh. Everything should work the same as before. But again, you also notice we're not going to get the initial log because this isn't going to run until we update the value. So of course, we can flop the console log here. And you can see here it is 0, 1, 2, 3, 4. Now we can see we get the same behavior. Alright, I have one more cool example for you. So far we didn't use any derived state, but of course you can use the derived rune inside functions and classes. But did you know that you can actually destructure values from a derived rune? Well, let me actually show you how this looks like. So we're actually going to create this counter right here. Let me just name this constCounter and of course you don't even have to derive a value we can just say derived by, we're going to pass in a function, inside of other write we can actually create a piece of state. Let's actually for example say count, we're going to use state let's use the same trick so we don't have to define getters and setters, and of course we can return from here whatever we want, we can return count we can return an increment function so in this case we're just going to say count value plus equals one, that's it, boom. So now that we have this we can actually just structure count and increment so we can go here let me just remove all of this so this is really simple this is just going to be count dot value boom all right so let's save everything now when we go back here to our example we can actually see that this count works the same as before and again this is just a cool example you wouldn probably use this for something like this but maybe you have some derived state Now you know that you can actually have your own state inside of this You can return whatever you want You can destructure the values if you want and that's basically it. And I think this is something really cool. Alright, so another question I get asked is, can I use runes or state on the server, right? And the short answer is that you shouldn't. Because, for example, effects don't even run server-side, so it doesn't make sense. but another thing is that you can get into trouble because of shared state on the server. So for example, if we read the docs for state management, here in their first example, they actually show you why you shouldn't just assign to a user when you get some data back in page server TS, because this is maybe a long-lived process, right? So you're going to get into trouble and share user data. But they also say in the second one, no side effects in load. So again, you're on the server, you're fetching some data from the user, and you might be tempted to use a store or state in this case using rooms, right? But this is bad because you get into the same problem because your load function should be pure. So no side effects, except maybe the occasional console log, right? All right, so what you should actually do, let's look at their example. So what you should always do, you can just return the data and then inside of your component, you can use a store or state in our case. It didn't update all of these examples. And you can use context to pass the data to children. Alright, so let me actually show you how this looks like. Alright, so just fetch the data, and then you can use an effect for example. Whenever this data gets updated, then you can update the store. Of course, in this example, they're using a store, the docs aren't completely updated yet, but you can of course just use runes. And now you can pass the data to the children. By setting the context, you can specify the key user in this case, and then you can just pass the user. And of course, the same rules apply here. If you want this to be reactive, you need some reference to this user, right? so using the $stateRune you can use a function you can use accessors getters and setters right you can just pass a function that can retrieve the data or you can just pass in an object here and then you have a reactive value because it uses a proxy right and I'm going to link these docs in the description if you want to read more alright friends that's it if you like what you've seen don't forget to like and subscribe and I'll catch you in the next one peace