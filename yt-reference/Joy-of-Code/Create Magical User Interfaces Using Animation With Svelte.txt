 Hey friends, this is the GreatSiltini and I'm super excited to announce animation with Svelte. So let's get started. So let's talk about animations being beyond whimsy. So there's a lack of reverence for both animation and accessibility where they're treated as nice to have instead of being part of a holistic user experience. But it's not because we don't care, right? But it's been historically hard. None of us intend to create a bad user experience on purpose. Animations can tell stories and help the user not feel disoriented if elements on the page reflect how objects behave in the real world instead of teleporting around, right? And can also help bring attention to parts of the site that require it. To understand how animation in Svelte are first class citizen, we have to go back in history. And Svelte was forged by Rich Harris in the newsroom for that purpose and is popularly used for, but not limited, for visual storytelling and data visualizations since then. So get the popcorn out because we're going to watch a movie. So Svelte is used where Rich Harris worked at the New York Times, right? So let me just play this for you. Speaking of the Olympics and all the different visualization work that you've done, what have you enjoyed building the most? The most recent project is a project around the Olympics. News organizations in the US are not permitted to use any video footage from the games at all because the rights are exclusively held by NBC. And yet we want to be able to tell people the results of the races, obviously, because people rely on news organizations like us to know who just won 100 meters. And so we have a choice. we can either describe what happened or we can find a new way to show it. And what we settled on was a data visualization, which looks like the race is happening in animated form in the context of a video that appears inside a tweet or inside an Instagram story. And so what we built was an app for generating these videos based on data that came from the live feed from the Olympics. And you've heard it from the leader of our church. So let's continue. First, we're going to look at some basic examples, but before I start with that, remember the code is available on GitHub and you can open the examples on StackBlitz to play around with them. And I hope you're ready to become an animation wizard and delight your users. So let's start with basic transitions. A transition is triggered by an element entering or leaving the page as a result of a state change. And Svelte exposes seven transition functions which are fade, blur, fly, slide, scale, draw, and crossfade. And we can look at the video here and you can use the same intro and outro transition for example transition fade but if you want to use a different intro and outro you can use in and specify your transition there And the same thing for the out So we going to here have some text And if I open this example, I can go to fade. And let's just import the transition, right? So just how we have it in this example, we can say import fade from Svelte transition. And then we can use the transition. transition fade let me just save this and then if i go here and if i enable it again it's going to animate in and animate out so transitions don't play on first render unless you set intro to true for cell components but since i'm using swell kit you can do that but you can do that on mount if you want to play the transition when it mounts because of that i'm using this trick where i'm setting animate to false and then when the component is ready we're just going to flip it using this checkbox and then we're going to animate it in. And I also made a specialized component here that's going to give me also replay features so I don't have to do this all the time which you're going to see. One thing worth mentioning is that transition functions accept at least delay duration and easing parameters but they might accept others which you can find in documentation. You can specify a custom easing function or use a built-in svelte easing function to give character to your animation which you're going to see in a bit. And you can use the ease visualizer to help you explore different easing option. So if I go here, you can see around you have all these transitions here and you can pick one and then you can play it or you can restart it. But yeah, you can play around with this and you're going to see it's really awesome. So you understand one of my favorites are Quint and Quart probably. But yeah, let me just close this. And for the next example, we're going to see how we can animate this text. So this is going to be a bit more advanced. Let me just close this. and this is the end result we're going to get. So I just want to show you something more interesting. So in this example, I want to split up and animate some text, which is simple using a declarative JavaScript framework like Svelte because it doesn't require a library. So you can just split the text and loop over the characters or loop over individual words. First, I'm going to declare the lines and use empty lines to create a pause between other tags that's going to animate in, which is a neat trick. And then I'm going to use some transitions and an easing function as we discussed it right now. And I'm also going to show you how you can create a stagger effect. And I also want the text to appear from the bottom of the element instead of fading in, so I just set an overflow hidden on the parent. So if I go here to the example let me just open fly I have a custom animate component so I don have to do the shenanigans with the label and check mark basically So here I define my line So I have some lines and I using an empty one so I can create a dramatic pause, right? So we can just import fly from Svelte transition. And then I also want back out from Svelte easing. And then we can just use the animation as I've shown here. So we're just looping over the lines, right? And this is really easy in a declarative JavaScript framework. So you're going to have to use some other library. And yeah, now we can go to our span where our lines are, right? And then we can just start, enter transition fly. And then we can give it some parameters. We can say appear below. And then we can stagger it. So I'm going to show you what it means. So I can say back out. and let's first animate this in so if i do this you can see it does this but i want the words to appear one after another right i mean this is an all right effect but we can do so much better staggering is simple as specifying a delay we can say 300 milliseconds and then we're going to multiply it by the index that we get from the loop and now i can save this and now we can get some awesome animation and how sweet is that and you can do whatever you want this can be some marketing right or whatever and I think this is really cool so yeah so let's go through another separate stagger effect so I can just drill how awesome this is so if I go to stagger see stagger and yeah let me just repeat this so this is another awesome trick when you're like looping over some items for demos you can just say length and specify the items and then you can just loop over them but yeah let's do the same trick so we can say import fade from Swell Transition Right. And then we can go here. Let's just give it space. And then we can say In Fade. And let's just give it a duration. Let's say one second. And then we can say Delay 300 milliseconds times one. We can save it. And we can see the boxes are animating now staggered. Which is really cool for some cards. But if you have a lot of cards, it might be also wise to use an intersection observer so you only animate the ones that are coming into view because if you have a hundred of them then it's going to have a weird effect, right? But look how cool this is. Here I also mentioned that if you use something like transition fly the transition would play in reverse when it unmounted or the component gets deleted right Yeet the component But if you use an intro like in fly, you can use an outro that's a different or the same one if you want, and it doesn't have to be the same, right? And if you don't know what mount and unmount means, it just refers to when the component gets created and destroyed. Another awesome thing about transition events is that you can have this listener so you can listen for when the transition starts, when the outro starts, and when they're finished, right? And I'm going to show you some fun examples later how we use this. I also want to mention that some of the transitions are specific to certain things like using draw for animating the stroke of an SVG elements, and I'm going to show you an example in a second. So this is basically how you can animate an SVG of a circle with a checkmark in Svelte to give that delightful interaction. So we just need to import draw, And then we can just use this to animate the stroke. And I have these examples here. If I go to the ones that we've seen previously, here I have an SVG. So let me just close this. I can go to examples. And if we go to the SVG here, here it is. So here's the path. And I'm just using in draw duration, one and a half second. And then I'm delaying the other one for 500 milliseconds, right? So if I refresh, we can see how it draws in. And that's really cool. and how simple it is to do in Svelte. So let's talk about something useful you should know and those are local transitions. You might encounter an undesired effect when your parent element transition plays causing the children element transition to also play. So if I go to an example here, let me just for example, if I add two more items and then for example, if I unmount the parent component, what's going to happen is the children are also going to animate. So if I go here, just see local and if I go to the animations here, we can see that I have a transition slide on the child when you add it. So this is the slide. And then it's just going to fade for the parent. But watch what happens when you unmount the parent. Those child elements get animated. And you might not want that. So we're going to look into how local transitions can help us solve that problem. And local transitions only play when the block they belong to is created or destroyed and don't get triggered when parent blocks are created or destroyed. So you're not going to encounter this problem often. but when you do, it's useful to know about it and it's easily solved by just adding the local modifier to your transition. Like here, you don't have to import anything and we can just fix this like here. So we can go to the slide and we can say local, save.

 And now when I add more children, it's going to animate as usual, but now when I remove the parent, it's not going to play the transition. And you're going to often run into this problem with page transitions and etc. So you're going to know how to solve it, which is awesome. Another useful thing to know about are key blocks. Sometimes you want to play a transition whenever a value changes and the key block exists for that purpose as key blocks destroy and recreate their contents when the value changes. So in this example, we want to update the notification, and each time we get a new notification, we really want to animate the text, or you can even animate the bell or whatever else you want. So you're going to get this nice animation. If I go here to that example, we're going to see I have a set timeout, so I can see it's right here. I go transitions key. Nothing special, I just have a set timeout. It increments the notification just for a demo, and we're going to learn how we can easily animate this using key blocks. So if I go here, we're just going to first import the animation. So we can say import scale from swell transition. And here we have the notifications, right? You don't have to touch anything else. And now the trick for this is to replay the transition each time the value gets updated. So we can do that by using a key block. We're going to use that value that always changes, which is notifications. And then we're going to close the key block. And of course, let's give it the animation in a scale, because if we don't have it here, this is what's going to happen. So if I go here, just restart this, and it's just going to increment, but nothing special is going to happen. But now we want to replay that animation, which is possible thanks to the key block. So if we can see, it's animating, and how cool is that? So let's talk about page transitions. Because SvelteKit is the default way to build Svelte apps, you might want to know how to do page transitions, and it's a great way to use what you learned so far. So if you notice so far, I already have page transitions. Really don't emulate this. This really isn't some slide deck or whatever. I just created a component where I'm using arrow keys to navigate around. So you can see I get this really cool page transition. But yeah, let me just show you quickly how I've done this. I created a transition component. You can put this anywhere you want. I just put it in lib. And how it works is so you have the whatever transition you want. I'm going to use slide. So I get this full slide effect, right? I going to give it a key which we just learned about right now And I going to also pass it a duration so I can set it from the outside And then we going to use the key block to restart the transition right Which we just learned about. And then for the delay, we're going to pass it a duration. Otherwise, we're going to get some weird effects because it's going to overlap. So if I go here, yeah, you see how weird it is because there's no delay. And then we're going to pass in a slot. So whatever it is after this is going to be displayed inside here. And then this is optional, but you can specify position absolute and you can spread it 100% width and height, right? And this is if you're using something like slide because you're going to have weird transitions. If I, for example, comment out this tile, you're going to see it looks weird, right? So you can just give it a position absolute if you experience this problem and it's going to be great. So another thing you have to do when you create your transition component, you have to somehow get what changed and that's the URL path name. And in the past I used the one from the Svelte store or the Svelte kit store but there's something weird going on with that and it doesn't give me the results I want. So what I found is that you can create a layout TS in your source routes and then you can just get the URL here and you can pass it the URL URL path name and now you can use it in your layout. So if you go to layout source routes and we just import the type page data the page transition which I just showed you now and then you can just wrap this entire thing here so you can use the page transition give it the key data url specify the duration and then you can pass anything you want after that and that's how simple page transitions in SvelteKit are. So let's talk about custom transitions. The transitions you've seen so far cover most of what you need but sometimes you want to combine them or do something crazy and that's where custom transitions come in. You might be thinking how Svelte being a compiler means there's some magic involved with transitions, but surprisingly, transitions use regular CSS with the help of JavaScript. So you can see how Svelte itself implements something like Fade if we go here to the source code, right? But let me just close this because I have it in the post. So you can see it's just a function and it has a similar signature to Svelte actions and it's just a regular function, right? Fade, it takes a node that's just an element, it has some options and then it gets the styles from the node, it gets the opacity and it returns delay, duration, easing and a CSS function that generates the keyframes for the animation and we're going to learn what exactly this means when we create our own custom transition As I mentioned Svelte transitions use CSS instead of JavaScript so they don cause jang because they can run separately and not block the main thread And next we going to work on the best model ever I hope you like that. So I have a simple model I want to spice up when a user opens it by scaling and transforming it. So we're going to create a custom transition for it. So for this, I created a custom transition function model that's going to take the element and parameters and we're going to get the existing transform and return a CSS function. And we're going to see how the CSS function takes a t argument that's a value between 0 and 1 with an easing function applied after. And then the u argument is really the opposite. And I'm going to explain more what this means because just saying it out loud is really confusing, right? So I'm going to use it to scale and translate the y of the element so it starts to grow from negative 100 pixel. But yeah, let's really look how we can do that. So if I go here, nothing happens because we haven't done anything, right? So we can go to custom CSS. Let me just see. Here we can open this and let's open the model. So inside the page I have nothing special. I just have some audio that's different from the post to make it more fun. And then I just have a model that I gave the image to. Yeah, so we can go to the model itself here. And as I showed you in the post, we can just create the custom event. So I'm going to show you how you can do that. And then we can import a transition, coined out, from Svelte Easing. and let's also import the type. If you're not using TypeScript, it's fine. You can just ignore types. So we can say transition config from swell transition. So let's just create some types so it's easier to read. We can say modal params. It's going to have a duration, right? Going to be a number and let's create the type for the modal itself. We're going to have a node. As we've seen, it's an element. Params, which are going to be optional. So let's use modal params. and then it's going to return transition config. So let's create our custom function and it's really nothing scary. So I can say const model. Let's give it the model type since we created it. And then we're going to pass it node and then the parameters, which we're going to set 300 and let's initialize it as empty since it's optional. But yeah, we can turn it. Now we can get the transform from the styles. So we can say const transform and you get it by using getComputerStyle and this isn't really swelped or anything, right? This is just regular JavaScript So you can use that node and we can get the transform properties You can see you can get many other properties because it really just regular JavaScript So we can say transform and then we can return duration that we pass in easy. So we can use quintile and here is the most important part where we use the CSS functions. So we can get t, t and u. and then we can return a string that's going to be our CSS right so we can say for example transform and then we're going to pass it if it already has existing transforms that's why we did that so we can say for scale t right to say translate y and then we can say u times since So you want it to be negative 100. And we're going to give it a percentage. And this is wrong. So you need to update this. Yeah. And let's see what else. Oh, I should also probably make this valid, right? I think this is it. Let me just see. So we can just give it also a transition. So let's recap. We created this custom transition. And TNU might sound complicated, but I'm going to explain it in a bit. So you understand more how it works. I also have some fun additions here that I didn't include in the post. because you can really hear the audio. So you can say transition model and now we can pass it a property. So it's one second and it's going to pass to our custom CSS function. And then when we save that, if you're using this anywhere else, you would just import the model, right? And then you can use it. So nothing here is specific to what you're doing, but the model itself. So when I go here, now our model should work. How awesome it is. The easiest way to think about T is that it animates to the value specified and U animates from the value specified. And I'm going to show you this quickly in Excalibur. So for example, let's say that you have a box and the box is going to travel 100, whatever. So for example, you have this, just draw T here. And here is going to be U. And let's say the distance is 100 pixels. So if you want this box to travel to what we used here, we used minus 100, yeah, okay. So let's pretend we want to animate this from minus 100 pixels on Y, right, or X in this case. It's going to go like this.

 This is when we use u, so we can say from this value is going to animate here, but if we use t here for translate y, it would go the opposite direction, right? So since we use y, it would go like this, when basically you want to animate it from this direction up. This is really confusing if you just read the documentation on this, but I hope my explanation makes a lot more sense. The Svelte documentation advises to use CSS when possible as a return function because of performance reasons, and CSS is just going to generate the keyframes, right? So this is why Svelte is awesome for animation. It doesn't use JavaScript, and it blocks the main thread, causing janky animations. But if you want to do something more ambitious, like a typewriter effect, using JavaScript, you can return a tick function. Instead, it's going to use the JavaScript during the transition with the same argument. So we're going to create something like this, which is really awesome. As I have it here, right now it's nothing special. We don't even have a transition. Let me just open this example so I can go custom JS. And also here I have some sounds I didn't include in the post. But yeah, let's just create a custom typewriter effect. So let's see what we need. As you can see, this is just a regular component, nothing special. I just have a background here. And here's some fun additions I made, right? Yeah, so let me just import first the type. transition config from svelte transition. So this is going to be great. Let me just put it here. And then let's create the types again like before. And if you don't care about TypeScript, you don't need this, right? Typewriter params. We're going to give it a speed. And I yeeted this from the svelte examples because math is hard, right? Type, typewriter. Say that 10 times, right? So you can give it node, which is again an element, params, which are going to be optional. Then you're going to use typewriter params. It's going to return transition config that we just imported. So you can save this. And yeah, basically that's the boring typescript out of the way. So let's do the fun part. Or if you don't like math, this isn't going to be fun over there. So let's create a custom animation typewriter. We're going to give it the type we created just now. so we're going to pass it the node speed at 1 and we're going to initialize it as empty in case it doesn exist so let do that and then we going to set for the text for the node text content If it doesn have any Oh again I made the same mistake here If it doesn have any See. That's pretty awesome. Completion. Boom. Done. So we're going to pass it as empty. If it doesn't have any text content. So we're going to set the duration. To the text length. And don't ask me about this math. Alright. So you can say speed times 0.1. And you can change this if you want. And let me also just make sure. it does the multiplication first. And then we're also going to return the same as we did before, right? So we can say duration. And let me just see. Yeah, I think I also forgot here. So you can pass it tick instead. So we're going to use JavaScript. And for each tick, it's going to do this calculation. So again, we're using T because we want to animate two. And then we can get I. That's the character. So you can truncate it. Say MF trunk, text length. times T. And then we can say node text content and we can just slice it for each one, right? Using the index or the current character, right? That's presented by I. And that's pretty much it, the typewriter effect, right? You don't really have to understand the math just that it's cool. And now you can export this function and use it on whatever element you want. But yeah, here I have some on intro and intro end, which isn't important. So I can just say in and now we can use typewriter. And let me just see if this is everything. Okay, so now when I save this, it should do the typewriter effect, but it should also play the typewriter sound effect. Okay, so moment of truth. Let's save. Beautiful. Next, we're going to learn about the third transitions. The third transitions are awesome when you want to choreograph elements changing position from one parent to another to create an illusion how objects behave in the real world instead of disappearing and reappearing. And we can see in this example how this works. So for example, you have a parent A and a parent B, and you want to send this item between each other. So let me just show you in this example I have here. So this is just going to be lame, right? Because when you change the container, nothing special happens. I just have some randomized function and that's it. But sad noises, right? So basically, we can use the first transitions to animate that. So we can send and receive the items using crossfade that Svelte provides. And here I show you that in this diagram. So the crossfade function creates a pair of transitions called send and receive. when an element is sent it looks for a corresponding element being received and creates a transition that animes the element to that position this might sound complicated but the only thing you have to know is import crossbait and then give Svelte the unique identifier and that it So there is what happens when it received If there is nothing to animate we can also use a fallback and you can set options for crossbait including delay duration, transition easing and fallback. So we're going to get this nice transition instead and how magical is that. So let's do that. If I go here to the third, I'm just going to open it here and here you can see it's nothing special, just have emojis. I randomize it using the shuffle function and then I swap the container each time I press this button and then I have a simple remove feature and a reset one and really nothing special, just simple, right? So let's see how we can introduce a crossfade here. So first I'm going to import crossfade. from Svelte transition. And then I'm going to import Quint out from Svelte easing. Thank you, TypeScript. And then we're going to create the crossfade, which might sound complicated as first, but it's really nothing bad. So for example, it's simple as this for now. We can say send receive and we can say crossfade and let's just pass it empty params because it's going to complain. And that's basically it for now. We can go back to this in a second. So now how do we use it? We can go to our animation, right? and then I have it here after the class. So we can say in receive. We're just going to give it a special key that's going to be the emoji and then we're going to say out send. Again, special key emoji. Let me just copy this over and we're going to do the same for the other parent because it needs to know what it sends and receives and it's really magical. So we can do this. And now if I save it, if I go to example, it should work, right? So if I go to this, oh, how awesome is that? This is just incredible. I could do this all day. There's another thing we can do to set as the fallback. So for example, now when we delete the items, it just, blah, nothing happens, right? So let me just reset this. And here's how you can provide the fallback. So if I go here, this is the spooky part, right? It looks similar like the custom transitions we did, so no problem. And we can set the duration, right, for the property. And we give it a fallback function that also accepts a node, right? Then you can say cons style. Again, get computed style node, and then we can see if it has any transform. So if it has a transform none then we going to return an empty string Otherwise we going to use the transform from the style And this is also an example from the docs I believe And then we going to return again the duration This is the fallback. So this duration here is for the crossfade itself, but here is the fallback when there is no crossfade happening, right? So you can say easing, quintout, and you can pass it a CSS function. And I called it time, but you can just name it T. and then we're going to return a string to be opacity t right and then transform let me just see transform right and then we're going to have the scale it's going to take the time and I should also wrap this since it's CSS right and then let's give it yeah call it t here and maybe we should also do it here so we can save this and let's see what happens now so remember here we have the duration now that's going to take when these items change position but now when i remove an item is going to fade out so also briefly want to mention that this is one of the most magical features of svelte list to me and it works great for elements that change position as long as you're not rotating the elements because rotations are for example the absolute pure evil for some reason so let's talk about svelte animate you can use the svelte animate directive to trigger an animation where the contents of each block changes using an existing svelte animation function such as flip or you can specify a custom animation function. And if you didn't know, the flip animation technique is great when you have items that change position and want to show that transition and lets you do impossible CSS animations while being performant. So basically the flip animation stands for first last invert play. As you can see for example if you have this element in the first position and then it goes to the last position then it's going to invert it to the first position so it pretends it never animated to this one and then it's going to play it but you might be thinking this looks like ridiculously simple right but for example let's say you have two containers how would you do that using css you can't right and this is where you can use the flip technique so for example imagine if this was the first container and the second container you could create the illusion that that item is transferring or animating over to that other container you just need to calculate the values in advance and you don't have to do any fancy math and then you just do the difference and then you animate it and basically in the context of this example in the previous example if you remove an element it just leaves an empty space so if I go here let me just reset this nothing happens here right

 Yeah, so we can go here to this example that I have separately. So again, right? Same as before. Nothing happens. We can make this a lot better. So how do we do this? And believe it or not, all of this that I said so far might sound super complicated, etc. But this literally in Svelte requires one line of code if you ignore the import, right? So let me just go to that other example. I named it animate flip, right? So let's just be consistent so I don't change the files here. Let me say animate flip. and this is the same example as we have here. So how do we do that in Svelte? And all that you have to do, so you can go here, you can import flip from Svelte animate and now you have to use it in your animation. So if I go here, let me just find it. Yeah, we can just say animate flip and we can also specify it for the other container. You can go here, animate flip And do you believe it when I say that this is everything you have to do? And let's just look at here. I'm going to save it now. And look what happens when you remove an item now. The elements around it are going to react to it instead of just being an empty spot and then everything shifts. So look when I delete this. How magical is this? Everything works the same as before. And now, pay attention when I add the items back in, they're going to also react. How awesome is this? One thing worth mentioning is that having Flip inside Svelte is amazing, but it's limited to one each block, and later I'm going to show you an example of using Flip with another animation library that's going to blow your mind. Let's talk about another awesome feature of Svelte, and that is Motion. Sveltex poses two writable stores, Twin and Spring, that are useful for values that change over time. We take for granted how the browser can interpolate values of an element such as opacity going from 1 to 0, right? We just need to specify transition and don't think about it, but the browsers have to smoothly interpolate those values by creating intermediate values from 1, 0, 1, 0, 2, and etc. all the way up to 1. Unfortunately, you can't tap into this power for values outside of CSS, but lucky for us, Svelte provides you with a way to interpolate between numbers, arrays, and objects of the same shape. You can also pass many different options, delay, duration, easing, and etc. And you can also use other interpolate functions such as defree interpolate. If you're into that, you smoothly interpolate between two colors among other things You going to be thinking I can already do that in CSS but the difference here is that you can do it outside of CSS right where you need it So you can create a HSL color spectrum or whatever you want So use twinned when you need a smooth transition between two values So let's look at the next example. If we go to motion twinned, here I have a Pokemon simulator, it just has a set timeout that's going to subtract the health from the Pokemon. And this looks cool, right, but what if that was like animated, right? So we need some kind of tween between the values, right? And it's only going to take one line of code. So for example, if I go here to tween, let me just find it, motion tween, you can see here is a simple component, current HP, takes the Pokemon HP, here's a timer, and really nothing special. That's it. So let's see how simple this is in Svelte. The only thing we need to do is import tween. So we can say import tween from Svelte Motion. And now we need to turn this current HP value into a store. So we can just say tween and we can say Pokemon HP. And now we need to update values where it's current HP so I can press Ctrl D and let me just reference it value HP. And now we can use the dollar sign for the store and we can say current HP and let me just make sure when I go here so for the value yeah we can do it like that so everything that's changed is we use the store and now when i save this it's going to restart but now we're going to have a smooth transition so let me save it how awesome is this this is really beautiful if you have a countdown or whatever you can simply use a tween value to get the values in between right and this is really awesome another thing you can use are springs to add more natural motion to your animations using spring-based physics. So you might be thinking, what's the difference between tween and spring? It's similar to tween, but it generates the value based on some other parameters like stiffness, damping, and etc. from physics, so you get more springy, natural-feeling animations. And unfortunately, you can't use spring with svelte transitions because springs don't have a saturation, but you can control stiffness-damping-transition, and you can create a svelte action and apply to your elements. So I have a simple box I want to animate using spring physics, and I'm going to use svelte actions which are just regular functions. They give us a reference to the element when it's created because I want to be able to reuse the animation on other elements So we going to end up with a springy animation like this So let see how we can achieve this If I go here here nothing special right now And let me just open this file So it motion spring and just a simple component So let's see how we can add springs. So we can add the spring from Svelte Motion. So let me just import the type again. Import the type action because we're going to create an action. Svelte action. and let's create a type spring in. That's what I'm going to call the transition, spring in params. It's going to have a scale. It's going to be a number. Rotate is also going to be a number. And then just so it's easier to read, I'm going to create this type, spring in action. This is just going to take a generic. So you can say it's a HTML element. Take spring in params. And then let's create the action itself. So you can say spring in. we're going to give it spring in action type. You can say node params. And also it doesn't complain. You can just say if there are no params, just return. And now we can destructure the value. So we can say const scale rotate from params. Actually, just make this like this. const value, which we're going to pass to the spring store, right? Then it's going to have a default value, rotate zero, scale one. Then we're going to define the options. So we're going to say, let's say stiffness, 1.1, damping, 0.6. Now we can create a spring store. So we can say let transition spring. We're going to pass in the values and the options. And now we're going to subscribe to the store. And we really can't use something like this, like you might be familiar with, because we're basically just in regular JavaScript. And we're going to create the unsubscribe, because now we have to do things by hand, right? So we can say unsubscribe. So we're going to say subscribe. And then we're going to destructure, rotate and scale, because we get state back, right? And now we're just back in regular JavaScript. So we can say node style transform. And whenever this update is going to change these values, so you can say scale, let say it going to be scale like this and then we going to give it rotate say rotate let close it out we can say degrees close it out like this and then immediately when this starts we're going to update it, and that's how I'm going to trigger that transition. So I can say transition update, because that's our store, and again we get the state back, but we really don't need it. So we can just return scale rotate. Yeah, so now we just need to return a cleanup because it also returns an update and destroy function. So when this is done, I just want to unsubscribe from the store, which would normally be done for you, right? And now you have SvelteAction that you can import from anywhere and you can just use it on any element. So for example, here I have a box and now I can say use spring in and now we can pass it rotate and since we're using TypeScript if we don't pass it something it's going to complain at us and we can get auto completion we can say rotate scale 2 so now when I save it it should animate so let's save it and that's it so now we can just restart this animation and look how springy it is and this is really awesome it might sound complicated but at the end of the day what's more awesome about this this isn't some Svelte abstraction, this is just regular JavaScript, and if you're comfortable with JavaScript in Svelte, you can become a complete monster, right? So how awesome is this? So let's talk about how you can use other animation libraries. Using Svelte is enough for most things, but sometimes you need a professional instead of a generalist, and you can reach for an animation library such as AnimeJS, GCEP, or MotionOne that have features like timelines to coordinate animations, or you want to use some other feature. So far, you've seen how a powerful combination crossfade and flip are in Svelte, but they have their drawbacks like not working great on elements that are rotated and flip can be used outside in each block. And that's a shame because the flip animation technique is mind-blowingly powerful. So for example, let's say I'm working on a card game and want to animate placing cards from your hand to the deck and taking the card back from the deck, but it's not looking great because crossfade doesn't consider the rotation. So here I just have a simple, if I go here, flip swelped. You can see nothing special. I'm just using crossfade and then I have some cards. Honestly, the hardest part about this is figuring out the math to make cards like this. So for example, I'm just passing in an index and then I'm using...

 using CSS basically to transform them, even using the Z index. So the first card starts at the top, which is really neat. You can look at it if you want. So basically here is doing some math for the transform. So it's going to get the rotation and it's going to multiply it by that. Yeah, this really isn't important. What's important here is the crossfade. So for example, I want to add these cards here and I'm like, okay, I learned about crossfade. This is really going to be awesome. And then this happens. And you're like, what is going on? And I can even add more cards. and if I return the card back to the hand it's like complete chaos and that's because Crossfade doesn't really work well using rotations and there's other problems when it comes to flip animations like nested transforms and when I say problems I mean when you implement it yourself because rotations are evil, okay but something like GCEP provides a flip plugin that takes care of everything for you and it just works like magic so you don't have to implement flip yourself and etc and this is where we hit the limitations of Svelte because right now as it is, it doesn't support flip for these use cases. But we can see how simple this is using something like GSEP. So if I go here, I can go to the GSEP example and right now there's nothing special. We haven't implemented anything, right? This is where you have a normal card game. You really have to think about, oh, when should I use flip and etc. We're just teleporting elements around and you're going to think, oh, I want to really use an animation for this. How can I do this? And you're like, okay, I can use crossfade flip or whatever for this. So let's go to that example. if I go to flip gsap and here's the same one I have here so now we can import gsap I already installed it import gsap from gsap and then we can import the flip plugin import flip from gsap dist flip and that's how we have to import it and then we can register the plugin that's just a gsap thing so you can say flip so remember how we explain what the flip animation technique is and again if I go to Excalibur and if I remove these things here we just care that the element is in this position right and then it's going to be in the other position and then whatever we do we're basically going to take a snapshot of this using something like get bound client direct or whatever we're going to get these dimensions and then we're going to do this again when something changes from the transition or whatever state and then we just need to calculate the difference and that basically it how flip works So I can close this and I can show you how simple this is So one method we can do is use before update and after update functions for Svelte And we can just say hey whenever something changes in Svelte you can do the flip here But for more control, I'm going to show you how to just create a simple function, which is way easier. So let's just remove this. I have to navigate. And it also did the wrong imports, which is hilarious. I love when it does that. But yeah, basically, so we imported GSEP and we registered the plugin because that's just what you have to do. so here we're going to create the function the flip function we're going to say flip and remember how i told you in the example what do we first have to do we have to get the state so where that element is and we can do that by flip get state and just give it the element it needs to keep track of and then here we can use tick so what's going on here if you're not using tick or request animation frame or even set timeout it's just going to instantly happen right so we need to wait for the next update to the DOM, right? And we can do that using requestAnimationFrame, and I prefer this because now I don't have to turn this function into async, and then I need to import tick from Svelte, and then I can use awaitTick. I just don't want to do this. So let me just remove this, and this is pretty simple. So I can say requestAnimationFrame, which takes a callback, and let me just do this. So now what do we do next, right? So we can say flipFrom, and then we can give it that initial state. This is what GCEP wants. And then again, because we're using a declared JavaScript framework, the elements are going to get deleted when we repattern them, right? So we need to pass targets to the GCEP plugin. We're going to say, hey, the change happened to card. And then we're going to use a built-in ease from GCEP, really similar how Svelte has it, right? So we can say power one in out and it's just easings that GCEP has, nothing special. But now nothing is going to happen because we need to give it an ID. so gsap also knows what updated. So here where the elements are. Yes, before we do that, let's go to the functions. Now we have the gsap flip thing, right? So now we have to say, hey, whenever something happens, value changes, it changes the position of an element, so we want to flip it, right? So this is what I like about using a function because this is really obvious that this is what happens. So we can just call it after this, right? And then auto-completion is working against me, but nothing I can't beat, right? So nothing's going to happen yet before we give it the ID. So this is something that GSEP keeps track of and you know that by reading the documentation But yeah we can just say data flip which is just normal HTML and JavaScript right So we can give it the unique ID In this case this is card ID And let just repeat it for the next one So this is really similar to how CrossFate also looks for sending and receiving the elements, right? So very similar, but flip on its own, it's very powerful. So we can also say card ID. And now we can save it. This is going to blow your mind if you've never seen a proper flip animation. And how incredible is this? One of the best things about Svelte is the ease of using existing JavaScript libraries because it doesn't require special lifecycle methods to work and makes code reuse easy thanks to actions. So remember the spring example from before? Let's do the same example using the animation library Motion1 and Svelte actions. So if I go here, let me just go to the next example. So here's similar to what we had before. Nothing is going on here. Let me just open this component. So this is just an actions. We have a box with animate component. Nothing special here. But now I have this file animations. It's just in the same directory. So I just want to show you how you can use actions. And I'm going to deliberately create them in a separate file. So basically this is what you do, right? So I already installed Motion 1. And now we can import animate in Spring. And we can see how easy it is using Spring in Motion 1. And then I'm again going to import type action from Svelte action. Then let's create the type spring in params scale optional number rotate number type spring in action. And now we can use the generic HTML element. Bring in params. let's close it and now we can create our action export con spring in we can use the type spring in action pass it a node right params and we're just going to use the api for motion1 so let me just reiterate this isn't svelte this is the library motion1 and motion1 gives you this nifty animate function so you can call animate and then you can pass it a query selector or whatever but we already have the node, right? We should pass the node. We're going to say scale and then we're going to say, hey, if params isn't available, set the default as one And we going to say the same for rotates or params Let just account for it say zero and you can pass in some interesting options here you can say easing and look how simple it is in motion runs you can just say here easing you can say this is a spring and boom that's it it's done so we can just save this and now we can use this action right because we exported it And now if we go here, as I show you in this example, we can just say import spring in from animations. And now we can use it, right? So we can go here, use spring in. Let's set the scale to 2, rotate to 90. Now if we go here, let me just save it, and we should see it works. And we can also restart it, and how awesome is this? And of course, we have other options. For example, we can say repeat and we can use infinity. And now we should just repeat, right? But this might be obnoxious, right? And Motion 1 also gives you a timeline, same as GSEP. And I think AnimeJS also does. And this is really awesome. Another awesome thing about Motion 1 is that it has motion dev tools, which you can use to inspect elements in your browser and even change the animations, which you can play around with. And it's really cool. So let's talk about the last thing, but not the least important, which is accessibility and arguably the most important one. So if you're using motion, you have to be responsible because it can make someone sick and you have to respect their preference for prefers reduced motion. If you open it, you can read more about it on MDN. And basically how you use it in regular CSS is you use this media query prefers reduced motion and then you can use this. And I also want to emphasize that reduced motion doesn't mean no motion. You just have to adjust the values to something more sensible for those users. But we're using JavaScript to set CSS, right? So how we can do this. Basically, I just have this example here, accessibility. Let me just open it here, accessibility. And I just have this function here to show you in the post. You can take this. The only downside of this is that if the user updates their preference, it won't get updated until the next time they refresh the page. So you can use a swell store if you want. But yeah, basically, you can just create this. So I'm just using a browser because it's going to run server side. So we're saying, hey, don't do anything. There's no browser. Otherwise, you're going to get a nasty error. But then once we're in the browser, we can say this is the query, media query list, give back the window match media. And let me just console log this out. So I can say media query list. Let me just open.

 here let me just see what's going on you can just increase the size turn off responsive view yeah so let's save this so you can see we get back a media query list and we get back the matches false right and now in your component you can import this here prefers reduce motion get it here and now you can change your animation values or whatever else you have and let's quickly fake prefers reduce motion so i press ctrl p now let's say prefers emulate css prefers reduce motion so remember now we have to restart and now this should be updated. So it says match is true, prefers just motion, yes. So that's how you do that. You should be a proper svelte animation wizard by now. Congratulations for making it so far. I hope you take what you learned and delight your users but remember that with great power comes great responsibility. Consider accessibility from the start and remember animations done right are subtle but impactful. Thank you for watching and catch you in the next one.