 Hey friends, what's up? Today I want to talk to you about the recent Svelte 5 changes. So if you missed it, Svelte Summit was this last week, so I'm going to link all of that in the description, so you can find the link there. Keep in mind, this is the alpha for Svelte 5, so you can now try it out and it's being developed in public. But if you have any concerns, you can of course always voice them in the YouTube comments, nothing wrong with that. But if you actually want to talk to the maintainers, they always listen for feedback in the Svelte Discord. So you can join the Svelte Discord, you can go to the Svelte 5 Alpha channel and you can talk to other beautiful like-minded people like you. Alright friends, so that out of the way, don't forget to like and subscribe and you can also support me by becoming a patron. Alright friends, in a previous video I already talked about runes in depth which you can watch but I'm going to recap it for you if you missed it. So Svelte 5 introduces this new system of reactivity using runes or signals, so you have fine-grained reactivity and these are just terms that people throw around and no one knows what it actually means but let me just explain to you what the current problem with Svelte 4 is and what Svelte 5 is trying to solve. So here in this example right now Svelte 4 uses compile time reactivity and what does that mean? Well here I define two values width and height right? So any dependencies are determined and Svelte compiles your code. That's basically what compile time reactivity means. And we're going to see in a second what's the problem with that. So here I have this label syntax which you're already familiar with it know and love right? Area width height. So the Svelte compiler can see this squid when it parses this file. You can say okay, area depends on this value, so whenever these values change, I'm going to recalculate area. So here I have a simple set timeout where I update these values. So Svelte knows to recalculate area and this is going to update. So if I go to the runes example here, I'm going to open the develop tools and clear everything. Then you just go to runes, you're going to see 100 and then it's going to update after one second to 400. So you see this works as intended. But there is a problem with it. The Swell compiler can't see into function. It can only see what's at the top level, right? So if I uncomment this, and let me just also uncomment this line. I'm going to comment reset timeout and this code, and that's it. All right, so now let's say, for example, that you're doing something like this. So the Swell compiler can only see width here, right? It has no idea about this height dependence inside the function because it can't peak inside of it. And then you might do something like this, area multiplied by height, and you're probably thinking, okay, if I update height here, it should work right, but you're going to be surprised that it doesn't. So let me just save this. I'm going to go here. And as you can see, it's only 100 and it doesn't update after that because the Svelte compiler has no idea about the height dependency. And this really isn't a problem with this simple code, but as code gets more complicated, now we have to learn these weird rules of reactivity in Svelte, right? And this works for example you update width but now you have to update them both at the same time and this just works by chance because you updated width because the compiler can see width here right and then it can update these dependencies so if i save this and then it should work as expected but this wasn't your intention right you only wanted this to update when you updated the value of height all right so let's look at how rune solve this so if i comment this out and then I going to comment out this section and let me just explain what we have here I also need to remove these values so now in Svelte 5 introduces runes or signals or fine-grained reactivity and this system instead of doing compile time reactivity it does run time reactivity so as your code runs Svelte is able to track dependencies so let me show you how this works So here I define a signal width and height, which I do with this dollar sign state, right? So we pass in the values, and now we can use this derived rune or signal, which is the area. Now we can pass it a function. As you can see, we didn't even have to pass it the width and height because Swell can track these dependencies at runtime. So now I have this here, multiply by height, and now we can just return the width and height. And instead of using the dollar syntax label, we use effects now. So we can do effects now. I already know what you're thinking. The Swell team hates me. Why are they doing this? I prefer doing this console log. Oh my god, this was so much simpler. But listen, this is just the alpha and these are just primitives. You can do whatever you want with this. For example, there might be a rune, which is called inspect, and then you can pass it value. And now you don't even have to know about this weird thing that you have to do dollar sign, console log, and etc. This is going to be even simpler. All right, so now this effect is going to rerun area and recalculate it, right? And here I'm using set timer, so I'm updating width and height. And now we should see that it updates after one second. So let me just save it. And now I'm going to refresh here, and you can see 100 and 400. And now things work a lot more predictably. If you're concerned that you have to learn all of these new things, you don't have to worry, because Svelte 5 is a drop-in replacement for Svelte 4. So when you upgrade to Svelte 5 in the future, everything is going to work as expected. And in the future versions of Svelte, things are going to get slowly deprecated. So basically, those are runes. Alright friends, I also mentioned fine-grained reactivity. And what is fine-grained reactivity? it's one of those terms that everyone just throws casually out like it means something, but you're just like, okay, it sounds cool. I don't know how this benefits me, right? But let me just explain it to you. It's actually really simple. These gatekeepers and academia are just trying to put you down, right? So here I have this example with to-dos. I have this remaining function here that filters the to-dos each time you update or add a to-do, and I'm console logging out recalculating. Let's actually look at this example here, so we're going to understand what talking about i'm going to clear the console so you might expect okay when we add to do's it's going to log out which makes sense it recalculates right so when we complete a to do or whatever it's also going to update what happens when we update that to do so we can update this to do and it's recalculating so it's invalidating this entire list and it's doing extra work for no reason so fine-graining activity means okay when i do update in this one spot i only want you you to update this because it doesn't make sense that you invalidate this entire list right so anything any individual to do will invalidate the entire list so that's really the opposite of fine-grained reactivity right and to make things worse everything inside this each block has to be checked for updates because of that so you're doing extra work for no reason right and this is another problem that room solves so you can have fine reactivity and i took this example from here fine grained reactivity So let look at that example I going to copy over the code so we don have to type it and save on time right So instead of defining this normal to do's, we can define a signal state. And let me just delete this line. You can also, if you're using TypeScript, pass it a type here. I'm just going to give it any array, it's really not important. And then for these values here, we need to make them reactive, right? so we can also turn them into runes or signals let me just do this i'm going to delete these lines and i'm using input element here i can just pass this and this is great all right so there's one problem if we just return these signals we can't really do it like that we have to use getters and setters and if you want to understand more how that works you can watch my previous video but it's really simple so we just need to copy over this code which looks a bit verbose but again keep in mind this is alpha there might be a wrapper or something else around this which makes it really simple to do this so now i can save this and let's see if everything is right oh let's not pass the entire element let's pass input element value so that should be it and now i'm going to refresh everything so let's see if i add we're going to see it's recalculating which makes sense right so now when i update the list this works as expected and now let's see so does our fine-grained reactivity work. So I'm going to run update. As you can see, there isn't any extra work being done. And this is what fine-grained reactivity means. And this is why Svelte 5 is going to be bonkers fast because it can optimize things so much further. All right, friends, so let's talk about events. And dispatching events or forwarding events right in Svelte is a bit strange, right? because you have this weird code and then you have something like on colon click and now this is a pain to pass down to the other components if you're working on a design system and etc but in svelte 5 events are considered regular attributes so now we can remove this colon and this works so now let me just show you also something cool if you go to this button component if you aren't familiar this props rune replaces exports you don't have to use exports right exports were also weird like it's javascript but it's not javascript right so now we can use props and now we can get everything from here so we can spread these things and let me just show you so you return an object so you get the children back and you get this attribute right so if you have a design system or something now you can just spread it like butter so you don't have to do these weird things you would have to do on click here and then you would have to pass this down which was really awkward but now it's really simple in Svelte 5. And again this older system also works you can use this if you want but now it's a lot simpler. And now if I go here and I press click we should see we get the click event. So let's talk about the last feature which I'm super excited about and it's snippets. So here I have these snippets and it looks just like a regular component right? So you might be confused what this is and let me just really explain to you snippets are trying to solve the problems you have with slots and having reusable markup in your code. Alright so you might be thinking what is wrong with slots and basically for the regular simple use slots are great but they have really some weird aspects on them like this let directive So the advanced usage for slots is a really bit bizarre So you can see here is this let prop, which you can pass up from a prop. And it's really mind bending how it works, right? It really doesn't make sense. And then there is also this weird thing, dollar dollar. What is it? I think it's slots. Yeah, dollar dollar slots. So you can check the keys of the slots. and this is really something weird maybe it's fine to if you're used to is so svelte 5 is trying to solve this problem with snippets and slots are still a part of svelte you can use them both if you want but i'm going to show you how awesome snippets are so let me just show you this so this was really a huge critique of svelte for a long time that it's not composable like react which really isn't true i mean yeah react is a lot more composable because a component is just a function but for example in react you have this example like a list an item and then thanks to closures you can do something like this. So this is really nice looking and composable. And let's see the same example using snippets. So here I just have these items defined as selected and this onSelect function which just changes the selected item. So let's see how snippet looks like. You use this new syntax hash snippet, so like in each block or those other blocks, and now you can define this snippet which are just like functions, right? So we're saying, okay, I have this li snippet, this piece of markup, right? So now you can use this in your code. If you go here, so I have this list and I'm saying each items as item. And now I can use this special at render tag to use this snippet. So this works almost exactly like the React example to make Svelte more composable. And now in the styles here, I can just target aria selected true. And that's it. And you might be thinking, okay, why would I use this? I can turn this into a component. Yeah, you can turn this into a component, but it's a pain, right? This makes it so much easier to reuse a snippet. So you can avoid that. So you don't have to create a component. You don't have to go out, create a new file, right? So you lose context. Now you have all of these files, right? And you can just make it so much simpler by using snippets. And that's basically how this works. So you can go the first snippet, then you select the last one, and so on. And that's basically it. If you want me to cover these things in detail, I would love to. so let me know. Please keep in mind that this is Alpha and the developers of Svelte aren't just trying to change things for the sake of changing things, they're trying to improve the framework. If you put things in perspective, Svelte 3 was released in 2019, right? So it's almost four to five years since there was any real updates to Svelte, right? So change often might feel intimidating, but we have to adapt and evolve. And so does Svelte. But as I said at the beginning, If you have some concerns, ideas, you love it right, you want to let the maintainers know they're going in the right direction, join the Swell discord and voice your concerns there. Alright friends, so that's it. If you like this video, don't forget to like and subscribe and you can also support me by becoming a patron. Thank you for watching and catch you in the next one. Peace. Transcription by ESO. Translation by â€”