 Hey friends, how are you doing? Welcome to learn how SvelteKit works as a framework. So let's set expectations. This isn't an introduction for beginners to SvelteKit. If you want that, I have resources for that if you want to watch it or learn how Svelte or SvelteKit works. But this is more of a deep dive in how SvelteKit works as a framework. So if you're someone that's confused, like where does your code execute on the server on the client, because I've seen a lot of this from the questions in my comments or even on places like Reddit. So this is going to be the resource for you, and we're going to go over what Svelk it is, what parts it makes. We're going to look at some technical details, but not that it's too boring, but we're not going to ignore them. So we're going to talk about that, we're going to talk about service-side rendering, client-side rendering, hydration, and etc. So I hope you're excited as I am. Let's talk about futuristic web development. I started web development at the height of the React era when single-page applications were older age. And that meant we had to recreate what browsers already knew how to do from navigation. So using the browser history with JavaScript, right? You might be familiar with this from single page applications. To handling forms, of course, event prevent default. Everyone is familiar with that. In fact, it became so common we forgot how the web works and that it already does that work for us. So we had to implement that in JavaScript to support those types of applications. This isn't me saying that's wrong or whatever, because that was really required for the time and we learned a lot from doing that. But as time moved on, progressive enhancement was pushed to the side and instead of using JavaScript to enhance the user experience, it started being required. So we can look at an example of that if I go to Twitter and if I open the developer tools and disable JavaScript, so I can press Ctrl P and then I can use the pointy boy. If I start typing JavaScript, I can disable JavaScript and now when I refresh, this is going to break because Twitter is using React. Yeah, so we can see JavaScript is not available. it's kaput. So yeah, you can do anything. It doesn't even server render to give you at least a placeholder or anything else. So yeah, you're out of luck if you're not using JavaScript. So we're under this assumption that everyone is using JavaScript. And of course JavaScript isn't bad. I love JavaScript. But the fact is that your site should work before JavaScript and not without it. So that's the philosophy that frameworks like Remix and Swellkid embraced. Also want to mention another great talk you can watch is from Rich Harris Futuristic Web Development Here he talks on the transition from Sapper to SwellKit and what the future of web development looks like So that a really great watch if you want So things are starting to change and we're seeing a shift to the server because we realized despite having a computer in our pocket, we shouldn't do everything on the client. The client meaning browser, but we say client because that can be any screen, right? Or device you're using to interface with something. The client can be anything and it's not just the browser and that's why we use that terminology. So that's really our worst user experience because of the bundle size of the JavaScript. So imagine your app that's just a single entry point like a single JavaScript index.js file. The bundle size is going to increase as your application grows larger. Of course, it's not always that case. You can use code splitting, et cetera. But yeah, having your entire logic in one place on the client, JavaScript can fail for whatever reason. If you duck under a tunnel where you're doing a request or something else, then you're screwed. So before we continue, let's explain all these esoteric concepts briefly, like server-side rendering and client-side rendering. So server-side rendering is the process of taking a request from the browser and returning a rendered version of the page as a HTML response, which is great for SEO or search engine optimization because it's easy to index by crawlers. Then you have client-side rendering, which we talked about just now, single-page applications, right? So it's the opposite where you send the browser an empty HTML document and then JavaScript can hook into some element, like, I don't know, like maybe it has an ID of app, if you're familiar with React, and then everything happens from that single element from navigation, etc. But it's really great for applications, but not for SEO. So why did we move from service-side rendering to client-side rendering? It's because we really wanted that smooth user experience. I'm not sure if you remember how Gmail, for example, was such a big deal because all of a sudden you had native app-like feel when you were using an application on the web. Instead of imagine if you're using Gmail or something and everything you navigate to has to do a full page or refresh etc that would really feel janky and awful right. And then you have a fan favorite SSG or static site generation if you're familiar with Jamstack. It's similar to server-side rendering so static site generation is almost the same as server-side rendering but the only difference is where your build time happens, right? So instead of building a page on demand when you visit you pre the pages in advance and you can cache it forever on a CDN So for example you ship your blog to Netlify or Vercel and their CDN is going to cache it forever And then when you make a change it's going to purge everything and then cache again everything forever. And that's what's going to make your site super fast and responsive. And it's of course great for SEO because it's pre-rendered in advance. So a spa or a single page application is a general term used to describe an app that doesn't need to reload. So again, that great user experience. when you change a route and it's contained within one page where javascript handles everything using client-side rendering so people get often this confused server-side rendering and spas but actually it's server-side rendering and client-side rendering so again server-side rendering you send a request to the server and it sends you a response as a html document where everything is rendered right but with a single page application javascript hooks into a shell of a html element right and then it uses client side rendering to change the content on the page and that's why you don't get great SEO so for example if I go to here and let me just see if I can not use the print options I do this always so you can enable back javascript and let's do this we're going to refresh twitter and now look at this for so for example let's see this text let me just select it copy it. If I go view source, this shouldn't be in the source. It's going to be in line in some weird JavaScript, right? So if I do a control F search, yeah, and I can't even find that exact text. So literally you don't have server-side rendering. This is bad for search engine optimization, but something like Twitter really doesn't maybe care about SEO. But of course, maybe it would be nicer to have some progressive enhancement. So you're not out of luck if you disable JavaScript, right and then lastly you have mpas or multi-page applications you can think of something like ebay that's an e-commerce and it's the opposite of a single page application because every page has to refresh like so you can think of php and etc and for those kind of sites first response is really important to show something on the page so the person doesn't leave your site because you want them to buy something so yeah so if you were to use a spa you would have to wait a longer time for all the JavaScript to load instead of using server-side rendering where you can get that HTML document, which is faster than having to wait for a spot to load JavaScript But yeah so where does SwellKit fit in all of this spectrum So SwellKit is a full framework that gives you the best of both worlds where the page is server rendered on your first visit but when you navigate to other pages they going to be client rendered Your first page is going to be server-side rendered and after that, SwellKit is basically a single page application, right? Until you refresh the page or visit another one for the first time. And SwellKit also gives you levers for your pages to use any of these rendering methods. So you can pre-render a page if you want, you can pre-render your entire project project if you want and we're going to look into those options later and i really like this quote from the documentation the core of cell kit provides a highly configurable rendering engine because well it blurs the line between frontend and backend it might be confusing where your code runs and that's what i'm going to try to answer here so this post assumes you're this familiar with swell kit but if you're not i have an entire swell kit for beginner series and a swell for beginner series you can watch swell kit is a backend framework and you're going to hear that Celtic is a full stack framework and then some people argue semantics. It's really not full stack. You don't get a database, etc. It's really not important. The important part is that you don't think of SvelteKit as Svelte with things on top because in reality, Kit isn't built on top of Svelte, but it's a backend web framework where Svelte is used as the view layer. But in theory, you could rip out Svelte and replace it with another component framework that supports server side rendering and the same is true for other web frameworks like Remix for example. So once you start realizing that SwellKit is a replacement for something like Express and you write your front-end and back-end logic in one place you're going to have an easier time and it's going to answer your questions like okay if I'm using SwellKit do I really need a separate back-end and the answer is no. So it helps if you're familiar with HTTP request methods and if you have prior experience with backend frameworks like express, but it's not required. And I'm really not a backend person. But as I said, you can think of SvelteKit as a replacement because you don't need a separate backend. SvelteKit is where you write your frontend and backend logic. And you can read on MDN amount HTTP request methods, all the good stuff like get, head, post, put, delete, and et cetera, which is going to be really informative. So basically this is the fusion that happens when you combine kit with Svelte. So let's look at an example. So here's an example of a REST API using Express. So you can see we're importing Express here, we're initializing Express, and then here is our getHTP method is going to return a JSON response that's a message, hello, and then you're going to listen for this on port 4000, and your front-end app would

 be at something like localhost 3000, where you can consume the JSON response. So the annoying thing about this is now you're hosting your separate backend and frontend, but if you're using SwellKit, this is really one app. So let's look at an example here. Here I have just a normal Express folder, and here is the same code I copied, and nothing special here. I just installed Express as a dependencies, and I said type modules, so we can use ES modules. Yeah, and then if I open the terminal, I can go into express and then I can just say no dots. So it's going to run the index.js file and it's going to say listening on port 4000. And then if I go here, actually it's 4000, right? My bad. Yeah, so we can go here and we're going to see the JSON response. And that's really awesome. So let's see how SvelteKit makes this so much easier. So I can quit this. Then let's go one step above and then I can CD into the SvelteKit folder. And let's look at that for a second. so I can collapse the express one. I can go to SvelteKit and in here I have routes. Here is nothing special, just the default one you get when you initialize a SvelteKit project. And here is the magic sauce. So we can create the same thing if we create a message.json.js file or you don't even have to include .json. But yeah, it's really the same thing. So we have an API and then we're going to get a JSON response. So yeah, so we're in the SvelteKit folder and I'm just going to run pnpm run there because I'm using pnpm here. But yeah, now if we go to localhost 3000, we can see the default message. But now we can go to our endpoint, message JSON, and we're going to get the same thing. So I hope now you understand what role SvelteKit plays and what problems it solves a bit more. Because SvelteKit is the front end and back end, you can deploy everything as a node server if you want, or you can use something like Netlify or Vercel that serves serverless functions, which is really a nice method to host something or you just need a zip of JavaScript on the server. right? So for example, for my site, I have a newsletter. I really don't need an entire backend for that, right? I can just use a zip of a server's functions and it's really cheap to host it somewhere on Vercel. In fact, it doesn't cost me anything to host it on Vercel. But of course, you can keep your server separate if you want, and it might not be a great idea for making something like Discord. But if you need some real-time communication like WebSockets, you can create a custom server if you want using SwellKit. And I even have a post on using WebSockets with SwellKit. I not sure if I would use it in production but you can and in the future I hope SwellKit will support WebSockets natively like it has the get post and all the other HTTP request messages right So among other things, SwellKit also includes pages. So it has file-based routing, right? It has endpoints, API routes. It has nested layouts. And this is way more powerful than just nesting files. So for example, if you're familiar with Next.js, you might be familiar. So if you go to routes and then we can say some nested route index Svelte, right? And this really isn't a nested route. Of course, it's nested in the file system. But nested layouts or routes are way more powerful where your components are literally mapped to the URL. So a great example is from the Remix Marketing where we can look how this works. SvelteKit really needs a site like this. This is really an amazing site. I really love what Remix is doing with their marketing. So Remix has a cheat code, nested routes, and it's really the same as in SvelteKit or other frameworks that have nested routes. So you can see how all of these components map to the URL if you look at it here. So here we're at the sales invoices and then we can see here is the sales. So it maps to the sales URL and then it's invoices and then it goes to the specific invoice, right? And how amazing is this? This means that, for example, if this goes boom boom for whatever reason, instead of your entire app crashing and burning, only this is going to fail and you're going to get a nice user error message, right? And this is really awesome. So thanks to Vite, we also get hot module replacement. So that means instant updates in the browser when you make a change and it preserves your application state. So for example, when you make a change to your CSS, it knows, hey, only the CSS changed, I can update this immediately. or if you update a JavaScript file or whatever Svelte component, it's going to be like, hey, only this part changed. Let me update this. And this is really an awesome development experience. You also get preprocessing for TypeScript, SCSS, and Pug, among others. So this is in your Svelte config when you scaffold it by default. So if we go to the Svelte config, for example, just close this and close the sidebar. Here we got the adapter auto for the specific target environment. We're going to talk more about adapters later. And also Svelte lets you build component libraries so you can have a monorepo setup and then you can easily create and publish NPM packages. And of course, I already mentioned it, you have deployment options which are adapters for any platform. SwellKit uses the web platform What does that really mean You might have heard of this for SvelteKit Remix and etc And everyone throws that term around like it means something but what is it right Let first start by saying that SvelteKit is a machine that takes your code as input and output code as you make a change. And you can find a generated server and client code in the .svelteKit folder, which we're going to look in the next section when we scaffold SvelteKit from scratch. But basically, SvelteKit like Remix is a compiler. And my favorite quote that describes SvelteKit comes from the SvelteKit documentation. Fundamentally, a SvelteKit app is a machine for turning a request into a response. And if you're not familiar with this, this might be like whatever, but I'm going to show you what that exactly means. So SvelteKit leverages the web platform and uses the regular request and response objects of the fetch API. So it works in any JavaScript runtime that's not a browser and uses adapters to output the code for the deployment target. So if we look here, here is the request interface of the Fetch API, and you can read about this more if you want to learn it. And here is also the response interface of the Fetch API. But yeah, this is really an interesting read. So let me just close this too. So let's look at an example, right? So here I have an example of a simple request object and fetching the data. So we're going to talk to the Pokemon API, we're going to get a list of Pokemon. So of course, you may be used to it it's way easier just doing a fetch and fetching the pokemon api right but here i'm going to show you how you can use a request object so we're making a new request const request then we say new request using the web platform right how awesome is this and this is basically what swellkit is doing under the hood and all these frameworks and then you can specify other properties which you can read from documentation and we're going to console log the request out where we're going to get a response like this. And here we're using normally fetch. But yeah, let's look at an example. Here is a code pane. I just copy pasted this code. So here we have the new request. And then I'm going to console log the request itself. And here we fetch the request. We turn it into a JSON. And then it's going to return an object that has results where the Pokemon are. So if I uncomment console log request, just so we can see the request. And we're going to also see the fetch. So this is a request itself that we created, right? So you can see it has a lot of properties and even more you can read, of course, when the documentation is before. But yeah, this is just the request. And here is the response we get. So we get a list of Pokemon and how wonderful this is So let look at the SvelteKit version of this So if we go to the SvelteKit endpoint I made so here is source routes again I created a Pokemon.json route. Let me just collapse the sidebar. And it's the same here. So we're just doing a fetch for Pokemon, and then we await it, and then return the Pokemon. So if I open the terminal, and I can say pnpm run dev, and we can go to the URL. so if I go to here I can say Pokemon JSON and then you're going to get the Pokemon and how awesome is this and I also console logged out the request and you can see here if you remember here is the request that we received and if you look at here is the same thing proving that SwellKit uses the web platform and this is what it really means that it uses the web platform because it uses web APIs and etc and not some proprietary abstraction on top of it we should embrace the web platform and it makes it easier to work and collaborate and things right to understand how swell kit works you're going to set a cell kit from scratch and it only takes a couple of steps and it's surprisingly easy but it's going to help us understand how swell kit works so inside an empty folder i'm going to create a handcrafted package json file and specify we're using ecma script modules which is the official format to package javascript code for reuse and we're also going to include some scripts to it interestingly enough when i was starting to record this there was a breaking change because SvelteKit split the SvelteKit and Vite configuration file so that was fun but yeah I just wanted to show you that it really doesn't matter how things change that it's all going to work the same and yeah it's going to be very interesting going over it so yeah let me just open the sidebar and we're going to create a package soon and then we're going to just copy and paste over the script. So we have a types module and Vite is going to be in charge of the development, building and previewing. So now we only need a couple of packages. We're going to npm install or in my case I'm going to use pnpm. But yeah, if I open my terminal, I can say pnpmd and it's already like I've done this before. Yeah, so we can just install this and yeah, that should take a second. And this is all namespaced under the Svelte.js organization on GitHub, so kit and Svelte. If we go to the repository here is Svelte. So here is a Svelte package and here is kit. And we're going to see how kit also works because if you go here and maybe, let me just bump this side up. Maybe if you're not familiar

 with monorepos basically instead of having different repositories for packages everything that makes swellkit work is going to be inside the packages folder so if you ever browse a repository github see a packages folder it's a good indicator it's using a monorepo because i think this is using pnpm and if you go here to the workspaces you can see how it sets up the workspaces so this is like if you install the package from npm so you can use that path and etc which is really handy yeah but if we go to packages we can see from kit here the adapters which we're going to talk about this is a google thing i think amp creates wealth is the cli for creating new sweat application and then you have kit and other thing that pertains to it so if you go to the source we can see core node packaging the runtime utils wheat itself which is responsible for the development server another thing worth noting it so what really happens when you run a command like npm run dev so it runs with dev but what exactly is with or before it was well dash kit so let me just close this and if we go to our node modules we can see under bin are the binaries so this is going to be confusing to you when i open it this is just a bash script and it's really not important even understanding how this works because i for example don't understand bash but i can get a general idea what this is trying to do so this is trying to find the starting point of the application or the endpoint which is going to be in kit's case svelte.js so if we go for example to node modules where svelte.js is you can see kit is here i think if we go let's see yeah it's going to be in this but actually the svelte.js file is here we just import the cli so if we look at this repository here is a cli and this was previously in charge of everything from the development server, et cetera, it used Vite still, but now it splits. So now this is only in charge of creating packages and the synchronization of generated files, which is interesting. But for example, if we go to Vite, we can see it's the same thing. It just looks for the entry point. So we can find it in bin. Let me just collapse it so it sounds confusing. Yeah, but again, we can just go under Vite and now it's in bin. So here is with JS and now we can see it's already here and here it imports the start So again very similar It does it from this node CLI So if we go here node CLI and if I search for dev yeah start the development server So this is really what gets output in your terminal. But yeah, let me just close everything before I spook you. Yeah, so that's really what gets executed when you run a command like this. It just finds some binary and does whatever else. We're going to need a couple of files to make SvelteKit work. So let me just close package.json because I don't think we need it anymore. And I'm going to collapse this. So we're going to add a ViteConfig.js, which is a place to add your Vite plugins and configuration. So I can just copy over the config, save it. Then we're going to add the Svelte config. And then I'm going to copy that over. And we don't even have to specify anything finished. So if we go here to wheat, we can see it imports the SvelteKit plugin. And yeah, so here we don't really have to specify here, but here you can include your preprocessors. For example, if you include the preprocessor, you get support for TypeScript, SCSS, Pug, and et cetera. But we're going to leave it blank until we get to learning about adapters. That's really it. So now we're going to have to create a source folder. So let's create source. And then we can create app.html. which is our entry point, which Svelte uses as a template, or SvelteKit, I should say. Yeah, but that's going to be it. And I'm always amazed how, even after we did this crime of this markup, the browsers are able to build a proper document out of this and output it. But yeah, I was lazy, so I just did it like this. But yeah, don't tell anyone, of course. So we're going to add a route, and of course, that's under routes. You have to do a folder structure like this, because SvelteKit is going to look for these files. Yeah, so we can say index Svelte and then we can save home and everything should work now. Now we have a general idea of what happens when we run the development command. So let's see if everything works. If I clear the terminal, if I run pnpm run dev, everything should work just fine. So we can see that Vite dev server is running at 3000 and we can just open it here. Local host 3000 and we should get our homepage. And that's it. That's how simple it is to set up SvelteKit. So let's examine the generated output further. So SvelteKit is basically a compiler that takes your app as the input and creates the output So when you start the development server SwellKit is going to generate a folder that contains a couple of interesting things and it gets regenerated every time you make a change. So let me prove this to you and if I run pnpm run dev, it's going to generate the SwellKit folder and here it is. So inside we can see it has a generated folder that has the client manifest which holds all your routes. If you see here is the layout, error and svelte route. and this dictionary is interesting because I think it also maps the component to a and b component where a is the layout or whatever and b is your page and then it also looks for a shadow endpoint but it's really not important so another interesting one is the matchers so if you're unfamiliar with matchers if you have a route like routes archive where you pass a number for a page you can make sure that this value is an integer by creating a custom matcher so someone can't pass in for example archive potato which would be valid and you really don't want that but yeah it's really interesting and then you also have a root.swelt which is your entry point and we're going to look at that in a second so let me just close the matchers and I'm going to leave that open for the runtime you have your app where is the environment the navigation the paths and stores itself and then you have the client singleton this just makes sure that only one instance of the Svelte client is running and I can close this and you have components here is your error and layout page really nothing special here and so you can close this and here is the server itself and basically this is just copied from node modules if we go to Svelte actually Svelte.js kit and then if you go to assets basically this is just copy paste it over so really it's nothing special let me just collapse this but another interesting thing i want to talk about is the root.svelte but basically the root.svelte file is interesting because it takes the routes from client manifest js that are treated as components and besides initializing some page values it's in charge of displaying the components so for example if you look at the client manifest it's an array so you would probably think that this is index zero which is correct right and then you would probably think that this is index one and of course this will be index two but really that's not how it works. If you have an error the error is the component is going to get rendered so this won exist and this is going to be index one but if you don have an error then everything is fine it won even get loaded and only you going to have your page you always going to have index zero and one etc yeah so let me just remove this i going to remove these values and this is going to make a lot more sense when we log out the values let me just close the documentation here and if we have our development server running we can go to the root swelt and this is always a fun thing you can do just don't be afraid to go into these files and folders poke and prod around right we can just console log all these values and this is going to get removed when it gets regenerated yes so we can say components so we're looking at these components let me just reiterate how this works so it's going to return proxy objects but as you see here if it has a component so it says hey if there's a page then we're going to wrap everything inside the layout and it's going to get nested and more deeper this pyramid that gets generated because if you have more named layouts and etc and here is even the announcer one if we go for example to our page if i refresh and if i inspect the element we can see that this is basically what gets generated so this is the most important part the root.swealth which is the entry point so this is responsible for rendering your components to the page but basically how it works is i made a simplified version here so if page then it wraps everything inside the layout then it gets deeper if page inside is a named layout then it wraps it inside the named layout and the page and yeah etc but yeah if we log it out here and if we go to the console I always like to refresh for good measure we can see what this page has so we can see this is a proxy layout component as I mentioned keep in mind how is zero index and this is one and as I told you this is going to be layout index and if you have some error on the page so let me for example go to index svelte and inside of here i'm going to wonder is going to work in regular script through i guess we can say from new error and then let's see you're just going to error route or it's going to yeah so you can go see layout and then here is the error so you see your component for the page won't get even loaded which is really interesting but yeah if if we go back to the root component and our post, if we regenerate the thing, so if we, let me just close these files because we don't really need them. So let me just also add a git ignore. I'm going to show you what I'm up to.

 ignore node modules usually the swell kit folder is also hit ignored because it's auto generated what i'm going to do is basically commit this and save it to the git history then we're going to see the difference what happens when you make a change so this is what i do in this post here but yeah we can just close it and if we go to our terminal we can stop the server i can say git init and because i'm lazy i'm going to go to the graphical user interface of vs code and we can just say source SvelteKit and we can just add everything because we really don't care. We're not going to commit this to GitHub or anything but now for example if I collapse everything and if I go to source routes if I say new file I can say some nested route index felt and this really isn't important so we can say nested and you can see here is some nested route and if we go to the kit history we have to regenerate there so you can see pinpm run dev and you can see what happens here so let me just close the terminal we added the nested out here which isn't important here are the types that get generated which is also interesting root swell gets regenerated so yeah that's whatever maybe it's going to change if you have more nested layouts or components etc but what's the most important here is the client manifest as I have it here, here is the git difference, so you can see what really changed, so it really added the nested route index Svelte, and then it updated the dictionary to include some nested route. So I hope this wasn't really that confusing, don't be really concerned about having to understand how it works exactly, but you're going to have a general idea how everything works. At the heart of Svelte Kit is a client-sized router that handles everything from intercepting links, so for example when you click on a link instead of refreshing the page it's going to behave like a single page application and it also handles file-based routing nested layers providing page and navigation stores and watching file changes to regenerate the routes as you've seen previously but if you want to learn how all of this works and even if you want to make your own client-side router you can visit lihao on youtube and he's currently doing an amazing series on writing your own client-side routing library so if that's something you're interested in give it a watch and say hi from me But what makes Sveltec truly work is Vite because it's built on top of it. But Vite is a next generation build tool made by the view creator even new and you can think of it as a replacement for bundles like Webpack and it enables a development server server rendering watching files for changes when we regenerate routes when adding a page so right have you ever thought about this how that happens you add a page and it updates it that's how it has hot module replacement so it updates your page when you make a change it supports unbundled development basically before in the webpack days every time you saved it had to bundle everything together because browsers didn't natively understand ECMAScript modules, but now they do, so we have blazing fast development speeds when we make a change because of unbundled development. But because of all the dependencies of the packages, it causes a huge waterfall, because if you can imagine A requests B and then it goes like forever, we still do optimized builds for production, and Vite uses Rollup for that, so it packages it all into one neat file, so it's really efficient, right? But if we could zoom out and see a visual representation of what makes SvelteKit we would see something like this and I'm going to show you this in XCollegeDraw. If we go here we can see how it all works. So basically these are the most important aspects I think what makes SvelteKit. So here we have VEAT which is the development server SSR and HMR so it's the server file watcher and bundler. Remember how I said that Svelte isn't something that this is just built on top of Svelte but Svelte is actually just a part of it. It's the view layer or the framework right and then it also uses chockidar to watch the changes for the packaging and the lib folder right and then we have also adapters which are plugins that generate output for target platforms and this is node which is a server then you have netlify over cell and cloudfire pages that are serverless you can also pre-render everything you have spas single page application rights and then you have other community adapters so remember how we talked about what happens when you run npm run dev and this is possible for shade because shade is just a cli helper and yes it's named after the senior so it's a smooth cli operator and basically when you run npm run dev it loads the svelte config and it also gets the wheat config and creates and starts the wheat development server but yeah if this was a crime show this would be the part where you say enhance so let's also do that for kit and see what makes it work so if we go here we can see here is kit and also you have VIT which is build development and preview and you can find all of these folders and packages as I show you previously in the SvelteKit repository You have packaging for publishing NPM packages right because with SvelteKit you can easily create your own Then you have core which is the build time and cli code then you have the runtime that includes the client and server code and the most interesting one is probably node because it includes polyfills and basically if you're not familiar what the polyfill is it basically adds code to make something work that otherwise isn't supported so for example before node didn't support natively fetch so SwellKit still uses Node Fetch to expose it as a global so you can use Fetch on the client and server so it's the same consistent experience but they're probably moving forward going to change that to use the one built into Node because it supports it as of recently but yeah it makes the web APIs available as globals the web crypto cryptography one the Fetch response request headers and it uses Node Fetch right so what's interesting is that when you think about this this all makes SvelteKit right so all of this combined is basically the Svelte.js with plugin Svelte combined with the with plugin SvelteKit plugin and this is really interesting because now they exposed it and since with has a separate config here it is but before this was something internal when I was looking at it but it's really interesting to see how it's exposed now because with has a separate config so here it is in reality but let me just close this and if I go back to the post so these parts together make sex sodia and you can see the vid plugin is used to make svelte work with weave and it passes the plugin options from the compiler options pre processor to the inspector which i might make a video on basically the inspector is awesome if you hover over a link in svelte it's going to tell you where the component is in your project and it's going to open it in your editor and again i talk about the vid plugin svelte kit because it's more interesting and at the time of writing is but need to update it because it's no longer internal but it's responsible for taking the swellkit config creating the routes server-side rendering and loading the template replacing swellkit so if we go to app basically replaces this with what you have on your page and it does also other things which is really interesting so i hope i didn't lose you so far if you confuse that's all right because right besides you trying to also understand how it works but now you have a higher level understanding of how sellkit works So let's explore how client-side rendering and server-side rendering works. Let's talk about client-side rendering. You might have to process a lot of data or want to use a huge library like GraphQL. It's even larger than React at around 160 kilobytes. So imagine if you did that on the client constantly you going to make the user pay not only for the compute but for the bandwidth when the server should do the hard work even though you have a computer in your pocket right And this is really the shift you're seeing towards the server because we started to realize, hey, maybe it's not a great idea. We're doing all of this on the client. We should move the computation to the server. And it's really not going back, but we learned a lot from the past. And what we learned, we're going to apply to the present and the future, right? so for this example I created an endpoint inside routes API that's going to talk to the Pokemon API and return a list of Pokemon so we can go to source routes and let's create an API folder and this really isn't convention I'm just using it to make it explicit that this is something that we're going to expose to the outside so anyone can consume this API endpoint including our application. Yeah, so we can create PokemonJSONJS and I'm just going to copy over the code. Yeah, this is just going to fetch a list of Pokemon. If I go here, if I copy paste it into the browser, it returns a JSON response. You're only interested in the results that gives us back the Pokemon. Now that's it and we don't really have to touch it again so we can go to index.svelte where the magic happens and previously we had this piece of code but let's just copy this over so again here it's nothing special this is going to be client side rendered and we're going to see what that means in a second but yeah it just talks to our own api and returns response as a json this is really another benefit of having your backend because we can really massage the data however we want for example let's say we had a thousand pokemon so now you're making the user on the client download that list of thousand pokemon and then you may be going to map over it, filter it, and you're like really taxing the user, right? But yeah, it's just going to fetch the Pokemon, and it's going to loop over them and display them, and let's see if I have the development server, so we can run pnpm run dev, and if you go to our homepage, we should see a list of Pokemon, and it's loading, and we can see we have all the Pokemon here, and this is really great, if we open our developer tools, everything works great, and we can see our elements here, and for example, let's say I want to make a Pokemon site and make all the sweet Pokemon dollars. I want to display all the Pokemon in a list and I want it to be server-side rendered really fast. I want to cache it and etc. And I'm like, that's really great. I'm going to have great SEO, right? But if I go to the...

 page source I'm like where is my markup what the heck is going on right and this is what it means to be client-side rendered because it isn't a document that the server sends that's complete with the pokemon response this is just a html placeholder if we go for example to the network tab and let me just refresh everything let's make it obvious and if you can see here is our html if you look at the preview there's nothing here because it's just a shell right javascript takes over this and it hooks itself to whatever element here it is to the body probably and then it creates all of these elements and takes charge but yeah that's really what client-side rendering means and now our business plan failed and we're really sad but really it's not lost because we can use server-side rendering and as i say here if you look at the network tab and the page load is going to fetch the Pokemon API JSON. So if you go here, the network tab, let me just clear everything. And I always like to disable the cache. And if I refresh it, we can see here it is somewhere Pokemon JSON. And here is our response. So the server has to do a round trip as I showed in this diagram. So here is the server and it gave us this index HTML file, right? Here it is. But now it has to go again back, talk to the server. so it has to do fetch api pokemon json and then it can do it on the client and that's what it really means to have a round trip right because it has to do all of this but using server side renderer we can get all of this data we need on the server and serve it to the user but another thing i want to mention is that some people are like oh it doesn't really matter google can execute javascript in can but you can even read this resource understanding javascript seo basics they can but it's not cheap to do because you have to open the page in a headless browser and execute javascript for millions of sites so imagine once google bots resources allow the keyword is allow a headless chromium renders the page and executes the javascript so really don't put your stock on single page applications being or having great seo right you have to rely on server-side rendering let's talk about server-side rendering because at this point you might be confused and you're like hey, didn't you say that SwellKit server-side renders every page by default before it turns into a single-page application, basically? And that true but we doing this on the client so it makes sense why it not server rendering because we fetching the data once the client loads inside the script tag right but if you want server rendering we have to somehow fetch the data before the page or the component is initialized right so how do we do that and you've probably done it before and you do that using the load function inside context module so i'm going to copy over this example so basically context module runs before your component gets initialized right so this is going to run on the server and the client because of hydration which we're going to talk about later but yeah it exposes a special fetch function and then we're going to fetch the pokemon from my api and now this is initialized and generated the html page right before our component right so we can just get the list of pokemon and we can display the pokemon if i save this and refresh we're going to see this is true and awesome we get the list of now and now we shouldn't see here a fetch request i think yeah because this happens on the server and now if you go here to the local host you just make this larger you can see instead of the shell document we get a real deal so we get the preview here are headers whatever and here is the response and now if you look here in the response here are pokemon which is really awesome and even if you go to the view page source we can see that we have now great seo because of server side rendering and we've done all the hard work on the server so we don't text the user and this is really a win but yeah let's talk about other things like for example you might be also wondering if we go to our endpoint if this only runs in node or on the server right how is this using fetch and that's because remember before SwellKit exposes globally the polyfill fetch right so it's not a problem on the server but on the client we need to import that special fetch because it also does some other magic things that makes it easier for us when working with these apis right so i really hope you understand the difference and how this works but if your page depends on data that's only used for that page let's say for example that only our home page is going to show the pokemon data and we really don't want expose our api for the entire world then you can just create a page endpoint which was previously called the shadow endpoint so you can also reduce that boilerplate you can just remove or delete this code and yeah you're going to have less code which is awesome I also want to briefly explain how context module actually works if you confused about it because it really not that spooky so let me just select here JavaScript But yeah in this example let me just copy this over So basically at the end of the day when your Svelte component compiles, and you can also think of your pages that components because that's what they are as we've seen in the manifest. But yeah, basically imagine this is your Svelte component and this entire file is basically a module, right? So you're going to have code like this where you import that component and you're going to reuse it like component one component two etc but since this file is a module and in the context of the context module right it's going to log context module only once but for these other components is going to always log out the component so the context module part is what happens in the script context module part right and the component here that we've seen this is what happens in the script tag. So if we do here, here is our script tag. I hope this makes a lot more sense how context module works and you're not going to be confused. Just remember that this runs on both the server and the client and we're going to learn why because we need to basically render it once on the server and then we need to hydrate it again on the client so we can add back interactivity like JavaScript. So instead of doing a round trip like we did using client-side rendering, using server-side rendering, we can just get everything all at once to the user. So we just hit the server, it sends us back the HTML that has all the data we need, and yeah, that's really it. Another interesting aside is what SwellKit does with the fetch response. So during server-side rendering, the response will be captured and inlined into the rendered HTML, and during hydration, the response will be read from the HTML, preventing an additional network request and here I have an example and we can look at this if we go here so if I actually we can go to the response and we can probably find it here even though it's not that pretty if you go here here we can see here is our fetch response so it returns all the data and this is going to prevent refetching and etc I'm just pretty formatted if I can yeah awesome So now we can look better at this code. And here is our JSON response, right? That basically means inlining. So what is hydration? When a user requests a page, the server sends a dry HTML page where the components are rendered as HTML. And that basically what server rendering is because for example Svelte has an internal method create SSR component that takes a component and returns the generated string of that component and that the HTML that gets returned but there's a problem you're just returning HTML so how do you get back the interactivity if you have an event handler etc and that's basically where hydration comes in and it's just a way to load the JavaScript and make the page interactable again as we can see in this diagram so you have the server and here it runs on the server the create ssr component you get the html back but then you also have to download the javascript and then you hydrate it and then you have an interactive page hydration sounds like a fancy term but it just means adding javascript back to your server-side rendered html page so it's basically like this image if you want to learn more lee hautan again has a great video explaining how hydration works if you want to look into that and this is important to understand because your page runs both on the server and client first the page has to be server side rendered on the server and sent back as html so you have to re-render it again on the client to hydrate the page so for example if we look at our let's go to index so in this load module the common question i see asked and confusion is why can't i just use my database here right and you really can't because of this right you have to run it on the server and client which makes it first unsecure if you're using some secrets you really can't use it here you have to use it inside the endpoint so if we go to our endpoint and let's pretend that our pokemon is in a database here is where you would use your secret credentials and connect to the database right and you can't do it inside the load function and we can even try it out ourselves and i think the SWEATLY documentation is a bit confusing because they make it sound like only load is this magic thing that runs on the server and client when it should be more clear that your entire page which is the module right the component that is what runs on the server and the client and we can prove this if we just go to the script we can say hello and let me open the terminal and i'm going to open local host our console so our terminal here is the server right this is a node process and here is our web terminal the console right and then let me just save this and if I refresh the page we should see hello in both places and sure enough here it is. Once you understand this everything else is going to be more clear so again let me reiterate it isn't just load that run

 on the server and the client it's your entire page because it's just one big module right and once you understand it is going to make a lot more sense and knowing this makes reading the warning from the swelky documentation on using loading start to make a lot more sense so the swelky documentation makes this point use the swelky provided fetch wrapper rather than using the native fetch and here i have an explanation because it runs on the server and you need to fetch the data to server-side render it. And it also says don't reference window, document, or any browser-specific objects, because it runs on the server where those don't exist, right? And it says don't directly reference any API keys or secret, etc., because the page gets server-side rendered, and then it needs to re-render on the client because of hydration. And we can even look at an example of how this works. Let me just close the terminal. And I already have this example in the Svelte REPL. but if you're like spooked by the selkie compiler output don't be because it's really not that bad and this is really how swell kit is a compiler and why does it need to ship a framework because it generates the javascript required to run the page and you can see all this happens inside this create fragment just creates the element then it mounts them and whatever and this works fine for the dom right and here it's also where it's a component so remember how i told you that every swell component gets turned into a class there really isn't no difference here as you can see in the options for now it's generating the DOM but remember how we said that it needs to return a string so what happens if we want to use server-side rendering and you can see this starts to look really familiar so you can see create ssr component all of this spooky scary nonsense like really doesn't matter we can just look at code like this and we can just gleam what it does right and it just basically returns a string that's the html and that's how really quote-unquote simple it is because service time rendering really isn't simple but the fact of that you just return a string yeah how does then swell kit know how to rehydrate it and here is where we can go back to the dom and you can make the dom output hydratable where swell kit is going to know what it needs to output instead of rebuilding the entire dom like using a single page application it's just going to attach what it needs back to those elements so yeah if we look at this output and if we enable hydratable then it's going to look slightly different it's going to again create the elements but it's going to claim the notes because L stands for claim because probably C was taken right so that another funny thing and then it going to mount them and then it using hydration append hydration et cetera And this is really not complicated And if you just understand like the surface level of it right we really don need to understand the internal specifically. A lot of this is going to make a lot more sense and give us confidence how it works. In the post, I've done the same thing where I went over it and yeah, this is what I went in and I cleaned up the code here. So it's much easier to read. And yeah, so let's make the same component in Svelte. So if we go to source routes, we can create counter. So let me just close this and I can just copy over this code. Yeah. And then we can go here. Say counter. Yeah. And everything should work. But for example, if we say context module, I can even remove this. this is just a snippet I have, we can say export let hydrate, we can say false, and then let's for example if I go here, you can see here is the hydrating part, so here's also interesting, just zoom in so you can see it, here is where everything starts, so it runs the start function, this initializes the client, it attaches itself to the body and etc, you can see here is hydrate, status, error, null, these are your pages, right? Forams and et cetera. But if I save hydrate false, then if I refresh this, you can see hydrate null. And if I go here, I need to refresh it. And nothing is going to happen, right? Yeah, so I can just remove this. And again, I'm going to refresh it. Let me just close this. And in the post, I really show you how you can learn how this works and debug it yourself. So for example, we can go to the sources tab in our developer tools and we can put a breakpoint on start and we can see how all of this works. So we can do that. Let me just go to the sources and let's make this more readable and awkward like this, but whatever. Yeah, we can go here and you can just plop a breakpoint on it, right? And now when we refresh the page, it's going to start here and now we can step through it. So we can go immediately to the start function and this is where the magic happens. So here is the start inside start.js, which is if we expose it, let's go see, reveal in sidebar, here it is, and of course this is in your project files you can poke around it so here is the most important things that happen the client gets created it gets initialized and then it hydrates everything and if you adventurous you can just step through it and you can just go through this We going to skip this we're going to skip over, and then when we hit hydrate, we're going to step into the function, get a surface area how that happens. So the client has a underscore hydrate option, and again, let's just go over these options. Yeah, and then you can just step over the things and see what happens so basically here is going to go over the nodes and you can really ignore this and basically what it does it like loads the javascript required to make it work and basically that's it so if you go here so it's going to a loop and remember we have two things that it needs to load needs to load the layout and it needs to load the counter.svelte itself but yeah you can just step through it if you want it's going to skip this because it's not a leaf and yeah this is where the magic happens right so we can even skip over this if you want there's a lot more but of course i leave that up to you and i also talk about this in the post if you step into the hydrant function you can see how swell kit loads the javascript modules so yeah basically it loops through the nodes the nodes are zero and two index from the client manifest again everything comes back to the client manifest it has the proxy layout in the proxy counter and it just loads them for the page but yeah again server-side rendering is a hard problem because you need to make sure what you have on the server and client matches and i'm grateful i don't have to think about it and i hope you also appreciate it more now so lastly let's demystify how adapters work so if you don't specify an adapter or use adapter auto swell kit is going to output for node if it can detect a supported production environment so first let's look at the adapter node which and we're going to import it inside SvelteConfig.js. So if I open the sidebar, let's open the SvelteConfig.js and ViteConfig.js because we're going to be using both. So first we're going to install the adapter node, development-dependent Svelte.js, adapter node, give it a second. And now we can just import it here. We can say import adapter from Svelte.js, adapter node, like this. And now we just need to specify in the kit options and adapter and yeah that's it and also inside the vidconfig we're going to give it some build options so if you want to debug your app in production you have to enable source map so you have to say true because otherwise it just some jumbled minified mess right so it not going to be accurate where your code happens or debug it right So you going to say true but I going to say false here And I'm going to disable minification because I want to be able to read the code. So I'm going to say minification false. I'm going to save this. And now let me just close this to files because we don't need it anymore. Now we can run the build, pinpm run build. And you're going to see it works because it created the build folder for production, but it also made a build and output folder in the SwellKit because you can run PNPM preview or whatever. But yeah, inside the build folder, it just closes. It is really interesting because we can find the client is here, right? So if you go here, here are assets, pages. This is our CSS, nothing special. So we have chunks here. Again, this is just some internal stuff. You don't really need to think about it. again the hydration we've seen before and you're also going to see a lot of interesting things here are pages remember a counter and this looks really exactly the same like we've seen in the svelte repel and you can even see this in the response in your network tab which is really awesome so again this really isn't any different like it's almost the same right and again if we go to the error here is our error page and it's the same for the layout right and then what's also interesting in the server we also have some chunks here are hooks and here are some really not doesn't matter what's here let's see entries here are endpoints so here is our api pokemon right and this is just a get function that gets exported and then we have some fallbacks our error page which is really similar again create ssr component and etc so this is really interesting we have our pages again creating the ssr component for our counter really the same as before so this is really interesting how all of this works right then we have the node folders where the nodes are and remember the nodes are the pages right which are like modules we also seen this in the manifest file so it's all interesting how it all comes full circle together and of course here is the entry point for the application and I think it uses Polka. Yeah, class Polka. So Polka is a micro web server. It's fast. It'll make you dance apparently if you can see it. Yeah, so it uses the Polka server by default. But yeah, let me just close this and in the post, I can close this, I go over all of this and explain these things. Oh, and yeah, I also mentioned

 how you can see these weird hashes and if you ever wonder why these weird hashes are is because imagine if you deploy this somewhere and it gets cached by a cdn and next time when you redeploy it's going to change the hash and it's going to bust the cache so it you don't get a css style forever so yeah that's the reason behind these weird file names but yeah i also show you here how you can use pre-rendering so for example if you want to pre-render our pokemon if you go to index Svelte, we can go here and we can say export let pre-render true. We can save it. And then if we run the build again, we're going to create an interesting pre-rendered folder inside build. Here is pre-rendered. Let me just close the terminal. We're going to also close this file so you can see it pre-renders the page in advance and again this is the hydration part and here is where it inlines the data so it calculated it in advance right because we're pre-rendering it so it's going to be fast and get cached by cdn and here is our pokemon api that gets the already done response so this is really interesting right and you can understand how these things work you can also go a step further of course and you can even disable hydration and disable the router for the page if you don't want to ship any javascript but yeah if you want you can even use adapter static to generate a single page application if you specify a fallback page which you can see from the documentation so it's basically this is single page application mode if you're interested in something like that so you just specify a fallback and you use adapter static and that really it but lastly i want to look at another adapter that adapter because it unusual because it using serverless functions which a lot of people don understand right so let me just for good measure nuke these two folders and we can install let's see pmi development dependencies adapter for cell we can install that inside the swell config we just collab this we can say adapter for cell and this is already done so now if i close this we can say pnpm run build and now we can see the output and this is what i've done here and yeah here is the output so let me just close this we're going to close this configuration file and this is really interesting so as i mentioned it here in the post let me just go here actually where did i mention it oh yeah here so let's imagine i was swell kid or i was a web framework author and how would i figure out how to output for these platforms and that's really an easy answer because you always start with the documentation right so for example if i'm interested in versell and how to figure it out i would go to the versell docs that are right here and here is their build output API and you can study this however you want right but let's close this and here's the quote from the build output API closely maps the versal product features in a logical and easy to understand format it is primarily targeted toward authors of web frameworks who would like to utilize all of the versal platform features such as serverless functions edge functions routing catching and etc and a lot of people are confused about what serverless exactly is And really it a server that someone else runs A lot of people make the joke like ah, it's really not serverless. You're still using servers. That's really not the point. You as the user aren't setting up your own server, right? So you don't have to set up a node server on wherever because you can just use Vercel and they're going to give you a serverless function. It spins up. You have 10 seconds, I think, of execution time. you really don't have any persistent memory etc but it's really awesome for like small tasks like that right basically this entire site runs on serverless functions when you request a post on joy of code it hits for sale it hits a serverless function it i guess it just builds the pages html and returns it and then i cache it and that's pretty much it so yeah that's what i've done here and you get this output so in the versatile build output here's the config and here are the routes and I think this is just some configuration for overrides from what I understand so it's not really important and then you have the static part which is your app again immutable and then you have your assets same as before chunks pages and really this isn't any different than what we've seen before so it's not that bad right but here is the API so it already fetched it. Here is the index. But what's interesting to us, if we just close the static folder, right? Here are the serverless functions. So this is going to basically spin an old instance or whatever for 10 seconds. And again, you can see this is just a server like before. Like it just a simple node HTTP server I think I haven really dove deep into this just wanted to demystify You can see it specified in package that it has to be common So SwellKit is like okay I need to output this code in common format so Vercel can understand it. And basically this is the folder what gets generated when you initialize your project on Vercel, right? And you really don't have to think about this. If you have the adapter auto and you just point Vercel to your repository on GitHub, it's going to do all of this like magic. Yeah, and you don't ever have to think about it. But yeah, as you can see, it's very similar to what we've seen before, only it's tailored for Vercel specifically, and it's the same for Netlify and all those other platforms. And I hope this makes it more clear how these things work. And going back to the SvelteKit quote, how SvelteKit is just a machine that turns a request into a response. So that's really interesting. Hope I didn't lose you. But more importantly, I hope reading the post didn't leave an impression like you have to understand everything or that I know everything because I don't, even after spending hours looking at the source code because it's really complicated. is basically code that outputs other code and how it pieces together is a bit hard to understand. So here's the takeaway. SwellKit is a backend framework and a compiler. You write your frontend and backend code in one place. SwellKit uses the web platform. Server-side rendering has improved performance and SEO. Pages are rendered on the server and client because of hydration. And adapters are used to deploy to different target platforms. So thank you for reading. And as always, if you made it so far, then if you found a mistake or anything you can edit the post on github if you go here on joy of code repository and you can edit it or suggest something if you found a breaking issue you can go to the appropriate issue for the post and you can submit it there and then i'm going to update it so thank you for watching and catch you in the next one