 Svelte is a language that takes your component code and turns it into efficient JavaScript code. In 2019, Svelte challenged what reactivity could be in a JavaScript framework by moving the reactivity from the component API into the language itself. Svelte 3 moves reactivity out of the component API and into the language. And if you're already a user of Svelte, this might look really familiar. So in Svelte 3, we can create a reactive value by declaring let count equals zero and then we can create at the right value by saying $colon double equals count times two and then we can use assignment for reactive updates and then double is going to update each time since count is a dependency but this is not without its problems and you might run into weird issues if you don't understand how reactivity in svelte 3 works so let's see what happens if we console.log count and double inside of the increment function you're going to see the double is out of sync and why is that well because the dollar sign colon line isn't going to run until the next dom update to make sure that all of the updates are in place and web pages are basically first person crawlers and you want that buttery smooth 60 frames per second so you want to do all of your logic at the javascript part then you want to do styles layout paint and compositing and then we can see that this is true by requesting the next animation frame in the browser, so on the next tick we're going to log count and double, and they should be in sync. And this sort of gotchas is what Svelte 5 is trying to improve on. So we can actually see how reactivity in Svelte 3 works by looking at the compiled output of $double equals count times 2. We can actually see that Svelte created this update function which has this invalidate function. You don't really have to understand how the code works, but we can actually see that for For example, if we try to move the count value inside of the double count function, our reactivity breaks because the compiler can't see the value. It can't reach inside of the function to update it. And if you look at the output, we can see that invalidate only runs once and it's never going to rerun again. To fix this issue, we can pass count as a dependency and the swell compiler is going to see it. And now the same as before, now we've created an update function with an invalidate function inside of it, which is going to rerun each time. And this is another gotcha that can get you if you don't understand how Svelte 3 works. Let talk about another gotcha Let say that you want to refactor your logic inside of a createCounter component Well count is now no longer reactive because this has no special meaning inside of a function and $colon has no special meaning also, which might surprise you. And to solve this problem, Svelte introduced stores, which are really just writable objects you can use inside of Svelte components and regular JavaScript files to have the same reactivity. So you can see we can just create a counter, we can import the writable, we can destructure subscribe update, and then we can provide an increment function and return the subscribe and increment method to create a custom store contract. And stores are great, but this is just one more thing that you have to learn and know about. And now we can use the store inside of our components. So we can subscribe for it and it returns an unsubscribe method which we can invoke inside when we unmount the component. But as you can see, this is a bit verbose that you have to do this. So Svelte introduced another syntax sugar, which is $. So we can see that we can say consCount equals createCounter, and then we can use this syntactic sugar $count, and this is going to de-sugar into the subscribe and unsubscribe method for us. But there is another gotcha that this syntax only works inside of .svelte components. So now this is another thing that you have to understand. And while none of these things are a deal breaker, things could be a lot more cleaner. Svelte introduces a new reactive system, runes. Runes are a universal, fine-grained reactive system reducing complexity and making Svelte smaller, faster and more consistent. And a rune is a letter or mark used as a mystical or magic symbol. So let's look at state in Svelte 5. Here I have a simple count and in this component this code might look familiar, I just have an increment function and I have a count here but in Svelte 5 to declare a piece of reactive state you have to use the $state rune. And next we can create a derived value double by using the $derivedRune and now you can pass an expression inside of it such as count times 2 and now this code is going to work the same as before. And the output is more predictable because Svelte uses signals under the hood. And now we can see that count and double are in sync and everything works a lot more predictably. Let's talk about side effects. Side effects are where you can run your code where you can talk to things outside of your component such as the browser API fetch for example or manipulating the DOM So here in this example we can use the rune and inside of here where we say console count, Svelte is going to see that count is a dependency of the effect, and is going to rerun each time count updates. As you can see, there are no dependency arrays. Because Svelte uses signals under the hood, everything works automatically. NFX are also a place where you can run your code when the component mounts. And you should rarely reach for effects unless you're doing one of those things. So let's look at another example. Here I have some count state and milliseconds. And inside of this effect we can see that effects rerun whenever their dependency change. Here I have const interval equals set interval and then we can see that we have count and millis here which are going to be treated as a dependency of this effect. and then we can also optionally provide a callback which is going to rerun each time before the effect updates and when the component unmounts and in this example we just have a simple interval which you're going to make slower or faster and you're going to see that it works beautifully and now we're going to see is going to be half the speed and everything works great. And now we can also save faster and return it back to baseline. And now we can see wherever these dependencies update before the effect reruns is going to run this callback and when the component unmounts is also going to run that code. But one thing that you shouldn't do with effects is using them to derive state or synchronize state. And that is why you're going to rarely reach for effects because there's simply no reason to since you have the state rune and the dollar sign derived rune. So in this example I have a count and double and you might be tempted to do something like this but don't do it. So I'm reassigning double equals count times two and now inside of increment you're going to actually run into the same problem that we've seen before. Count and double are going to be out of sync because effects always run before the next update. So you shouldn't use effects to derive values and you should instead use the dollar assigned derived rune. Beautiful. Runes are just function-like symbols that provide instructions to the Svelte compiler. For example, you might be tempted to think that these runes are functions, but they're just instructions to the Svelte compiler. As you can see there are no imports and another benefit is that they easy to type because they look like functions So when it comes to your tooling this might just as well be regular functions But as you can see we can look at the compiled output which is surprisingly simple to read So let's look at the state rune, which gets converted into a signal. So first, you're importing everything from this $import, so you can say $.source, which is basically just a signal. You can also see that the write rune gets turned into a derived signal. So this is just another signal that has count as a dependency. And we can also see that Swell differentiates between user effects and the template effects. So user effects are the effects that we define ourselves. So you can see here is console.log and this is very easy to read. This just gets the most recent value of count. And we can see here are the template effects from your template in the Swell component. We can see it uses a special function to set the text and it says the text to what it should be with the freshest value of count. And this is a huge reason why Svelte 5 is smaller, faster, and more efficient. So what is universal reactivity? Universal reactivity means that you can use the same logic inside and outside Svelte components. So here I have a simple count example, and unlike before, now we can encapsulate this logic inside of a createCounter function, and then we can return the count. But there is going to be one problem. Svelte doesn't change how JavaScript works. For example, if we try to use count inside of this component, we can initialize it by saying letCounter equals createCounter. And now when we log.count, we're going to see it's zero as expected. But now when we increment the value of count, we're going to see the next time it's zero. And that's because that's just how JavaScript works. Reactivity in this case can't magically cross the function boundary. So what we actually can do is use a getter and setter, but we can also just use a regular JavaScript function. so in this case we can say get count and we can return the count value and we can also set the count value we can accept the value and then we can set count to the new value and now in this example when we define the counter again and we say dot count is going to be zero now we're going to increment the count and then when we say dot count again is going to be one and we can actually see if we try to refactor this function into a separate file this can be a .swell.js or .swell.ts file. And now when we have this here, we can just import the createCounter from counter.swell.js or ts if you're using TypeScript. And you can see it works beautifully. Now we can say counter.count

 plus equals one to increment it and is going to update where we have counter.count. Thanks to the magic of signals. Inside a dollar sign state rune svelte wraps objects and arrays with proxies which intercept reads and writes of objects and array properties and turns them into signals. And what does this exactly mean? Well, let's look at some examples of deeply nested reactivity. If you remember this example from before, here we define a count with saying count equals dollar sign state zero and then you have to define a getter and setter. Now when we say counter.count plus equals one we're going to invoke the setter and update the count value which is going to reactively update in our template where we have counter.count. What I haven't told you is you can write this in a simpler way. So instead of having to define a getter and setter you can use deeply nested reactivity by using an object in this example. So we can turn count into counter which has an object with a count on it which is zero. And this uses a proxy under the code, so you don't have to specify a getter and setter yourself. And now everything works the same as before. And why is this actually important? Well, let's look at how you would write code if you didn't have deeply nested reactivity. In this case, I have a simple to-do example where I have this to-dos array. And let's say that we don't have deeply nested reactivity. We have to create a done and text signal. And then it wouldn't be enough just to push this if we want it to be truly reactive. we do have to specify a getter and setter for each of the fields. And this is a lot of boilerplate, so Svelte introduced deeply nested reactivity. You don't have to do any of this. This is how we do it in Svelte 5. Since we defined an array, it's already deeply reactive. And now the only thing that you have to do is push the done and text values. And under the hood, to do's is a proxy that still uses signals, and Svelte is going to turn the properties on the objects into signals. And now you can simply bind the value of the to-do text, and you can also easily bind if the to-do is done. Another benefit of nested reactivity is if you're, for example, storing your reactive value somewhere in local storage or a database, now when you return them, you don't have to runify them or do anything else when you reassign them to state they're going to be deeply reactive. Also, alternatively, you can use a class, because Svelte makes classes cool again. So if you feeling classy if you have a class here you can define a done and text fields and Svelte is automatically going to turn them into getters and setters for you So now this greatly improves the experience of using classes in Svelte 5 Let's look at some other benefits of deeply nested reactivity. Thanks to deeply nested reactivity, you don't need reactive assignments for objects and arrays. So here I have some numbers and then I'm going to calculate the total by using the right rune and I'm going to just reduce the total sum. But that's really not important. But it's important how we update this value. So in the past, if you're using an older version of Svelte, you might remember something like this. To update the value reactively, we had to reassign it, and then we would have to spread the value and then add the new value. But this is no longer the case in Svelte 5 because of deeply nested reactivity. You can just straight up use array methods like .push. So you can say numbers, .push, numbers.length, plus one, and this works as expected. Let's talk about Shared State. Because of deeply necessary activity, you can have Shared State across modules. So you can export LetPreferences equals $State and here you can have an Options object or whatever else you want. For example, I'm going to set a theme to dark and now when you update it, this is going to reflect in your components. So now we can look at Preferences.theme. If it's slight, then we're going to show one of these emojis. Svelte also provides proxied map set date and url classes which have the same api as their non-reactive counterparts and this is really cool in this example we can look at some reactive imports so here i'm importing url from svelte slash reactivity then we can actually construct a new url and then we can pass it some url and now we can bind these values to it and this works as the regular API. So now when we update host name, it's going to reactively update. And same with the path name. So this is deeply nested reactive state in Svelte 5. While there are some surface level similarities with Svelte 5's API to React, Svelte 5 is nothing like React and is more inspired by its contemporary frameworks like SolidJS and Vue. And what's really important to understand in Svelte 5 are the reactivity patterns and that runes are just reactive primitives. So you can use Deeply Nested Reactivity or a class to avoid Boilerplate but runes are just reactive primitives which can be used to make a reactivity system Let look at some of the examples Maybe you're a fan of solid. So we can create this useSignal function, pass in the initial value. We can create a valueSignal and pass in the initial value, and then we can create a read and write function, and we can return the read and write functions. And now we can use this API. We can say letCount setCount equals useSignal, which we destructured using array destructuring. And now we can use this the same as solid. And solid is actually closer to svelte because they both use signals. Maybe you're a fan of you, so you can create this function ref passing the initial value. We can create a value signal with the initial value. And now instead of returning a function inside of a tuple, we can return a getter and a setter. And now we can say let count equals ref. We can pass in the initial value and now we can use it the same as before. And of course, this is completely up to you, what do you want to use, but it's really important to understand what are runes. Runes aren't some marketing gimmicks in an attempt to rebrand signals, because as you've seen, runes are just function-like symbols that give instructions to the Svelte compiler, which then get turned into signals under the hood. Let's talk about props. In this example, I want to create a simple reusable button.svelte component. The first thing I want to do is get children, which I can do using the $props rune. Now I can destructure children from the props object and I can render them to the DOM. Another prop I want to include is a class. But a class is a reserved keyword in JavaScript, so we can just rename it. And lastly, let's also spread the other props we want to include. And this looks great to me. And now inside of our component, we can import button. We can, for example, create a count signal and then we can pass it as a child to button. This works great and let's also pass an event listener. So we can say on click and we can just increment the count. And notice another thing in Svelte 5 is that event listeners are just regular properties which mean that you can pass them easily and even spread them. Props are read only by default though unless you're explicit and make them bindable since state is deeply reactive. And this just means that you can change some state upwards in your parent from a child on accident. So let's look at an example. So here I'm importing this mouse component, and then I'm going to set the coordinates here and output it on the screen And here is the mouse component itself So we can just pass the coordinates as a prop then we can reassign the coordinates You can see because state is deeply reactive we can by accident change the state in the parent. And that is why this is read only by default. And of course, the first thing you can do, we can just pass chords as a regular prop to the mouse component. And you're going to see, we're just going to change the X and Y of the mouse in the mouse component itself. And this is great, but what if you want to bind the value in the parent and change the cores itself? Well, we can just make the cores bindable using the $BindableRune. And that's it. And now we can change mouse, we can bind the value of cores, and now it's going to work. And now we're going to see the value is going to update in both components. Beautiful. We can also set a default value for coordinates inside of bindable, so you can pass whatever you want as a fallback value if you don't pass the prop. Under the hood, Svelte uses getSet methods for props and the text if you're using a set method on a read-only prop. We can look at the output. So here is how it looks like. Components are functions, so we have this mouse function that accepts a node, and then you have this read-only property getCords which is the default and then Svelte can check, hey, if this is writable, okay, then everything is fine, otherwise it's going to throw an error with a useful message informing you that you should make it bindable if you want. Props are more simpler and more powerful than before. Let's talk about inspecting state. Being able to debug values and see how and why the change is really important during development. We've seen in a previous example that we can use an effect to log the value of count when it updates, but this is verbose. And instead of using an effect for this, you should use the $inspect rune. By default, once you pass it a signal, it's going to use console.log by default. So whenever this value updates, it's going to get logged. But you're not only limited to console.log, you can provide your own custom callback using .with. This is going to accept a type, and you can also pass it a parameter which you pass to inspect. In this example, this is count. And then you can also check what type it is. In this case, if it's type update, you can open the debugger or you can do a stack trace. That is completely up to you. As you can see in the next example, you can just simply pass console.trace. And another benefit of using the inspect trace

 rune in Svelte 5 is that it only works in development, so you are not going to accidentally ship it in production. And how beautiful is that, friends? Svelte 5 not only enables a better developer experience for the average developer, but also for library offers and maintainers. And that is why we're already starting to see some awesome projects in the Svelte ecosystem. So for example, here we have this awesome project rune, which has a bunch of useful utility functions for Svelte 5. Here we can look at this watch utility, which watches for changes and runs a callback. And we didn't talk about some more advanced aspects of effects, because they're really not important for this video, but for example, Svelte provides an untracked function, allowing you to specify that the dependency shouldn't be tracked. And this watch utility, basically, you just pass a signal in, and then when that signal updates, it can run some callback for you. And this is all possible, because Svelte 5 is smaller, faster, easier to use, and more capable than before. about what this means for people who are already maintaining sizable Svelte codebases. We've spent a lot of time converting existing apps and libraries to see how it feels, and it really does feel good. Thank you for watching.