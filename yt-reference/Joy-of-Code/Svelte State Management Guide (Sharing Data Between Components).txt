 Hey friends, welcome to Svelte State Management. Today we're going to learn about tools to manage complexity and learn how to manage state in Svelte and ways you can communicate between components. You're going to learn about passing props, bindings, component events, stores, the context API, and when you might use them instead of being a prescription. So you can find examples on GitHub, or if you want to play around and follow along, you can open it on StackBlitz, which is really awesome. It should take a second. But yeah, let's get into it. So let's talk about component props. By default, the data in your app flows down from parent to child component like a river. And you can collocate or lift state up to the parent component that's going to pass the props to children. As you can see in this image here is our app. Then we have the parent component that shares the common state between these child components. And then you can just pass the props and the data flows top to bottom. As you can see in this example, I have a simple count value. I have increment and decrement methods. And now we need to somehow make this work. If we look at the count component, it just accepts the count. The increment component accepts the increment method. And it's the same for the decrement component. But yeah, if I go here and if I open the props example, we can see that right now it's undefined. So how do we solve this problem? We can simply pass it what it requires. We can say increment, we can say count. And this is just shorthand for this. If the value has the same name as well, this works just the same. And then we can also pass it the decrement. and now we can save this and it should work. So if we go here we can increment the value and everything works great. This really isn't anything to write home about because it's just a basic example right and I also want to stress that this is a contrived example and you should only split your code into components when it becomes hard to manage because hasty abstractions can shoot you in the foot. But yeah this is really an awesome talk by Ken C. Dodds if you've never seen it which I highly recommend. If you're unfamiliar with TypeScript that's all right and And if types spook you, you can just ignore them because they're optional. Valid JavaScript is valid TypeScript, so you don't have to think about it. And if this is confusing to you, you just need to try it out and practice it, right? And then it's going to make a lot more sense. So yeah, don't just watch, but try what you see, and that way you can learn a lot. So let's talk about bindings. If you had to pass input from one component to another and update it to any changes, your code might look like this. So you would have to create an update input method that gets the event, and now you need to update the input by giving it the event target value and this would work and you might be already familiar with it from other frameworks but I mentioned how data flows down but we can use the bind property directive to let it flow the other way so if you look at this image here is the parent component again it has the common state right which is the input among these two components and then we can communicate both ways between the child and parent using the bind directive and the data flow goes to waste. So in Svelte you can bind values to properties of DOM elements but also to component props meaning your child component can talk to the parent component. So if you look at the input component here we bind the value of input here and the element component is nothing special right but currently if we look here and go to bindings it doesn't work so you can simply bind the value by saying bind input and now the bind input that's importing this component is going to be bound to the input value and we can avoid all of that boilerplate which is awesome. One thing I want to mention is that with great power comes great responsibility so be careful to not abuse bind because it's going to be hard to keep track of your state and what changed it the more you pass it around so use it sparingly. Let's talk about component events. Component events are another way to send data upstream based on the custom event API. And you can try this example in your developer tool. So if I open developer tools, you can just create a custom event message that has a detail hello. And now we can add an event listener to the window. That's the message. And then we can alert the event detail from the custom event. So if I press enter, we're going to see it, which is awesome. And this works the same in Svelte. So if you look at this example, in Svelte, you can dispatch the custom event from a child component and listen for it in the parent component. So here we have the parent component as the listener, again the common state, and then we can fire an event from the children, and then the data flows in two directions. But one difference is that the events don't bubble like the regular DOM events, so it means that it's a bit harder if you have a lot of nested elements because you have to pass them along to the other components. So in this example I just really have a simple area here and want to track the x and y coordinates of the mouse, and here I have a simple component where import the mouse, we track the X and Y position, we update the position here, here the target element and we want to subtract the element left and element top so we only get to read inside this area so how can we do this so if i look at the example here we can first define the event inside the child so inside mouse.swelt we can import create event dispatcher and then we can create const dispatch create event dispatcher and that's basically it so now we can dispatch any event we want and the parent is going to listen to it so we can say dispatch update position this can be anything you want and i also want to pass the event so i can get the coordinates and here i just listen to mouse move so i can save this and now if we go to the parent as I have it in this code here is the mouse and now we can say on update position so that's the custom event we're going to listen to and then we're just going to trigger update position and now if I save it and go to the example everything should work so this is really awesome and yeah as I mentioned it here component events are awesome but they don't bubble like regular DOM events so you have to forward them but you can do whatever you want like having an on submit on your form component or whatever else you can dream up like for example on register on login or whatever and in Svelte you can also forward DOM events so if you have a button component that's on click handle click inside the component you can use button and you can just say on click to forward it but yeah that's pretty much it let's talk about one of my favorite features of Svelte which are Svelte stores stores are just objects you can subscribe to and be notified whenever the store values changes and they're great if you have a global state as sometimes you have values that need to be accessed by multiple unrelated components. So you can see in this image here is our global state that represents the entire app right so if we define something in a store like count then every component can have access to it regardless where it is right. So let's start with the most basic example here and I'm excited to show you how you can make a a simple toast notification system right here. But if you're unfamiliar with stores, here's just a basic example. So basically we import a writable from Swell store, and then we can set account to be a writable zero, and then we can use it on a button on click, we can increment it, and this magic syntax is a Swell convenience that subscribes and unsubscribes to the store for you, saving you from writing extra code. And this is basically it. So you would literally store this inside another file, And then anywhere you import count, it would be updated. But yeah, that's a really boring example. So I want to show you something awesome, how simple it is to make a custom Toast notification system. So inside of here, I have a simple entry point where we import Toast from Toast Svelte. And the Toast is just responsible for looping over the notifications and displaying them. It has some animations, which looks fancy, but it's really nothing special. And then we're going to import the Toast from notifications, which are going to create the store right now. And then the idea is when you click on a button, it's going to display the toast. And in the future, you can customize this in more ways. You can specify the type of the notification. You can specify the duration or whatever else you might want. So let me show you how simple this is to do using a Svelte Store as I have the code in this example. So we can do it together. We can import a writable from Svelte Store. And then we can import it. We can export const notifications. Then we can create a writable. And we can just set the default as an array. And this is just TypeScript. This looks confusing. So we're just saying that the values inside are an array of strings, which they are right. And then it's simple as creating an export function toast. We're just going to receive the message right. But this can be more complicated, like an object. So we're going to add a notification. And the way we can do it is we can say notifications. so this is a method of the store we can say update and we really can't use the syntax the magic dollar sign because you can only use this inside swell components so that magic or convenience isn't available to us here and this is the methods we would usually have to use if this syntax didn't exist right which is why swell it's so awesome but yeah now we can do this since we're inside the regular javascript or typescript file we can say update and then we get the state back and then we can just put the message on the top and we can spread the old state and that's pretty much it and now we have to remove this message hard-coded to two seconds we can set timeout remove toast we can say two seconds so now we can create a remove toast function and then again we can say notifications update we get the state and then we can remove the last one We can say shift and then we just need to always return state Actually, not inside shift, right? State. And this is pretty much it. We made a custom toast notification system that you can customize and expand on however you want. But let's look, if we look here, we just import the toast. So this is responsible for showing the notifications. and then we import the toast from notifications. So we just have toast here. And again, here it is, toast, where we pass a message. And here is how it works. So let's go here to the example. If we go to stores, now when I press show notification, it should show up here. And let's see the moment of truth. How awesome is this? And it should disappear after two seconds. Imagine if you send error notifications or success messages and et cetera, and you can just tag them like this and they're going to disappear after two seconds. How awesome is this? Let's talk about one of my other favorite features of Svelte, which is the Context API. The Context API is useful when you have nested components that share state to avoid passing the same props around. That's also known as prop drilling, but also sharing logic. So as you can see in this image, we have an app and here we have a parent component, which we can set the context in and in the children, we can get the context. And you can see the context is all around this, so you don't have to pass props, method, and etc. And for reactive values, use context API plus stores, right? This is a simple example, right? And I'm going to show you where this is more useful right now in this example, but usually you really don't want to abuse context for simple components unless they're nested and you have really this problem that context solves. But in this example, my goal is, for example, I want to use canvas, and I just want to draw a circle in the middle. and let's say for example that I dreamed up this API of canvas to be more declarative so I want to write something like this as you can see on the left canvas circle which is the equivalent of writing this imperative code so how much nicer would it be to do something like this but there's a problem with this approach we would have to pass the reference to the canvas in every component so example if you have more components box text etc now we would have to pass these props all around So how do we solve this problem? Easy, we can solve this problem using the Context API. So this is where the Context API can help us because instead of passing the reference around, we can define the context inside the parent canvas component and the children components like circle, which we can access the context. So if I go to the canvas component, we can see here I have the reference to the canvas by using the bind directive this to the canvas. So now we just need to pass this somehow to the children, right? and we can do this in the parent. So here's the component we've seen before but now in the canvas Svelte component we can just go to the top and we can say import. So we need to set the context from Svelte and this is really a similar API to React if you're familiar with that. So we can say set context. Now we can give it the key canvas so we know how to get it and now we can just specify a method so we can get the reference. this is going to be a getCanvas method which is going to return the canvas reference. So it's going to return this and now all of our children are going to have the reference to the canvas. So now we can save this and as I show you in this example now we can use it. So we can import getContext and now we can say const getCanvas. We can destructure it easily. We can say getContext and remember the key previously we had. Now it's getContextCanvas and now we just need to use it. So inside this onMount we can just create constCanvas and we can say getCanvas and also because TypeScript is mad we can just say hey this is HTML canvas element and now inside the child we have a reference and this declarative API is much nicer because we just define all the properties x, y, radius, start, angle, etc. And now we have the reference to the canvas and we can just use it as is and now if I go to example here a circle should be in the middle if I go to the context API and it is and how awesome is this and I also want to mention that if you want reactive values you can pass a store to a context so it's only available to that component and its descendants so in this example I'm importing set context from Svelte I'm importing writable from the Svelte store and then I'm going to declare a value that's a writable set at zero and the value is now reactive when you pass it to context. So you have the key and the value. The context API is powerful, but don't treat it as a solution for everything and use other methods like props, bindings, and event until you need it. So let's talk about module context. And before I confuse you this has nothing to do with the context API but refers to the script context module in your swell component so far we have covered things that you going to use most of the time but this is more of a bonus so i can just show you and you're aware of this if you ever need it so module context is useful when you want to share state between multiple component instances so for example let's say you have one component and then you invoke it you for example have hello world then you're going to get hello world hello world etc for all of this but if you have it inside the module hello world is going to get only output once and this is the module context it's literally just javascript so for example this file is a module when you create for example a component js file you console.log context module and then in swelt your components are basically classes at the end of the day so if you have a component and you console.logout component now when you import it inside an app for example, it's going to log context module once, but for every component instance it's going to log the message component. So this is how it works in Swell, because your components get turned into classes at the end of the day. I have a goofy example because this isn't something you're going to use frequently and I almost never use it, but let's say you run some banana processing plants and each time you add or remove a banana you want the data to be shared among the processing plants. Because we're inside a module context, the value isn't going to be reactive, but we can use a store instead. So here I just made inside the context module, imported the writable, and then I have a bananas that I can export and use. And really here is nothing special. We just have a method for adding bananas. So now we can change it reactively, right? And then how do we use it, right? So this is where the power is. So we can just import the production and then we can import the exported bananas. and now no matter how many instances the state is going to be shared so here I have for example production and if I go to example here module context so now if I add for example four bananas and now if I go to another component and continue adding bananas it shouldn't reset but it should just continue right because it has the shared state so one two three four and now if I want to remove those bananas we can start from the first component if we want one two three four and we can go to anything else and we can just remove the bananas. And really this is a goofy example but there's a more useful example in the Swell tutorial where they show you how this is useful if you have a lot of tracks playing on a site and you want to say hey pause all of tracks that you can loop over the tracks and pause them which is a more useful example but yeah I wanted to show you something fun but yeah now you're at least aware of it so if the need arises you're going to know when to use it. So here is another bonus one. What is the first state manager that ever existed for a page. You might not expect it, but it's the URL, of course, and you can use it for things like coupon codes or referral links, but you could also use it to preserve some state over a link. So for example, if you had a list of ascending items, you can maybe send it to someone else where it's in the descending order, you can preserve some state, and it's like really interesting, I don't see it a lot being used. But yeah, basically in this example I just have some simple list it can represent anything so it's ordered in ascending order which is really nothing special here simple component and then we just change the order but in SwellKit we can get the query params using the page store so you can say page url search params get order and if there's no order is going to be default ascending but now if we go here to the URL and if we say order so descending and now it's going to look for this and the list should be inverted right so it's going to use reverse and let's just see if this works so yeah our state works now it's four three two one and everything works the same let's summarize what we learned so far i want to avoid the famous it depends answer and that means i have to give you an opinion that doesn't represent every use case and it's more general to help you pick a solution so here is the Svelte State Management Guide. And first we start off with do you have deeply nested components that depend on some state? If the answer is yes, is the same state shared among your nested components? If the answer is yes, use the context API plus stores if you need reactive values, or if the answer is no, use stores. And if the answer for the original question was no, then the question is do you need to share state across component instances? And if the answer is yes, then use module context, and if the answer is no, use props bindings, and component events. And as I said here, I spent a lot of thought and research writing this post but I can't decide what state management method to pick for you and I hope at least you have more confidence to make an informed decision. So that's basically it. And also don't forget that if you find any mistake or you don't agree with something, you can edit the post on GitHub and I'm going to gladly have a discussion with you. But yeah, that's it. So thank you for watching and and catch you in the next one.