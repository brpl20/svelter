 I haven't been this excited about Svelte since probably the launch of Svelte 3. And over the next 15 minutes or so, I'm going to explain why that's the case and hopefully get you a little bit hyped up as well. I wasn't totally sure whether or not to do this because this is all still slightly speculative, what I'm going to show you. This isn't an official announcement from the Svelte team, although they are aware of this work and they are supporting this work. But we shouldn't take that as any guarantee of anything that's going to happen. And we certainly shouldn't take it as any guarantee of when things are going to happen. But I figured it's worthwhile talking about it for a couple of reasons. Firstly, as previously mentioned, I'm excited about it. Secondly, I think it's useful to manage expectations, particularly when a lot of you have the same questions about where the project is heading. And thirdly, some of this stuff isn't really about Svelte. It's about the future of web development more broadly. And there are some ideas out there that I want to try and help push in to the mainstream if I can. Alright, so that's the caveats out of the way. Last time I did this, I was answering some frequently asked questions about Svelte. And a lot of that video was devoted to Sapper. For those of you who aren't familiar, Sapper is a complete application framework that sits on top of Svelte. It includes server-side rendering, routing, code splitting, and so on. People often ask us, when is Sapper 1.0 coming out? And today, I can give the answer. Sapper 1.0 is coming out never. No seriously it's not coming out. There isn't going to be a Sapper 1.0. Here's the thing I really love Sapper and I think there's a lot of really great things that you can do with it and some of you have built some really amazing apps with it but I think we can do a little bit better. The pace of development has been a lot better recently thanks to Ben McCann and some other contributors. But the code base is kind of gnarly and it's hard to work with. It's tricky to add valuable features like building for serverless platforms or pre-rendering a subset of your application that is static files. And if you're new to Svelte, the very first choice that you have to make is do I use the default Svelte template or do I build a Sapper app? Which is a really confusing thing to have to answer right off the bat. And so it would be much better for everyone, users and also people giving support on Discord and Stack Overflow and places like that. If we could give you a single canonical answer, this is the officially supported way to build apps with Svelte. Meanwhile, the front-end development landscape has changed quite substantially since we started building Sapper back in 2017. And we have an opportunity now to really think deeply about what a modern development workflow looks like. And that is the stuff that I want to show you. So, demo time. So in here I've got an an empty directory and I am going to create a new Svelte application using npm init svelte at next because this isn't yet released. Hit enter and it's created some project files over here so I'm just going to quickly turn that into a git repo and install those dependencies. I would show you how long the equivalent setup would take for other frameworks, but I don't want this to be a really long video. So let's take a look at the code base. We have a source directory here, which contains an app.html. It's just a bog-standard HTML file with these little insertion points for salt to add some head tags and some stuff for the body. we've got a roots directory if you're familiar with Sapper then this will all make sense inside your roots directory you have files that determine the structure of your application in this case we have an index.svelte just the one just one page it's importing a counter from this we've got dollar components here may change I don't know but that is an alias to this components directory. Then we've got some markup and then a bunch of styles, all very standard stuff. And then inside the counter we're just doing the demo button clicky thing. Static down here we've got some some files that just get uploaded as is. We've got a favicon and a robots.txt, nothing very exciting. Package.json So this is what is being installed to make this run. Let's give this a name. Demo app. We have a couple of scripts here, Svelte dev and Svelte build. That command is coming from this thing, Svelte kit. Name might change, but we like it for now. And there's a few other things that we're going to encounter as we go through this thing. One thing you will notice, we have a snowpack config. That's because this project uses snowpack. It doesn't use rollup. Well, it does use rollup. Eventually, we'll get to that. But when you're developing, it doesn't use a bundle. It uses something called snowpack, and that's what I'm going to show you. We also have a svelte config file, which specifies a thing called an adapter. And later on, I'll explain what an adapter is. Okay, so that's the structure of the project. Now let's start the development server and see what that looks like. So down here in the terminal, I gonna type npm run dev dash dash open And you see it basically instant So we now have the development server running on localhost 3000 and if I start making changes to this counter component like I'll change what's inside the button then you'll see it hot reloads and and we get those changes almost instantly. We can change the state and the state will be preserved as we're making changes. So I could, I don't know, change the font family to chalkboard. I could make it a little bit bigger and it's just going to preserve the state the whole time because we now have really good hot module reloading courtesy of Rick so who's been working really hard on this and has done an incredible job and we can even do things like this with the clicks count is getting a little bit high here so I'm going to change this to a decrement function and get that down a little bit so far our app only has one page let's add another one we'll begin by creating a navigation component inside the components directory here it will create nav.svelte a very simple just a nav element with a href equals slash for the root and then another one for the about page that we're going to create and then on the index page we will import the nav component and then just add it to the top of the page like so and here we've got our home and about I think actually it'll look better inside that main block. Here we go. But now if I go to the about page we're gonna get a 404 obviously because we haven't created that page yet. So let's create a new route about slash index dot svelte and it's created that already about this page. Looks a bit ugly though. It doesn't have the same styles as the index page. We could just duplicate everything from the index page but we're not going to want to do that for every new page that we had. So we'll solve this with a layout component which if you've used SAPA you'll be familiar with. Layout.svelte just controls, it's like a wrapper around the content and all we need to do is create a slot for the content to come through like so. But I think what I'm going to do is I'm just going to copy everything over from the index page, put it in the layout and then up here get rid of the content and replace it with a slot like so. Count has been grayed out because we're not using it, so I'm just going to get rid of that. Also, we're getting some unused CSS messages here, so we can get rid of those as well. Okay, now we have a layout for our About page. On the Index page, we don't want the layout inside the layout, so I'm going to get rid of everything except the content. Again, we can get rid of that unused component and we've got some more unused CSS here. So we're just going to get rid of that. And actually this root CSS is unused too. Okay, so now we can go between the homepage and the about page. And if you look here, you see this little reload icon. If it was doing a normal or conventional full page reload, then you would see that reload icon spin. but because we're doing purely client-side navigation, it's instant and you don't get that reload icon. Having said that, this is all server-rendered. So you can go to any of these pages and I can show you by going to view source that it does actually have the content of the page in the HTML that gets delivered to the client when you first go there. So you get the best of both worlds. You get a very fast startup with the static HTML, but then you get instant navigation client side because the client side router has kicked in. Now a cool thing about Snowpack is that if I make a compile error somewhere on here, like say I forget to close my tag correctly and I save that, then I get this really nice overlay. I get instantaneous feedback that something is wrong and it shows me where the error is so that I can know how to fix it. Fix that, save and the overlay just vanishes. So Snowpack is obviously incredibly fast and you might be thinking, well it's a very small site, of course it's going to be fast, you've only got two pages, but the way that it's designed it will continue to be that fast even if you have a huge site with hundreds of pages and thousands of components. And it's worth taking a moment to understand why Snowpack is so fast and why this represents such what I think is an important change in web development. So for the last few years we've been using bundlers, things like Webpack and Rollup and more recently Parcel. And the way that they work is they take your source code and they trace the dependency graph through the modules, like through the import statements that you have in your modules, and they combine them into a file that can then get loaded in the browser and run as a script. And that was necessary for a long time because browsers didn support modules natively But nowadays browsers do support modules So instead of bundling your files Snowpack just transforms them So if you have TypeScript it turn it to JavaScript If you have a Svelte file, it will run it through the Svelte compiler and turn it into a JavaScript module. But it won't stitch them together. It'll just rely on the browser's native import to fetch the rest of the modules in your dependency graph. And so because of that, it doesn't even need to transform everything immediately. It just waits for the browser to actually request files and then it transforms them on demand. And so if you have thousands of modules but you're only looking at a few of them on the page that you're currently developing, then you only need to transform the ones that you're currently interested in. And then when you make a change to one of those files, previously a bundler having created the bundle in the first place, it now has to re-bundle it. And even if it's got really good caching is going to have to do a bunch of extra work to create a new bundle to represent the one file inside that bundle that has changed. Snowpack doesn't need to do any of that. It can just say, here's the new file, please load this Mr. Browser, and the browser fetches the module, replaces the module that already existed if you've got hot module replacement working, and that's it and so because transforming a single module is generally pretty fast your reload speeds are much much quicker than any bundler could ever hope to be and so I think we're going to get to a point pretty soon where projects that use bundlers during development are going to seem a little bit antiquated looking at you other frameworks now you do still need a bundle for production snowpack just does this one-to-one transformation and it's still not good to have hundreds of small modules zipping across the network you want to try and turn those into a bunch of coarse grain code split chunks which is what we've been doing for the last few years anyway and it's what happens in svelte now in svelte kit and I'm going to show you what that looks like. But first, I just want to take a moment to shout out to the Snowpack team, in particular Fred Schott, who is the genius behind this whole project. Fred's been incredibly helpful to us as we try and figure out how to make Snowpack work for a server-side rendering framework and it's been a really productive partnership. So thank you, Fred. So here's what it looks like to build one of these projects. I'm going to type npm run build. And you'll see it happens in three phases. First, we create what we call an unoptimized build. And this is just running all of the modules in the entire application through Snowpack. And that, as explained, it does one-to-one transformations. And it'll spit out this unoptimized version of client and a server version of the app with all of your modules just sitting around here. So this is the server-side rendering version of the counter component, for example. And then in phase two, we optimize the output of that by running it through rollup. And the end result of that is a group of chunks representing the roots of your app plus anything that's shared between them. Plus a manifest which is going to be useful later and various other bits of information. It also has some special CSS handling. And then finally we generate the app using what's called an adapter. And the adapter, as I showed you before, is specified in svelteconfig.js. And it's currently set up to use something called adapter node, which if you're familiar with SAPA is basically the same as you would get from running SAPA build. But for this site, we don't really need a node server because we can just create static pages for everything. So I'm going to change that to adapter static. We're going to install that. And then we're going to rerun npm run build. And it'll do the same thing again, unoptimized build. Then it'll run it through rollup. and then it passes it to, oh, hang on, I actually need to save the config file, otherwise this isn't going to work. And then it'll pass it to adapt to static. And you'll see that now we've got 200 responses for slash and slash about, the two pages in our application. And if we look at the build output, we've got an index page, which contains our hello world. and we've got an about page which contains about this page. One big difference between what just happened and what happens when you run Sapper Export, for those of you familiar with Sapper Export, is that rather than building a node server, running the node server, and then crawling the output of that node server, it's just doing everything with the Svelte SSR API directly, the server rendering API. And what that means is it's very fast, very efficient. So you will be able to statically render sites with huge amounts of content very quickly with this new setup. Now with Sapper you have to choose. You either get a node server that dynamically renders everything, regardless of whether you have pages that stay the same forever, or you statically render everything which doesn work if you have any pages with changing data or personalized content or anything like that But with this new system we can have hybrid apps just like recent versions of Next you can have some pages that are dynamically rendered and some that are pre-rendered. So I'm going to take you to the Hacker News Svelte implementation and show you what that looks like in practice. So this is Svelte Hacker News running on localhost and all these pages are dynamically rendered using fresh data from api.hnpwa.com and you know we can click around here and it's it's actually fetching data direct from that API it's not even hitting our own server at this point but then if we go over to the about page there's nothing dynamic on it it's just static data. So what we want is to dynamically render all of these pages, but then statically pre-render the about page so that we never need to do any computation when someone requests it. We need to have some way though of identifying which pages are suitable for pre-rendering because it's difficult to tell automatically. There needs to be some explicit signal that you, the developer, provide to say this page is one that should be pre-rendered, this one is one that should be dynamically rendered. And the way that this works, obviously this is all subject to change, but currently if you have a page that exports this prerender equals true value, then that is a signal to Svelte that this page can be statically pre-rendered. Okay, so let's build this app. Shut the development server, npm run build again, and it does the same thing, unoptimized build, optimizing, and this time when it generates the app we see pre-rendering static pages and it's found the about page that we marked as pre-renderable. And if we actually look at the build output up here, build, pre-rendered, there's an about page that's already been generated with the about this site corresponding to what we see over here. And so now if you actually run this app with node build, then when we serve that page, it's not having to do any rendering, it's literally just serving a static file. This is a Node app, but we can also have adapters for cloud function based services. So for example, if you want to deploy your site to Netlify, it will split out the static assets from the cloud functions that dynamically render pages and it will deploy those together. When we launch this thing, we'll have adapters for all of the major services. the whole serverless thing it's a pretty good trend and Svelte is now a serverless first framework yay so this really just scratches the surface of what we can do in this new world one interesting thing I think we could do now is we could use this same template for component libraries as we do for sites and apps which I think will be a really nice development experience You probably have some questions though. So, will I be able to migrate my existing sites and apps? Won't be completely automatic, but it should be reasonably straightforward. The project structure is pretty much the same and most of the ideas from SAPA read across. So, I'm not expecting that to be a massive headache. Do I have to use this workflow? No, absolutely not. So, this is split in framework land between things like Angular and Ember, which kind of really want to own the entire experience, even if it's technically possible to use the constituent parts by themselves. And then on the other side, you have things like React and Vue, which are really just component frameworks, and you're expected to build an app yourself, which is why things like Next and Gatsby and Remix exist. I once felt to be both of those. You can be wildly productive with this app template in a matter of seconds, but if you're a power user with specific needs that aren't met by this template for whatever reason, then those needs will continue to be met by the Svelte project. It is critically important that people are able to build their own custom integrations, plugins for things like Eleventy, or even Svelte-based frameworks like Routify and ElderJS, and that is not going to change. Will it work with TypeScript? Yes, it will. I haven't set that up yet, but absolutely it will launch with TypeScript support. How can I contribute? So we're still figuring a lot of things out right now and this work is happening in a private repo for now. So we're not set up for contributions just yet but as usual you can visit us at svelte.dev.com or pay attention to Svelte.js or Svelte Society on Twitter and you'll be kept up to date on what's going on with this. Okay, one more thing. So when I did the FAQs earlier this year, one of them was, can I give you money? And at the time, the answer was no, but maybe soon. Well, we do now have an open collective where you can contribute financially to Svelte if it's been valuable to you. We don't exactly know how the fund's going to be used. There are some costs associated with running a project like this, and those can now be offset. And it may one day put us in a position to directly fund work on specific features. So it puts us in a really healthy position. Massive, massive thanks to those of you who have already become backers without us making an official announcement It is really, truly appreciated Right, that's enough from me How about I turn this thing off?