 Hey friends! Today I'm going to show you authentication in SvelteKit using cookies, so let's not waste time and let's get started. If you want to follow along, I'm using a regular SvelteKit project with TypeScript you can set up with npm create-svelte and you can find the project files on GitHub. To set up the database I'm going to use Prisma because you can just write a schema to define the tables instead of writing raw SQL, which is awesome because I have no idea how to write SQL. I'm using SQLite for the database because it doesn't require any setup since the database is just a regular file on your system. So let's get started. You can open the terminal and this setup couldn't be easier. I'm going to open this terminal and let me just open the sidebar so you see what's happening. So in my case, I'm going to use pnpm, but if you're using npm, it's just the same. So I'm going to say prisma init data source provider SQLite and a couple of things are going to happen. Just give it a second. So it's going to create a prisma folder with the schema prisma, which is awesome. and then it's going to create an env file and it's going to populate with the connection string. Another awesome thing about Prisma is that we're using SQLite, but later when it's changed to MySQL or PostgreSQL, you can just change the connection string and you don't have to change anything else. So Prisma is really amazing. But yeah, I'm going to close the terminal for now in these files. I'm going to keep the Prisma file open and close the sidebar. And then let's just create a schema for the database. Since this isn't a Prisma tutorial, I'm trying to do my best to explain things. But yeah, let's get started. So here is just the setup for Prisma. You can ignore this. This really isn't important. So let's create the tables. And this is called models in Prisma, but it's really the same thing. So for example, we can say model user, and then we're going to give it an ID. And if you're wondering to get formatting, I'm using the Prisma extension in VS Code, so you can get that if you want. And I'm going to say that it's of type string, it's ID, and it's going to be default, and we're going to assign it a unique identifier. and then we're going to have a username which is also going to be a string. It's going to be unique and this is the most important part. So we're going to have a password hash because storing plain text password is the worst. Even if your database gets compromised, the attacker would need to decrypt the hash, right? And then we're going to have a user of token that we're going to use for the session ID when we create the cookie and we're going to create a new one each time the user logs in to be secure in case it gets compromised. So we can also say unique. There are some optional fields Created at Datetime is the built type So we can say default now so we going to give it a timestamp and also updated at datetime we can say updated at and this is the interesting part so we can just create another table model row so we can give it an ID this time I going to use an int and we going to give it default auto increment so it going to be one two three four etc The role is going to have a name and you're going to create the roles. It's going to be unique and now we just need to connect it to the user table. So again, Prisma makes this super easy. And then we can go here, we can say role, I'm going to refer to the table and we can specify our relation. So it's going to use role ID, which is going to reference ID. Let me just do it like this. Can remove semicolon. We can do it like this, and then we can add roleID int. And that's basically it for the schema. But another thing I want to mention is that later when you change to MySQL or PostgreSQL database, you only need to change the connection string and don't have to change your schema, but you can also use other features only those database support, like enums for the user role. And if you use any of those other databases, this is even easier to create roles. Let me just show you. If I open here the Prisma documentation, give it a second. And you can see how simple this is when you use enum in a supported database. You can just create enum role and then you can say user admin. And this is the only thing you have to do, which is way easier. But I really don't want you to struggle to set up a database, etc. And want to make it more accessible. So yeah, just keep this in mind. You can do that later if you want. But yeah, let's continue. Another thing I want to mention for the schema is that you could create a separate table for the password to reduce the risk of querying it on accident and sending it to the front end. This is just a security precaution if you want, but you don't really have to do it. So to query the database with Prisma, we need to install the Prisma client that's going to run Prisma Generate, which is going to generate the Prisma client that's unique to your project. Prisma is really awesome because it gives you insane TypeScript support because of this. We're going to install the Prisma client, and then we're going to create the database from the Prisma schema. So in your terminal, you just clear it. I'm going to say pnpmi, Prisma client. And then I can say pnpx prisma db push. And we're using npx or pnpx because we don't want to install the Prisma CLI locally, so we can just execute the binary And we can say push and this is going to create the schema Now I going to open Prisma Studio that a nice graphical user interface for your database and go to the roles table and we going to add some records And you can do this from inside your app, from some user interface, but I just want to give you a brief overview how you can use roles, right? So we can just say PNPX Prisma Studio. But yeah, let me open it so I can go localhost 5555. And you can see here are users. So this is our table. and here are the roles. So we can create the roles in advance. So I can say add record and I just need to say admin and I can press enter and I can save one change. Now we have the admin role. I can add another record which we can call user and I can save that. So let's keep the Prisma Studio open which is going to be useful later. And yeah, let's continue. I'm also going to create a new terminal here so we can just start pnpm run dev. And for the project itself I don't have anything special. I just have a layout file for the styles and I put all the styles in a global file so we don't get distracted because it's not important, right? And here is just the homepage, right? And the last thing we have to do is initialize and export the Prisma client to use it in our project. So inside our project, I'm going to go to source, lib. I'm going to create database TS and then I'm going to import Prisma from Prisma client. Then I'm going to export const db. new Prisma, Prisma Client. And that's it. Now we can use it inside our project. Let's do the user registration. To register the user, I'm going to use SvelteKit form actions. That's an easy way to write an action you want your form to take once you submit it and return form validation errors. SvelteKit makes this really easy. So let's see how. If I go to source and routes, I'm going to create a register folder and I'm going to create the page.svelte. and this is going to create the folder and inside is the file. So let me just close this and I can close the sidebar and then let's just type it out together. So you can say script language TypeScript and we can say import type action data from types and this is going to complain because it's not generated yet. So you can just say export let form and we can say action data which is the type so we can get form validations here and other things I'm just going to say register. Now let's create the form, so I can say form. And for the action, if you want, you don have to specify an action if it the default one but I going to name it just so I can show you the difference So I can say action and then we going to have an action register And this is really great because when you see something like this you know where the file is located which we're going to create in page server TS in a moment. And we're going to give it a method of post. And let me just keep this. We can rename it to register. And let's just add the field. So we can say div for styling. Let's give it a label for username. We can say username and then let's create an input. So we can say input type text sure and we can say it's required so we already have some validation from the browser but obviously we need to do check server side. So you can say id username. Name is going to be username and let's create the same thing. So I'm going to copy this lower, make space. So instead of username, I'm going to have a password. And let's also change this occurrence as we can say password. And there's also the special type password. And this is also going to be required. And for the form validation, whatever we get from form from our server, we can just say if, and we're going to have, if we send user true, there we know we have an error, which we're going to see in a second. So now we can use a paragraph tag. We can give it a class error, which I have globally, and we can say username is taken. And now we're going to create the endpoint, but before I do that, we're going to need bcrypt for hashing the password. So let's open your terminal again. Let me stop the development server. I'm going to say pnpmi bcrypt, and we're going to install the optional types, but if you're not using TypeScript, you can ignore this. Types bcrypt. Let me start the development server again. I'm going to close the terminal. So now our goal is to validate any errors there might be, and then we're going to hash the password. We're going to create the user authentication token, and assigning it a role, after which I'm going to redirect the user, as you can see here. So we can go to the sidebar again, and let me just go here, and now when you refresh, let me just go to the register page. And if you go here, and a pro tip, if you have trouble generating the types, you can press Ctrl P and then you can either restart the language server or there's an option to restart the TypeScript server because sometimes this is buggy. And yeah, once it's going to generate, it should work. But yeah, we need to create the file, right? So I'm jumping

 ahead of myself, but yeah, I can actually say page server ts, and then we can just close this, and in the post I have it like this. So we can import invalid redirect from SwellKit, and then we can import some type. I'm going to need actions, page server load from types and then I'm going to import bcrypt and let's import the database we created so we can use it right so we can say import db from lib and it's already alias so we don't have to deal with path names and now we're going to create something that's typescript specific and that's enums because those don't exist in javascript but if you're not using typescript here you can just create a plain object, and I'm only creating this to prevent typos, and this is really, in general, good practice. So we can say enum roles, and we can create a string enum, so we can say admin, it's going to be admin, then you're going to have user, which is going to be also user, and then I'm going to give it the load function, which we're going to return later, so I can say load, page server load, going to be async, and let's just give it a to-do, and then we're going to see what we're going to do later. So here are the actions, and I like to extract the actions outside of this object because it's more readable to me. For some reason, I have an easy time parsing unreadable JSON API responses, but reading logic inside objects for whatever reason confuses me. But yeah, you don't really have to do this. You can just type this as actions, and you can type your function here, or whatever you want, so you can say export const actions, give it a type, and you can just do it like this, you can say register, you can give it a function here, you can do this type if you want, but yeah, I'm just going to extract this, so I'm just going to say here register, and then I'm going to create the function, as I have it here. So I can go const and it's really a shame. I really prefer regular functions usually but because I want to type the entire thing I have to do it in the arrow function way so I have to say action and then async and now we have type So we can say control spacebar and we should get the types back so we can say request Let me just see Request and now it knows what this is So now let get the username and password And we get those because we gave them a name here. So this is name, username, name, password. And this is how we're going to get them on the server, right? So this is just the web platform, right? And then we can say const data. So first we need to get it from the form. We can say request, which is just a structure, right? So you can say form data. See, we get also an autoconpletion. Now we can get the username by data get. We give it a string username. And then let's just get the password. I get password. And that's basically it. So now if we submit anything, we can just log it out. We just do username password. And this is server-side, so it should be logged in our terminal. And since we're using our .server.ts file, this only runs on the server. so this one's showing in your browser console. And now we can just say test. It's going to post to itself, right? And then we can say username test, password test. And that's really how simple this is. Let me just close this and I'm going to go back here. So now honestly, a lot of this code here is just validation because we really don't want to skip on this. But the authentication code itself is like maybe 20 lines of code. So yeah, this is just validation. But yeah, let's get to it. So we can just say, for example, to make sure, even if we have browser validation, So I can say if type of username for whatever reason is not a string or type of password for whatever reason is not a string. And then you can check, hey, is there even a username? Like is someone trying to bamboozle us? What is going on? And then we can just return invalid, which is provided by CellKit. So we can return 400 and then we can say invalid is true. And then we can show this for the form error, right? but we also have another one where you're going to return user true. So you can use that. And basically this is just a safety precaution. And now we can query the database for the user. Does this user already exist, right? So let me just save this with formats. And let's query the database, const user. So we can say await. And remember this is already typed, which is amazing. So we can say find unique, right? This is a method from Prisma. We just need to tell it, hey, where username, right? And this is going to return us the user. So if the user already exists let return the error invalid 400 We can say user true And this is basically going to exit this function but we can continue If there is no user, we can say DB user create. And we just need to pass it. If you press control spacebar, you can see what options you get. And this is why TypeScript is so insane. You just say data. And it's even going to tell you, hey, I want this, this, and that. So we can say username. And this is the same username we got from before, right? From the form. And now we can just create the password hash. We can do this by using await. We're going to use bcrypt hash. We're going to say password. And we can give it salt rounds. 10 is okay. And then let's create the user of token. And we're going to use a built-in method that Svelkit provides crypto. So we don't really need to import some UUID library or whatever. We can say crypto random UUID, which is fine enough. And now we just need to connect this role to the one we created. So if you remember here, let me just go to the database, roles, we created it basically here. And we just have to say, hey, when you create any new user, just default assign it to user. And it's going to be part of this array. And we can later query the users, which user have the user role, admin, and et cetera. But yeah, it's really nothing complicated. So we can just say role. Again, TypeScript is incredible. Say connect. And we just have the name field, right? so look how this maps to your thing so this is name and we just say name here and i have it in the post and we're going to use our enum that we created right so we don't make any typos so by default i want to make roles user right we don't want to create admin by default okay so when all this is done we just have to say to swell kit hey redirect so we can use row redirect we can give it a 303 status and then we can redirect to login which is going to fail right now because we don't have that page but the registration itself should work so basically that's it for registering the user let's try it out so we already have some feedback from the browser itself but you should also rely on this validation here right because the user might turn off this validation or whatever because they just really need to inspect the code and disable the required so yeah you have to think of the worst possible scenario but yeah let's just create test and we're going to say test and we see we're going to get the error because login doesn't exist but yeah everything works fine if we go to our database let me just go to the users and it showing zero because we need to refresh it but if we go here we can see here is test the id that created the password hash the user of token created updated and it even has role so if you go to the roles we can see it has the role of user so how awesome is this and it wasn't complicated at all so i also want to show you how the validation works so remember if the user already exists if you go here and type test test we should get an error because we're having form here and then we can say hey form user remember if the user already exists we're going to return user true and now we know we have some errors on the form so let's see this should say username is taken and awesome it works let's work on the user login that's going to be similar to the user registration page i also want to emphasize that if you have sensitive information like usernames and password be vague with the error messages do not help bad actors who might be trying to abuse it so try to be as helpful as possible but really don't give specific information like, hey, this username isn't valid or this password isn't valid because someone might use this to phish for information. But yeah, let's create the same thing if we go to source routes and then I can say new file and I can create login, same thing as before, page swelled. This is going to create a login folder with page.swelled. And now let's create a script tag so we can import type action data from types and we're going to do the same thing action data and now we're going to have login let's create the form so again for the action we're going to create a login one and method is going to be post again so let's rename this to login and everything else should be fine and let's create the label for the username say username and again we have the same code right say input and again it's required i'm going to create the id and the id is important for for so it knows to identify it so when you click on a label it's going to click on the input that's how that works and the name is important to get the information on the server say username and let Let me just copy this over. So now I'm going to have password. And don't mind repetition, right? So we can just type instead of text, it's going to be password. And then again, validation errors. We can say if form, this time we're

 going to say invalid and this is what I'm talking about. So be vague with the error messages. Let me just see do I get... sometimes it works, sometimes it doesn't. Username and password is required. So you see I really don't want to be specific what exactly is wrong here which is more secure. And Then we're also going to return if the credentials are wrong. So I can say if form credentials. And if you never saw this symbol, this basically just means, hey, this value on the right might not exist. So instead of throwing an error, just be undefined or whatever. So basically that's all that is. But yeah, we can just create another p tag and we can just say class error. and we can say you have entered the wrong credentials. And let me just fix this to have it the same as I have in example. And that's basically it. So we're going to create the page endpoint. So I'm going to check if the user already exists and compare if the passwords match and I want to generate a new authentication token each time in case it gets compromised because in that case, let's say your token gets compromised and then what can you do? You have to ask the creator of the site, hey, can you update this in the database for me? And you really don't want to do that, right? And then we want to authenticate and redirect the user. And another awesome thing is that SwellKit provides a nice API for interacting with cookies so you don't have to import the cookie package because SwellKit uses it under the hood. But let me just go here. And we can create inside the login, we can say plus page server TS. Let me close the sidebar so we have more room to work. And now we can import the same things from before. Invalid redirect. Also, lgskit. We're going to need bcrypt again. And let's import the types. So we need action, actions, page, server load. From types. And then let's import our database. and let's see it's already smart enough see TypeScript is awesome so you can say database but sometimes it does this weird thing so it does half the job and I'm like okay thank you TypeScript is like hey I'm trying to help thank you TypeScript export cons load save page server load async And again I going to tease you with a to So basically, we're going to do the same thing, right? So let me just export const actions. We can give it a type actions. And this is even optional here, because otherwise you would define the type actions here so you can have the types inside, but we're really extracting the function. so maybe this type here is redundant, but up to you. So let's create the login. Let's say the login, which is going to be the action. Again, async. And we're going to give it the body. And now we have awesome auto-completion. So if I press Control-Spacebar, you can see we get cookies. We get the request itself. And now we can just do the same thing. Data await request form data. And then we're going to get the username. just do this and we're going to get the password data get and then again let's do the validation so we can say if type of username dot a string or type of password and if someone is trying to bamboozle us and then we can return invalid 400 and that is going to be true and really don't display this on the client but you can if you want I just have it here for posterity but yeah let me just save everything so it forms nicely and remember let's go to the next line so now we can get the user const user await db user find unique and now we can say where that username. So this is short for username, but we already have the username from the form, right? So we don't really need it. And we can say, hey, if this user doesn't exist, return invalid. We're going to give it 400. And remember, vague. So we're going to say credential. Credential true. So the type of error is credentials. And now we're going to get the user password. So const user password. We're going to say await bcrypt, and bcrypt has a compare function. So we can say the password that was provided to us let compare it to the one from the database user password hash And then we can check if the user password doesn exist We can return invalid, again 400. Credentials true. And now we're going to generate a new of token just in case it gets compromised. And this really isn't anything hard. So we can say const authenticated user. we can say await db user and how we update our record in Prisma simple to just say update we have to specify where username so we get this from the user username and then we can give it the data we want to change so we want to change user of token and then we can use the built-in crypto from cell kit we can say random unique identifier and that's basically it So now once we've done this, we can create the cookie. So we can do that by saying cookies, which we get from here, remember? Provided by SwellKit, which is awesome. We can say set. We're going to give it a name session, but you can give this a name banana, whatever you want. And we can say one, two, three, four, right for the value. But I'm going to use the authentication token. So authenticated user, which we updated the token right now. So you can say user of token because that's what it's returned from Prisma. And now we can provide it some options. So we can say path, which is going to be for every page. And I commented all these options here so you understand what they do. And this just sends a cookie for every page. And then we're going to enable HTTP only true. And this enables HTTP only cookies so you can't get the cookie by doing something sneaky like document cookie. So it's more secure. And then we're going to restrict the request to be from the same size. So for example, the downside of this that you can be linked from another page and send the cookies. So if this is something that you need, then don't use this option, but basically this is more secure in general. So you can say same site strict. We also want to send the cookies only over HTTPS, but in development, we might not have HTTPS, right? So we can check if we're in development. We can say process environment. So we can compare if the node environment right now is production. this is going to return a boolean right true or false and then you need to set the cookie expiration which is going to be a month and remember when you have that option remember me you can even change this programmatically so maybe you have this for a week and if someone checks remember me then you just increase the max age here and that basically how you do that you can say max age 6060 and I just don't want to give an entire number because this makes more sense it's easier to read right so you can save this and now when we created the cookie we want to redirect the user so we can say fro redirect let's give it a 302 and then we're going to redirect to the homepage where you can redirect to admin or whatever protected page you have, that's up to you. And basically that's it for the login. So this should work. Remember we already created the user. And let's go to login. So let me just try something that shouldn't work. So I can say one, two, three, four. And it should give me an error here. You have entered the wrong credentials and we're being vague on purpose, right? This is really awesome. And let's try to enter something that exists. Let me just open the developer tools. I'm going to zoom in. Hope you can see this. So let me just go to application. Let me just move this. Cookies. So nothing should be here. So we can say test. That's what we had before. And you can see the session has been created. The value is the token that we have in the database. So if I go here to user, we can see the password hash, the ID, and the role that was created, right? This is really awesome. And again, I want to stress the reason we recreate the user authentication token each time the user logs in, because if someone just copies over the cookies you have, it's game over, right? Because they're basically you at that point. And if that gets compromised, you need to change it on the database level. So if the user gets compromised, we can just change it for them, and that's everything. And at first, this code might look daunting, but if you ignore the user validation, basically this is only 20 lines of code to get the user login and registration working. So let's see how we can implement the user logout. and this is going to be really straightforward. To make the user logout work, you only need to eat the cookie and redirect the user. So I'm going to just create a page endpoint without the page itself in logout page server TS. And you can even use server TS and create your own endpoint endpoint but I want to be able to use progressive enhancement later and that would require JavaScript. So this is what I decided. So if I go here to source routes, I can create a logout folder and I'm just going to create page server TS and I don't need anything else so we can close the sidebar and now I can import redirect from cell.js kit and let's just get the types

 Actions, page server load. And let's create the load function. So remember, there's no reason to visit this page, so we only can redirect. So we can just say throw redirect, so we don't get not found or whatever. and that's basically it. And now we can use a default action to not be fancy, and we can use this anywhere in our app, right? So you can say export const actions. Let's give it an actions type. We're going to use default, and let's get the cookies. And we just need to eat the cookies, so we do that by setting a cookie to expire right now, so we can set it to, hey, remove session. we're going to give it blank the value and for the option we have to specify path we're going to say everything and now expires we're going to say hey this should have been gone yesterday so we can do it by new date providing zero and that's basically it so we can redirect so remember we ate a cookie here and we can say fro redirect 302 and we can just redirect to login and that's going to be it but right now we don't really have a form we can use this, but we're going to use this in a bit when we create the layout file. Let's talk about something that might be hard to wrap your head around at first, but I'm going to do my best to explain how it works. So we have to pass the user data to pages somehow, right? Because remember those load functions where you had that to-do left? We somehow need to get the data if the user is authenticated or not. And as you might know, each load function has the event, right? So if we log out the event, we are going to get all these options like client address, cookies, locals, platform and request. But the one that's most interesting to us is events local, because we can store some shared data among the load functions on the pages and make it available wherever you use the load functions. And that's really great in our endpoint, but we also need to make it available on the client somehow. And thankfully, in the same way, to get access to that information on the client, we can use the page store and access it via page data, and that only stores the combined data of all the load functions And this might not make any sense yet but our goal is basically to populate locale user or whatever you want to call it right and pass a user prop to the page store And first we going to achieve this using the hooks file at the root of the project And let me just explain this to you how this works. So basically this is your SvelteKit app, and you have your pages here, login register, right, and this is my mental model of this. So this is your page in this box, page of Svelte, whatever, and around this is this box, your endpoint page server TS, and it has the load function, and this feeds data to your page, right so you can fetch something from the database whatever and this accepts an event right and we've seen all those options and basically what hooks are and a lot of people are confused by this terminology because hooks mean a thousand different things but basically what hooks in swelter are basically like a man in the middle that intercepts any request you make from the page and you can change that request to whatever you want so for example i have an example in this post Let me go here. So in SwellKit, a hook is just a file that runs every time the SwellKit server receives a request and lets you modify incoming requests and change a response. So for example, this is the default behavior. You have this handle function and accepts an event resolve and then it just returns resolve event. If you wanted to, you could turn every page into a banana, for example. So you can check if event URL path name is the root, then you can just return a banana instead of the HTML or whatever. And this is how we're going to populate the locale's user. So we can make it available in all the load functions and pass it to the page store. Whenever we create the cookie, right, the hook is going to trigger, it's going to check, hey, if the cookie exists, it's going to get it from the database, the information we need, and then we're going to populate the event locales. And that's how this is going to work. So I hope this makes a lot of sense. Because again, let me repeat, the hooks gives you access to the event. So we're going to create the cookie and then it's going to say, hey, does this cookie exist, right? okay, oh, you must be the user that's authenticated. Let me just make sure. And then it's going to populate the locale's user. And that's how we're going to get it in the load function and in the page store. I can talk about this all day, but it's only going to make sense once we do it. So if I go here to the post, the first thing we're going to do is at the root of your project. So source, we have to create a hooks.serverts because this only runs on your server. And let me collapse. So we can just import type handle from, let me just see, soil.js kit. And then let import our database because we need it from lib database And then we going to create the handle function export const handle And then we can get the event resolve. And let's just create the body. So now we get the cookies from the browser. Const session. We're going to get it from event cookies. Get session. So if it exists, we're going to be like, okay. so let me just show you this session I didn't save it yet so if I go here let me just open the terminal because remember this is server size so if I refresh this the hook is always going to run right let me see oh it complains because let me just see we need to return the default behavior right return wait resolve event the more you play around to try it out is going to make sense so return bananas or whatever fruit you want and that's the best way to learn But yeah, let me go here and I'm going to save it. So remember, every time this is going to intercept our request, if you refresh this, we're going to see this is the cookie, right? This is the exact value we have here. And this is how we're going to use this. So let's check if the session exists or doesn't exist. Session doesn't exist. We can do the default. So let me just copy this over. You're going to need it later anyhow. So we're just going to do nothing like as usual. And if it does exist, we're going to find the user. based on the session. So we can say await DB user. We're going to, let me just, oh, I did a mistake here. DB user find unique. And we're going to say where. So we can say user of token session. Remember, this is the session that we just returned. And we're going to look that up in the database. That's it. And now to not return any passwords or mistake. And remember I said at the start, you can create a separate password table if you wanted to avoid making a silly mistake like this. But don't worry, we're also going to control what we return in the events locale. So you really have to move things up to return the password in the client. So we're going to say, hey, select username, true. And I just want the role, right? I don't want anything else. So now if the user exists and everything is okay, we can say if user. So now we're going to populate that event locales. And remember what I told you, we get the event here and we're going to populate that. So we can say event, a walkout, and as I told you, this can be banana. This can be whatever you can think of So you can say user and then we just going to create name user username and we going to create a role user role name That the values from the database right Nothing special. And I already returned here the normal one. So yeah, we can just save this. You can notice there's an error here because we need to create the type and I show you also that in the post. Let me just go here. Where was this? Yeah. So let's just quickly do that. That's in source. So So this is if you're using TypeScript. If you're not, then you can just ignore this. Interface locales or locales, whatever you want to prefer it. User name string role string. We just really need to tell it what it is because it can't know, right? So that's it. Let me just close the terminal. I'm going to close this. Yeah. So now we don't have any complaints. We're going to get type safety. And where we left off after the user is authenticated and the cookie is created, we can populate event locales user with the username and role. It has told you the event local user naming is arbitrary. You can name it event local banana and pass event local banana equals banana if you want it. So since the locales user is now populated, so it's available in the load functions, we can pass it to our application and to the page store, right? And we're going to do this by creating the layout server TS file. So we're going to create an endpoint for this. And this is already done for the hooks file we can close this and in routes we can just create a new file and we can say layout server ts let me just close the sidebar and i can say import type layout server load from types so we can now get the locales from the load function and we're going to pass it to the page store by returning it from the load function and that's because remember i told you that the page store keeps all the combined data from the load functions. You can say export const load layout server load, which is going to be async. And then we can get our locales right. And let me just do this. And let's just log it out so we can see what's going on. So we can go here and it should display in the... No, it's going to display on the server, right? And so you can go here and you can see here we get it back. User name test role user. And now we just need to pass it here like I show you. Let me just close this. So we can just return it. We can say return user calls user. And that's basically it. We can now authenticate the user, but we don't have any

 protected route. So let's see how that works. So here I have a layout file. Let me just open layout.swell. And I only have styles here, the title for the page. So let me just import the page store. Remember, this is why we needed it. So we can use it on the client. So we can say page from app stores. And now we get access to this. So inside we can create a nav here, for example, and we can say if there is no page data user, then we can say, just see a tag, then we can have this link. So we can say login. We can say register. And if the user is logged in, then we can show the links admin and we can show the logout. And we're going to use a form here, as you see, to log out the user, which is going to eat the cookie and redirect the user. Yeah, so let's do that. You can also use an else, but I'm really not a fan of that. I just prefer to make another if block and that's a lot more readable to me, but you do, of course. Page data user. So if the user exists, right, we can just create a link. I've been only going to create that in a moment. And then let's create a form. It'll be simple. The action is going to be logout. That is going to be post. We can use this anywhere on our page right now. So we already have a submit, but let's just give it a name logout. And I also think I have a class logout, just so it doesn't clash with the other styles. So I'm going to include that. And let me just go here and let me save. So we can see we're logged in, so we only see admin and logout. And let us see if our logout works, right? We made it before. So this is going to disappear here and it should redirect us. How awesome is this? So now when we go, let's say to home, we just see login and register, right? and then we can log in. We can say test. This is going to create the cookie home and we haven't created the admin yet so we're going to get an error but the logout works. We can also update the other load function. So remember, let me just open the register and we can open the page server TS for register. Remember how I have a to do here. So now that we have access to the locales, now we can use it here. So we can redirect the user if they're not logged in. You can say locales user throw redirect. You can say 302 and then you can redirect to the homepage And we also going to do the same for login So you can go page server for the login And we can say if not local storage local user Oh, because we need to import it, right? See, right? We're trying to be helpful and you mess it up, right? For redirect 302. Yeah, and that's basically it. So now we can try it out. So remember here for the, let me see, this was the register page, right? So we can go to register. And if you're logged in, there's really no reason to show register, right? So if I go, it's not going to show, but even if you go here, it wouldn't make sense to show the register page, right? So that works. And for the login, if the user exists, again, there's no reason to go to the login because it doesn't make sense. But yeah, that's basically it. So again, let me log out, see if this works. And beautiful. So let's create the protected route admin. So I'm going to do that. Let me just close all these files because we don't need it. And in start routes, I'm going to create a new file. I'm going to create the admin folder. And I'm just going to say page swelt. Let's create a script tag so we can again import the page store from app stores. Let's give it a title admin. and I'm going to show you how you can use the user roles if you want, and you can do whatever you want. So you can do if page data user, then we can log a message. We can say welcome page data user name, right? And here's how we can use the roles. So now we have roles. So we can say if page data user role is equal to admin then we can again do the logout and then let's give it a post and you can say logout and before we do that I also want to make sure that to redirect the user if they're not logged in so for the admin page which is right here I can create an endpoint page server ts, just close it, then I'm going to import, redirect, no, cell.js, let me see, cell kit right I going to import the type page server load and let say export const load page server load which is going to be async and get the locals here So if there's no locals user we can throw redirect. so this is how you can protect your route but another thing is that you can also do it inside hooks as i showed you in the banana examples where we checked if the page is the home page you can do the same thing you can say hey if the user is not authenticated and this is the protected route then you should redirect but i'm going to show you why i'm doing this that way in a second so for example if i go to the page right now we're not logged in right so if i go to admin it should just redirect us. Nice. And if we log in test, we can go to admin and we can see we greeted welcome test. And let me just make it more exciting because it should be right. So let's do another thing where I go to the user and let's just change the role of the user, right? So you can see roles. You will do this programmatically in your app, of course, but I just want to show you the simplest form of it so you understand what's going on. So let's just change it to admin. We can just do this. then we can say one change and this shouldn't update now because oh it's going to update that's nice so now the user is admin and let's just do it again just so we can see it so we can test and this is the admin now so we can go to admin and now we have admin only features so we can log out from here and how awesome is this i also wanted to mention in the final example i used a svelte kit group to group the off related routes inside an off group and the protected routes inside a protected group. So if we go here, just collapse everything so it's easier to read. So inside routes, you can create what's known in Svelkid as groups and groups are folders, but they don't create new routes. So you can create a folder. You just see I named it off. So you can put your off inside here. We had login, logout, register. So you can place it inside off and then we can create a new folder. protected and just so you know to differentiate them. So basically that's it and there really isn't any change to functionality. These are new routes and everything should work the same so you can log in edit test go to admin log out But yeah basically groups are a nice way to organize your routes Let talk about progressive enhancement Have you noticed how so far we didn use any JavaScript And that's really true. I can, for example, press Ctrl P. I can type JavaScript. I can disable JavaScript. And let's go to the register. And we can create another user. So we can say whatever. And it works as before. so you can log in as that user. And we don't have admin privileges, right? But we can see the admin section. And we're doing this all without using JavaScript. And the point isn't to not use JavaScript, but to use progressive enhancement so your apps are more resilient. So if JavaScript fails for whatever reason, your app is going to work the same. But if JavaScript is available, we can progressively enhance and improve the user experience. So let me just enable JavaScript back on. And you're going to be surprised how simple this is in SwellKit even though it might sound complicated. The only thing you have to do is import the enhance action from SvelteKit and it's going to progressively enhance the form and use JavaScript when it can. So let's go to the register page. So we can type register and then we can see page.svelte for register. And we just really need to import enhance. So you can say import enhance from app forms. And the only thing you have to do is use the action. and that's it. So now when JavaScript is available on the page, it's going to do all of those shenanigans that you would otherwise do in JavaScript frameworks like event prevent default, and it uses client-side rendering instead of refreshing the page so it's a smoother user experience. But we need to do something different for the register page, because, for example, right now, let me just log out. So if I go to register here, and you're going to see how the transition is smooth. So, for example, I can just create another one, and we shouldn't get a refresh. Yeah, it's going to go to login. So now let's also do it for the login page. If we go here, we can just import enhance from, what was it again? It was app forms. Yeah, see, yeah, app forms. And then we can just use it here. And I can save this, but I'm going to show you a problem. So we can register the user right, and then we go to login for example. We can do test. And remember now we're using JavaScript, and this is going to work of course

 press login, but not updating the UI. It updated the other values in the background like locales. So for example, this is happening because if we go to, for example, login, and we go to the load function here, basically to solve this problem, we need a way to rerun the load function for the pages somehow, right? So it's going to rerun this, and it's basically going to do the equivalent of me refreshing this, because now it updates, see? And we can do this using invalidate all, and then we're going to supply a custom return function that's going to give us the result and basically this overrides the default behavior of the enhance action. So we can say invalidate all which is going to rerun the load function for the page and then since we customize the default behavior we really don't want to re-implement everything useEnhance does so we can use applyResult and pass the result back in. So let me just go here, I'm going to close this page and this really sounds intimidating but it's really nothing special. so let me just say equals brackets and then we can just pass this a function and this returns an async function which is going to give us the result and you can also get access to other things inside here let me just see you get action cancel data form so you can do some loading states or whatever you want and this is really useful for this but i would advise you to read the documentation to learn more but yeah so we can do invalidate i already imported let's invalidate all Yeah, not invalid. So we can say invalidate all. And we really can't use it outside here because we need to get to the result after everything is done right. So we can say invalidate all. And then we want the default behavior again. So we can say apply action result. And we can save this. And now we also need to do this for the logout. And if we go to layout where our logout is, we need to do the same thing here. So I'm just going to import those things. Import apply action. Oh awesome Enhance app forms and then we going to say import invalidate all from app navigation and that's basically it so we're going to do the same thing here where we have our form we're going to use enhance Let's pass it a function. I'm going to return async result. Give it a body. Then we can say invalidate all. Await apply action. I'm going to do it for the result. And also let's fix the mistake here. So yeah, I hope this makes sense. And now everything should work properly when JavaScript is disabled and when it's not. So let me just close all of this things because I think we're done here. And let me open the console back again. Let's first try it with JavaScript disabled. So we can see, just log out of here, you can see register, you can see we can do it here. So for example for some reason JavaScript is not available you can see everything still works and you can go log out and now let bring JavaScript back in and I just going to refresh it for good measure the register is going to work and again if we have some errors username is taken which is really great you can register the user and now if I type some wrong credentials we can give vague but helpful information. Let's close this. And now we can log in here. It's going to redirect us. And now we can go to the admin and we're also admin and the logout should also work. So regardless which one we press, it should log us out and update the user interface. So you can say logout and everything works. Hey, that's everything to authenticating users with cookies in SwellKit. I hope at least you found the video educational and learned more about SwellKit because it's mostly about just using the web platform. If you have a serious project, I would look into using an authentication library because security is hard and you don't want to run into edge cases and maintain one yourself. So you can look into SvelteKit off and Lucia which are great libraries for authentication in SvelteKit. Thank you for watching and catch you in the next one.