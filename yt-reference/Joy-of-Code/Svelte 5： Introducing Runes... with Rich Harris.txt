 All right, friends, gather around and let's talk about Svelte 5. A lot of you know that we've been hard at work on the next version of Svelte for a while now. And in this video, I'm going to share a preview of some of the new stuff and hopefully get you all as excited about it as we are. Before we do that, I want to talk about Svelte today. We like Svelte. We're proud of Svelte and all of the love that it gets in developer surveys and so on. We think it's the best way to build most web apps. but there are some undeniable pain points that you've probably encountered and which are difficult to fix with Svelte's current design. Let's look at a simple component that we might write today. We're declaring a count variable and using its value inside our template. Every time we update its value inside the event handler, the page automatically updates. Very cool, very easy to learn because there's no API, we're just using the language. If I want to add a derived value, I can do that with $label doubled equals count times two, and that will be updated whenever count changes. There's a little gotcha here, though. Because Svelte doesn't want to run this code until it's sure that there are no other changes to take account of, it won't recalculate doubled until right before the DOM is updated. So if, for example, you log the values inside the increment function, you'll see that they get out of sync. Another gotcha is that the dependency tracking happens at compile time. What I mean by that is that the compiler looks at this expression on the right, this count times two, and understands that the value of double is dependent on the value of count. But what if we refactor our code by having a double count function? The compiler can no longer see the dependency, which means that double will never be updated. This makes it a little hard to refactor code out of dollar label statements, which means that they tend to attract complexity. Now let's imagine that we want to encapsulate this logic so that it can be reused. Perhaps we want to have multiple counters on the page. We might try wrapping it in a createCounter function like this. But this completely changes the meaning of the code. it no longer behaves the same way because it's no longer at the top level of the component. The let no longer becomes magically reactive and this dollar label has no special meaning at all. This is just an assignment to an undeclared variable. So at this point, we have to use a completely different mechanism, we have to use a custom store. First we import writable from svelte slash store, and then we create a writable store inside createCounter so that we can steal its subscribe and update functions. If an object has a subscribe method, then it's a store. So we can return that from our function along with increment. But increment can't just assign directly to count anymore. We need to use this update function with a callback that produces a new value from the old value. And I'm not even gonna get into how we would implement doubled here. Once we've done all that, we can create a counter object, update the event handler and reference the store value by prefixing it with a dollar And now our counter works again in a reusable form Now I'm speed running large chunks of the Svelte tutorial here and I'm zeroing in on problematic things. But I think you get the idea. There is room for improvement. Let's take another example, a to-do list. In this demo, we have an each block with some bindings. When we toggle these checkboxes, we recalculate this remaining to-do's expression down here. I've added some logging so that we can see when it gets called. Notice that when I change the text of a to-do, it recalculates that remaining count, and you can see the count tick up in the console in the bottom right. The way that this all works is that when you update a value inside an each block, Svelte will jump through some hoops to figure out what underlying piece of state may have changed as a result. And in this case, it can clearly see that each to-do is a member of the to-dos list, meaning any changes that happen inside the each block will invalidate the entire to-dos list. As a result, this remaining to-dos expression is re-evaluated. The trouble is that when to-dos is invalidated, Svelte needs to check this entire list. It's able to do that pretty fast, but you can imagine that if this list was very long, that would cause a lot of unnecessary work. Svelte 5 fixes all this. It's going to make your app smaller, faster, easier to understand, easier to refactor, more consistent, all around better. And even though I'm going to be showing you some new stuff, the framework is actually going to get easier to learn because a number of the things that you have to understand today will no longer be necessary in the new world. Now that sounds like a lot of change. And so I want to reassure you that what I'm about to show you is opt-in. Your existing components will continue to work, and you can mix and match the new mode with the old mode. We are totally committed to this being a seamless upgrade that you can apply incrementally. So without further ado, it brings me great pleasure to introduce runes. A rune is a letter or mark used as a mystical or magic symbol. In Svelte, runes are function-like symbols that provide instructions to the Svelte compiler. The first rune we're going to learn is state. Let's go back to our counter example. Not our counter example, our counter example. Two words. The first thing I'm gonna do is use the state rune to mark count as a reactive value. At first you might look at that and think, but why? Maybe you're thinking of the meme. Maybe you're even... You maniacs! You blew it up! Ah, damn you! God damn you all to hell! Bear with me, I promise this will all make sense very soon. You can see that everything just works like before. All we need to do to update this value is assign to it. Under the hood, Svelte is using something called signals to make this work. Count is turned into a source signal The assignment is turned into a set call and we have something down here called a render effect that updates the DOM When this function runs we call this get function The count source knows that it should notify that render effect whenever its value changes. If I try and put doubled back in using the $colon label, it's going to yell at me because we're now in runes mode by virtue of the fact that we're using the state rune. So instead of that, we're going to learn the next rune, derived. In runes mode, we say let doubled equals derived count times two. Now, derived behaves a little bit differently to the dollar label. Remember before how the values got out of sync? That no longer happens. The value is still recalculated lazily, but it's recalculated when we need it, so it stays in sync. You'll also recall if we refactored this into a function, it would break. That no longer happens because we're tracking dependencies when the expression is evaluated. A few minutes ago, when we tried to encapsulate this logic into a reusable function, it got a bit ugly. With runes, it is much, much simpler. I can just wrap this up inside a createCounter function and the runes will continue to work. Notice that I'm using a get property here. That's because if I just return count, it'll be whatever the value was at the time the function was called, and we want counter.count to always refer to the current value. What's really cool about this is I can move it into an external module, and it still works. There's no code changes necessary. You no longer have this magical Technicolor experience inside your Svelte components, but a lousy black and white one everywhere else. We Svelte it all over your code base. Another example. Here we've got a fun little canvas painting app. Inside the component, we have an onMount, which runs some code when the component is mounted to the DOM. Below that we have a reactive statement using the $label syntax. The first thing we need to do is check that our canvas context has been created. If we opt into runes mode by turning this mouse value into reactive state, we'll get a compiler error telling us that we can't use the $label and should use derived or or effect instead. So let's learn about the effect rune. Effect is what you use when you want something to happen in response to something changing. I'm going to paste this code into our effect, and I'm gonna delete the outer if context code. The reason I can do that is effects only ever run in the browser after the DOM has been updated. So context is guaranteed to have been created in onMount. In fact, if we look at the JavaScript output and switch it into SSR mode, we can see that the effect has been completely removed from the output. The on mount is still there though. Now, if you're using SvelteKit or you've managed to set up your build tool incorrectly, then that will get removed later on, but maybe we don't need it here either. It turns out that you can use effects instead of on mount as well Now we can delete the import and see that it all been removed from our SSR output and everything continues to work We can also return functions from our effects These functions will be called whenever the effect refires and also when the component is unmounted. We can also nest effects. So we can put this update effect inside the initialization effect and now we can avoid cluttering up the top level scope. All in all, it just allows you to encapsulate your code a little bit more logically than you could in the old world. There's one last rune to show you and that's the props rune. Today in Svelte, if you want to declare a prop, then you use export let, define the prop, and then optionally provide a default value. If no default value is provided, it means the prop is required. If a prop is a reserved word like catch, then we can't declare it locally so we have to create the prop in two stages. First we declare a local alias and then we export the alias to the outside world. If we want to get all of the other props that weren't explicitly declared we need to use this $$RestProps thing. Finally we can also export functions. This isn't a prop, it's actually a method on the component. Over in app.svelte we have a reference to this child component provided by the bind this binding, and we can call its methods from outside. If we instead use the props rune, we can declare all our props in one go using familiar destructuring syntax. And I can't show you this in the playground because we don't have TypeScript rigged up, but you can also use a type argument here to define the shape of your props. All in all, I think this is a pretty substantial upgrade. So that's a very quick introduction to Svelte 5. There's a lot more cool stuff that doesn't fit into a short video, but hopefully this has piqued your interest. With runes, Svelte becomes a much simpler framework. You don't need to understand the special let behavior. You don't need to understand the dollar label. You don't need to understand how export works. You don't need to switch mental modes between Svelte and non-Svelte JavaScript. You probably won't need to use stores or lifecycle functions. And so when people come to our community in future, they're gonna have a much easier time getting comfortable. I think if anything, I'm more excited about what this means for people who are already maintaining sizable Svelte codebases. We've spent a lot of time converting existing apps and libraries to see how it feels, and it really does feel good. You can't install it yet. We don't have a release date, but the good news is that you can visit this playground right now. Just go to svelte5preview.vacel.app. We have docs, we have an FAQ, and a link to the Discord server so that you can come and ask your runes questions in the Svelte 5 Runes channel. I want to take a moment to acknowledge the hard work done by the team on this. This wasn't easy. It took a lot, but hopefully you'll agree that it's going to be worth it. I want to thank the Svelte Ambassadors who have given us a ton of great feedback that's helped us refine the design. I want to thank all of the other framework communities whose research we're very much building on top of. Good luck catching us now. And I want to thank you for watching. See you in Discord.