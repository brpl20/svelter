 Hey friends, what's up? In today's video we're going to learn how to make animated code blocks using Shiki and Svelte. How beautiful is this friends that we get these granular, smoothly animated code blocks. And for this we're going to use Shiki Magic Move. If you're not familiar with Shiki, Shiki is probably the best syntax highlighter you can use because it uses the actual text made grammar like you see in VS Code. So you get actual syntax completion and you can use any theme that you want. So for example, my favorite theme which I use, always get this question, what theme do I use, which is in the description, you can check that out. So for example, we can say Poimandress, we can just switch this theme, right, because it's cheeky, you don't have to import CSS and etc for all of these things, right, and let's see how this call block smoothly animates, we can do something like that, in this example it uses view, but there is a slight problem, as you can see here it uses the view renderer and the react renderer, which is great, right, so even if we go to the repo, and if we go here to the usage, right, let me just bump this up so you see what's going on, and they say the package provides framework agnostic core and render and framework wrappers for view and react. Where is Svelte on this list? Excuse me. Well, actually, this is where I come in today. So we're going to actually learn how we can take view or react code and we can port it to Svelte very easily. But yeah, that's basically it. And if you're interested in how Shiki Magic Move works, it's really fascinating. I'm going to link in the description also this post, the magic in Shiki Magic Move, so you can see how beautifully this animates, right? And it really uses text diffing. So first it finds the difference in the text that you just see. So here is how it works move. So it divs the text. So if I hover over it, you're going to see the blue one move. The green one is enter and the red one is leave. So first it parses this, right? And then it uses the flip animation technique to animate these changes. So let me just scroll down to that part. And this looks familiar, right? If you've seen one of my recent videos on the flip animation technique. So what is this? Alt position first, last, and then we invert it. And then we just play it by removing the transition. So let me see. Here it is, right? So we remove it and boom, now your animation plays using the flip animation technique. And if you're interested in that, I'm also going to have a link for you. So basically, I covered a variety of topics on this channel from doing impossible flip layout animations with Svelte and GSAP, from page transitions using the View Transitions API, and recently actually implemented a flip animation library from scratch. So if that's something interesting that you want to do, you can check out those videos. Alright but before I get started don forget to like and subscribe and you can also support me by becoming a patron Alright friends so like any good chef I prepared a couple of things in advance So let me just close all of these things that we not going to need anymore And then we can look at the Sheiky repository So here we can look at the first thing, which is their example. So we can reverse engineer this into Swell. This is not a problem. So we already know that we need something that is called Sheiky Magic Move. So this is the first component that we're going to create. So when I look at something like this, I'm only interested in the big picture. I actually don't know a lot about Vue. I kind of really don't care what any of these other things mean. Of course, I know a little bit about you and I look some of these things up. So for example, here, this colon highlighter, this is equivalent to bind in Svelte. So we already maybe know from this that we maybe need to bind these values, but I'm actually not concerned about this right now. I'm just going to create normal components and then I'm going to see what values are reactive and then I'm going to bind them if I need them, right? So what we're actually going to do, we're going to go here to source and here this has two versions, so it has a react and view version. We're going to go to view and we're just going to mirror this project structure. So we're going to create a Shiki Magic Move component and a Shiki Magic Move renderer component. There's another thing here which is pre-compiled if you don't want to use the Shiki highlighter because it's heavy, I think. So you can use this and you can pre-compile these steps ahead of time, which you're not going to do today, but maybe you can do that as homework later, right? So we're going to just do that. And of course, this is the part that I prepared. So here is just a fresh SwellKit project. You can follow along if you want so I don't spend minutes on video doing this, right? So here inside the lib folder, I created this index file. here we're going to export this thing. So I created a Shiki Magic Move component and a Shiki Magic Move renderer component. Nothing to it, right? That's basically all you have to do. And the most important thing is, so for example, here when I open Index TS, just import Shiki Magic Move component, import the renderer, if you're following along, that is. And then you can just import these components. That's how easy peasy that is. And something that is very important, please don't forget about this. The first time I was doing this, I forgot the styles and I was debugging this for hours why it wasn't working. the most important part about this is that Sheiky has these styles that you have to include and where you can find these styles and again this is something you learn the hard way because we have to reverse engineer these things but for example here again if we go to source and then we can see oh what is this? style.css right and you're like okay maybe I need to include that because no one else is going to tell you that right and of course when you go to their site you should always inspect things right and you're going to notice oh I'm missing this class right it's not working like I'm expecting right so basically you can just go here You can just go to this button copy your raw file and then boom bam thank you man You can just copy over these tiles Easy peasy like that right And that basically it The only other thing I have is this layout We importing app CSS And today we going to use Svelte 5 for fun Oh, and let me stop the presses because people are going to ask. So let me just quickly explain this. So for example, you create a new Svelte 3 project. You have an option to use Svelte 5. But if you don't pick that, that's fine. You can just go to your terminal. Let me just open it here. Control C, kill terminal. And you can just use NPM, PNPM, whatever you're using. You can say add Svelte next. this is going to give you the latest version of Svelte. And that's basically it. So let me just do that. I'm going to start the development server back again. And that's it. Beautiful. All right. I'm going to close the sidebar and all of these files. And I'm going to press Ctrl P and open our route. So we can open plus page.svelte in source route. And here I have just some simple things set up. Here I'm using the state rune. So I'm going to create a simple toggle just so we can toggle this string so we can animate it quickly without having to constantly refresh the browser which is using this other rune code. so this is just a reactive state in Svelte 5, right? And here instead of using some button, I just put a click event listener on the window itself, and here I just output this piece of string, so when we go here to the browser, we can see here we have bool, when we click we have bool true, and etc. It just goes back and forth, right? So we can toggle this animation. Alright, so the first thing we have to do is pass some props to this Shiki magic move component here. So this component that we have accepts a highlighter, language, and code. As you can see, the only thing that we have to do here is create this highlighter. And something that's really cool about view, you can do this top level await and then this prop becomes available. And the only other thing we need is this reactive code variable, which view uses ref for, but we have runes in Svelte 5. All right, so let's see how this looks like. When we go back to our component, let's just move this to the top here. And then I'm just going to remove this instead. And let's first create the highlighter. So I can say const highlighter, and then we can start typing get highlighter and we're going to get an option to auto import it which is beautiful and let's just do this and we can pass some options here all right so we can pass some themes and i'm going to use point managers but you can use anything you want and then here we're going to pass the languages you can do by saying lengths and again you can use anything i'm going to use javascript typescript and even swell and that's basically it but now the problem is that we really can't do something like this in so we can't use top level await so in the past you probably done something like this you used on mount and then you done it inside of here awaited whatever you want blah blah blah you already know what i mean and then in your template you probably had some check you were like if thing or exist and then you would use the component or whatever else you want But actually instead of doing this it way easier just to use the await block in Svelte. Alright, so we can do this, and we can just go here to the template, and let me just use this snippet so you can see what I'm talking about. So this is the default template, so you can show the loading state, you can catch the errors, but in this case, it's highly unlikely that you're going to get an error, so I'm going to use the shorthand, I'm going to say await highlighter and I'm going to say again await highlighter then highlighter and let me just finish this and now we're going to import our component which was Shiki magic move so this is going to get auto imported at the top for us and just move it here and yeah then we can just start passing in props right and again we can just go here and remind ourselves what we need to pass we need to pass the highlighter language and the code so we can first start by passing the language which is going to be TypeScript and then we can just say highlighter equals highlighter and what was the third one? Code, right? I'm like a hamster. As you can see here because the props share the same name, once I save this, it's going to shorten it to a single prop. And how beautiful is this, friends? Okay, so let's see how they do it in the view example. So we can go here let me just collapse this. So let's open Shiki Magic Move. And at first this might look intimidating. Okay, so first you have this wall of imports. Then you have this and you're like what the heck is this? But actually if you just think about it, the first thing you have to learn is ignore 95% of things. Imports, not important. As you can see, we can just infer, even if we don't understand view, that this is just props. We can ignore it. They're just importing props. They're just setting the types on the props. It's really not important. The myth of the entire thing is here in this setup. First, we need to create this machine, and then we need to create this result. And again, we can infer it's named computed. We don't have to understand view. We just know that this is some value that gets updated reactively, right? And in Svelte 5, we can use a derived rune. And then you have this weird thing, which is a view renderer which I'm not sure why they're using because view actually has almost the same syntax as Svelte. Someone can maybe enlighten me but we just need to pass these props. Tokens, options, previous, on, start, on, end to the Shiki Magic Move Render component. Again, here's another cool tip. So if you're maybe intimidating by this you can just look at another example. If we go to React, if we open the same component in this example it's actually a lot clearer what you have to return. You can see here they're just returning Shiki Magic Move Render component. they're passing the same props. So you can be, okay, let me just do this. You can try things out. Maybe they work, maybe they don't. Again, you just follow the trail of breadcrumbs. But going back to our

 component. I'm going to open the Shiki Magic Move component. Let me create a script tag. So in Svelte 5 we have to destructure props. So I can say const and I can say equals $props. So this is how we get props. No longer export let etc. You're going to see this is way easier and cooler and it's also easier to type. So we can see here we have length, highlighter and code props. So for example I can destructure highlighter. Of course I chose the hardest thing to type. We can say console.log highlighter and now we can open this, let me open the developer tool so you can see what's going on and you can see here it is on the object so now we have access to all of the methods from the highlighter from Shiki right? How beautiful is this friends? And instead of doing this actually so I'm going to have to type prop to prop free and etc I really don't want to do this I just want to spread all of the props and we're going to see why it's also going to make a lot more sense here. Alright so I'm going to spread all of the props and here I'm going to cheat I created some types in advance for people who don't care about TypeScript, but I want great completion, right? So I'm going to say Shiki Magic Move Props, and this is just going to import from types. And if you hate TypeScript, close your eyes for 5 seconds. But yeah, basically I just have some simple types for these props. You can see how much easier it is to type props in Svelte 5 right now. But yeah, basically now I have these beautiful props, and the next thing, we just have to reference their component, right? So what is the next important thing? This machine and resulting we can literally yoink their code mine now yoink so now we can go here we can just copy paste it right let me just comment this out because it's annoying me all right so now we're looking at this we're looking okay where is this import coming from create magic move machine so we're like okay create magic move machine from core okay but they have this core because they have this internal package but in our case we actually installed shiki magic move slash core and we're going to import it from there. Cool. So now we can just go here, import, create magic move machine from Shiki, magic move core. And you can also find about all of these things if you look at their package.json. So for example, let me just look at here. You're like, okay, how do I get this import? These tricksters, right? And then you can, let me see if it's here. You can see, okay, here it is. Exports slash core, boom. And now you can see from their entry point how you can import it here. It's a bit more advanced, but yeah, you'll learn about these things once and then you know it forever, right? Alright, and then we can import this code to key tokens. I actually just copy this. 200 IQ boys Let go As you can see now it makes sense why I decided to use props because I can make my life easier I can yoink their code literally because what we have from the props we have the highlighter, we have the code, we're passing the language theme and even the options optionally which we don't need because they already have defaults. Alright, but now let's see if this thing is going to explode. So we're going to get this machine, right? Let me just go here and beautiful. We know it works because we get this methods from it. Commit, reset, and nothing is exploded. So how beautiful is this, friends? All right, so going back to our component, we can just remove this. So now we can uncomment result. And as you can see, they're using computed, but what is computed to us, right? So maybe in Svelte 4, you're used to this and then you have something reactive here. Well, in Svelte 5, we use the derived rule. So we can just straight up replace computed with derived. And believe me or not, this is almost going to work. Derived can accept any expression, but in this case if you actually want to do something more advanced and if you want to pass a function here and do something else you can use derived.by if you want to do that but in this case we actually don't even need to return a function we can just use the derived rune we can actually remove this and now we're going to get this result but now actually let's see if this is reactive remember here we created this rune using code state so now in theory when we flip or toggle this animation this should actually reflect and update our code and to do this we're going to use a special inspect room to see updates. Otherwise, if you just use console.log results, you're going to see it's not going to work. And in the past, you might have done something like this using this $console. This is what $inspect is the equivalent of. So we can actually see when you go here, we can see current, let bool, and you also have the previous. And then let's just click here. Ah, it updates. How wonderful is this, friends? It works like absolute magic. Okay, so going back to our component, let me just remove this and this is how simple that was now we can just import our component we can say shiki magic move renderer and we can just import it here from blip so let me just move this up and i'm going to say cool i'm just going to do this and now we get our component and let's just remove this so now we can pass our props easily so what were the props we can pass tokens the previous tokens, options which are optional, and then we have this on start and on end callbacks, right? So we can actually refer to this code here and actually see what are the props tokens options previous on start on end and again we can just copy paste this as reference if we need it right so just temporarily just so we know what you doing again this is the result and again we already have to understand how these things work view has some wrapper for this reactive thing but to us we can just use result.current and etc these are just things you understand over time yeah so we can just go here let me just comment this out so we don't run into weird issues again we can go here to tokens we can say result current we already have great auto completion right and then for previous we can just say result previous options this is going to come from the props we're going to say props options which is optional and then we can also pass this from props we can say props on start props on end awesome now we use this as reference and there's another thing which i only know with the power of hindsight so when we look at the next component here, let's just go here. So this is going to be the last component that we're going to look at, and again, I know this because I've already done it once, but the other component that I'm going to pass in is going to be this animate. Because I ran into an issue, things weren't working, I was like, what is going on? And there's some piece of code here that checks if you pass an animate by default prop, if it's set to true, then it's going to animate. Okay, so we're just going to do that, and I only know that because I have the power of hindsight, right? So again, you always run into weird issues, you investigate them and then you realize it's really not that intimidating. Yeah, so we can just go here and we can say animate true. And of course you can also destructure this in other props and you can set a default but it's not going to do it here for convenience. Alright, so we got an error. So let's say requested module does not provide an export named Shiki Magic Move Renderer so I think we made a blunder here. Ah, I see. Okay. Well, let's just yoink this because this is default export. Okay, and let's have it your way. This really isn't important. Alright, cool. So now we can actually save this and we shouldn't get any more errors. Wonderful. All right, so now we can look at the ShikiMagicMoveRenderer component. Okay, so looking at the view code again, let's just go back one step, and then we can open ShikiMagicMoveRenderer. And again, we don't care about the imports. We don't care about this props crap. We only care about what piece of state we need. So the first thing we see here is const container, which is a reference to some DOM element. Okay, so we immediately know that there is some DOM element here that we need to create. And of course, this is a pre-element. As you can see, here is a container, and it has to have this class ShikiMagicMoveContainer and this part really isn't that important but I think I'm going to show you anyhow later. This is just if you're using server-side rendering just so your page isn blank it going to take these tokens and it going to temporarily output some code right and then you going to see once we mount the component here it is is mounted true here it is container dot value inner html we're just going to set it to blank and that's it and now we're going to initialize the render and do the actual animation work so view has this watcher which botches these tokens here when this changes this immediately runs this function where we pass the tokens and this first line is very simple object assign it just merges the render options which are the defaults with the props options you passed in so this is the prop I talked about before if props animate then it's going to check if there's a previous animation then it's going to replace it immediately and then this is the most important part this is going to run this process renderer.render tokens which is going to start the animation and here view is using some lifecycle method which they require in our use case we really don't need to do this and again this is using this optional callback so you can ping back start and then you can await the process until it ends and then you can do something based on when the animation starts and when it ends. And otherwise if there is no animation prop, else we're going to just render replace token, so this just replaces things in place without animating them. And that's basically it. Now we have basically all of the information we need to convert this view component to a swell component. Okay, so this is how we're going to do this. Let's just open this Shiki magic move renderer. I'm going to create a script tag. Again we need to destructure our props the same as before so you can say equals props and I'm going to cheat so I have these types cheeky magic move renderer types render props it is. Okay so now we can just import it from here and how beautiful is this friends. So now let's just save it and again what piece of state do we need? We just need the container. We need a reference to the renderer. You're going to see and then we need let is mounted. Alright so first the container is going to be a HTML3 element and then the renderer is going to be magic move renderer I think. Let's just see if we can import this. Cut this from import magic move renderer from cheeky core cheeky magic move actually renderer. There it is. And then let's just use some piece of felt state. We can just say state false. and we don't have to do anything else. Alright, so we're going to save this and let's just create the pre-element. So again, we need to bind this value. I'm just going to say bind this to the container. That's basically it. And now we actually need this class. So I'm actually going to copy paste this from here so I don't make a mistake, which can be easily

 done right let me just do this and we need this so shiki magic move can hook into this and that's basically it so now we can save this going to format and that's it all right so now we actually have to convert this on mount and watch thing since in svelte 5 instead of using on mount effect replaces that so we can use effect for effects basically right so whatever doll manipulation you have to do don't use effect to update some state use the rise for that but in this case we're actually going to use effect like this. We can say effect and now here we're first going to check if the container exists otherwise we're going to return. So we're going to say if container doesn't exist we're just going to exit and then we're going to clear everything. Container, innerHTML, empty. And then we're going to say isMounted is equal true. And again this is only if you're using server-side rendering and you don't want blank content. All right so here is where we're going to actually reassign the renderer so we can do something. We're going to say new magic move renderer I think. Let's just see. And then we're also going to pass it the container. So magic move renderer. Oh, and we already did it here. So actually let's just do this and it should work. All right, cool. So this is the first effect So this is just going to run once And what awesome about the fact it not like the crap effect from React in Svelte you don have to think about dependencies because this uses a compiler under the hood, so you're never going to run into those same foot guns. Alright, so now we can look for inspiration in quotes here, and we basically just need to yoink this quote and put it in another effect. Alright, so we can actually take this quote, let me just copy it over. We're going to create another effect that's going to rerun since our first one runs only once then we're going to do this I'm going to create function render let's actually make it async and let's just remove things we don't need we're not going to emit anything let's even remove this I'm just going to say await and again tokens come from props tokens replace props tokens and the other things look like they're in place we can also make sure the renderer exists just so we don't run into nasty surprises. So we can say if there is no renderer return, let's just save everything and let's give it a look over. Looks good to me. And also don't forget to run this. So we're just going to run render. And cool As I said we really don have like this dependency array here that we have to say tokens and etc This is just already automagically done for you Alright, but the moment of truth is does it work? So if we go here, for example, and as we can see, something is already going on. So you can see we have the proper syntax highlighting and I'm just going to close this. And now when I click on it, we're going to see this automagically animates. How beautiful is this, friends? hmm okay but there's something going on weird with the theme and let's see okay here we even get an error so property theme is oh of course i forgot to pass the theme because if we go here let's just see yeah here we have on this type that we should pass a theme yeah which we pass to the options right so we can go here and we can just say in this case theme and we can say polymangerous let's just save this and now we're going to see even the background is right because it matches my background color and I can even go to the CSS here and let's just I don't need this anymore I think okay so I just set here also a preview so it doesn't shift and let's just in this case let's text align center so you can save this and we can see now we have our animation working and how beautiful is this friends and another thing we can do actually let me go here so you can invoke your callback what were they called props dot on start but you might not pass this so let actually when you invoke this we can use nullish coalescing so we can do this and you can do the same thing for onEnd, so we can say props onEnd, invoke it use nullish coalescing so we don't get an error now we're going to see our animations work the same as before and we also talked about options which we can go here to our Shiki Magic move component, and besides this we can also pass in an options component since this is type we get all of the great auto completion we can say duration I think this is just 2 seconds you have to type 2000 and then you can even pass a stagger 3 or maybe I'm wrong let's actually see we're going to say duration oops that's a lot that's 20 seconds okay so let's see okay yeah so this is slow great this works as intended and there are some other options you can pass here so for example you can disable container style so you can set the background color that you want. You can also, let me see from the options, you can also disable animate in the container if you want. But yeah, that's basically it. And let me change the direction to something more sensible. And here we have our beautiful animation working. But yeah, that's basically it, friends. If you like what you've seen, don't forget to like and subscribe and you can also support me by becoming a patron. Thank you for watching and catch me in the next one. Peace!