 Hey everyone, I'm Simon from the Svelte team and today I'm going to show you a few SvelteKit remote function demos to answer some questions I got after my recent YouTube video on them. So we're going to talk a bit about authentication guards, how to basically protect routes, managing async loading states, a bit more general than remote functions, but it's a good topic regardless, and what query batch is. So let's dive right in with the first one. authentication guards. How can we protect routes that the user should only be able to enter when they, for example, have the right cookie set? For this demo, we have a very simple form, which when we enter the right passphrase, we will be allowed to enter the guarded route to then see this super, super secret text, which we can now see. And so this, let's make this so that we can no longer see this secret text. And just, I'm just going to clear my site data to see that. Yes. So right now this doesn't have any guards in it. And so let's put some method guards in there. So what we're going to do, this is how our guards the started page basically just looks like. We have three queries, two secret texts, secret text two and secret text three. And we just wanna make sure that you don't can call any of these when you're not authenticated, quote unquote. And what the authentication will just look like in this example is we're gonna just set some kind of authenticated cookie in a real app. You should use like a proper database check. okay, is this correct? And then use proper session management, but this will do for our demo. And so now how can we then check, okay, is this user allowed to see the super secret text and the first one is just to do an inline check. So we're just using get request event and then saying event cookies, get authenticated, if that is not true, then we know the user is not allowed to enter this and so we're gonna send them back to the auth page and so now when I'm reloading this I'm redirected directly back to the auth page so it works. This is fine for one-off checks but probably within your authenticated page you want to protect all queries. And so you probably don't want to write this out every time you have a query again and again. And so what you can then do instead is put this into a reusable helper function. So we're just saying check authenticated. And we're making this a query as well. So we can also do private queries, so to speak. And we're just going to copy what we have up here in there. And then we're just doing check authenticated. We don't even need the wait. Well, I guess we do. But we have to make this async. And this way we're saying, okay, whenever this user is not authenticated, then this query will tell us and redirect. So this is all we need to do. And we could put this up here as well. And this wouldn't cause this query to be called two times. Instead, it would be deduplicated. So when you, in the same request, call secret text and secret text two, and they both call check authenticated, this query will be cached. So it will cache the promise it returns. And then whenever someone else calls check authenticated, we'll just return that cached promise. So this function body will only be invoked once. So if you have some kind of expensive database operation in there, you won't do it over and over again. The third variant is to have some kind of higher order function. And so we're basically flipping this around instead of doing check authenticated everywhere. We are creating a guard query function, which basically is returning a query, which first checks for authenticated. So doing this and that if that is fine, then we're returning the function we are calling. And so instead of calling query, we are now calling guarded query. And all of these things will now mean that whenever I'm on guard it, it will redirect me back to auth. And if I now do enter the secret phrase, I'm able to see my super secret text. So this now works. And this is how you can do authentication guards with remote functions. next up managing async loading and error state so there was a few questions around how with these new primitives async svelte boundaries and so on how do we do loading and error state in a svelte or sveltekit application and for this we're first going to have a look at how it basically what the built option was for a long time and that the wait block which is not recommended anymore So the wait block is here and we have two requests and we basically want to show them both And so we do the whole await, pass a promise. Then this is the result. Show the result. If you catch an error, show this. This is all you need to do to interact with async data, but it will not work on the server. So on the server, we'll just show the pending snippet. And you have to repeat it over and over again with, so if you have more than one request and I have to put all this wait, then catch and so on in there again. there again. And now if I, for example, have a query that depends on the result of the first one, I have to also do this again. So I have to nest it over and over. And so this is really, really tiresome and cumbersome. It also means that the async work is not coordinated. So it will show this loading spinner and this loading spinner and then this So like loading, loading, inner loading again. And so it's like a lot of spinners that keep going in and out and that makes for a very janky UI. Ideally, you just want to have one pending UI for the whole thing. And that is where boundaries come in. So using boundaries. using boundaries. And so the recommended way for what basically to interact with async data is to use Svelte boundary. And Svelte boundary, some of you may know already because it's a new thing in Svelte 5. And so far it has enabled you to catch errors in your UI and then show some kind of error UI. But you're also able to use it to show pending UI. And so what we can do in here instead of doing whole await dance, we can now just use the await keyword in line in our template. And we're just saying, okay, show request one. And then we're just saying, we also want request two. We can put this directly in a function expression. We can put this in a const. You can basically use await everywhere in the template now where you would expect it to. And we're putting it inside a result const because A, we want to show the result itself, but also because we have some dependent inner request, we want to pass the result into the inner request to basically do the same we do with the inner await block here just to show how you would do that and so in here it's just these few lines of code and now what we need is a pending snippet which will show up while the UI is loading for the first time So now when I refresh this, you're seeing loading here once and then everything comes in together, whereas up here, loading, loading, loading, loading. You could, of course, put in your boundary around these weights to make them more granular, but you don't have to. So you are free to make it as granular or as broad as you want it to. and every await inside the boundary will be coordinated so that the UI updates together. And this is the big advantage compared to the regular await block that the work is coordinated. It will also, once async SSR is available, which very, very, very soon, basically it's already out. It's just not integrated with SvelteKit yet. But once that's there, you can also use async SSR with this. And that is another advantage because this wait block just doesn't work with SSR. It will always show the pending snippet. Another difference with this is when I now fire a request again, like an update, it goes back to my loading state. And most of the time, that's not what I want. So what boundaries do instead is they show the pending boundary only on initial data load. And on refreshes, it basically waits until the data is resolved. So we click, and then after one second, it shows me the new UI. And in order to make some kind of affordance to see, okay, the user has clicked something and something happened, we can now instead use the effect or effect pending to make this work. So in this case, I'm putting the loading class onto this div and it should be applied whenever pending is greater than zero. So effect.pending returns a number that is the number of asynchronous requests that currently in flight And so if the number is greater than zero then I want to apply this loading state And as a result I can now see the initial one And now when I click this we see everything goes opaque for a second here. So next up, how do we do the error state? And this is where the already known failed snippet comes in from the boundary. So we're just going to say error. Let's just say an error code. It's fine. So in here, when I'm now saying, okay, this is all loading and I'm saying, okay, the next request that should error. and in this case it's loading and it's showing the failed UI for this await block but it's not showing it for the other ones whereas again with boundaries everything is coordinated with one and so when I'm firing this request the whole thing will get replaced with error boundary and again this works by checking okay the error occurred in this place let's walk up to the next boundary that has a failed snippet and then show that. And so again, this means you can make your error UI as granular or as broad as you want. And we also in SvelteKit, we have this pluserror.svelte. This isn't directly integrated with the new async work yet. We have to find a way to make that possible in a way that is non-breakingly for existing users so yeah give us some time there to to figure that out but once it's there plus error.svelte svelte kit will also work basically like a boundary with a failed snippet under the hood cool now you're using await await basically means it's coordinated but also it's blocking together but maybe you want to have some other asynchronous work that should not be blocking in that sense or should be independent. And for this we can use something resource-like. So in this example here in this variant, I've created a little resource function. So we have a current state, a loading state, a narrow state, And then we just have an effect sets loading to true calls the function. And then depending on whether or not the request succeeded or failed, we'll set current or error to true, to the value, whatever value that is. And then we'll just return a bunch of getters. And we can use that now inside here to just use if blocks. So I can say if results loading and the current is still undefined, which means it's the initial load or result error, then show loading. Else if there's an error, I'm just going to show the error UI else, everything's fine. And so I can show the result that I get from ZultCurrent. And now we basically have turned our async resource into something. So do this here, loading, result loading. And this way we have turned our async work into a synchronous resource. I'll see that in here. So we have now the resource pattern. It's showing loading initially, then result zero. We're firing a request. It's going opaque for a second, then showing the new result. If the request fails, it's going to show the error. I'm going to reset that, fire the request again. It's going to show the next result. So this works as well. And the nice thing is you don't have to create this resource yourself. It's basically what the remote query functions in SvelteKit give you out of the box. So I can just use this with remote queries. Basically, remote queries allow me to use all the variants that we have shown above in any way I want. So in the example right here, I have a slow query. I have my regular request. Both are using await, so they are coordinated. And I have a non-blocking query. It's also, again, just the request. And we make it non-blocking by using the .current instead. And so what that means is now when I refresh the query, the slow query will be updated. the blocking query will be updated and the non-blocking one will be updated. And because slow query and blocking query both use the wait keyword, they will update together because they are triggered at the same time. But non-blocking will update whenever it's ready and this one will be faster than the slow query so it will update before. So I'm going to click refresh and seeing this updates, Now this updates. This updates Now this updates And so yeah depending on your use case you can basically do everything you want with this You have await for asynchronous coordination You have dollar effect pending to show affordance when you're re-entering loading state. If you don't want to use await keyword because you don't want to enter this coordination, you can also use query functions in a resource like pattern. with the dot current property, for example. Okay. So last one, query.batch. What is it? So query.batch is used to solve the so-called N plus one problem. And the N plus one problem is when you do repeated requests, many requests at the same time to the same resource, basically, but with different payloads. So in this example, I'm showing the city weather for New York, London, Tokyo, Delhi. And if you look at the network tab, we can see that it's doing four requests to our weather query. And so our weather query looks like this right now. So it's just a regular query. And now instead of making four requests, we only want to make one basically. Because imagine some expensive DB operation is in here. Then I don't want to make that expensive DB operation four times in here. Ideally, I want to make it only one time. And in order to do that, we can turn this query into query.batch. and instead of city this is now a list of cities so on the client it will wait one macro task collect all the requests to get weather turn this into an array send that array to the back end the back end will call query.batch with this array and now it's our time to implement the response correctly. So instead of just returning one temperature, we're returning a list of temperatures now, or rather we're returning a function. We're going to see that in a second. So we get the list of cities and for each city, I'm just going to put the city in here and the temperature for that city. And now we have a list of city and temperature objects. And what query batch wants us now is to return a function, which is called with each of the inputs one by one, so that we then can return the corresponding result. And so in our case, we're just doing a temperatures.find. Find the temperature with the correct city. We know it's there, so we can use the exclamation mark. And then we're returning the temperature. We're not just returning the array here because in real life, if you do database operations, it's not guaranteed that the result will be in the same order as your input. And so it's safer to return a function instead, which is called with each input and it expects the corresponding output. And this is how I implement query batch. And notice how I didn't have to change anything in the UI. So I left the weather component, which is just doing city, wait, get weather, city. I left that completely untouched. So for the client, it's exactly the same interface. It's just for the backend. On the backend side, we have changed the implementation. And now when I'm looking at this, I can now see that I'm doing only one request instead of four. And this is how query batch works. Speaking of queries, some people have asked us, hey, remote functions, especially the query function, that looks really nice. Will there be something built in when I don't want to use SvelteKit SSR or even SvelteKit? And the good news is, yes, there will be something built into SvelteCore. So we're actively designing a resource primitive that will look very similar to what the query, remote function query API looks like on the client. And in fact, once we have that in core, the query function will then reuse that to implement the client side. So, yeah, stay tuned for this. We're going to have some built-in resource-like API in Svelte itself soon. Speaking of more enhancements, some other people have asked me about more details and demos around form. the mobile function forms, and I'm going to do another dedicated video to that soon. We're currently working on tweaking the API for forms, so to make some cases even easier to work around, to work with, and once that's ready I'm going to do another video on this. Okay, that's it for me. Hope you got something out of this and yeah, let me know if you have any more questions and see you next time.