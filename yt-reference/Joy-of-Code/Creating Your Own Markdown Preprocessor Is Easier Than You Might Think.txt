 Hey friends, what's up? Today I have something really cool for you. Today we're going to make our own MD Svex. So you might have used MD Svex in the past, so this is really an awesome preprocessor for Svelte. You can use this to use Svelte components inside Markdown and vice versa. And if you're interested in just using MD Svex, I have an entire video on making a Markdown blog with SvelteKit and MD Svex. But today we're not only going to learn how this works under the hood, because we're going to recreate a bit of a mini MD Svex, right? We're actually going to learn a lot about how Svelte works and etc. And I think that this is the ultimate markdown experience that I want because I want absolute control over it. So let me show you here in our example. As you can see, this is just a regular markdown block. Here I'm using a counter component in Svelte, nothing special. Here I have this widget, which we can look. Here I have this markdown text. I can change it so you can have interactive examples in your post to make them more interesting, right? Let me just change this color orange-red. Let me actually show you something interesting. So in this case, maybe you would want to use an iframe or something because here we're using this if we remove title and we press title we're going to target the elements on the page and this is also kind of like really interesting maybe we can make like one of those block cmss with live editing and etc i don't know this is very interesting in my opinion but yeah you can also target let's say for example we can target the p tags on the site and you can see this looks like a complete disaster right so maybe we can revert this to titles just so this is affected as you can see here we're using a modern syntax highlighter shiki which is really awesome and I also have an entire video on using Shiki and why it's really awesome. As you can see this is a really a perfect example using this Svelte code snippet why Shiki is so much better than your standard syntax highlighter because we have something like this which is a Svelte syntax we don't really need to specify this syntax it works absolutely beautifully and the syntax highlighting is simple. You're going to be surprised how simple it is to implement something like this. And yeah that's basically it. In the next part I actually want to show you how a preprocessor actually works, so what is our goal, and etc. How are we going to achieve this, right? Just to understand what a preprocessor is, even though I have also an entire video on preprocessors in Svelte and why they're so powerful. Alright, so if we look at our markdown, here is nothing special. This is just a regular markdown file, which is our post, and this gets actually treated as a Svelte component. I'm going to show you how that works. So here we have this front matter, nothing special. But as you can see, now we can use our script tag because this is actually just treated as a Svelte component. so we can import our components here here i have a counter and widget and if we look at them we going to see nothing special I can also show you the widget So we can open the widget And if you wondering how I made this widget it really just a cheat for a simple editor I just stacked a pre and text area on top of each other. So I get this awesome syntax highlighting using Sheiky again here. Very meta, right? But actually, I want to show you how this actually works. So what is our goal? So you better understand the power of a preprocessor in Svelte. alright so if I open a new pane here on the right let me just copy over everything I'm going to create a new file and I also even kind of don't want to even include syntax highlighting because I kind of want you to understand that this is just a string and whatever string is here we're going to feed to the Svelte compiler and before we do that this is where a preprocessor comes in because we can actually write a preprocessor that can turn this string into anything we want so any valid Svelte component syntax is going to be valid at the end and actually let me show you what I mean by this so actually I can copy the same code again this is a new file let me just use the pointer but I'm going to change the language mode back to swelt or whatever so actually our goal is going to be here to turn what we have on the left to an actually valid swelt component so for example here we have this front matter what we're actually going to do is we're going to use something like grey matter to parse this thing and then we're going to have an object and then we can use context module so we can say for example I think it's context module or module context it's really not important and then from here we can actually say something like export meta and then we can export an object with all of our data right and also imagine what possibilities this unlocks like this isn't just for markdown etc you can make useful pre-processed for anything you want for example let's say that maybe you want a table of contents on your page you can just export a table of contents right and now boom you're going to have this actually on your page not just inside of your markdown where you have no control over it, right? You can actually have a table of contents. You can do whatever you want. And then the rest of this is also going to be very easy. So we're going to just turn Markdown to HTML and we're going to use a Markdown preprocessor, right? So everything here that's not Markdown is going to be ignored anyhow. So this component, for example, is just going to be turned into a H2, right? So this is going to, at the end of the day, turn into something like this. And this is how simple this is. This, of course, is going to be a PTAG. And this is basically what we're going to do using a preprocessor. That is how simple this is. So anything that we can turn at the end of the day into a valid Svelte component is what you can do using a Svelte preprocessor Oh and by the way if you don know what context module is which I don blame you for this is something that it kind of rarely used to be honest If you have a prop drilling problem you should probably use the context API. But in this case, it actually works great because we want to export something on the module. But what the heck is actually a module? Let me just explain this quickly. So for example, let's say that you're writing here something like function counter and etc. So this file where you're writing your JavaScript, etc. is a module, right? And under the hood, this is how actually components work because in 12.5 and moving forwards components are just functions, right? But for example, let's say that you have multiple instances of a component and you want to share some state across them. Well, actually instead of defining it inside, we can define it inside context module. So as I showed you before, we can just say cons meta and whatever we put inside of here is going to be available in each of these counter instances. And that's how simple that is. So now we can take that, we can just parse out the front matter. So actually in the next section I'm going to show you how I have this project set up because I'm not going to do everything from scratch. But if you want to dive deeper into it, I'm going to have a link in the description. All right, so here I have a simple SvelteKit project. I'm importing this SvelteDown preprocessor from source lib SvelteDown. This is where we're going to spend most of our time because we're just going to focus on making the Markdown preprocessor, right? And we have to specify the .js extension because we don't have really any preprocessing here from Vite because this is outside the scope of the SvelteKit project. but you can publish this as a library, maybe somewhere else, and then you can use all your tooling and etc. Whatever you want, if you prefer to use TypeScript and etc. And the only important thing here is using extensions, right? So you can specify extensions.svelte and .md, but this can actually be .banana if you want, and this is going to work, and maybe you can also associate the .banana file with something else, but you can actually specify anything you want. And here what you specify is going to be treated as a Svelte file. If you want to learn more, you can watch my entire video on a Svelte preprocessors. and here is the actually also important part here we're going to pass this preprocessor and it has to come before anything else so we want to turn this string into something else that we can pass to the Swell compiler and this is also going to get changed by the VIT preprocessor, right? if you're using SAS, TypeScript and etc so we want all of this to be done before it gets passed to the VIT preprocess and here another important thing I have here since I have in the root here POS so this is how I want this to work I want to have an example here and I just want to have posts inside of here and components, right? And that how I want my markdown structure to work So I going to just dump posts here and I want to include any component that I might want Another thing that you have to do if you going to have this post folder at the root in your vidconfig you have to actually specify this option server file system allow so this is going to go one step up to serve files right otherwise you're going to run into some weird vid error right but that's how we can do it. And for the actual project there really isn't anything else that you should do. This is just really under routes. I have this post route. Here I have this page.svelte and page.ts where you're going to get the data. So here if I open page.ts, as you can see, because we specified .md to be treated as a Svelte file, now we can import it here as a module. And you can see this is how this works. So we can get the content from the module and we can also export the metadata, right? And this can also be table of contents, etc., whatever else you want. As you can see, if we go to plus page.svelte, we can just get the data from the props and we can output it on the page. And this is how easy peasy lemon squeezy this is, friends. But in our case, we're just going to mostly work inside lib slash swelldown.js. And you can actually see how simple this is. This isn't actually any amount of lines of code. It barely has any lines of code, right? You're going to actually see how simple this is to create something like this. All right, so let's start working on the Mardon preprocessor. And here I'm going to save us a bunch of time from installing all of these dependencies so you can do that yourself if you're following along but basically we're going to use unified which is just a tool chain for working with text so we can convert markdown to html html to markdown and etc there's other formats but you probably heard of this and their plugin ecosystem which are remark and rehype plugins so for example here i have this remark github flavored markdown so we have tables and a bunch of other things and then i have remark smartypens so remark smartypens is going to use actual typographic quotes instead of those fake quotes that you use in your post, right? And then we have something like Rehype Shiki, which is going to be used for the syntax highlighting. And then I'm going to use Gray Matter for parsing from Matter, so we can return back the content and the metadata. Alright, so the first thing you have to do is actually declare our preprocessor. I'm going to name this SvelteDown, but you can name this whatever you want, right? And let's just say Export Default SvelteDown. This is actually going to be it. There we go. And now we also have to return now some methods, so we can actually change the script section, the content section, which is going to be the markup, and the style text section. But in our case, we just want to change the content. And again, if this is going too fast or is confusing to you, watch my entire video on how preprocessor in Svelte works. So this is going to be an async function,

 up and now we can destructure two things. We can destructure content and file name. And that's it. And now we can say for example console.log content and you're going to see this is going to log everything. So let's start the development server and you're going to see it's going to spit out everything that it opens. So let me just refresh this. And you're going to see it's all of the components it interacts with once it boots up. But this is the reason why we actually picked that .md file but it can be whatever you want. It can be .banana and etc. So to only console.log content if filename ends with .md in our case. And let me just console log out. And again, the only thing that sucks here is we have to restart the development server when we're updating this file here. But you're going to see now we only get the input for our markdown component because we're only targeting .md files. And another thing here that sucks is this vague error message. So for example, could not find the example. And it's really annoying because where is this error here in our terminal, right? So how can we know this? And basically, this is a scale issue because that's a me problem. So for example, here in plus page.ts, I actually have this error here. Could not find post, but we actually should output something more useful. So let's say, for example, in this case, let's output the actual error. And you're going to see now when we refresh this, let me just see. Now we should get this error. So this is more verbose. And when we read this error here, it says post example, blah, blah. A component can have a single top level script element and a single top level script context module element. Okay, so this might sound confusing, but actually if you just go back to our post and if you just strip things down one at a time, you're actually going to find what this error is. In this example, the problem is we have this call block, we're using this script, but this actually closes this script tag, right? So Svelte is really confused and we also have this problem because these curly boys are going to be interpreted by Svelte as an expression, right? So let me actually prove this to you. For example, if I remove this call block, everything should work. Of course, it looks like junk, but actually we're not going to get any error. so you're going to see everything works as expected kind of right but for now i can just return this and when we get to processing the markdown we're going to uncomment this but for right now let's just comment this block and that's basically it so now we're going to see if you refresh everything is going to work as expected now we get more useful errors okay so let's start with the low hanging fruit which is going to be front matter so i'm going to go back here to our code and i going to create here a front matter function so we going to process front matter is going to take in content and that basically it Alright so now we can use matter and we can actually destructure two things here So we going to pass content to matter So we can get back two things, content and data, which we can return here. We can return content data. But the problem here is that we already have content here. So let's rename content to markdown and then we'll just return that. Say markdown here and that's basically it. So here I'm going to yoink this and now we can destructure from our front matter two things. Again, we're going to pass the content. So now we're going to get back markdown and data. So if we console log this out, console log markdown data, let's just restart this, refresh the page. So now we're going to see that this is actually split in half. So we can see here we have our markdown, which is this, right? So we can see this is our plain text and here is the front matter. So actually this is parsed for us. We don't have to do anything special. So now we have title, description, date, categories, publish, true, right? So this is from our front matter. But to make this available here to our component, we actually have to return this on the module, same as MD Swags does. So what we're going to do here, I'm actually going to create a meta variable. And let me just use template literals like this. And again, we just need to construct a valid Swell component. This is absolutely awesome. So we can say script context module. And we just need to export the metadata, right? So we can say export const. We can say metadata. And now we need to serialize this because we can just really pass data, right? This wouldn't work. So we actually have to say JSON stringify data. And instead of data, now we're just going to pass meta here. All right, so now we're returning markdown and meta. So now we split our front matter and content. So we actually don't even have to worry about removing the front matter, right? how beautiful is this friends and now actually it's really so much easier with TypeScript but we're moving blind here friends so we can just actually say meta and let's just do this let's save everything and again since we made changes we have to ctrl c kill it and start it again and let's just reload this just so we get everything here and now you can see here we get our markdown content and here we get the meta so this is just a string and of course everything in programming is a string which is absolutely beautiful. But this is actually going to be a valid 12 component. And now when we import this mardanPost as a module we can actually destructure this from it So let me actually show you that To actually return the changed value here is what we need to do Let me remove this. We have to say return, and we have to return code, right? So we can, for example, say code content, but in our case, we actually want to return meta plus the code that we have. So for example, meta plus markdown. Let's just restart everything. Now when we go here and refresh, you're going to see now everything works because this is actually the front matter that we parsed and again if you're lost let me just reiterate that here we get the data for the page from the post here we're importing this from the module right and then we can just pluck those values so for example this can be content metadata it can be table of contents it can be whatever you want so now that we have this we can send this to the component itself so let's just go to the component itself in source routes slash post, right? And now we get this from data. What do we get? We have meta. So we have data.meta, where is our metadata from the front matter, and we have data.content, which is our content itself, right? And how beautiful is this, friends? All right, so now we have the content, but we need to parse the markdown, right? And this is going to be very simple. So I'm going to go here, and I'm going to say async function, I'm going to name this parse Markdown, which is going to accept content. And the only thing we have to do is create a Markdown preprocessor. Or processor, right? Since we're using unified. So they're called processors. Yeah, so we can just say const processor. And now we can say unified. Actually, let's await it. So we can invoke unified. And I'm going to go to a new line just so everything is neat and tidy. All right, so now we have to turn our Markdown into an abstract syntax tree so we can parse it, right? So for this, and using unified, we can just say use. and we can say to markdown AST. And then we can use the markdown plugins. So I'm going to say remark, GitHub flavored markdown, and I'm also going to use SmartyPans, but you can include as many plugins as you want. All right, so now when we're done with markdown, we need to turn this into an abstract HTML tree. So we can say .use to HTML AST, and we have to allow dangerous HTML because we're using things like script tag and et cetera, which otherwise would get parsed out or replaced with HTML entities. I'm not sure. Alright, so now when you have this HTML3, this is a perfect time to use our Rehype plugins. So now we can just say Rehype Chiki, and boom! We can also pass it some options for example which team I use I always get as this I use Point Managers and this just happens that this is a team that chips with cheeky if you have some more esoteric team you can of course load it all right so now that we processed all of this so now we have a tree right we just need to turn this into html string that we can render so you can say use to html string and again we have to set allow dangerous html and that's going to be it and now once you're done, you just have to say dot process. What we want to process, we want to process the content. And because this returns a processor, we actually just want to return the result of this. To do that, we can just say return, and you can just say processor to string. And that's basically how simple that is. Awesome. So now here, where we have our mardown, we can just convert this or transform it from mardown to HTML. So you can say pons.html equals, you can say await. What we want to do? We want to parse the markdown. So we just pass the markdown and that's how simple that is. And let me just console log it out so that you see that it's true. So I'm going to restart everything. Just restart the development server. Refers the page. And boom! Now you're going to see all of the markdown is going to be transformed. You can see our component title went from markdown to HTML exactly as it should. But actually you're going to notice that we're going to run into some problems. Because for example you can see how we're passing this counter component with this curly boy which is perfectly fine. This is a regular Svelte component. But remember what I told you about expressions. This is where we're going to run into a problem. As you can see for example here where it's on click and it has this curly boy, Svelte is actually going to try to interpret that as an expression. So here for example we actually don't want to return code meta plus markdown we want to return meta plus html. So when we save this, let me just refresh this, we're going to run into an error. As you can see we get an internal error. And you're like okay, what is this? Count is not defined and etc. And then you just start looking at this massive error, which might look confusing, but actually it makes perfect sense. Because for example, let's just go back to our blog post. Again, I'm going to remove all of this. As you can see, it works fine. Again, that pesky component, right? So what we have to do for the last part, we actually have to replace those characters with HTML entities. All right, so going back to our code, Beautiful. Alright, so now let's leave it as is and now we can actually create a new function here. And I'm going to name this function escape HTML. This is going to accept the content and I'm going to

 earned escape content. And let me actually close the terminal. And for this part, actually, stick with me because this might seem a bit weird, but there's a method to my madness. So for example, what I'm going to do, I'm actually first going to replace all of the entities in the file, then I'm going to specifically target the components with regex, and I'm going to return them back from HTML entities to the regular curly boys. And I'm doing that because you actually run into some weird issues and annoyances with how you convert that using regex, right? So it gets It's really complicated, but I actually found that this is the easiest way. And of course, you can do this your way. So the first thing we're going to do, we're going to reassign content. I'm going to say content replace. So we're going to actually pass this regex here. We're going to use the opening curly boy. Let's just make it G or global or gangsta, whatever you want. Cool. And now we only have to replace it with this HTML entity, which is going to be ampersand found side 123 and then colon. And let's also do the same thing for the closing curly boy. So we going to say replace It going to be closing and it not 1 2 3 but it 1 2 5 Okay so now that we converted all of the text we just want to revert the components So for this we going to use a component regex I'm going to say, cons, component regex. And this is really simple. So here we're going to create a regex. We're going to say it has to have this opening pointy boy. It has to start with a capital letter, so we can say A to Z. And then we can match everything after that. Of course, you can be more concise with this. you can target only the components that have the curly boys in them, but that's up to you. I haven't found a problem with this approach yet. And of course, let's add the global flag. All right, so now we just need to find the components, loop over them, and replace them. So I'm going to say cons, components, and then we have to say content, match, and let's pass it the component regex. That's basically it. All right, so let's say components, and they might not exist. So let's use question mark for each. So now we're going to loop over the components. And first we need to replace the value of the component so we can replace the old value with the new value. So we can say const replaced and we in this case need to do the opposite thing for the component right So Svelte treats it as a regular component So we can say component replace And here we're going to first start with the entity. So let's just copy this over so we don't make a mistake. And what do we want to replace it with? With the opening curly boy. Alright, so now we can just copy this over because we want to do it again. But for the closing curly boy. So let's just close it. And instead of 1, 2, 3, it's 1, 2, 5. All right, so we just need to return what we mashed with the updated or replaced component, right? And that's how easy peasy lemon squeezy that is. All right, so we can reassign content. We can say content replace. Replace the component with what? With a replaced one, right? And then once that is done, we can just say return content. And that's actually it. So now we can go here to our preprocessor. Below HTML, we can actually say cons code. And we can just say escape HTML. we can pass in the HTML, and now instead of returning meta plus HTML, we can actually return code. Alright, let's save this. I'm going to restart the development server, and let me actually log this out just to see what going on Also log code Let do that And now we actually going to restart And now if you look at our component everything looks right Here we have the script Again, we're just aiming to make a valid 12 component. Nothing special. As we can see here, this looks right. This is our regular component. So we did that right. And let's actually see when we look here, this should be replaced with our HTML entities. So we should find no curly boys here. So remember how it was complaining about count or something because it couldn't find it? Well, here it is count. and again, it's not going to be interpreted as an expression by soil because we're actually replacing this with HTML entities. How beautiful is this, friends? Alright, so now when we go here, and even if I refresh it for good measure, you can see everything works beautifully. So now we can also change this and do whatever else you want, right? Alright, that's basically it. Regardless if you just want to make a blog with empty swags or if you want to learn how to do it yourself and have complete control by making your own custom Marathon preprocessor, I hope you at least learned something. Alright, so if you like what you see, don't forget to like and subscribe, and you can also support me by becoming a patron. Thank you for watching, and catch you in the next one. Peace!