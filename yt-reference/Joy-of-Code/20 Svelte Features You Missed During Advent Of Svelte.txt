 Hey friends, what's up? This year's Advent of Svelte, the Svelte team is absolutely cooking. They've been releasing one feature a day until Christmas, basically. And as you can see, the list is pretty long. They added over 24 improvements. And of course, I'm going to share all these links in the description so you can even read this thread on Blue Sky, where they posted each day during Advent of Svelte. Alright, but before we get started, here's a message from our sponsor. I'd like to thank this video's sponsor, you, the viewer. you can support the channel through patreon or a youtube channel membership members get early access to videos help shape the content and a special discord role you can find all of the links in the description thank you for your support all right so the first thing that's well added is error boundaries so let's look at what are error boundaries so to prevent errors from leaving your app in a broken state so you get an error during rendering whatever well now you can use a svelte error boundary using svelte at colon boundary and let's actually look at their example so here we have some flaky component that's acting unpredictably. This is usually something you don't control because of course you're going to do error handling yourself. But let's say you have this flaky component here and now we're checking the mouse position and now when you go boom it's actually going to take down our entire app. But we can actually fix this using an error boundary. So you can just press solve and now it's going to introduce these error boundaries. So now we can pass it a non-error prop and you can send this error to some service, whatever, or you can actually provide a fallback using a snippet which is named failed in this case. You can just pass this inside here so you don't have to specify this as an argument or a prop that is all right boom so now when we break our app it's not going to take everything down it's going to gracefully crash and now we can resume what we were doing before and you can see it works the same as before and this error boundary thing might look boring to you but this is actually a precursor to something more awesome so now that you have error boundaries in svelte you can enable things such as acing data loading patterns like suspense so for example in swell kit wouldn't be awesome if you can fetch data at the component level instead of the page level and that is basically what this feature is going to enable possibly in the future but basically that's svelte error boundaries all right the next feature is a great quality of life improvements and that is each without s so for example you often want to loop over x amount of items in soil but this is a bit boilerplate for example you're not using really this value in s so you just say blank and then you just want to access the index and you can give it any name you want. So actually this is now way easier, you don't have to do any of this, you can just ignore as, and now we can just get access to the index, so in this case it's rank and file, and now we're going to see it works the same as before, so we can output this checkerboard pattern. And that's basically how simple that is. Alright, so the next feature by popular request is the ability to export snippets. That's right, now we can export snippets. So in this example here we have just a simple SVG that's looping over a bunch of icons, but if you look at snippets here. Here we have gift, tree, and Santa, and now we can just export them as long as it's not referencing anything inside of this component. The only important thing is that we're using here script with context module, so this is not a regular script, this is script module. Now we can export this from the module itself, so we can say icons, and this is just array of snippets, and if you didn't know, snippets are just functions. So let's see how they're using them here. So in app.svelte, they're just importing icons from this Christmas.svelte module. That's basically it. they're picking a random snippet from here and inside this loop it might look weird but keep in mind snippets are just functions so we're going to pick the snippet or the icon and then we're going to invoke it so we can render it that's basically how this example works all right so now you can enjoy sharing your snippets all right let's talk about default form value so everyone knows and loves the bind directives in swelter we can easily bind the input value using the bind directive and while you can easily specify default values what if we want a default value once we reset the form Well, now you can. So if an input has a default value and is part of a form, it will revert to that value instead of the empty string when the form is reset. As you can see here, we bind this value and then we specify this default value. So when you reset the form, you're going to get not the empty string. But keep in mind that for the initial render, the value of the binding takes precedence unless it is null or undefined. So for example, if instead of this value, you had banana or something, once you reload your page component, whatever, instead of this default value is going to use this value. So let's actually look at an example. So here you have Dear Santa, This Christmas I Would Like, and a list of presents. And how this works, it's wrapped inside of this form. So now we're going to parent the default behavior, and then we're going to alert the user with this message. Alright, so now we can just send our letter, and we're going to see the else received your letter. Alright, so now if we start over, we're going to see this text area has a default value, a lump of coal for some reason. So if you're Thomas the Train, you're going to be very happy, but as you can see here we have this input type reset. So now when we start over, we're going to ask Santa for a lump of coal. But basically that's it. And remember if you have a piece of state here that has some value, when you reload this component is going to use that value instead. But that's basically default form values in Svelte. Alright, so the next couple of features are really awesome So Svelte introduced this reactive browser API So you can just import something like media query from Svelte slash reactivity you also have things like prefers reduce motion from svelte slash motion so now you can just create this media query here here we have a derived rune so we looking if the user has prefers reduce motion then we're going to introduce less motion or the normal amount of motion you can see it just works as expected if you look at this example so now this is just an svg which has some transitions inside but what's actually more powerful about this you can check out my entire video i made on this is actually this new function create subscriber so you can actually create this reactive browser apis yourself it's not just limited to browser apis you can actually make these kind of reactive subscriptions yourself and if you're interested in that watch my latest video where i actually create this create subscriber function from scratch so you can actually understand how this even works but of course you don't have to and you can just use create subscriber or you can use any of these predefined reactive apis that's that Svelte created for you. So now we can get our nice little present. Alright, if you want to add some character to your site, you can use the Motion module from Svelte. And this is really awesome when you have a value that you otherwise can't animate with CSS. The alternative would be to use another JavaScript animation library, but fortunately, Svelte has this built-in using the Tween and Spring class. In this example, we have a simple progress bar, and it looks really jarring if we go, for example, from 0 to 50%, but we can actually use the Tween store from Svelte slash Motion, and now you can smoothly animate this value over time. And you can imagine this being something else, like a Pokemon game where you fight monsters, now you hit a monster and you deplete their health bar, now you can see this smoothly animates. Please don't zoom in, Nintendo. And besides the Twin class, you can use the Spring class for Spring Physics. So in this example we have a circle that follows the mouse, which looks really boring, so we can actually spice this up using Spring Physics. So instead of using Twin, we can actually import Spring from Svelte Motion. And now we can use Spring Physics on our site for some cool effects. and we can also change some other options here. You're probably familiar with these features in the past if you used them as stores, but now Svelte modernized them to use runes. But basically that's how simple it is to add motion to your site. Alright, let's talk about a really cool feature which are function bindings. So we already know that we can bind values from inputs very easily, but what if you could specify your own getter and setter for validation and transformation? As you can see, the syntax is really simple. You can of course do the same thing as you've done before when you pass a single value, but now you can also pass a getter and a setter. Alright, so in this example we're returning a reactive value, and then in the setter, whenever this value changes, we're going to transform it using two lowercase. And we can look at this Christmas countdown example. Here we have selected the first month, so it's 24 days to go until Christmas. And here we just specify min, max, and the date. And we have some reactive state, and now this is the really cool part. Here we have this input date, we have bind value, but we're using a getter and a setter. So here in the getter we can just say return date, so this is this reactive value at the top and now we can say to iso string we can slice it and we can return whatever we want. All right so now whenever this value changes we can actually validate it and now we can reassign this reactive value date to a new date with that value. And I also have a sneaky console log here so we can actually see what happens here. So now we're going to see we're going to log this when we change the date. So for example let's pick the 12. All right so now this is 13 days to go until Christmas and now we're going to see is going to output this which is validated. And as you can see, this is a really powerful pattern. Alright, so here's another great feature that improves error messages. So for example, here we have some reactive piece of state user, but the important thing is that most people don't realize that when you pass an object to state, it becomes a proxy. So when you want to log the actual value of this proxy, it becomes a bit difficult because it's hidden under some target property or whatever. But actually, Svelte can intercept that you're trying to read this value and it's going to give you a snapshot of that. So for example, this is what you would otherwise have to do. Let's say that you want to log the actual value of this proxy. You would have to say state.snapshot, and then you can pass in the reactive value. And you're going to see, you're going to get the actual value instead of this weird proxy. So what Svelte actually does is that it knows that you're trying to read this, and then it's going to use this for you. So let's actually look at their example. So they're doing the same thing here. They're going to log the user. So now when we press the button, it's going to log the snapshot for you. but another new feature is that besides giving you this useful warning, now it's also going to link to the documentation so you can understand the warning. We can actually see when we log this value, we're actually going to get this snapshot here, which is just the regular value that you expect, but if you weren't using this snapshot, you would have to go for this proxy. So let's say this is target, and then you have this on target, which can be confusing if you never use proxies. Alright, so let's talk about two new awesome sveltehooks, init and transport. So if you need to do something once when the server is created or the app starts in the browser, then you can use the init hook. So you can see how simple it is. You can just define this init function here, and then you can do inside of it whatever you want. But this next hook is really off the hook. Alright, so here's the transport hook, and this hook is really cool. It allows you basically to pass custom types return from load and form actions So for example we can look at this example if you using something like a vector you can actually specify how this can pass the server and client boundaries So you can encode it you can say okay if value instance is vector then you going to return an array of x and y coordinates. And then you can decode it back on the client, you can create a new vector out of these coordinates that you returned from the encode function. Basically, you can return a bunch of things from the load function. So SwellKit actually supports returning maps, sets, dates, and so on. But basically what transport gives you is the ability to define this yourself. So you can actually look at an example of this. So this is some reactive user class where you have first name, last name, avatar, greeting, and so on. That's really not important. What's important is when you try to return it here. So you're saying user, new user, you're passing Santa Claus, and you're passing this icon. So here in page.sale, you're trying to use this, but you're actually going to get this internal error. So let me actually show you this error message. So it says error. Data return from load while rendering is not serializable. Cannot stringify arbitrary non-podjos. And basically what a podjo means, it just means plain old JavaScript object. It's basically saying, hey, whatever you pass to me, I can turn this into a regular string. And this is where transport hooks come in. So I'm going to uncomment it here. Now we're going to see here where we have in code, we get the value. We check if the value isn't instance of the user, then we're to return it otherwise we're going to return this array of the first name last name and the avatar and now we can use this value when we decode it so now we can actually return new user with the first name last name avatar and as you can see this works expected so you can say for example centiclaus or whatever and you can see this is reactive all right so another cool feature that svelte introduced is the new svelte reactivity window module and basically this module exports reactive versions of various window values so you can reference them in templates derived and effects without using Svelte window. So if you ever use Svelte window, it's really great, but it's a bit boilerplatey because you have to bind every value. So now we just have these values exposed to you, so you can use them anywhere. And we can even look at an example. So instead of using Svelte window, we can just import inner width and inner height, for example, from Svelte reactivity window, and now we can just use this as is. And now we can see if we resize this window pane, it's going to be reactive. How cool is that? All right, let's talk about AI-friendly documentation. Svelte now supports the LMS.txt convention for making documentation available to large language models. This basically means that Svelte now spits out AI-friendly documentation. So for example, you can get the complete documentation for Svelte, SvelteKit, and the CLI, you can get this compressed documentation for use with smaller context windows, or you can get individual documentation for Svelte, SvelteKit, or the CLI. And if you want to learn how to take advantage of this, Stanislav is one of the people that actually work on this, and they have a great video on this topic titled Perfect Svelte 5 Code Completion for any LM. So I highly recommend it. Alright, this next feature is really great if you want to programmatically mount and unmount components. And this is how simple it is. You can just manually mount a component that you're importing and then you can unmount it. Let's actually see an example of this. So you can actually see that we have this Santa.Svelte here. As you can see, it's nothing special. It's just an SVG with a transition. So in the past, if you wanted to mount and unmount a component, you actually had to use a piece of state or you could even use the key block. But now it's even simpler. You can actually see in this button here, when you click on this button, we're actually going to mount the Santa component. And when you want to unmount the component, you can just use unmount. As you can see, it's a promise that you can await. And of course, we can bind the value of the target element. Alright, so now this should work. When we say mount, we're going to get this beautiful transition and then we can unmount it and repeat however many times that we want. So this is something that is now way easier to do in Svelte. Alright, so this next feature gives you debugging superpowers, and that is the new inspect.trace rune. So this rune causes the surrounding function to be traced in development. Anytime the function reruns and is part of an effect already derived, information will be printed to the console about which pieces of reactive state cause the effect to fire. As you can see, it's simple as using $inspect.trace, so now you invoke this as a function. We can actually look at this example. So here we have a butterfly, we have count here, then you have these derived value doubled, quadrupled, and octupled. So now we can actually see who triggered these reactive events. As you can see here we're just using inspect trace and now we're going to track this value when octuple changes. So if I pop open the console here. So let's just increment this value. And when I increment it we're going to see this waterfall that caused this. So this is the last derived. But we can just go inside of it. We can see we have this other derived where the value was 4, we have this other derived, which is 2, and we have this original piece of state that is 1, and all of them have their own stack trace. And this is very useful if you run into some weird issue and you have to track down what is causing an update. Alright, so the next feature modernizes App Store in SvelteKit to use runes. So we can actually see now we have app slash state. So now things are more consistent with Svelte 5. And now we have the same three read-only objects navigating editing page and update it So you can use this across your apps like in this example to know what URL the user is on and we can update it accordingly Alright so the next change is a great quality of life improvement I don't know about you, but I have to constantly restart the TypeScript server because the thing constantly keeps crashing. Until today, IntelliSense would often fail when you were in the middle of writing components because Swell's parser crashed on syntax errors. And basically it doesn't do that anymore and now we have a buttery smooth experience. Alright, there's been a couple of improvements to the Swell Playground also. So now if you go to the Swell Playground, and if you want to learn how the Swell Compiler works, we can go to the AST output, and now when we hover over these things, you're going to see what they correspond to in the code, and vice versa. So for example, we can change this world here, we can see what it's creating, so you can change this into banana, or whatever else you want, so you can play around with it. We can also look at the CSS output, if you have CSS, we can also look at the JavaScript responsible. So we can see what code this generates, which is really cool. Some other improvements include Wim mode if you're into that. So now we can enable Wim and you can go crazy. DD, boom, boom. Now I'm a wizard. Okay, that's great. All right. And you can easily quit Wim. Don't worry. You can just disable it. And another feature that you have in the Swell Playground. Now you can download this entire app as a SwellKit application. So that is some really great improvements in my opinion. And let's get our code back. And that's it. It's magic. All right. this next couple of features are going to be an improvement to the single page application experience in SwellKit. And the first feature is going to be single file bundles for SwellKit. So by default, your apps in SwellKit use code splitting to ensure that you only load the code for the current page. But sometimes you need a single bundle for the whole app, and now you can do that with the new bundle strategy option. So now you can just go to your config, and you can specify bundle strategy single. So you can actually look at the config here. If single creates just one .javascript bundle and one .css file containing code for the entire app. And this was a highly requested feature for a while. Alright, but there's even more single page application love in SwellKit with hash-based routing. So SwellKit now supports hash-based routing in addition to the default pathname-based routing. This can be useful for purely client-side apps, including those you might build with Electron or Tori, or situations where you don't control the web server and need to put everything on a single page. And the only caveats are that you can't use server-side rendering, and all your links need to start with a pound sign. And this is just a simple config. So now in the router option, you can specify the type, path name, or hash. And we can look at this example. As you can see, this is a purely client-side application with hash-based routing. And speaking of purely client-side applications, now you have the option of creating self-contained SwellKit apps. And what this means is that you specify the bundle strategy to be inline. Now you can put your entire SwellKit app, including the code, styles, fonts, images, audio, and everything else inside a single .html file. So inside your config, the only thing you have to specify is inline. So this is going to inline all JavaScript and CSS of the entire app into the HTML. And now if you have a simple project like this snake game, where we can play this game, and I'm a super pro gamer as usual. Let me just, okay, I'm going to stop. So basically, now you can just go to the other parts of this page. It uses hash-based routing, everything that we discussed so far, we can download the entire game, which is a single HTML. What is great about this, let me actually just copy this. If we look at the page source, we're going to see that everything is contained here. So now you can easily create self-contained SwellKit apps. Alright friends, there is one more feature to go and Tailwind users are absolutely going to love this one. Alright, so in this example here we have this card that we want to flip. So if we add, for example, a flip class is going to be flip, but of course we want this to be conditional. So something that you usually do, you would do something like this, where you use a conditional. Let's just copy-paste it like this. So you're basically using a ternary, and now it works. Another option that you had in Svelte was using the class directive. So let's say that we have this card here, but we can also go back here, we can use the class directive, we can say flipped, and now we can do this. And this is great, but it's a bit tedious, especially when you're working with Tailwind classes. So what you can do instead, we can go here, and now we can specify an object, we can pass in an array, so we want the card class to always be present, and now we only have to pass in an object. And now if flipped is true, it's going to include this class name. And of course, you get other benefits from Svelte, like warning you from classes that you're not using, and etc. And if you want to learn more, you can always read the documentation. So whenever you're using an array or object form, you can set multiple classes simultaneously with a single condition, which is particularly useful if you're using things like Tailwind. Narrays can contain arrays and objects, and CLSX will flatten them. So you can have a class that should always be there and you can combine it with local classes. And there's even a bunch of more examples. And I should think that it's really funny having this example in the Svelte doc that says accept the inevitability of Tailwind, which is really funny to me. Some people are going to be very upset at this, but what you can be upset at is the amount of ridiculous features Svelte introduced in the last 24 days. Alright friends, that's it. If you like what you've seen, don't forget to like and subscribe and I'll catch you in the next one. Peace!