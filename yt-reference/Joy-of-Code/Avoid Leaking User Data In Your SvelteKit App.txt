 Yo friends, what's up? Alright, so one question I often see get asked is how can I get my page data and pass it to unrelated components? And then people think, okay, maybe I can use global state so I can use it in my other components and actually that's a really bad idea and that's the focus of this video. We're actually going to learn why having shared state on the server, especially when using server-side rendering is dangerous. So there are two safe options that you can use and that is using the page store from CellKit or the Context API. Alright, but before we get started, here's a message from our sponsor. I'd like to thank this video sponsor, you, the viewer. You can support the channel through Patreon or a YouTube channel membership. Members get early access to videos, help shape the content, and a special Discord role. You can find all of the links in the description. Thank you for your support. Alright, so I think the biggest problem that people have is this blurred line between the frontend and backend in the JavaScript frameworks. The first thing we have to understand that in the browser we're running Svelte, so on the client, and Svelte is our UI framework or the compiler, right? And then we have Kit, which is actually the backend framework. And by default, once you run the development server, this is going to use Node.js, but it's really not important, because SwellKit can run anywhere where JavaScript runs. And this is achieved through adapters. But that's not what I want to talk about. I want to actually talk about how SwellKit itself works. All right, so for example, what is a server? Well, basically, a server is usually a long-running process in the background, right? And we usually say for a server that is stateless, but it's actually not true. Of course, you can slap some state on a server, you can define a variable and boom, now we have some state in memory. As long as that server is up, you're going to have that state. And that state is separate on the server, right? That state isn't shared between the clients. So for example, if we use page.server.ts and we set some state in the server, that's only going to be available there. It won't magically update this state in the client, right? And we already know that in page.server.ts, this returns a load function so we can get the data for the page. Another benefit of that is that we can use server-side rendering so we can return this HTML file. And then, of course, we can also use page.ts to return a load function. This is going to run on the server and on the client. And what's also interesting, I don't think a lot of people know that you can use them both at the same time. So you can actually pass the data that you receive from page.server.ts to page.ts. You know, I'd be asking yourself, okay, why would I do that? One example I can think of is that maybe you receive some data from the server, let's say images, and you want to await them on the client so you have the images loaded and to avoid layout shit, right? So you can outweigh the data inside this function and then you can only navigate to this page when everything is ready That one of the examples But you probably also noticed that I have something else here and that is JSON So what if I put JSON here And that is basically very simple how SwellKit works. By default, once you load the page the first time, it's going to be server-side rendered, and then SwellKit is going to load on the page, and it's going to behave like a single-page application. So when you go through another route, you're not going to get and receive HTML, you're going to get JSON. so on. So it can update the data on the page. And that is how you get the best of both worlds. Let me actually show you an example. Let's go to swell.dev, for example. Alright, so let me open the developer tools, and I'm going to go to the network tab. And let me just reload the entire page. And you're going to see if we go at the top, we can see that we actually get the entire document. So this is what you get from the server. The initial page load is server side rendered. But you're going to actually notice something interesting. For example, let me clear everything. And then, for example, if I navigate to something else, so for example, if I go to docs, and let's say, for example, that I hover over Overview, you're going to see we get preloading. So that is already awesome. So let's just go to Overview. And then if you look at the top, we no longer get the HTML page, we get JSON, right? So this is all of the data for the page here, unless it's pre-rendered and etc. But in this case, I don't think it is. You can actually see all of the data is here. And this is how every API route works, because, for example, we can go here and use double under dunder, and you can just say data, jesson, and you're going to see we're going to get the data for this page. And if I print and print this, you can see all of it is here. But yeah, let's just go back here, and I'm going to see if I clear everything. And when I navigate through all of these pages, you're going to see that we get data.jesson as a request, because it's no longer just using server-side rendering. We get a single page application experience, because otherwise, if we don't use that, every page would do a hard refresh, right? So you can see if I go over all of these links, he's just going to load data JSON for those endpoints. But that's basically it. And if you want to learn more how data loading works in SvelteKit, I'm going to link to this post if you want to understand how data flows in SvelteKit, where I explain all of these things. So this is going to give you confidence to understand what you're doing in SvelteKit. Alright, before we start talking about shared state on the server, I think it's really important for us to understand fundamentals, because some parts in a SvelteKit doc leave some things to the imagination. So, for example, all of us probably know that pluspage.12 is just a component that defines a page in our app. So by default pages are rendered both on the server using server rendering for the initial request and in the browser using client rendering So on the first request the server sends the HTML document and then it gets hydrated so all of the interactivity and etc And we also know that pages can receive data from load functions via the data prop. And also if you didn't know, these types are completely optional, so you don't even have to use these types because SwellKit automatically generates them for you. And this is how we can load some data on the page using pluspage.js for example. So often a page will need to load some data before it can be rendered. So for this, you can use pluspage.js that exports a load function. And basically what's going to happen, this function is going to run alongside pluspage.12, which means it runs on the server during server-side rendering and in the browser during client-side navigation. And of course, then you have pluspage.server.js, so if your load function can only run on the server, for example, if it needs to fetch some data from a database or you need to access private environment variables like API keys, then you can rename pluspage.js to pluspage.server.js. And another great use for pluspage.js, for example, you can disable server-side rendering that is completely optional if you want to build a single-page application with Swellkid, you can, no problem. So you can use pluspage.js to load some data and return it on the client. And of course, if you want, you can just fetch the data inside the component. But at least this way, inside of the load function, you can get access to other things like the params from the URL and etc. So this can be super helpful. Alright, enough foreplay. Let's get to the good part. So the SpelkyDogs have this useful section on state management and why you should avoid shared state on the server. And this mostly applies to server-side rendering. So let's read what I have to say. Browsers are stateful. State is stored in memory as the user interacts with the application. Servers, on the other hand, are stateless. The content of the response is determined entirely by the content of the request. But of course, in reality, servers are often long-lived and shared by multiple users. And even if you're using serverless function, they're often shared. For that reason, it's important not to store data in shared variables. They're specifying the user here at the top, so this is basically a global state on the server, and then they're returning the user, and they're doing the same thing in form actions here. So you should never do this. And let's actually look at the diagram again to understand why this is bad. So if we have this state on the server that is separate from the client, so this is our single source or true, so now we have 1, 2, 3, 4, or how many people looking at our page if this is a single source of truth, and they receive this state based on what is on the server, then we're going to get into trouble. And now that we understand this we understand why this isn a problem when we don have a server So inside a single page application for example if everyone has separate state when they load the page in a client then it not a problem But this is a single source of truth And let me actually show you an example of this. So here I have just a simple SvelteKit application with some off, but basically I'm going to just log in. Let's just log in. So this is going to redirect me to secret. and here I have some nested components so we can explore later how we can pass data through components. By this case you can see I have this user ID and the username. And if I go back to VS Code, I'm just going to do a fuzzy search so you can see this secret route has plus page.svelte and plus page.server.ts. So for example, if I open this, we can actually see I'm just taking this event to load function then we're checking if the locale's user doesn't exist we're going to redirect it, otherwise we're going to return the authenticated user. But where you can get into trouble on the server if you share state here I can for example say secret 1234 and now if I go here and I say console log secret let's save this you can see here we have secret let's say that someone else comes to our site and now we're going to see we're going to log the same piece of data and now we understand why this is so bad if you have some data that you don't want to be shared by everyone Alright, this example looks scary, but it's not as insidious as the next example. So here we just have a load function which returns the user. Nothing special. We can even use fuzzy search. We can search for secret. Let's go to the page where we receive this data. Alright, so we get this data back through props. And you can see if I look at the type, it's already typed for us. You don't even have to use types. Alright, so I have some deeply nested components right here. So for example, if I go back here, you can see A, B, C, and D are all different components. And now, of course, we just need to pass the user prop, which is really tedious. So if we go, for example, to the A component, now we're importing B. We're reusing B, we have to pass the user again. And in this case, I'm just being cheeky. I'm just importing the type from page data, which gets generated for us, which is a bit meta, right? So you can see it's typed properly. We don't have to type it ourselves. But yeah, now we can just continue down the chain. If we go back to the B component, then we're going to import C. We're going to pass the user to C. If we go to C, we're going to give them the D. So now we can use the D, we can pass the user to the D. And now if we go back here, again, we're going to pass the last component user, and then I'm just going to use JSON stringify, I'm going to pass the user, and that's how we get this output. So often what I see,

 he asks is how can I get this prop and how can I avoid this prop drilling, right? How can I pass this data to deeply nested components? And the first idea people have is can I use a store on the server so I can just share the state in my components? And this is why I actually want to show you why that is a bad idea. Alright, so now all of the fundamentals that we've learned, all of this is going to come together once we read this example in the Sveltee docs. Alright, so the Sveltee docs say no side effects in load. For the same reason, your load function should be pure, no side effects except maybe the occasional console log. For example, you might be tempted to write to a store inside the load function so that you can use the store value in your components. And then they give you this example. And this is why it's really important to understand the difference between page.ts and page.server.ts because they're using page.ts on purpose. So you can see here they have this user store. It can be a store, it can use runes, whatever. This example in the swelky docs isn't updated for some reasons. We're going to use runes, of course. Because runes replace stores, you don't need to use stores anymore. And you can see in the swelky docs, they say never do this. So they say user.set and then they set the user. And I already mentioned why this is such a bad idea. Because for example, if the server is the single source of true and we get a stale data from the server, right now this is going to be shared between users. But you're actually going to see that this is not such a problem with page.server.ts because this state is completely separate from a client state. You're going to see the user state is just going to be blank in the client. But let me actually show you this in practice. I created this user.swell.ts file to mimic their example from the docs. This really isn't important. This is just a user. So we initialize it here, const user equals new user. And I even made the same function like they have in their example. So we can use set to set the user that we passed and we can get the user. This really isn't important. So let's just pretend and take that naive approach that we actually want to use this global state so we can use it in our components. so let's actually search for secret and now we can go to page.server.ts and you might be thinking okay instead of returning the user let me just import user and I'm going to say set event locals user okay now I just have to go to d.svelte now I have this great store oh my god everything is working beautifully let me actually just go here and I'm just going to comment this out so I can import user let's see okay great you now remember on the user we have this get method so we can just invoke this but you going to see it actually just going to output the blank ID and username Because again this is very important to understand the difference between this. Because in the swelky docs, they actually do this really intentionally. And this can throw you off because in this previous example, they used page.server.ts, but the state is going to be separate, right? They actually done this on purpose. But unfortunately, they didn't mention this in the docs. And as you said, if we go to this diagram, because we're using page.server.ts, yes, this is completely separate from the client. So I hope this makes sense. And if you're thinking this makes you safe, you're wrong because you actually have the same problem that we've seen previously, because right now you're setting this state on the server even though you're not sharing it at the client at the moment. But let's say that you're using it to modify some other state and etc. It's just a bad idea, right? All right, this is great, but kind of disappointing, right? I wanted to show you a real-world example just the same like they have in their docs. So I was thinking, okay, what can I do? And then it dawned on me, of course, I can pass this data to pluspage.ts. As you can see in their example, they're using pluspage.ts, right? And I actually want to recreate this example to show you the downside of using shared state. All right, so how can we actually do this? Well, I'm going to search for secret and now I have this pluspage.ts file inside source route secrets. I'm going to open that. As you can see, I have this commented out. It's already working. This is just a simple old function. I get the event and then I can pass the data from the event. So everything works the same. But now we can actually recreate their example and learn why this is such a bad idea. The first thing I'm going to do, I'm going to uncomment this line user set. We're going to set it to the user. And then this is the important part. We're going to set a delay of four seconds because otherwise you wouldn't be able to catch the problem. You would maybe get a flash, but this can also simulate a bad network, no JavaScript enabled and etc. So let's make sure you just comment this out and I'm going to show you. So for example, if we go back here and if we refresh this page, we can see Marco and we can see here Polo. But right now, nothing is bad because you don't even see how fast it is. But let's actually put an artificial timeout. I'm going to save this. And now we're going to see the first thing I'm going to do is refresh this. And I'm going to refresh this other one. And now we're going to see this is going to change to Polo. And now they're going to share the state. How crazy is this? And then it's going to go back. This is really bad if you don't know about this. All right, but what if I told you that this isn't even the worst part yet? Let say for example that you have a bad internet connection JavaScript is disabled for whatever reason if you block the script on the page you going to see something interesting is going to happen So the state is never going to update So now you can see here we have Polo on the left and Polo on the right How bad is this friends But of course not all of this is doom and gloom. I'm going to show you how easy it is actually to share state without doing any of these dangerous things. So you can actually do it very safely. All right. So if you want to share some state between components from the server to do it safely, of course the first step is don't use server-side rendering. Of course I'm joking unless you're working on a single page application but let me actually show you how you can use the page store from CellKit to do the same thing. Alright so I'm going to go here and let me comment these things out. We don't need it and now we can for example go to d.svelte. We actually don't need any of these things. We can just import the page store from CellKit. So I can actually just say import page from app stores and then we can just go here and subscribe to the store. So you can say page.date Let's save everything. And now we're going to see we're going to get the information. And how this basically works is, for example, if we go to page.server.ts, whatever you return from a load function on this page is going to be available to that route, including its parents. So, for example, I can go inside of layout here. And let me just use pre here. I'm going to say page. Let's see. Do I get auto imports today? Okay, thank you. The gods have mercy. So we can subscribe to it. and we can actually just say page.data. Alright, so now you're going to see it's actually going to also show this from the layout. And this is why the page store from CellKit is so powerful. Of course, I'm going to remove this. We just open the D component and you're going to see everything works fine. And one thing I want to mention is that, of course, this in the future is not going to use a store, it's going to use runes under the hood. Right now, they didn't update this in CellKit because it would be a breaking change. But if you're watching this video in the future, all of what I said in this video is still going to be true. The only thing that's going to change is this import for the page store or whatever it's going to be, right? It's going to be just runes. But everything else is going to work the same. There is one cool thing that you might not know about stores in Svelte 5. And that is basically that stores are signals. What Svelte does under the hood is just subscribe to the store, but it returns a signal which updates when the store does. And this is done so you can use stores with runes without a problem. So for example you can use a derived rune and if you use a store inside like the page store and let say for example the URL changes or whatever this store when it updates is going to also update this expression which is really awesome And I can even show you this in the source code If we for example go back to the developer tools we can go to sources Let open source lib Here I have my components. We can actually see this is our offered component, right? And here is the compiled output. So basically, what Swell does, if we look at here, it creates this $PageRoon. It uses this function store get to subscribe to the store and it returns a signal and let me actually show you how that looks like so i can copy that i can go to node modules let's search in the folder i'm going to search for store get and let's see here it is export function store get let me close this and if you read through the code it's not even that intimidating it basically just creates this source signal whatever but here is the interesting part so here it is where you subscribe to the store and each time when the store updates it's going to update this signal right here. That's basically it and then it just returns the signal. That's basically how it works. And there is one more cool thing about stores is that for example how do stores work in SvelteKit? We actually just learned of the downsides of using global state something like stores, runes, whatever on the server. So how does actually SvelteKit do it? And basically they explain it in the documentation. They explain that you can use stores with context. You can replace stores with runes, whatever. They just didn't update this section in the docs for whatever reason. and it's honestly quite simple how it works. So we can actually look at the source code if we go back to the page. We can actually see this is just a subscribe function and here you have this store. If this is in development, it's going to say getStores or getStores.page and I'm not sure what the difference is between these two. I think this one only serves to give you an error. Client side, if you look at this, we can actually see this is going to give you an error because you can't use context outside the component initialization phase. So I think that's the only reason this exists because getStores is basically the same function. What it basically does, if we go back to getStores, you can actually see here is a variable stores. It checks, hey, if you're in the browser, then it's just going to return you browserStores. So it's going to create a pageStore. It's going to use this function notifiableStore. Let's go to it. And it basically just creates a writable here, and it just returns a store. That's basically it, nothing special. So here it is. It returns notify, set, and subscribe. It's really not important. But basically, this is the interesting part. So if this is on the server, it's going to use the context. so that store is only going to be scoped to that component. So that is a safe way to do it. And the only thing that happens is going to return this page with a subscribe method. And if you already don't know basically how this works, if you're just used to this sugar syntax page.data, basically what happens, the actual syntax for this

 This is page, subscribe. And then you pass what you want to happen when this thing updates, right? And this is basically what it is. This is just syntactic sugar, which swell does under the hood for you, right? That's basically how the page store works. But basically here is how it works. So you have this component where you say set context. So that state is scoped to the component. And then you can just call get context inside of a child component and it's going to walk up the component tree and it's going to get the state. And this is why this is so much safer than using state from the server because it's only going to sculpt this to the component on the client so it's not going to be shared by everyone. Because if you go back here to the code and if you go to page.server.ts or whatever, what you should always do, as they say in the Svelky docs, you should just return the data and then you can pass it to a store on the client. That is the safe way to do it. So you shouldn't use shared state on the server for that. Oh, and since I'm here, let me also show you something else that is cool. So for example, if we go back here to page, let me actually just go here. let me go to get stores. I just want to show you this where we have stores. So you going to see something familiar Let just log the value of stores And because we using Vita node modules we actually have to force this update So it updates the cache NPM dev force Okay, so this is going to update the node modules. So we're going to actually see the console log. And you're going to actually see something very interesting. If this is the server context, let's actually see what is going to return. If we go back and we refresh everything. And as you can see, here we have all of the SvelteKit stores, page, navigating, and so on. How cool is that, right? Alright, so let's use the Context API to add our own store. Here I'm back in plusPage.svelte where everything began, right? So we're passing this data to this component. But in this case, instead of using the PageStore, let's use the Context API. Alright, so this is basically how we can do this. Let's just say letUser. So let's make this reactive. We can say state. And then we can make this reactive by using a proxy. So this automatically becomes a proxy. And Svelte is going to turn every property on this object into a signal. and this is the only thing that you have to do so we have to use an effect and now you probably have to say user ID and then we can say data user ID and so on for the username I just going to be lazy I going to say user equals data dot user I think that this should work alright so it basically going to going to happen when data updates we just going to update this reactive value And boom now we can set the context We can say set context. This is going to import set context from Svelte. Let's give it a name, user, and then we're going to pass the reactive user right here. So now that we've done that, we can actually remove all these things. Yeah, we don't need any of this. Just remove this. let's go to the B component same inside C and then we can go to D and that's basically it so now everything should work the same as before because we're using this page store from CellKit but we can now instead of this use context so we can actually say const user get context we can get the user let's change this to use user I'm going to save this and everything should work the same as before. Let's see. If we go back to here instead of doing this I'm going to actually pass data just the same thing that they done in the docs right Yeah so you can just do this let me save everything And you going to see now even if I refresh everything should work the same as before How beautiful is this friends Alright now we can go back to the D component. We can even remove the page store since you don't need it. And now we're just using the context API from Svelte. And if you look at this, everything works the same as before. And of course, if you want to learn more about the context API, here I have this post sharing state without props and events in Svelte. You can check this out if you want. And I even cover some things that people struggle with, like passing reactive state to context. It's basically really simple. So a lot of people don't understand that you can just pass a primitive value like a string. Because, for example, this state banana, if you just pass this, this won't work. Because if you look at the compiled output, basically this is a signal, and this is what Swell does under the hood. It just gets the value of this banana, which is just a regular string. So that's why it isn't reactive. But of course, you can use whatever you want. You can use functions. You can use a class, pass the instance. you can use accessors, whatever else you want. But yeah, I think that's going to be it. I think I covered everything that I wanted to. And as always, if you like what you've seen, don't forget to like and subscribe and I'll catch you in the next one. Peace.