 Hey friends, welcome to using SwellKit endpoints. The goal of this guide is to give you a mental model at the end on when would you use page endpoints and when would you use standalone endpoints. This is something I often get asked about and it's what most people are confused about, so the goal of this video isn't an introduction or a guide to SwellKit endpoints, for that you can watch my entire SwellKit video or the standalone video made on endpoints, and as always the post and what I use is in the description, so you can check that out. So to understand endpoints, first you need to understand what is even the goal of SwellKit, right? So let's look at client-side rendering and service-side rendering, which are the two popular rendering methods that are most frequently used. So the problem with SwillKit is that it blurs the line between frontend and backend, right? That's what confuses most people. But let's say for example that you're using client-side rendering, so you build your SPI, you're happy, right? And you might be familiar with this sort of code, so this distinction between frontend and backend is obvious because you can see you're using fetch, you're pinging some third-party API or whatever, and then you're just rendering it on the client and everything looks great. But the problem with this is that JavaScript first has to load on the page, so now you're fetching the data and then you're returning, so you're making a round trip. And this causes loading spinners for your users. And another downside is if you go to the page source and open it, you're going to see none of your data is here because this is just a HTML shell, right? But the distinction is really clear between front and back end. So we have something like server-side rendering, if I go to that example. So you can see it looks the same, but if we look at the code here, you can see here we have some data from the server right and this is really starting to get blurry like where is this data coming from but this is just server side rendering so this is the point of cell kit so you have your backhand file or plus page ts this doesn't really mean that it only runs on the server if you're already familiar you already have a dot server file also but in this case this can run also a load function on the client if you need which we're going to look at an example later so basically the point of this we want to fetch this before this component mounts and then we can use this load function to pass any prop to the page so now when you go and view page source you can see here is your actual markup here which is great for seo and is a greater user experience let's look at another awesome example because in swell kit you can use these endpoints to fetch data dynamically so if we can go to this example here i'm just having this endpoint so get post here's this function and here's the json placeholder api and of course you usually don't do this in your project right because you don't use a third party api like this because you don't own the data you don't change it, but I'm just using this for example so you just have some data. But of course, you can always fetch some data, save it in your database, change it, and format it however you want. As you can see here, it accepts an ID, and we can just get the ID from the params. So basically here, whatever you input, or 1, 2, etc, if I go for example to 2, it's going to dynamically fetch the data from the JSON placeholder API. And this is really awesome. And then again, you get this data from the export-led-data prop, and then you can just render it on the page or do whatever else you want. Another thing you're starting to notice is that usually this pluspage.swell file is accompanied by a pluspage.ts file, so it's like the rule of two in Star Wars for the Sith where there's always a master and an apprentice, right? And knowing this removes a lot of confusion because a standalone pluspage.ts or pluspage.server.ts file does nothing. It always has to be accompanied by a page, which is always going to be in some folder because they have to be together based on the file system routing in SwellKit, and of course you're also familiar that layouts can also have their data, and that's the same story. So now you know that these files always have to be together. But sometimes there's an exception to the rules and only the safe deal in absolutes, so let's look at an example when you can have three files at the same time. So you have a page file, you have a page.ts file, and you have a page.server.ts file. So when would this really be useful? So for example, we can look at this example. Here I'm fetching some images, so here I have an endpoint. I'm just getting some images from JSON placeholder API, which I'm passing a limit. So I have 20 images, then I'm showing them here. And this is really great. But then for example, if you navigate usually to an image, it's going to navigate to a page and then it's going to cause some flickering or layout shift and it's going to load. But maybe you want to defer navigation until the image has been loaded. So let me show you that example quickly here. If I go to the network tab, and I'm also going to disable cache, let me show you how that looks like. So here I have this route which takes ID so you're going to say ID for the image run etc and let me just show you this so we're going to fetch this on the server but another awesome thing is that you can pass the data from the server load function to your load function on the client so now as you can see I doing something interesting I have this load function here which takes the data and then we going to check hey if we in the browser context because this runs on the server and client we going to load the image which is just using a promise so we going to create a new image we're going to use the event listener onload, just so that the promise resolves, we really don't care about what this returns or anything else, and this is going to basically block the navigation, which is going to be fast, and of course, it's also going to start preloading, but in this case, I disabled preloading, which is by default enabled in app.html, so your app is going to be a lot faster. But now, look at this. I'm going to go to no throttling. Let me just use Fast3G so we don't wait forever. Now when I navigate, what you should see is it's going to load the image first before it navigates, so pay attention to the network tab. As you can see, it's loading the image, it's loaded, and boom, immediately navigated. If you weren't doing this, it would just navigate immediately and if you're in a slower connection this would cause a layout shift and this is really cool but let me show you something cooler in the next example another thing that you should know is that SvelteKit has this concept of universal and server load functions and now i can open this in a SvelteKit documentation so let me just close this and i'm going to zoom in so you have a easy entire scene so you can see universal versus server it basically distinguishes universal load function which are located in page.ts, layout.ts, and etc. And if the file extension has .server, then it's just a server function. But basically, this isn't really that interesting to us, but the output is. So UniversalLoad function can only return an object containing any values, including things like custom classes and components. Ah, so you can get a Svelte component and a ServerLoad function must return data that can be serialized with the value, which is a library that Rich Herius also made, which is like JSON-SignifyButtonSteris, which SvelteKit uses. But yeah, let me show you how cool this is. So here I have this endpoint. As we said, this is a universal load function, so you can only do this here. So you can see, as usual, we can return any props or whatever. Ah, but look at this. We can also return a component. So I have this counter component here, and basically you can use a dynamic import, you can import it however you want. And then inside of here, we get it over the data prop, so we get the data title as usual, but look at this. Now we can use the Svelte component, which has a dis prop, and we can pass the data component. And now you're passing this component to the page. And this isn't possible using a server load function. But let's have a quick look at server load functions. This is what I said before, so they can only return data that can be serialized with the value, which is this library, this is what the swelky docs refer to, it uses this. So basically this data can include anything like big int, let's see, I have this example here, it can be, so as usual you have your props, title, etc, the data you fetch, it can also handle big int, date, map, set, and even a regex. So as you can see here on the frontend, I just installed the value, and I'm just going to also console.log it so you can see what's going on. So here is an object, you can see here is a begin, date, map, rejec, etc. And this really isn't that important, I just thought it was cool to let you know how this works. The coolest part about working with data in SvelteKit is probably how the data flows through your routes, which you can pass like a hot potato. So let's look at an example how we can pass child data to the parent. If I go to this example here, if we navigate to a child route, it's going to trigger the load function, which is going to update the page store that I'm using here in layout.self. So as you can see, I'm just using this layout. And basically, this is a store, right? So you're subscribing to the store. You might be thinking we're passing the data up. You're not passing any data up. This is just a store. We're subscribing to this value, which is going to get updated. If I show you here, so I can use my snippet and I can subscribe to the store. So now you can see this data here. This is what every page has. So this data, and now if you go to the child route, you can see, ah, this updates, and this is going to update the title here for SEO or whatever else you need. You can make this title, for example, fly or change color. You can do anything you want. So this is just a child route, which is slash child, and that's basically it. There's nothing special here. I'm just returning from this load function title in the description, and this is what gets updated. So for example, you can see here is the title, but now since we subscribe to it, right, when we move away from this page, it's going to update, and this should be undefined here where you can set a default value or whatever you want. So you can see here we're using it $PageDataTitle, $PageDataDescription. So if I go back, this should be undefined because we don't have any fallback here, but you can include this if you want. And how awesome is this, friends? Let's look at one of the best features of Selkid, in my opinion, that's working with forms and to be more precisely, form actions. So if I go to the form actions example, of course, if you're familiar in the past with working with forms, you have a server, you make your endpoints and then you ping it but now you have to manage all of that yourself with javascript fetching the data error handling etc but look how simple this is in swelki just because we using a plus page of server file So we have a form here which can only post using this method So we can just specify an action here which is just a query param and then we're using this string so SwellKit knows hey I should map this action to a method. So for example here we have two actions you can log in or register. So we can say question mark login and then here we can override it by using form action and we can say register. So now in our endpoint here how cool this we can just specify actions we don't need to concern ourselves with all of the junk we can just get the request we can get the data from the form the email password etc we can do some checks we can use swelkits error handling using fail and now back again here if we make some mistake for example test and then i don't include my password or whatever invalid credentials and etc so you can see how simple this is and can you find any fetch here i can't right As you can see, how awesome is this? And you would have to basically implement this all by yourself if you're using a standalone API endpoint. All right, so I already hope it's starting to help your mental model what page endpoints and what standalone endpoints are used for. But of course, we're going to talk about the use cases for standalone endpoints. So a standalone endpoint, you can use it for anything. Compared to using a page endpoint, you can only return some data for your page. Usually, as you've seen, it's some JSON, right? But a standalone endpoint can return anything. You can return text, JSON, XML for your RSS feed. You can generate a CSV file, PDF file. You can make a REST API you can use inside your app, or you can expose publicly by setting core scanners on your endpoint. But let's look at the most basic example for a standalone endpoint. So I can go to this random number generator. As you can see, if I press this dice, it's going to give me a random number. So how does this really work? Well, as you've seen, this is a server-only file. So this runs only on the server. and here we have access to all of the HTTP request methods so you have get post patch put and delete and you just export this function like this and now thanks to this URL we can see what the user passed in the URL and with that query param is max we can say okay use max or set it to default as one we can pick a random number using math random times that number and then we can return a new response which is just a web standard this isn't even specific to Svelte this is why this is so beautiful because you learn about web standards and then you just turn it into a string which is a random number. As you can see, how do you use this? So now you can use this anywhere in your app. We can just use this using fetch. And of course, I have this random URL, but if I go here, for example, let me just open in a new tab, and I can say my endpoint random number, and this is what this is. Really, it's that simple. It's nothing complicated, right? So there really isn't a right or wrong way. It's basically what you want to accomplish. If you want server-side rendering, for example, but fetching your data in the client, and it's causing a bad user experience, and it's slow, then of course, that's really not a great approach. But if you want something like server-side rendering, then you know what to do, right? And you also shouldn't be afraid. I see most of the time people ask, okay, when should I use a .server.ts or a page.ts file? And basically any file that has server in the name like server.ts or page.server.ts can only run on the server, which means you can read from the file system, you can read from the database, and etc. Even if you do something, which I'm saying in quotes, wrong, like trying to use a database using a page.ts file, it's not going to work. It's just going to explode, and Svelkit is going to give you a nice error is going to say hey you're trying to use this on the client maybe don't and then you just rename the file and boom you can move on with your life so don't concern yourself about what is the right approach or etc because that's really not important it's important what your goal is remember how i told you that standalone endpoints can return anything well basically this is again what i'm talking about everything depends on your goals if you want an rss reader on your site this is the only way to achieve it basically so you're thinking about your goal, I want to return XML, how do I do this? Oh, I create an API endpoint and return the XML. So if we go to example here, I can open the XML feed and here everything works great. Of course, this isn't a proper XML feed, it's just an example. So you can see here is nothing complicated, we're just using the get method because we just want to get the XML and then we specify in this scatter content type application XML and then we can just generate this as a string and then we can say return your response XML with these scatters. So the browser understands that we're sending RSS. So you can see every firmware is great. And if you need an actual RSS feed for your site, I'll link in the post to how I've done it on my site. So as you can see, it's really nothing complicated. It really looks similar. I'm just getting the post again and looping over them. And basically that's how simple that is. Let's look at another example, file generation. So for example you can make an endpoint that can create a spreadsheet or PDF So you can return a CSV PDF file and etc And basically this is how simple it is So I using this library PDF kit and then I creating a new PDF document and it has API you can read how it works if this is something you need to do So I'm just, again, returning, return new response PDF, and I'm setting some headers, content type application PDF, and content disposition. And how do you find this out? Well, you search how to do it, right? And this is also the beautiful thing. For example, if you wanted to figure this out, you wouldn't search for SwellKit PDF, just search for something more generic, like Node.js, creating a PDF, or maybe using a library like Express, because basically this is what standalone API endpoints are. It's the same thing if you ever use something like Express where you're returning an endpoint, and that's basically it. So if you can figure out how to do that for those more established libraries that have more examples, right, so this is something great, then you can just port that example over to SvelteKit. That's how simple that is. You don't have to look for specific SvelteKit examples because it's just using web standards. So let's look at the last example for standalone endpoints which is creating a post api so as i said you can use standalone endpoints for anything you can create a rest api that you can consume inside your app or outside your app as i said if you include core scatters so let's see how something like this is awesome so if i go to the post api as you can see here i'm fetching all of these posts which is a hundred posts i believe let's see so how am i setting this up so i created a standalone endpoint post slash plus server ts right as usual and now i have this function get post i can pass it a start and end number so a range and then i can even specify a user so i can filter it but you can do so much more you can do categories and etc then imagine if you have a categories route you can just use this existing data and you don't have to duplicate your logic in other endpoints so as you can see here nothing special i'm just fetching some posts for some dummy data right and then i'm checking hey if this has some user data then we're going to filter the post based on the user otherwise we're just going to slice it start to end and that's basically it so how do get this parameter this is an awesome part so if i go to the post api endpoint here you can see by default gets 10 posts so these are always going to be 10 posts but then we can also look with range parameters so here we're saying 0 to 100 so now this gives us 100 posts so now look at how flexible this is this is the power of standalone endpoint so now you can say something like 4 or i don't know whatever you want you can just say 2 and get 2 posts but let me also show you something amazing also. But now we can also get the posts with the range, but we can also filter them. So now, if your gears are starting to spin, now we can use this for pagination or whatever else you want. So if I go here, I'm grabbing 0 to 100 posts, I'm only grabbing the posts that have the user ID 1. Otherwise, I can specify a user with an ID 4, and now I'm only going to get this post. And now you can do whatever you want, you can even filter it, add your own parameters and etc. and basically this is how simple this is so when we hit this endpoint we can grab this and the structure url so now we can get start and using url search params get with the name right here and the beautiful part is that this also doesn't matter the order of these parameters and this is why the web is so beautiful because of course you can just use a function and do this but you can just use the url as a state manager right and now we also get the user id and then we just pass it to our function get post and that's it and now we can get it here we have some default values right but that's how beautiful that is all right so i hope this wasn't that confusing as i said the call primarily wasn't to give you some working examples or how to do this or that i just want to give you quickly a bunch of examples so it improves your mental model how this works and the only thing we need to talk about are server only modules so let me open this in the docs and now i can browse this so what are server only modules basically this is any file that ends with dot server but you can also have server only modules if you place a server folder inside your lib folder so as you can see in the selkie docs here it talks about private environment variables but this is what i'm talking about your modules you can make your own module server only in two ways by adding a dot server to the file names for example secret dot server ts and you can place them in lib server so they're going to be server only of course you wouldn't store your environment variables use environment variables that swellkit provides for that right but this is more something like let's Let's say that you have Prisma you're connecting to it. Just connect to Prisma in a .server.ts file so you can't import it by accident in a client file or if you have any secrets and etc. Alright friends, that's it. Don't forget to like and subscribe and you can support me on Patreon and don't forget to join the Discord. So thank you for watching and catch you in the next one. Peace! Thank you.