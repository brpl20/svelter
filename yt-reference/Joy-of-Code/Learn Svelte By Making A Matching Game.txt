 Hey friends, today we're going to make a fun matching game in Swell to learn more about state management and reactivity. As you can see, if I press play here, we can see this awesome flip effect. If I'm any good at the game, which I'm not, and I made it, which is really sad, let's try to get at least one, because I'm going to be upset. Let's see, oh my god, I'm so bad at this game. Okay, let's see. I should have turned on the hacks for this. Okay, just give me one, please. Where was it? I know. Oh my god. Here it was. Oh my god, I got one. Wow, I am a genius. Actually, Tom is a genius, but irrelevant. Here we go. Oh my god, I'm so good at this game. Pro game, my friends. All the links are going to be in the description, so don't ask me what to use and etc. So you can check that out. If you want to code along, I highly suggest you open Svelte Lab in the browser if you don't have a local development setup. And you can even go here to the project. or actually let me see easy preferences. I think it's Svelte Lab somewhere here. It's project and then you can say new with template and you can pick any of these templates, which is really awesome. So if you want to use TypeScript, you can do that. I'm going to use TypeScript, but of course it's optional. All right, so see you in the project setup. All right, so let's set up the SvelteKit project. You can use VT if you want, since we don't need any functionality of SvelteKit. I'm inside of a simple empty project. So I'm going to say PNPM create Svelte. then you're just going to answer a couple of questions. Let me zoom in on here. Okay, so it's going to take a second. So I'm going to just press enter because I want it in the same directory. I'm going to create a skeleton project. Yes, I'm going to use TypeScript, which is optional. You don't have to use it. Just ignore the types, right? And let me see. I want at least prettier for formatting. All right, so that's basically it. So now I'm going to install the dependencies so I can say PNPMI. And that should be it. All right. and of course there's at least 10 times an update to pnpm at the day so I can say pnpm add because I'm obsessive compulsive like that but yeah you don't have to do that of course so okay that's done let's see at least I want to change one thing here let me close the terminal so here let me see pretier rc so I'm going to open that and now I'm going to go inside of here I'm just going to disable semicolons which is optional so I can say false awesome so now let's close that and we can start the development server in pm run dev And it should open on 5173 So let just copy that Go here. Fantastic. We can press enter. And beautiful. Alright, so let's close this. I'm going to add some base styles. So if we go to source, let me see. Does this include any styles? I always forget. Alright, so if I go to source, I can just say new file, app.css. So now I'm going to go to the post and I'm going to copy the base styles so we can get to the fun part, right? You can just go to the post, copy over, or you can copy it over directly from here. Let me just copy that over. Just close the sidebar so you can see what you have going on here. So basically I just have font source pop-in. So maybe we should install that. Let me just open this. So we can say, just zoom in. So you can say pnpm i font source and now we can say pop-ins. And that's how simple it is to install a font. So basically that's it. Let me just close that. Again, let's run the development server. And awesome. So if you don't have pop-ins, do that. So here I have just a basic reset, nothing special. Here I have some CSS variables. I set the height on the HTML and the body. I'm centering everything using CSS grid, so it pops off. Speaking of popping off, here is pop-ins. So here I use the CSS variables, some base styles for the title and for the button. That's basically it. You can pause the video and copy this over, but it's easier to just go to the post and copy over these base styles. All right, so since we're here, and let's say lib, we're not going to need lib, I think. So we can just go and delete this, move to trash. Let's see in the routes, we're going to create a plus layout.js file. So in the routes, plus layout.svelte. Let me just close the sidebar. Now I can use my snippet here, and I can say import. So we need to go one above. And then we can say app CSS. And don't forget we need to include the slot. And awesome, now our styles are going to apply. Let's also add some SEO. So we can say Swell Head. And I'm going to create a title. Which is going to be Matching Game. So you're going to see it's going to update right here. Matching Game. Alright, so the next thing for the cards. I'm going to use emojis. But you can use whatever else you want. I just really like emojis for their reason so let me show you a pro gamer move so we can go to getemoji or we can go to the post and copy them since i have them right here but let me show you something if you didn know how cool this was so they all separated by space right so you can select any emoji you want and maybe you can use the animal one because they're really easier to differentiate than this one these faces are a lot similar so yeah that's what i'm going to blame my struggle with playing the game all right so you can select these emojis press ctrl c to copy them let's open the developer tools so now we can go to the console and now we can put them inside quotations and now we can split them so pay attention to this look at this pro gamer moves all right so now you get an array of emojis which you can copy so you can copy the object so now inside of our routes let me just go here I have routes so now I can say emoji TS and now we can just copy and paste our emojis here but of course we have to go to the top so now we can say export fonts emoji and that's basically it and if you have some that you don't like you can just remove it or swap it out and that's basically it so now let me close that I'm going to go to routes open plus page svelte like this. Let me close everything. So now I can also use a snippet here. I can say import emoji and we can see we can already get auto-completion which is awesome and we already set the prettier settings from before. Now it's going to auto-format. How beautiful is that? So let's look at here what we have and now we can say hello and awesome. How beautiful is that friends? All right so in the next part we're going to talk about state management. Let's talk about how we can manage the state of our application or game in this case. You might be used to using booleans to represent state, but that's really a bad way to represent state because you might get into impossible states. So instead of using booleans, let's use explicit state, which is basically just a string so we always know the state of our app or game in this case. So as a challenge, I want you to pause the video and think about all the possible states our game can be in. So I hope you at least took a second to exercise your brain muscles, but for the state we're going to have a start state, or this can be named idle, so we're waiting for the player to start the game. We can have a playing state, pause state, won, and lost state. And we can also have intermediary states if you want, so we can have playing, matching, or whatever else you want. And this is really powerful if you do some animations and have data attributes For example we have some div and on that div you can have data state and now we can pass it the state variable and this is now really easy to target in CSS and style it however you want trigger some behaviors and etc. Alright, so how do we turn this into code? Well, we're going to use a TypeScript alias, but if you're not using TypeScript, you can create a JavaScript object, so you don't make mistakes, and even you can use a TypeScript enum if you want. So here's how I'm going to do that. So I'm going to create a new line. I'm going to say type state. And now I'm going to assign it the state I talked about. So we're going to have start. And then we're going to have plane. We're going to have a pause state. And then we're going to have one. And we're going to have a loss state. And that's basically it. And now we can create some state. So we can say let state. And we can assign it that type. And by default, it's going to be start. so you can see now we get this awesome autocompletion so it's less error prone. And that's basically it for managing the state of our app. Alright, so let's work on creating the game. We can hard code the emojis we want and shuffle them around but that's really boring and we might later implement some difficulties and etc. So let's create a function which can create a dynamic grid. So first let's add some more state. So we're going to add the size of the grid which is going to be 20 by default and then we're going to say let grid and then we can create a function create grid. So now let's go to create the function. We can say function create grid. Because we want unique emojis, I'm going to use a set. So I can say let cards equal new set. And if you're using typescript, we can say here they're going to be of type string. Alright, so how do we determine the max size? Well, we can say let max size. We're going to look at the size, which is going to be 20, and we're going to half it because we're going to select 10 emojis and then we're going to double them and shuffle them. So we can say while cart size is less than max size then we're going to keep adding them. So we want a random index so we can say random index equals and then you can say math floor math random times the emoji length. Alright, so now we just need to edit. So cards, and we need to type this properly.

 alright so we can say cards add which is really simple and now we can pick an emoji using the index so we can say random index and that's how simple that is and then we're going to return a shuffled version so let me just go here we're going to create this function in a second but we're going to say return shuffle and then we can just use spread so we're going to create an array we're going to turn the set into an array so we can spread cart and we can spread them again. Alright, so now let's create the shuffle function. So we're going to have a function shuffle. You can use a library, but I'm just really going to use this simple method. And then we're going to accept items. And then let's just return array. I'm just going to name it items, actually. Let's say items sort and we can just pass it a callback and this is how simple it is. We can say math random minus 0.5 and it's basically going to give us some random items and just to be consistent how i have it i'm going to rename this to array and let's just type this as a generic isn't anything spooky if you're not using types you can ignore this but this is really simple to type so we're going to pass a generic is going to be items and then this is going to be an array of items and that's basically it so now we're going to get types when we use shuffle all right so i'm going to save this and let's just console log our cards. We can console log cards. Before I say, let me just open the console here. Or let me just see what we have. Actually, it's grid, not cards. Alright, let's save this. And let's see. Do I have the development server? Of course I don't. So we can start the development server. This should take a second. So now we can say localhost 5173. and we can see we have our unique emojis. So this is how simple this is. So now we have this function where you can create dynamically whatever you want. So later, if you want to implement the difficulties, you can play around with the grid size or whatever else you want. This is how simple this is. All right, so let's add more things to track the state of the game. So we're going to need max matches so we know when the game is over. We want to know what the selected emojis are or cards, right? And then we want to know the matches so we can compare it. So below grid, I can just say, let matches max matches and that going to equal to the grid length divided by 2 because we need to half it by 2 because we want the unique emojis. So for example if you have a grid size of 20, if you reach 10 matches then the game is over. And then we can say let's select it which is going to be an array and it's going to be a number so we're going to have numbers here so this is going to be the card index which you're going to compare and match and then we can have let matches which is also going to be an array and that's basically it but these are going to be strings so this is going to be the actual emoji that's basically it for the state for now so now let's add the markup you're going to see how awesome using explicit state is so now we're going to go here inside the markup area so let's just start by creating an if block so you can say if state and now we should also get great auto completion so if state is start then we can say h1 we can say matching game and let's also add a button it's going to say play and on click you can create a function for this I'm just going to say state is play and this is going to kick off the game so now let's create another if block so you can say state is equal to playing. Now we're going to have a cards div. And inside of here we're going to loop over the cards or grid in this case. So we're going to say grid as card. We're also going to want the card index so you can use i but I love to be explicit so I can say card index so it's clear what this is. And then again we can create a button. So let's just say like this button card. So we're going to create a button with a class of card. And then inside of here, we're going to create a div. Now we're just going to output the emoji like this. So let me save this. And you can see our markup is already visible. So now if we go here and press play, we're going to see here the generated emojis. How beautiful is that, friends? All right, so now we have to add the lost and won state. So again, this is really simple. So you can see how explicit state is awesome. We can get into an impossible state because we always know the state of our application. So I can say if state is lost and then we can say you lost And we can also rub the salt in We can say, let's see. This beautiful poop emoji. We can use that. And then we can also offer the player to start again. So we can say, play again. And here for the button, we're going to say on click. Again, you can turn this into a function if you want. This is really simple. So we can say state playing. Alright, so now let's copy over this part. So this is going to be really similar. Going to be one. You win. Let's add another one. Say party. I like this one. And this is going to be the same. So play again, and we're going to change the state to play. But of course, you can change this however you want. All right, so let's add the styles. I'm going to go here. So we're going to say cards. We're going to say display grid. Grid template columns. I'm going to say your repeats. We're going to have five columns divided. So fractional unit. Then we're going to have a simple gap between them. 0.4rem. So now when we look at our cards, we should have a grid. So that looks beautiful. So let's tile the card. And we can nest this. Now CSS supports nesting, but it's going to have it separate like this because even I have a tolerance for the level of nesting I'm comfortable with. Yeah, but basically I'm going to say height. 140 pixels. The width is also going to be 140 pixels. So font size is going to be 4rem because emojis are just text, right? so we can say background color we have some CSS variables I'm going to use so I can say pg2 and then we can use nesting so here is how we do it in CSS so we're not using sass or anything, how awesome is this so now we can use ampersand point selected so this is going to be the selected style later when we implement this and then we're just going to add a border which is going to be 4 pixel and you just going to use a variable All right so if I save this we should see our styles look awesome how beautiful is this friend so let see how everything looks like alright so in the next part we going to work on matching the cards alright so in this part we're going to work on matching the cards and of course here I made a blunder because this new keyboard is killing me, my ability to use the computer is at 60% which is really fun so let me just save this and this should be great, so let's see how we can match the cards alright so how can we know when is the time to match the cards well we can use a reactive declaration in Svelte so let me just go here I'm going to remove this console log and we can go here and I'm just going to use a dollar sign so this is going to be a reactive statement or declaration so we can say selected length so when we have two cards selected then we're going to do something so we can say and match cards and you can also write this as an if statement so you can be like this, you can say if selected length equals 2 and then we can make it reactive like this match cards and you can even turn this into a reactive block if you want so you can have all your if statements inside of here and that also works great but I just like to be terse here alright so let me just remove this so that's really great so we can invoke match cards and then we can also say, hey, if max matches equals to matches length, then the game is won. That's how simple that is. So basically whatever you specify here in the reactive declaration, Svelte is going to treat as a dependency and this is going to rerun. So you can see here we specify selected, so this is going to get tracked. And here we selected max matches, this never changes, right? we define this once but matches does change right so this is going to get rerun and how awesome is this so now we can specify a couple of functions so here we're going to have one function which is going to select the card so we're going to say select card like this then we're going to have another function which is going to be match card so this is going to get invoked how cool is that and then we're going to have function game1 and that's it So we're going to update this in a second, but for the selected cards, we're going to accept a card index, which is a number.

 So now we're going to update the array of selected. So we can be the generate here. We can use array spreading, but I can already hear the primogen screaming at me. So we're going to say selected and we're going to use the concat. Wow, such a pro game move. We're going to use concat instead and then we're going to say card index. So basically this is just so we don't abuse spreading because you don't always have to spread things in JavaScript because it's more expensive, right? All right, so the logic for matching the cards is simpler than you might think. So we're going to destructure two values from selected which are going to be the first and second card. So we can do this and now we can use array destructuring. So we can use the selected array and when you destructure an array you can name these values whatever you want. So this can be banana apple. So this is going to be the first and second card whatever is in the array right. So you can say first, second. This is just a fancy array so you don't have to do things like this and then name these cards or whatever. Alright, so now we can look at the grid. So we can say if grid, so now we're going to say hey, does the first card match the second card in the grid? And if that's the case then we're just going to add it to matches. And again, to not be degenerates, we're going to say matches equals matches concat and now we can just look at the grid and we can just say the first card or you can even say the second one it's really not important and then we can also clear the card so we can say selected is empty so now we're going to empty the selection for the next one and also since we're here for the game one you can just say state once since we have great auto completion all right so now we can save this all right so let's implement this logic right or actually invoke it so we can go to our card here where we have the loops so we're going to add something here let me just go here create a new line so we can say on click going to pass a callback we're going to invoke select cart I'm just going to pass it the card index all right so let's see if that works here I'm going to let's just use again our reactive declaration we can say console log you can even console log out state so you can have state select that and matches all right so let me open the log I going to clear everything So I just going to zoom this out so you can see more what's going on here. So as you can see, if we select the first one, so this is going to be the index, and then when we select this one, it's going to get cleared. As you can see, it's not a match, so we clear the selected. But let me just comment this out. as you can see here is the star state we can select this one so now we can just continue selecting them and then there's no end so we have to clear it let me just uncomment that another thing I love to do so we can do set timeout so we can give the user a brief moment to see what's going on so we can say selected going to empty them but we're going to wait 300 milliseconds like this so let's just do it like this so we can play the game and we can select them you can see it takes a second and then it's going to clear it so let's add some more things here so now we can select the card but we also want to apply that outline so how can we do that we can go here and we can say class select it remember this is the class we made here select it choose apply to the card so now we just need to pass it the condition and the condition is going to be is selected and for this you're going to use the local constant which is really awesome it's a way so you can create variables inside your each block and in this case really don't have to create the variable but this is going to be more readable but in the case where local constants are more useful is in the cases where you have to create a component to compute some state right from each because there's really no other way to do it besides creating a function maybe or some other way but yeah local constants are really awesome so let's see how we can do that so we're actually going to create three local constants is selected, is selected or matched so we can disable it because right now we can select just how many we want and even if they're a match we can select them again which really isn't ideal so we want to disable it and then we're also going to have a match one which we're going to add the styles in a second so here I'm just going to go inside each loop and I'm going to create a local constant I'm going to open the curly boys Now I'm going to say at const, so now we can say is selected, and we know that by saying hey selected does it include a card index Then we know it selected So we can do this again We can say const is selected or matched or you can name it match whatever you want. And now we can say selected includes card index or matches includes the card. And that's basically it. And now we can create the last one. So you can say const match matches includes the card. Alright, so now we can use this. Now we apply this class condition we selected. If is selected is true. And now we can do the same for the disabled prop. We can say, hey, this should be disabled if is selected or matched and then for the card itself we're going to have a conditional class match based on the match so we don't really have to do anything special here alright so we can save this and now we should see the outline when we select the card so now we know what we're selecting we select these two for example and now as you can see here they're matched so now we can't select them anymore so yeah now we can select anything we want So this failed, right? So let's add these two. And we can see they're added. And yeah, that's really beautiful. So let's just update the card styles here. So here we have selected. If we load this, we can use an ampersand. And then we can say match. Then we can give it a transition so we can fade it out. We can say opacity 0.3 second ease out. so now we're also going to reduce the opacity so as you can see here it already kicked in so now we can select this guy with the monocle and i'm really bad at this game okay so we selected this one so you can see it works for all the other ones let's see where is he yeah and now we can play the game and this is how simple this was you can see here they are and now you match them and this is really beautiful all right so let's also show the match card so we have to go where we have playing right here, I think, okay? So we can go here. And now we can say div with a class of matches And now we can use each loop We can say matches Yes cart now I can create an empty div and we can just output the card here so let's just say the styles for this so this is mattress so now we're going to add a new one so not inside card we're going to go outside of card i'm going to say matches going to say display flex gap is going to be one ram margin block going to be two ram and the font size is going to be three ram all right so let's save this and let's try playing the game so we can select this mask and you can see this is matched. How beautiful is this, friends? And yeah, our game works beautifully. As you can see here, we have this great state so we know we're playing and et cetera. We know the selected cards and we know the matches. So in the next part, we're going to implement the game timer. All right, friends, let's work on the game timer. But before I do that, let's just turn this console log into an object so it's easier to see. So we can go here. Let me select this and I'm just going to turn this into an object. And that's basically it. So we need to add new state. so we're going to need to keep track of the interval so we can clear it inside of our app and then we're going to set the time so we can go here and I'm just going to say let timer id which is going to be null by default and it has a type of number or null so you can say number or null and that's it and now we can set the time which is going to be 60 seconds by default but I'm going to give it 20 seconds just so it's easier so we can see the failed state. So now we're going to create a startGameTimer function. You can add this wherever you want. So we're going to add it here. Function startGameTimer. And this is going to be really simple. First, I'm going to create a function countdown. And then for each tick, we're going to subtract the value, but only if the state isn't paused. So we can do some defensive programming. We can say, hey, if the state isn't paused, again, great auto-completion. then we can just say we have to put it in parentheses otherwise it's going to be invalid syntax, let me just show you so we can say time and now we can say minus c plus one, so it's going to subtract one, but as you can see this is invalid syntax so we can just put it inside of parentheses or you can have more readable code and use an actual if statement but yeah, I like this. Alright, I'm

 Now we can create a timer ID for the interval, right? So we can say timer ID, so we can reassign it. We can say set interval. So we're going to count down each tick each second. And that's basically it. And this is also awesome when we implement the pause state, so our timer isn't going to run in the background and ruin the game. All right, how bad would that be? All right, so now let's just go here where we have game one. So basically, I'm just going to copy this over. so we're going to have game lost and now let's see we have lost and that's it so this might be a great challenge for you okay so how are we going to invoke the game lost maybe pause the video and try this here is a hint maybe what is the condition where the game is lost I'm going to wait have you figured it out well let's just go here create another reactive declaration we can say color sign if time reaches 0 then the game is lost. And that's basically it, how simple that is. So another challenge, maybe if you want to accept you want to start a timer if the state is equal to playing. So that's maybe another challenge if you want to pause the video but let's go ahead and do that. So now we can say $ and of course you can be thirst like here but let me be more verbose here so the code is more readable. So I can say, hey, if state is equal to playing then I can just use an if statement here. So first we need to check if there is no timer ID. And we check this because we're going to go from the pause to playing state, and then we would start the timer each time, right? So that's really bad. Then we can say, hey, if there is no timer ID, then we're going to start the game timer. Alright, so now let's set the game timer. This should be here before matches. We're going to go here and say H1. We're going to have a class timer. so we're just going to output the time here which is going to tick and then I'm also going to apply an animation to it when it's below 10 so it's going to have a pulsing effect we can say class false and then we can say hey if time is less than or equal to 10 so this is going to apply the class pulse which we're going to add the styles right now so let's go to our styles and now we're going to add new styles here for the timer so you can say dot timer we just going to add a transition to it which is going to be color 0 seconds ease Now we going to add the pulse animation So we're going to do it like this. I'm going to say color, which is going to be red, or tomato. So we're just going to say pulse like this, and then we're going to use an animation. Pulse one second, because there's a tick every single second. and then we can say infinite and give it an easing of ease so now I can create the keyframes so we can say keyframes pulse we can say 2 and we're just going to change the scale or increase it in this case let's just save it and let me just clear everything here so let's pretend we're playing the game oh no we're struggling as usual ok now we should tick So this is going to apply the class pulse. You can see 10, 9, 8, 7, 6, 5, 4, 3, 2, 1. Happy New Year. Oh no, you lost the game. Oh, my bad. Okay, so this is it. You can see this works great. And we can even change the size. Let's see. Just so the game is done quicker. Maybe we can go here and change the grid size to 4. And let's just say play. So let's see if we go, yeah, we go into the win state. So another problem is that we didn't reset the game, which we're going to do in the next part. For reference, we're gaming so hard right now, but we need to reset the game. So how do we do that? Let's go to match cards probably. Here we can add it. So we can add a function, reset game. And now we're going to need to reset it. So we can check if there's a timer ID. Then we can clear the interval. this is why we had to assign it globally so we can clear interval timer id that's how simple that is now we can also reset the grid so we can say create grid we can also reassign max matches going to be grid length divided by 2 let's empty the selected same for matches timer id is going to be null again and the time is going to be 60 seconds in a real game but in this case let just reset it to 20 seconds alright so where do we invoke this So we can go when the game is won We can also say reset game And when the game is lost, we can also reset the game. And then basically how simple that is. So let's play the game. We're gaming so hard right now. Okay, so... Oh, wow. Wow, I'm such a gamer. Holy crap. Wow, okay, so now we can see everything is reset. Even if we reset the game, of course, the timer is going to reset. But yeah, we can win like this. So let's see if this works when the timer runs out. So really anticlimactic. And cut. So let's see if this is going to work. So now we should lose the game. Nice. And we can see the timer is reset. So this is really beautiful. Alright, so next let's create the card flip effect. And to achieve the card flip animation, we can use a simple CSS 3D transform. So if we go to the button here somewhere. Okay, here it is. So we're going to apply a class flip on the condition that the card is selected or a match. So let's just put it here. You can say class flip is selected or matched. That's basically it. And now for the card itself here, you have to apply a class of back. So now let's find the card styles. Here where the card is. I'm just going to apply a transition here. so I'm going to say transition rotate 0.3 seconds ease out now we need to say transform style preserve 3D and now let's place it here so we're going to create a flip and back class basically we're just going to hide the back face and then we're going to flip it and that's going to get animated so we can go here and say ampersand flip like this and then we're going to say rotate so we're going to use the shortcut property rotate so we can specify on what axis we want to rotate it we can say y is going to be 180 degrees and then we're going to say pointer events none so you can't interact with this because you can cause jank awesome now we just need to create the flip effect itself now we can say ampersand let's put a space here back so this is the effect on our card we can say position absolute let me just really show you how this looks like so this is like this so now we have to fix this so this position absolute inset so we don't have to do left right top and etc for all of them so we can just say inset We going to center them by saying display grid Place content not container Center, so you can see here it's fixed. And now, this is the magic sauce. We can say back face visibility hidden. And now we can rotate it. And say rotate again y-axis. 180 degrees. And that's it. And now we can play the game. This is how this works. So this is really simple. Alright, so let's try to be a pro gamer right here. There we go. I didn't even try. That's how easy this is for me. No effort. Easy game, boys. And girls. I don't want to exclude anyone. 6, 5, 4, 3, 2, 1. Oh my god, this game is so rigged. Horre, friends, so in the last part, we're going to implement pausing the game. Horre, friends, so you're playing the game, you're crushing it, but then maybe someone rings you on the phone or you want to eat a sandwich and now you can't pause the game so now all your progress is lost and you can't show anyone how awesome you are at this game. So let's fix that by pausing the game so let's find a pretty little spot here. This looks great to me we can go here, create a new function. We're going to create a function pause game which is going to take an event so we're going to listen to a key event which is going to be escape. So now we can say keyboard event type and let's just do this so now we can check if event e is equal to escape now we're just going to use a simple switch statement so let's just say switch state and in the case we're in the playing state because we don't want to pause the game when we're on the playing screen right waiting for the game to start that doesn't make any sense right so we can just do it like this and then we can say state reassign it to pause and we need to break out of this you can also use an if statement if you want now we can also say hey if we're paused then in this case we can set the state playing again and we can also say break so we can save this so now let's add an event listener which is really simple to do in Svelte we can go right here and we can say Svelte colon window so it's going to add this for us we can say on key down and now we can say pause game awesome let's save it and

 That's how simple that is. So you can just say if. And again, how simple and awesome explicit state is. So if we're paused, then we're going to say game paused. And how powerful is this? So really we can get into an impossible state because we're using explicit state. So let's see how awesome this is. Let me try pressing escape here. It doesn't work right. How great is that? So let's just start the game. So now we're gaming super hard. And now let's see, 54 seconds. so we're going to press escape so remember here where our gain timer was this isn't going to run out of time because we actually set it to only tick here was the timer okay we set it here so if the state isn't paused the timer is going to tick so let's see if this works if I press escape again oh where we left it how awesome is that friend and now we know always what state we're in and etc so let me see if I can beat this game by talking to you let me see what is this game I'm going to do my best and oh look at this oh my god how easy this is friends right so let's see oh can i beat it oh no oh no this is rigged take it back this is rigged okay it not really it not really doing great boys we can can beat this Oh my god Oh I know you here Okay maybe No no no I can do this Easy easy game What? I don't need to see here. Okay. Let's see. Oh, no. Oh, no. I was so close. You know what? I didn't get enough sleep today. That's why of course I'm usually a pro gamer like this. But yeah, this game is rigged anyhow, so who cares, right? But yeah, that's it friends. So as an exercise what you can do, try breaking the game into separate components and you can also add difficulty levels for the player to choose from. So you can have easy medium hard and you can also use explicit state for this, which is really simple to let you control the UI. Alright, so I hope you had as much fun making the game as I have and you learned something along the way. So don't forget to like and subscribe. If you want to support me you can become a patron and you can join the discord. Thank you for watching and catch you in the next one. Thank you.