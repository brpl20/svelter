 Hello and welcome to the video. Today I thought I would talk about a topic that is super interesting which is SvelteKit streaming. So ever since streaming was announced in February of 2023 I've been super fascinated with how it works. Like how can you load some data in the initial response and then stream some data in later. So today I thought we would look at exactly that. So we're going to take a look at the technical details. How does it work on the browser level? We're going to talk about when it makes sense to use streaming, what kind of considerations there are maybe for SEO or for users that don't have JavaScript, and we're going to talk about how it works on different server platforms like serverless hosting or Node.js hosting. So we're going to do that by taking a look at an application. We're going to start with having no streaming at all in it and then we're going to progressively add more and more streaming and see how that affects the user experience and what kind of changes makes in the browser. So without further ado let's get into the video. So this is the site we're starting out with. This is a demo project that I prepared for this video and it's the fittingly named StreamCo. And right now if we load the page up we see that we have no streaming going on the page just loads. We can take a look at the HTML here and we can see that the HTML is all being loaded into the page here. Welcome to stream code, that was the text that we saw here and so on. Okay and now we're going to progressively try to add streaming to this site. So let's first have a look at the code and this is the demo project. We have the plus page.svelte file that makes up the main page and here we see that we are rendering various items that's coming from the server. So we have the quote which is this quote up here. We have the menu items which is these items on the left. We have this is open boolean which is actually showed down here that takes into account the current time and shows whether the fictional company is open or closed. And then we have the main content which is what makes up this part. Right now if we look at the server function, we have kind of like, it's just dummy data, right, and we have kind of like modularized it into these different functions to easily be able to refactor it. So we have a function to basically get all of this different data. So what I'm actually going to do is I'm going to copy this existing code into a new route, which I'm going to call streaming, and I'm just going to paste the same code in and that way we can go to this streaming page and we can kind of compare the streaming and non-streaming versions. I'm gonna start by refactoring the quote function. I'm gonna just make it async here and when I do that, let's see here, I need to change the right file as well. So I'm gonna go into this file, streaming one, I'm gonna change the function to async and by itself yeah that's gonna give us the object promise because we return here quote from the load function and instead of when we make the function async instead of returning the actual data we're going to return a promise so that's step one and the second part we need to do to make it streaming is to actually use the svelte await syntax so in here in this quote block I gonna go ahead and type await quote There we go And then while I doing that I can sort of show a loading state There we go and then when the quote has loaded that's what I'm actually gonna print the quote and of course if something goes wrong we can catch that error and show that the quote failed to load all right here we go so now I have converted it it was a little bit more cold but now we have streaming in place but when I reload this, we barely see anything happening here, like we see the text kind of flickers and to make it more visible what we're actually doing I'm gonna introduce an artificial delay kind of like it was being the state is being fetched from some from some third-party service somewhere. So I'm gonna go ahead and create a delay function, here we go, and I'm gonna actually just introduce some effective delay here. So we're gonna introduce two seconds of delay. Now when I reload the page we see here that we have loading inspiring quote and then the quote is replaced with the actual data. So first thing that is going to be different about this is that the final representation, the streamed in representation is not part of the initial server-side render data. And to kind of compare that I'm gonna show you the source for both of these pages. So if I go first to the non-streaming page and I check the source code and I look for this text of the Steve Jobs quote, I find it right. It's in the initial server-side render response and if I go to the streaming version. I'm gonna change the title of this page to say streaming instead. That's gonna be great. So we can tell them apart. Here we go. And if I go here into the streaming version and look for the quote, I don't see the quote in the initial response, but I do see it here in this weird script block. So what is going on here? This is the way streaming works. So let's kind of have a look at how it does this. In a normal request, the user asks for page, the user's browser asks for page, and SvelteKit builds the full page, fetches all the data, awaits everything on the server, gives us the complete HTML back. And the only thing we have is the start of the HTML tag, the end of the HTML tag, and all the content in between. In a streaming request the user browser does the same thing, it asks for a page, SvelteKit returns the full HTML but then it actually keeps the connection open, it doesn't close the connection like it does in a normal request. Instead it leaves the connection open and then it returns a inline script block for every streamed update, basically one per await that you have in your code and only once that is done does it actually close the connection. And I thought it would be maybe more interesting to see how this looks kind of from the browser perspective in real time So what we gonna do is we gonna run a curl command and this curl command is going to show us how the kind of browser sees the page as it's receiving it. So I'm gonna open up a terminal here and first we're gonna run the non-streaming endpoint. So we're gonna curl fetch the non-streaming endpoint and when we do that we immediately got the response because we don't have any big data loading going on here and then we have the end HTML tag. Great. Now let's try the streaming endpoint. All right, he saw that. So we first got the HTML tag but the connection was left open and after some time we got this extra script tag and this one calls sveltekit dev.resolve and it has the data we need and what this method does it's going to look a little bit different in production but that's not important what this method does is actually going to reach into some code here which actually is going to replace that part that svelte component that's going to use that streamed data. And so let's look at that again. So first we got the initial response and then we got the extra streamed data. So what I'm going to do now is I'm going to make all of the different data loading streaming and we're going to kind of see how it works when you have multiple updates going on. So let me go ahead and do that. All right, and now I've refactored everything, so let's take a look at the new endpoint with streaming. So as we reload it, we see that we get all these different loading indicators. We have loading up here, we have loading for the menu, we have loading for the content, and we even have loading for this closed or opened state. So you can see here how it works. Now let's look again at the curl for this request now. So I'm going to clear this out. I'm gonna call the streaming endpoint again, and we're gonna see multiple script tags being appended. So, and how this actually works is that as long as, even if you close the HTML tag, if you keep sending script tags afterwards, the browser is actually gonna execute them as they kind of stream in, as they come in, and run that reactive code that will update the data. So it's actually a very, very smart system that is being used here, where it's using a browser behavior to be able to stream in the data. Now that we've done this, let's talk a little bit about like some of the issues with this approach or some of the considerations that you might take. So for example, one thing is that because this is using script tags, it does not work without JavaScript. So if I go and I kind of disable JavaScript here on this page and I reload it, you see we get stuck in that loading state. And this is the big downside with streaming, that it's not a thing that you can easily, progressively enhance if the user does not have JavaScript available. Like for example, with form actions, those we can kind of still have working, even if JavaScript isn working by relying on the normal form handling in the browser But with this approach with SvelteKit streaming it just not possible So that a big consideration to think about before you start to stream data. And the second consideration is SEO. So as we saw, the data isn't present in the initial response, and it's kind of because the initial response is just these loading states and then as the extra script tags are loading in that data the loading state gets replaced with the actual data. And Google and other search engines now they do run JavaScript so you can have like a single page application that is completely client rendered and have that actually work and be indexed by Google. But Google kind of does a two-pass indexing right now. So they will first fetch your HTML and kind of just scrape all the data that's in there and that's gonna be available in searches pretty quickly. And then they're gonna kind of come back to it at some point later, it can be just hours or it can be even weeks if the site isn't very popular, and actually run the JavaScript for the page and then actually resolve all of this kind of streaming data and single page application stuff that might be rendered client-side. So even though your page will eventually get indexed even if you use streaming promises, if SEO is very important to you it might not be like a really good approach for important content, content that you want Google to see quickly and react to quickly. So that's a big consideration. You can still use streaming promises for stuff in the sidebar that's maybe not so important, latest news in the sidebar something like that, or a comment box that is shown under articles where you maybe don't care too much if Google indexes that quickly or not. So these are the two considerations that I have when I'm thinking of using streaming. And then I also want to talk a little bit about which platforms you can actually use this on. So as far as I know streaming does work on the kind of major serverless platforms so if you run something like Vercel you're gonna be able to run to use streaming and I do believe that they also work on on it also works on Netlify as well. It also works in Node.js so and I think that a lot of people are maybe not using who are not using serverless platforms they're probably using Node.js or something like BAN or Dino and generally those type of non-serverless platforms are supported for streaming. So the support is very good. You might run into some problems with custom adapters or I believe in the blog post it is mentioning that stuff built on AVS Lambda will not support streaming. Although I do think there is some workarounds, there has been some workarounds to this since the blog post was released. But it's very important to without before you invest too much time to actually check that streaming is working with your provider. Thank you so much for watching to the end of the video. If you found the video interesting please leave a like and subscribe if you want to see more content like this. If you have any suggestions for things you want to hear about in upcoming videos please feel free to leave a comment as well and I will see you next time.