 Hey everybody, welcome to This Week in Svelte. I am your co-host today, Enrico, and joining me is Karim. Hello everyone. Hello. The agenda, as usual, every Friday we talk about what happened at Svelte or on the Svelte Discord, including the changelog, quick facts, community showcase, discussions and questions and answers. No place to start than from the start with the changelog. Oh, this whole time I had the Discord chat overlaid. Apologies, YouTube audience. So we had a couple, well, a handful of Svelte changes. The first one is 4.0.2. I'll go over these. Most of these are patch changes that you may have not noticed, but if you do, you do. Reflect all custom element prop updates back to attribute. So some improvements have been made to Svelte components building as custom elements or web components, What do you like to call them nowadays? Do you say custom elements API? I wonder. Next is fix the shrink custom element baseline a bit. That's probably the output size. Use non-destructive hydration for all HTML tags. This may have been related to an issue. I wonder if I can hover over. No, there isn't context. Next is align disclosed version exports specification. I haven't looked too deeply into that. but it probably has to do with building component libraries. And then finally, source set when hydrating to prevent needless requests. There have been a few patches related to source set, like even 403 has a source set patch, because the way images are handled with the source set attribute, you want to make sure that sometimes relative or absolute links are used judiciously and spelled accounts for that. In 404, SVG tags in raw mustache tags are correctly created. Okay, so I guess there was an issue with braces being misinterpreted in SVGs. Repair invalid raw HTML content during hydration. Good. And then generate type definition for nullable types. This may have been related to last week's patch for type generation. Nullables are kind of tricky. I wouldn't know too much about them. But SvelteKit also has some updates We have version 1 There a new head server method Interestingly SvelteKit manually maintains all the HTTP methods available in plusserver files or plusserver So head is a new one You can do export post export get, export options. Options was the recent addition, and now head is the newest. Support caching of responses at the very header. This was an interesting feature slash patch two in one. What happened is some people use content negotiation, which means a single Svelkit route can have two kinds of get requests. One is a backend JSON get, and one is a HTML get. But with the new built-in support for the very header, if you do have this setup in which there's a get request for JSON and a get request for HTML, SvelteKit will automatically add the very header for the content accept type. The accept header will be added to very. So if you want to learn more about that, check out the related pull request. What this means is if you go to an HTML page and then open a new tab, There used to be a bug where it would load the JSON instead of the expected HTML. But thanks to this new Vary header, that will no longer happen with content negotiation. Patch changes. Avoid running load function on invalid requests. This is true. Related to the new head server method, you want to make sure load does not get called. When you're doing content negotiation against options, for example, you want to do an HTTP request. So why should load run? It no longer does that. the page store updates when the url hash is changed that's good so now you can expect the page store to be reactive to hash changes and there it is again the very accept header is there to correctly cache the right pages based on the accept header so that's good 1.22.1 a performance improvement. Only have Vite generate relative paths when required. I looked at this lightly. I think this is mostly like generating the build for your site. So the build time performance has improved a bit by determining whether to use relative paths or full paths instead. So there you go. That's the change log. Next topic. is quick facts and announcements. No announcements, but a couple of quick facts. First off, I think Karim you made a tweet is that right Let me open the tweet Yeah I did I just realized that this is actually not the best example but there were a few comments So you know it about we have cons and I rarely use it I don't really think there is much use for it. But, yeah, it's useful to generate IDs, I thought. I think it used to be only possible within, I think, in each block, and now it's also possible in, like, every other block, if blocks. And yeah, it's just not possible at the very top level. So here, the each bug is actually missing. It's not the best example here because you could actually also use ARIA label instead of ARIA label by, but ARIA label takes higher presence over ARIA label. But if you scroll down, there are other few use cases. You can use this to group in the comments. Scroll down a bit. It won't show. Hang on. Twitter is rate limiting me. I think Hunter might mention that he also does this too. Here it is. One second. Group labels and I think inputs. I think this would actually, personally, I think it would be great if you could actually use this everywhere in the template because in that case, it's really related to the template. So if you don't have an each or if block, you can't actually do this. But I like to do this sometimes because especially when I have like small components, I don't want to create components for buttons and icons because you're just wrapping styles basically. So yeah, if you need an ID, you can do this, but only inside if and each and whatever blocks we have. Yeah, that's correct. So the const, I call them directives, but that's incorrect. I think the Svelte docs refer to these as something else. I use them quite a lot, actually. So today's your lucky day. The logic box, special tags. so const is a special type that lets you define a variable in line with your html i actually use this quite a bit because i have a lot of if statements and and i have a lot of each blocks in my code so in there i use these const statements to determine conditionally whether to display certain content such as a label for example i want to input label to say enter your name or enter your pet name That a really contrived example But I use const to set up that logic by adding a ternary or an inline condition. And then in the component, I pass in the prop as a single variable. So the component markup looks cleaner. That's why I like to use const, especially in each loops. So you use const for data? Yeah. Just for display logic, like I use const to hold a variable to show a static string to display to the user, such as an input label. Oh, okay. I see. Yeah. Makes sense. Yeah. It just cleans up the Svelte markup a lot because you don't have to have inline functions or inline ternaries inside the braces. You can define const up above and then below in your HTML markup, it looks a bit cleaner. That's why I like it. I think it really makes sense if this works every way of a markup, because I think this It's mostly related to mock-ups, so it doesn't necessarily have to be the script block. But yeah, you need an each block or an if block to do this. That's an interesting wish list item. Maybe you can wish that the const could be defined in the global scope, besides being nested in if or each. But yeah, as of today, const has to be nested in if, else if, else each, then catch, as well as you can do it inside the swell fragments. So if you're doing a slot, you can also have const. oh that's pretty cool right all right nice so let's move on to something i learned recently i learned this like a week ago i took it for granted that when you have a form element in html you can call dot submit to submit the form but there are some things to watch out for When you run submit, the actual submit event is not dispatched. So if you have an on submit event handler, it will not run if you call dot submit. There's also constraint validation. Alternatively, if you use request submit, so if you have an instance of form, an HTML form, and you call request submit, this is sort of like a virtual way of calling the submit button, which means it will actually call the submit event if you have an on submit event attached to your form. And I think this is widely available in browsers. I'm not sure if this- Yeah, it is. Yeah, there we go. It's been around for a while. So you can try requests a bit.

 However, if you're using SvelteKit form actions, you may not need either of these most of the time because use enhance can have options passed in. So if I look for the enhance docs here, let's say like majority of the time you want to submit a form but enhance it so that it shows a loading or intermediate state. Then what you do is you have use enhance. Let me zoom in more. Gotta zoom in. as soon as use enhance gets called the upper scope of the function here where i'm highlighting here you can say loading is true and then you can have a variable react to a form submitting and then finally down here you return something this is the callback when the form action completes and here you can say loading equals false and then your loading state view or loading spinner can disappear this is uh this is great for quality of life developer experience otherwise if you happen to be using form instances, then you can also check out request submit. I'll leave it in the chat along with Karim's tweet. I think request submit is, at least I use it frequently when I submit the search form and you want to submit the form while you're typing. But it's updated, like a footer form. Then you can call request submit and the enhanced action will handle it. Yeah, that's true. If you call request submit, it will also call use action. Is that right? Sorry, use enhance. Yes. Yeah. Yeah. Because it's also a simulated submit button. M writes in the chat, having const in top level, not in side blocks would be cool. I was hyped to use that when I saw it being added, but was disappointed when it was constrained to blocks and templates. Are you aware if this was discussed? I'm not aware, but I think the right place to check is felt issues or RFCs. perhaps there we can bring this up. But don't worry, we're actually going to segue into that very topic. Yeah, request submit. Pretty cool quick fact. And is that all the quick facts? Yes, it is. All right, let's move on to Community Showcase. We don't have one today. But as usual, if you have a library you'd like to present, an open source project, or if you yourself want to present some quick facts to this week in Svelte, join us. Let me know. Send me a DM. And now this week in discussions This week in discussions We have the Svelte 5 wish list Dominic Ganaway, recent hire at Vercel, recent new full-time core team member for the Svelte team, has asked on Twitter, what do you want to see in Svelte 5? Here it is. And I'll share this in the chat as well. So you can reply to Dominic on Twitter or on Discord. There's also a thread I will share. But this is a great time to bring this up. Like, what do you want to see in Svelte 5? What changes or new features? We were just talking a moment ago about top-level const that doesn't rely or depend on an outer scope template, like each or if or a slot or even a component. That would be kind of cool. Let me link to the other thing I promised, which is the Discord thread. So if you're on Discord, you can also reply here. Check it out. Personally, if I were to take a moment, I'd say my wishlist items are some improvements for component library maintainers. In the past few months, there have been a lot of new or improved Svelte component libraries. And I think some of the things that library maintainers would like to see, myself included, are things like conditional slots. And this was brought up in a prior week. Take a look at this. There's an RFC for conditional slots, which I guess, long story short, is easier syntax for conditionally rendering slots like this. You can say if condition, render slot. Sometimes you want to show a slot in some default content. And this alone gives you a lot of powerful features because you can have default content or an overritable slot. But adding a condition to that can give you even more flexibility. Maybe you have different markup in one slot and another different markup in another default slot based on prop conditions. Second to that is the forwarding directive. The forwarding directive rendered a couple of years ago. is one of the problems that component library maintainers face is having to manually forward events Because in Svelte events are not actually props they special syntax using the on colon characters here It not possible to globally forward all of these I think there's a Svelte extension or Vite plugin that lets you do this, but there's nothing built in today. So library maintainers would like to make, for example, a button component, but also forward all of these events using a single syntax. One of the proposed syntaxes are using a use directive or a forward directive. Like here it says forward on, and this will allow all events to be forwarded. That way the component consumer can decide, hey, on change, I want this. On click, I want this. On key down or on hover, I want to do this. And instead of opening issues in the component library saying, hey, can you please forward this? Can you please forward this? Here you can just indiscriminately forward everything. And then finally, this is less important, but a little bit more personal, is compiler options for CSS. Something I had requested, which I'm sort of growing into. At first I was hesitant, but I think it would be kind of cool to see component level compiler options. Right now we have Svelte options today. This allows you to set compiler options for components. What if it was possible in Svelte.config.js to choose a library? let's say you're consuming a component library like material and decide, hey, this module, this component in this NPM module, I want to disable all CSS. That way I can provide my own. If that were a compiler option, it would be kind of nifty. But that's just me. Karim, what are your thoughts? Do you have a Svelte 5 wish list? I'm actually not sure. So I was thinking about like improvements to the store contract, like being able to listen to specific props of an object inside a store. I think it came up a few times, but I don't know, but I think it probably would make stores a lot more complicated. Yeah, you would require more knowledge to create custom stores, so I'm not sure about that. I think the nano stores from Astro do this, and SolidJS also has a storage where you can specify a prop as a string and then you're just listening to updates to the prop in the object. But it uses E6 proxies so yeah, it's a little complicated. I not sure if this makes sense Yeah a small thing I would like to see is being able to bind to properties of web components just in case you using a web component it doesn happen too often but in Vue.js for example you can bind to yeah the value of a web component and you have to specify that in compiler options and tell you that every component that starts or every element that starts with sl- for example for toolace UI is a web component. Then it works but it's what that's currently not possible. Jason, I'm not overly sure about this but yeah, it would just be nice. Cool. If you could find that issue, share in the chat. I'm sure folks would like to have a look. But as mentioned in the chat, go take a look at Twitter or the Discord thread to see if you have a Svelte 5 wishlist you'd like to bring to the attention of the Svelte core team, and they will definitely keep it in mind. And if no one else has chat messages, let's see in the chat. She writes, proxies for array updates would probably help a lot of beginners. Array.push equals no reactivity. That is true. So today, arrays and objects, only all reactivity in Svelte works on assignments exclusively. You have to reassign the array or reassign an object for it to be reactive and actually re-render the DOM. I guess, yeah, some folks are thinking about some sort of opt-in behavior. So that when you call array.push, it will update the DOM. I think an opt-in behavior would make the most sense rather than to be the default because array updates, especially pushing new items is highly nuanced. It can be a performance hit if you're not careful with it. Personally, I do a lot of object manipulation in my applications. I do like delete key, delete this key, add this key, mutate this. Then I do the reassignment to re-render the DOM. So I like having that control today, but I can definitely see how people would like some of these functionality to be built in because sometimes all you need is a button click to push a new array item. And yeah, that could save you one line of code. So I can see it, but it has to be used with care. All right, so let's, I'll come back to the chat if anyone writes anything more. but for now, let's move on. Two. This week in questions and answers. Okay, so first question is how do you use local search?

 yeah custom store like this is just um how it's just a good way of using local storage or like any other um browser storage or even external um uh data service like um a socket uh or at sse so um yeah um it's just an overview of how you can do this using a store um you can of course of course use a pre-built package. I'll list some of them at the end, but it's very easy. So we have a store, a function to create a store. And this is just the general pattern that I like to use. So we create a writable store. Usually the subscribe is, you always have to turn the subscribe function because every store has to have a subscribe function, otherwise it wouldn't be readable. but very often you would want to control right axis. So set and update are just renamed to underscore set and underscore update. And, oh, there's a small mistake I see, but another thing when we're using SWAT kit is that if you're using browser APIs, you need to make sure that these browser APIs are only used in the browser. So we need to import the browser. environment variable you can use it directly inside the store I like to pass it into the store as a parameter so we have it in it's here and in its variable that by default is true so if you would just copy this function into a plain spread project it would also work without any changes and then if in it is true which it is by default but of the browser in in the in the server on the server it isn't then we get the key the data from local storage and we pass it to the writable and return a subscribe function and then here we can overwrite the set function we create a new one and use the the original set function here. And before that, we can also set the data using local storage API. This is not a complete example for local storage because there is a scenario where the user may have multiple tabs open of your app and in one tab the data is updated and that wouldn't be reflected automatically unless you subscribe to events that the local storage API dispatches. You can subscribe and listen to these events and then also update the other tabs. But this is just generally how you can do this, so you can overwrite the set function. You can also override the update function if you want to. But yeah, the store contract is just made up of the subscribe function, which you generally never have to change, and the set function, which is responsible for making a store writable. I think. Yeah, that's it. So there are a few pre-built packages that you can check out. I'm not sure if I can just copy paste that into the chat. Maybe I will. Most of them are from... I'll get in the chat for you. OK. Most of them are from people, from the community. So yeah, that's for the question. Another question or issue you may encounter is when using setInterval or setTimeHard, or is that set, just another set function. These functions, or these intervals, you have to clear them, and you should always clear them if possible, like always. And to do this, there are, like, you need to use something to have access to lifecycle functions. And as far as I know, there are three ways, three things that have lifecycle hooks in Swell, which are components using unmarrant. Then stores also have lifecycle functions, or lifecycle hook that starts stop notify, that we'll see in a second, and actions, theoretically, it doesn't really make sense in this case, but actions can also return a destroy and update function that you can use to clean up your timers or anything. When using on mount, it's very important that you don't use on destroy to clear your interval, because that also runs on the server. Instead, you want to create your interval on marned and return a function that is called where the component is destroyed A small downside of this is that this only runs after the component has actually been mounted So another way you could do this is use a store. And this is a readable store. It's just a function that creates a readable store. And this here is the start-stop-notifier. So you can use that. and it's called whenever the first time a subscriber subscribes to the store, then you automatically create an interval. It's just a counter to increment, and you return a function that is called when all subscribers unsubscribe. And then you can create an interval and use it to trigger any code you want. So I have an example here because, yeah, the issue, the context was that let's say you have you create an interval here, you don't clear you see it just runs down here but inside your wrapper and I think also in a plain V project, if you were to just make changes and you will see that it reloads and the old intervals continue to run the background this is why it just, I don't know it does whatever it wants so you can see it's not really called every second, but other intervals in the background continue to log to the console because you don't clear. And in that case, yeah, you can use a store or unmarked. Now, if you go in here, just make some changes. You see all the intervals before get cleared in the background. There's nothing left. I'm going to share this too. And I think last question or almost last question is, yeah, how do you use code across multiple projects? This might be a little bit more of a discussion or just an overview of things you can do. So I think the first thing you will always do is create a new project using npm create it at latest and then select the, I think it's called package option or something. And yeah in the docs they all explanations of how you can create a package You just put all your code into the lib folder and make some changes to the exports that you need And then you can publish a private package to npm and just use it. If you want this code to be private, I've never really done this before. But it's an option. Another option you have is you can install your packages just directly from GitHub, which is what I like to use, like to do. So if you're fine with your projects being public, they can actually be private. The problem is just that if you use something like GitHub Actions, then your action somehow needs access to your private repository. You can do this, of course, but you have to input some secrets and stuff. Yeah, so the easiest way is just to have a private repository and your SwagKit package project. And then in other projects, you can just install your GitHub username, follow-up your repo name, and optionally, you can have a commit hash or a branch. Yeah, so that's the easiest way, I think. There are probably a few other ways. Oh, yeah, I forgot the MonoRepository case. So you can have a MonoRepo, But that only really makes sense if all of these projects inside the repo are somehow related to each other. Yeah, and I think that's it for the three questions so far. I could add on to that. So I've published private NPM packages in the past, and this is a great overview for everyone's awareness. As Karim mentioned, you can publish to GitHub privately, and you don't have to pay a subscription fee. On the NPM registry, npm.com, I think, if you publish there privately, it must be a paid platform, I believe, whether it's using a single string or a namespace string. You can do like at username slash package name. That also is a paid product. However, on GitHub, you can do it privately for free. And if you use your GitHub Actions, GitHub Actions have convenience environment variables. you can look up in the docs that will expose your secrets to publish to your private GitHub module registry. So on GitHub, you can publish Docker images. You can also publish NPM packages. And then on the bottom here where it says npm install dash d GitHub username, it is possible to

 install packages from GitHub. However, the package.json file must be in the root scope. So in order for this to work, you can't have a module in like a packages folder and then expect it to work when you do npm install username slash repository name. That won't work unless package.json is in the root scope. But you can use the GitHub registry. All you need is a .npmrc file and to set up the exception. So in your package.json, if you're consuming a private module, you can consumed by the module name. That's fine. I can call it my private package. And then in your npmrc file, you input the registry location for my private package. That way it can dissolve the package location during the install. And as long as you have your secrets set up locally, that will work. This is not an in-depth guide, but it's good for your awareness. So you meant if you install directly from GitHub, you can't have... The package can't be inside a monorepo. If you're consuming using the npm install http.github.com name.repo name, if that's the method of consumption, then no. Package.json must be in the root scope. But the better, more compatible method is just to use an npmrc file to resolve the registry path. You can add a single line of code saying, hey, this package is on github.com and then npm knows that. It'll throw an F03 error if you're not authorized. If it's a private module and you do npm install and you don't have your token set up locally then yeah npm or pnpm will throw an error. Otherwise it's just a few steps. And that's pretty cool. Since we have some time remaining I think I will do one last question and answer. Something I prepared for everybody is down below Okay found it How to use Markdown with SvelteKit So SvelteKit does not have I probably should use Chrome for this SvelteLab coming to the rescue So the question is as this loads how to use Markdown with SvelteKit SvelteKit does not have any built-in Markdown functionality. It's a bit unopinionated when it comes to built-in functionality. There are preprocessors, some provided by Svelte, the team, like there's Vite preprocess, there's Svelte preprocess. And preprocessors help interpret other kinds of languages within Svelte files. For example, lang equals TS. That requires a preprocessor because you're telling the Svelte compiler to preprocess the Svelte file and check for TypeScript support. Another example of a preprocessor is style lang equals SAS. So if you want SAS support, you need a preprocessor to support that, as well as any libraries such as the SAS library and the TypeScript library to do that. But for the sake of this demonstration, I'm going to show you how to set up a package called mdsvex over here. So in package.json, I have mdsvex, which is created by Penguin. Here's the repository or website. It's cool because it brings you MDX functionality in Svelte. So I believe the word is MDX. And then there's like a snippet of Svelte. So you've got MDX and Svelte combined into MDS VEX. I'll probably never pronounce that correctly. The easiest way to install this is with Svelte Add. So there's Svelte Add MDS VEX. I'll link it to the chat below. And following the guide here, we'll set up MDS VEX. But then you've got to draw the rest of the owl. And I will show you what the owl looks like. So in this example, I have a very plain blog. And when you click on this blog post, it takes you to the page called Physics. If you go to this other blog post it takes you to a place called Aliens And both of these blog posts were written in Markdown And what I done is I have a folder in my source called posts You have this Markdown file This is plain Markdown. I can put spell components in here, but for the demo, I'm not doing that. And then I have another block called physics. And if you're familiar with Markdown, you can see there's front matter at the top. Front matter becomes Metaprops. And what this allows you to do is if your markdown is stored locally, you can load it using meta imports. If your MD files or MD content is in a remote API, like in headless CMS, then you can use Felkid loaders to get, you can use Felkid loaders to fetch them. What I've done is on my homepage, I have a array of links and this generates based on the amount of blogs I have. This is less interesting, so I'll skim over it. So here on line four, I'm running import metaglob. I'm using root relative links slash source slash posts starred on markdown. I couldn't get path aliasing to work, so I think this is the way to do it. So my posts are written in markdown outside of the lib folder here in source posts. And after this, I can cycle through the data and then return a set of posts. And this allows me to render an array of bulleted links. And then from there, they render here. The interesting part, though, is how do I display the markdown content? So here I have a dynamic path called blog slug. And in the Svelte file, I have export let data. And then I have the title, which is data front matter title. And then I render the Svelte component. Since MDS VEX returns Svelte components, I call it using Svelte component. And I'm using page.js. And I'm not using page.server.js because server.js cannot serialize components. I am using page.js to do that. So the order of operations is line seven. You import the markdown once again using root relative. And once you build your project and ship it to production, this will resolve as something that safe for use in production That is if your files are local And then finally I do object and I map over them to get the post data So mds provides some ways to get post data. In my case, it's just like this. So this is entries and this is load. The distinction here is I'm using entries because This is a fully static site. If you want to ship a static blog with MDS VEX, you can. And that's what I'm demonstrating here. So it's pre-rendered. I have a list of entries. That way, the SvelteKit compiler knows to crawl through these entries. And then down here is the loader. Loader is where I actually get the data to display on the page. And this is a lot simpler than the entries function because I'm calling the slug of the markdown file being requested. So slug is the name of my param. That's why down here I have params.slug. and it just looks it up in source posts param.slug. If the param is physics, then it looks for post physics.markdown because that's the name of the param. And I'm using dynamic imports to achieve this because the string path is dynamic. There's a variable inside. And then finally, in the return statement, I have the article, which is a component. Since I'm calling await import and Svelte components are default exports, I have to call article.default because the default export is the Svelte component. And then the front matter is article.metadata. Metadata is the name of the named export returned by MDS VEX. So MDS VEX returns a default export, which is a component, and a metadata named export, which is the front matter. And that gives me this. If anyone has questions about Markdown support, feel free to leave me a message. Otherwise, this demonstration is for you. I'll link it in the chat. Okay. Okay. And with that done, thank you so much for listening, and I'll see you next time.