 Hello, everybody. Welcome to This Week in Svelte. My name is Enrico and joining me is Paolo. Welcome, everyone. And also joining me is Kareem. Hello, everybody, again. We did it just in time for the long weekend, if you have a long weekend. The agenda includes the changelog, maybe one small announcement, no community showcase for today, no discussion for today, but there will be a couple of Q&A demos. thanks to our co-hosts. Let's go to it. Change log time. There's one noteworthy change log for today. I guess I'll save the best for last. SvelteKit 1.23.1. We have a patch for processing glob patterns in package.workspaces. I assume this is related to Svelte package and how it configures workspaces, so thanks for that. and now SvelteKit 1.24.0. This week has been, you know, there's been a few topics around the internet around view transitions API and SvelteKit now supports an onNavigate lifecycle function. I think it's documented onKit.Svelte.dev, onNavigate. There it is. So as part of the app navigation suite modules, OnNavigate is a new lifecycle function now available in SvelteKit. So it'll be the callback that is run immediately before navigating to a new URL. So this is handy if you want to make use of the new Vue Transitions API, which is available in some browsers, just the Chromium-based ones. And I think Kareem has a demo for all of you in a few minutes that we'll also go over. But Vue Transitions API is the browser-based JavaScript API that allows you to set up single-page application-like transitions, even in a multi-page plain HTML application. It's supported in Chrome and Edge today. Safari and Firefox are allegedly coming soon. I don't see any green boxes here, but wide browser support is in the works. So you can get started today with this as a progressive enhancement. And that's that. There's also a patch. Use proxy to track usage of client-side load using event.route. Client load Yeah that something really interesting because basically if you use a proxy you can avoid being tracked by event So if you access event.root inside a load function, and if it's using a proxy, basically you can avoid being tracked, like avoid the load function rerun by accessing it in a certain way with get on property descriptor. but on the client side SvelteKit was using a simple getter and setter and so basically they made this PR to being able to avoid being tracked by it's not as own property, it's a get own property descriptor that you want to do It's really complex, but basically you can pass a proxy and get a specific, in this case, root property description, and then you can access the value. And this will not trigger the traps from the proxy. and so this basically allowed a library to access root without the user of the library having the load function rerun without them actually accessing the root. It's a bit complex. I see. So that sounds like a roundabout way of avoiding the event object tracking that is done in load functions. Exactly. Wow. Thanks for the supplementary explanation. This is not something I do day to day. I usually just let things get tracked. But yeah, there's an ongoing issue about how to opt out of tracking or perhaps vice versa. I don't have too much context in front of me to share today. But yeah, that's something that people occasionally talk about is sometimes you want to track things like search params. Sometimes you don't. And the way you avoid that is probably related to what you said. Yeah, I mean, in this case, it was important because this was a library author that was accessing the route. And so as a library you don want to track the route for the people because otherwise it gets confusing because they are just using your library and you are accessing root for them And so basically their load function will rerun every time the root changes even if they have not accessed the root So that's why they wanted this. And it's a good addition, I think. All righty. So with that said, the changelog is now over. Let's bring down the chat and move on to... quick facts and announcements. Part of the theme today is the Vue Transitions API, and there is one new thing in the Svelte blog. I will share this in the chat. Thank you, Jeff Rich, for writing up a explanation for SvelteKit 1.24 and how it unlocks the Vue Transitions API. Link is in the chat and in the YouTube description below. This article breaks down how OnNavigate was made and what it can do, and it also provides some handy examples. I think if Karim joins the call again, we'll go a little bit deeper into this, but just for some highlights, you can see that the VTransitions API is largely a JavaScript-based API. There is a Node.js solution, but it's not widely available, right, Paolo? I think it's only in Chrome Canary. Yeah, I guess it's just in Chrome Canary. I think WebKit is working on that too, but I think, I mean, it's in the spec. So if the browser wants to be really compliant, they should also include the non-JS part. But for the moment, the JS thing is started to take form inside WebKit and Chrome. So let's hope that in the near future, we can also do transition without JavaScript. But for the moment, we have this. Right. I won't steal Karib's thunder. because he is back and probably going to give a proper explanation of on navigate so let's move on to um yes i hope you can hear me uh i don't know i just got kicked out of discord but um i hear you yeah we can hear you for now it doesn't doesn't seem to work you can hear me okay i can hear you really well, but... Okay, so... Um Can you go to my GitHub Maybe you can just show my demo Do I have to clone it No, no. I just go to my GitHub, and there is a repository called swagkitsviewtransitionsdemo. Let's see if I typed it in. Got it on the first try. Yeah. Now I go into the address bar and replace the github.com with stackblitz.com slash github, if that makes sense. Okay. I'm doing this in Cognito browser, so this might break horribly. Yes, I think it will break. Because in Cognito, you don't have access to the shared buffer. Don't worry. I have a backup browser. Ta-da. Yes. Thank you, joining us, Karim, over the wire, through several portals. You're able to talk to us today. Okay. Okay. So yeah, what I wanted to show you is just a couple ways you can do view transitions. I think while Karim tries to download some packets, I'm going to try to intuitively find out what this demo is about. So I can see Karim has written on line 5 in pluslayout.svelte. There's an onNavigate callback utilized here imported from SvelteKit app navigation. So as per the documentation, onNavigate should call immediately before the routing has completed. And so navigation is the object passed in as the first parameter to the callback function, which is defined below here. Let's give Karim a chance. Are you available to speak? No? Okay. Seems to know. Then I will just improvise. So this function returns a promise. If you want, I can talk about it. Yeah, go ahead. Yeah, okay. Basically, the onNavigate, it's a new hook for ValtKit, and it's very similar to beforeNavigate

 navigate in the sense that it gets called whenever there's a navigation. But instead of being called before the load function runs, it gets called after the load function has already been run immediately before reaching root, basically. And so with this, basically, you can check if you have a start view transition. and if there's no start view transition in the DOM, in the document, you just return. And this basically tells SvelteKit, okay, go ahead, just do your normal navigation. And if you return a promise, SvelteKit will actually await your promise and wait, so block the navigation until your promise resolved. Let's see if... Karim, are you there? Yeah. It seems no. Okay, so let's go ahead and talk about this. Basically, so if you return a promise, basically, SaltKit will await that you resolve this promise before continuing with the navigation. And this gives the StartViewTransition API the ability to actually take a snapshot of your page before the navigation happens. And when you resolve, SvelteKit will complete the navigation. And when SvelteKit will complete the navigation, the navigation.complete promise will resolve. So you start a new view transition on line 21. then you resolve your promise and this tells SvelteKit okay you can now go ahead then you await navigation.complete so you basically ask for a callback from SvelteKit when the navigation is actually complete and when this function with resolve and await navigation.complete finishes the view transition API finish and so basically the browser does his magic and crossfade between the two snapshots of the DOM. What Karim is doing before starting the view transition API is actually setting a view transition name so that basically this is telling the browser okay, the new transition name of this actual image is this one, and this allows the browser to recognize the image between two pages because in the two pages there will be a CSS that tells that this image has the same view transition name of the new image and will crossfade between the two transitions. I don't know if it's really clear. Sorry. Yeah, image is defined here. Oh, Karim, you're back. Oh, Karim. Yeah, yeah, Karim. I think it works. I don't want to try sharing my screen because I'm not sure if this will break again, but there are, I think, two or three kinds of transitions in this demo that I just wanted to showcase because I think these are, like, the very common transitions that you want to do. So, yeah, if you scroll down, you can see that, yeah, there is the transition of the indicator, the navigation. You see there is a bottom, what is that, a bottom bar or something underneath the links. This is just, yeah, the before element of the list element, essentially. So we set this using the aria current attribute. And I'm not sure if this was already mentioned, but in order to do view transitions, when you enable them using JavaScript, there are default transitions. It's a crossfade. There's a, if you move elements, or if you isolate elements using the view transition name, style CSS property, it will actually move these elements by default. You don't have to do anything. It's just assign a VTransitionName. So there's one thing you probably want to do. Just isolate specific elements like this indicator and let the browser handle the movements and the scaling and everything. Another transition you can see is around the main element essentially the page So if you scroll down to the CSS oh, no, in this case not, but if you scroll down further, you should be able to see, yeah, if we transition to name property, we just call this indicator, and that would just isolate the element and move the indicator between different pages. And the other thing, Paul just talked about, which is the image. If you click on this moon image, you will see... I think you have to make the image, the window larger to see it. Yeah, if you go back, So yeah, and I'll click the moon. You can see that the moon transitions from the current page to the new page. These are separate HTML elements. But in order to do this, you have to do this right before the transition happens. And imagine this is a list of items. you don't actually know which element will be transitioned until the user clicks the element. So a naive way would be to just attach an event handler to the moon image, and then just say, yeah, onclick e.currentTarget.stile.setProperty, and then viewTransitionName equals image or something. But the problem is this happens right before, like the re-transition could always happen when you do this. So you have to find a way to do this before it is scheduled to happen. So in the JavaScript code above, what I did, I'm not sure if there's a better way to do this. But before the re-transition happens, I query the link that has the same href attribute that we're going to navigate to and look for an image inside that. And I set a data attribute which is like the name of the vtransition that I want And then I just assign that to the element. I assume that's the XYZ page. And it's at the XYZ. Inside. Are you inside? No, you're not inside. The other one? The page? One over. X, Y, Z, if you open the X, Y, Z. Oh, it's on the ground, of course. Yeah, and then image. Yeah, this is one. But it doesn't have the view transition name yet set. It happens when it's clicked. And on the other page, inside the image directory, yes, there is another image. It's the same image, just different dimensions, and it has the view transition name stacked by default. Yeah. I see. So this is like a handy way of on the fly targeting an image that you want to transition and then applying view transition name because this CSS identifier is what informs the browser what you're transitioning. Yeah, exactly. There's also a way to do this with videos and the video keeps playing while it's transitioning. I haven't actually tried this yet, but that's possible too. Wow. Yeah. Yeah, also, they don't even need to be the same element. Like you can transition an image to div and it will still work because at the end of the day, the view transition API, again, just basically to take a screenshot of your page and then move your page, like take a screenshot of your page, take a screenshot of the new page and the transition between them. Very cool. So Karim, do you have any last things to share in this demo? Well, yeah, I think this is exciting because it's not possible. It's like it requires the unnavigate handler. But I think something that gets often overlooked is, I mean, maybe for a lot of people, this is the main use case, doing page transitions, but you can transition anything with the real transition API, and you can already do that. So if you actually feel links, so if you wanted to share, maybe you can just

 Yeah, so if you actually go to the Chrome article, with the chat, developers of Chrome here, they have a spot example at the bottom, a repo example, and you can use it to transition anything. So you can, for example, use this to transition a hamburger menu, which is really handy, because the view transition API I can transition anything, even display none, which is not possible in CSS yet. It will be possible sometime, but currently it isn't. Or, yeah, I think that, like, this is something you can already do with Swap. You don't need the on-navigate handler, but, yeah, just to be aware of, you can only use it for page transitions, but you can transition, I don't know, an image gallery, for example, that is not made out of several pages, or a menu, things like that. Okay. And if you go to the form article, you can see how they do this. You have to call the tick function, I think, the way tick insert to force rendering everything, essentially. but yeah, otherwise it's very easy. Okay, cool. Maybe now's a good time to address some comments. Paolo, you had a thought? Yes, I mean, I was just addressing the comment. Hugo said, what's the difference between before navigate, after navigate, and on navigate? We kind of say that, but basically, before navigate will be called before the navigation even begins. So before SvelteKit called the load functions and given that like the load function can actually take time because usually in the load function you do PI calls and everything else. So this will be called before the navigation even begin. After the load function has finished. So after we already have the data right before we start the actual navigation will be called on Navigate and obviously whenever the navigation finish after Navigate will be called Yeah I also noticed these modules are where I expected them to be App navigation shows after navigate, before navigate. Oh, and further down, there it is, on navigate. And we had a question further up from Naso. It looks like you can do a lot of cool transitions without JavaScript. I think in theory, yes, but currently in order to leverage the view transitions API today in Chromium browsers, you still need to use JavaScript as like as shown in Karim's demo. Yes. Also, can Trophic say, OK, perhaps another approach to setting view transition name is to set it using an on mouse enter? yes but also you have to be aware of the fact that like not everyone uses a mouse so if you try to find a way to do it without on mouse enter it's better probably and to answer Hugo's question this was kind of required for view transition view transition was one of the main reasons to add on navigate. But actually if you look at the PR for when they, where they added on navigate, they mentioned that someone also got some oddly specific reason to use on navigate. But yes, the main reason is because it was added it's because of view transition because given that view transition frees the page if you call start view transition before the load function starts running if them take time to get running the whole page is it's unresponsive until the load function start finishes so this is the reason why we now 8. Yeah, very cool. So whatever your reason may be, this lifecycle function is for you. And if there's nothing further, we can proceed to the next section. Let go Two This week in questions and answers more specifically an answer to my questions answer from last week I showcased a demo last week about using What was it about It was about calling form actions that triggered some unexpected results because I was not using a board controller. But Paolo, I believe you have an answer to this. Yes. Actually, don't be too harsh on yourself because actually your demo was correct because abort controller, it's something that you need to be aware of, but for post request in SvelteKit, you were doing a get request. So it's all fine. Don't be outsharing yourself. But yeah, someone pointed out, Patrick, if I can remember, that you need to be aware of the abort controller. And if you want, I can share my screen. yeah you can go ahead i i was just gonna bring this up but i'll yeah okay so let's let's see your demo last week before i thought that you were opening my demo on abort control yeah let's go do that how about you share your screen yeah sure uh so uh first thing first what is abort controller? So abort controller is a browser API that allows you to basically have a way to control something. So when you create a new abort controller, you have a signal that you can pass around. And on this signal, which is an abort signal, you can add event listener, for example, to get notified when someone call abort on the abort controller. So this is the MDM documentation, but let's see how it works. So if we go to abort here, here I have a simple plus page.svelte, which basically has a new controller, and I add an event listener on abort. So whenever someone aborts this controller, I will get a window.alert the abort controller was aborted. So if I try to do abort, I get the abort was controller. And this is because on this button I just do controller dot abort So this may seem kind of like why do I need this The reason why it useful is because for example if you are a library author you can create a controller pass the controller back to the user, and whenever the user decides to abort your request, it can do it with controller.abort. This is also used in fetch. So for example, to fetch, you can pass a signal. In this case, the signal from fetch controller. And basically, this allows you to abort this fetch request. So if I open this in another page and I open the network tab, I can make a fetch request. this just make a fetch request to this end point, which just never return. So this is a fetch request that will be basically here indefinitely. So if I do the fetch request, you can see that I have a new abort request that is pending. So now I can still use my browser because it's not frozen, but this request is always pending. Can you zoom in to your dev tools, please? Unfortunately, I think there is a slight bug with... Yeah, there is a slight bug with ARC and does not allow me to zoom in here. But I mean, trust me, there is an abort request. And if I click on abort fetch, it actually gets canceled. So this stopped this fetch request, basically. so how these relate to svelte kit so if we go back to home i have this wrong page.svelte and basically in this i'm not using the abort controller so i have this page server and in this page server basically i have a default action and in this default action what i do is just I get the form data, I get the search, which is this field here, and I do a fetch request to JSON placeholder with jar returns, a list of posts basically. Then I do

 a kind of silly thing because basically I just filtered the search, filtered the posts, and then I wait 100 milliseconds for every post. I just added this console log so that we can see them. So this is, again, in the wrong field. So if I search, for example, S and I go search, now the waiting game. So this is filtering the posts. And if we wait a bit, we can see that here's the result. So this is all the post filter that have the S inside. Now, if I do a more specific search, like Zoomed, for example, and I search again, you can see that we waited a lot less because we have a lot less post to wait. So we just wait like 600 milliseconds instead of a lot, like different seconds. So why is this important? Because let's say that I search for S. Now this takes time. If I make another request in the meantime, for example, for Soomt, what happens is that the second request may finish before the first request. And as you have seen now, when the first, the first request finishes, I actually get the old, the old, uh, results back. So let do it again I will go to home I go to wrong So if I search for S this will take several seconds If I search for UNT this will take a lot less So the request for SOONT is already finished. And now the request for S is finished. And so the results were swapped, basically. And this is bad because, I mean, as a user, I search for S And then I search for soont. I want the result for soont. I don't want the result for s. So how to do it correctly? Let's go to the correct route. And this is basically the same on the server. But on the client, I do something else. I use announce. And when you use announce, you can pass a function. and this function get a controller. And this is an abort controller, basically. And so what I do is if I have an old request control, I just abort the old request. And then I store the old request inside this variable. And what these allow me to do is that if I search as and then I search soon. Now that I searched the soon, I removed, like I've aborted the old, the old request. So I now don get my result replaced by the old one One interesting thing And we can see that in the log is the fact that the old request got still fulfilled by the server because once the request is on the server you cannot stop it But this abort controller allow you to basically ignore the request on the client. And that's the important part. All righty. very nice demo very thorough and jay in the chat wrote i need to name my folders correct from now on so that my code always runs yeah that's that's how you make your your code work that was a very good explanation thank you for going through all of the advantages so because this is a post request in particular that's where a board controller is handy because in use enhance i'm trying to make sense of this now old request controller line nine is aborted so how does that stop the results from updating on the page because whenever you abort the request basically the the request get never fulfilled so with use announce what's belt kit is doing under the hood is doing a fetch call and this controller is the controller that is passed to the the fetch call to the fetch that SvelteKit is doing. And obviously if the fetch fails, SvelteKit will not update the page. And so basically this is just making the fetch fail. I see now Thank you SvelteKit for pressing in the controller parameter Now I can use it And in the chat it looks like everyone went through some alternatives as well. Captain Wright, use a map of queries to results. You can always display the correct result and then use a cache. Yeah, caching strategies are always like on a use case basis. Sometimes you trust your data won't change. You can cache it on the browser. Sometimes you can cache in the backend using Redis or some other means, local caching. I don't know if undigfetch has caching, but that's kind of out of scope of the conversation. But likewise, yeah, that's a valid method as well. Yeah, obviously. The only important thing is the fact that you can avoid showing wrong results. So even, for example, if you want to have, I don't know, a sequential number, and then when the request comes, you check if the sequential number has been updated and you don't show the result. But I mean, this is a browser API that is there for this very reason, basically. So it's cool to be able to use it. Okay. And now it's time for us to wrap up. Thanks again, Paolo. Everybody give Paolo a hand and also give Karim a hand. Give a high five clap emoji for our wonderful view transitions API and a board controller demonstrations. It's time. For the final word. I will share my screen now. Yeah, go ahead. Thank you so much for participating today, and we'll see you next Friday. Bye-bye. Bye-bye. Bye.