 Hello, it's June 30th, 2023. My name's Enrico, and this week we have Svelte. The agenda is the usual changelog, some quick facts. We have one special community showcase today, followed with discussions and Q&A. The changelog must go as planned. In SvelteKit, version 1.21.0 has been released. That's a minor change. feature add event is sub request boolean indicating whether this is a call to one of the apps own APIs during SSR or pre-rendering okay so let's look at this change log there we go so is sub request is similar to is data request this is a new feature so in the types you can see over here that in the request event you're able to destructure is data request here. This is an existing feature, but there's a new one called is sub request. Is data request occurs when the user has hydrated your application, they click on a link, and then they navigate to another page. This would be set to true if that's the case, and you can call these in your backend loads or your backend hooks. Is sub request is new, So whenever you call an endpoint using plusserver.js or TypeScript, then is sub request will be true when you're making an internal fetch. So let's say you're running a load function, and then that calls an endpoint within your SvelteKit application, then is sub request will be true. This could be useful depending on what you need it for. Next, add private prefix to config.kit.environment. and that's the private prefix for variables. So if we go to dynamic private, for example, then here by default, private variables don't have a prefix. Public variables do have a prefix. Usually it's public underscore. But now in the configuration, you can set a prefix for private variables right here under kit.env.private prefix. That's new. Next, export version from SvelteKit. So version relates to the version of the application So in config there also a version configuration but this is different So the version configuration helps you do background polling so that if a user is actively on your website and it hydrated but you've deployed a new SvelteKit version, then version will help sort of cache bust your SvelteKit application and do a full page load. If you actually need the version of your SvelteKit application, that is now being exported in the SvelteKit module. So if you import SvelteKit, you can extract an all-capital-letters version. That's available to you now. Patch changes. Update inline navigation type documentation. Good to see. And cache dynamic imports of nodes. So some improvements have been made, and we all like to see it. Next up is Svelte 4.0.1. It's a patch. First patch is ensure identifiers of destructured context don't clash with existing ones. That's more or less an internal thing because sometimes Svelte itself will have some internal named variables. And if you incidentally make your variable names match the ones Svelte uses, there might be some clashing. That's no longer going to happen thanks to that patch. Ensure create event dispatcher and action return work with types from generic function parameters. yes so this is like a major typescript fix i think by default some parameters are marked as never i'm not a typescript expert but things have been improved now so they're more knowledge and more easier to contend with you can check out the pull request discussion for more details apply transition to Svelte element with local transition. In Svelte 4, there was a breaking change. One of the major announced breaking changes is local transitions of the new default for all transitions, and Svelte element was missing out, but no more. In Svelte 401, Svelte element will now provide local transitions by default, as per the rest of Svelte. The accessibility no redundant rule for your li, ul, and ol elements has been relaxed. I'll actually showcase this in quick facts. You'll see. And then finally remove the tsconfig from the publish package. Got to make sure your npm packages only have relevant files. This is one of them. No longer. And that is it for the changelog Moving on to quick facts and maybe announcements You arrived So the quick fact, as I mentioned, is about this accessibility no redundant role. So here in Safari, I have a Svelte REPL. And in Svelte 400, there was an issue with applying role equals list to UL. Svelte would give you an accessibility warning saying, hey, that's redundant. We know it's a UL. You don't need this rule anymore. That warning no longer appears now. So as you can see, this REPL is running. I don't see the warning. And that's because in Safari, if you have this CSS rule down here on line 9, setting list style to none, Safari will break the semantics of the list. So for example, if I turn on voiceover, which I will do now, there it is if i go to the list item selected and then i select the list list two items it says list two items i'll move this over here and then i go to the first list item item one it says item one one of two this is good this is working but if i delete this i'll turn this off voiceover off if i delete this role, look what happens. VoiceOver on item. All right, now. Item 2. It says item 2. It reads it as plain text. Item 1. Item 1 also reads it as plain text. Item 1. And I can't go back. I tried to, but there was an error. So the semantics of this list have been broken all because of CSS. That's right. Selected. Amazing. CSS can break accessibility semantics. It is true. So if you do list-tal-none, which I often do for my navigations, it's important to add back role equals list. And in doing so, the semantics are brought back. One more time. Now it says list two items. Item one, one of two. And there you go. Crazy, right? CSS. It totally impacts semantics. At least on Safari. Maybe this will be patched. Maybe it won't be. but the safest bet to do is to always add role equals list when you use the CSS. Because whether or not Safari patches this, who can say that they'll regress later? So in this week in Svelte repository I updated my examples to use role equals list here So I had a hamburger menu demonstration that did remove list item in CSS So now I added role equals list to bring back those semantics So we did it We patched our own code. The next quick fact is the international API is widely supported by browsers and Node.js. So I just want to give everyone a glimpse. In case you did not know, there is a cool API in web browsers and in Node.js called INTL. And you can use this to translate numbers or different common script or language across different locales. A common example I saw on Discord this past week was this one. The tab must be loading. There it is. Yeah, there's this one. INTL.numberformat. So some fun examples here. For example, intl number format, Deutsch, and the expected output is comma separated items and the euro symbol. You can do Japanese yen. You can do Indian English to do comma separated values. So this is cool, and this is all built in. So if you happen to be using an internationalization framework or library and it doesn't have these mechanics built in, you can always leverage intl. That's a quick fact. It's also good for server rendering because if you do server-side rendering and you run this in the root of your Svelte files, it will also run and output static HTML. So that's cool. All righty. Next is we have a community showcase happening. I would like to invite to the stage Baffy. Welcome. Hello. Hello, welcome. How are you doing? All right. Yeah, thanks for the opportunity to show and tell. Let me just turn on the screen sharing. Go ahead. I'll let you know when I'm ready. All right. So this is Socio. It is a real-time communication API framework that I've been working on, and it's pretty much ready to use. So this demo here today I'm going to be showing is in SvelteKit and Vite because Svelte's awesome reactivity has a nice synergy with Socio's reactivity. But Socio itself is framework agnostic. So the point of Socio is to move away from antiquated HTTP APIs like REST,

 or whatever. So with Socio, you have no endpoints, DB interfaces, handlers, schemas, fetch pooling, refreshing of data, and et cetera. So you can just simply write your SQL on the front end to interact with your DB directly, and then subscribe to resource changes automagically. In a bit, I will show why that's also secure here. So simply here, we have some SQLs. Let me just, So this table right here pretty much displays all the attributes on this table called users. I just have one table right now. So if I insert on there, we can see both instances here automatically live show the exact current data on the database. So they both refresh. And if I insert here a John, give him a different number. Is there another one? The updates happen. And here also this query receives an update. so we always have the exact data available on the front end that also is the same on the back end, which is, I think, pretty cool. But if you happen to not like SQL, which a lot of people don't for some reason, I have another mechanism called server props, and essentially it's some kind of value that you want to share across all of your clients and server that will also be live synced as if it was some kind of resource on database or whatever. So, for example, if I start typing away here, as soon as I give it a valid color, that gets propagated to all of the clients. And if the client refreshes, he, of course, still grabs the value that's there. Same can be done for numbers, whatever. Here's a cool, fun thing to do with Svelte. The bind value of the actual input HTML tag works very nicely with the way that socio is written up, its functions and whatever. and this can be as complicated of a JSON serializable object as you want here it's just a string and a number and if the object happens to become super large you don't want to send that across the network so you can also just send the differences in objects to the client so the differences in the updates of the object whatever, you get the point and so Socio pretty much supports everything and more that HTTP does and always want it to do. For example, here's uploading files. Let me just upload 17 by file. And we get a progress bar at the bottom there So that very nice In standard HTTP you would have to do an XML request which is even more integrated than the Fetch API So in Socio, that's very simple. So let's actually look at how simple that is for the developer. Let's take a look at this ancient Sanskrit. So here is the plus page index route. Here is the Socio client instance being created at the top level here because I want to access it in the HTML and do things more ergonomically. Let's see, let's see. So this is the page state, a bunch of variables you would have in Svelte. And in the, actually, let's not look at that. The first cool thing is, so you would just do social query if you want to do one query to the database. So that's like a one shot that you see at the very top here. Just executes once. And so you can show like a spinner until you get the data and then, yeah. So very nice with Svelte's integration here. The second thing you want to do is subscriptions. So that's done through the SE subscribe. And again, you just pass it to SQL. And just in case you don't actually want to deal with SQL, you can actually do something like an endpoint key name. And this will, on the server side, be resolved to some kind of SQL string. So through a server-side hook, socio hook. I'm going to read the documentation about that if you want to actually use that. Here are the dynamic parameters here. Be sure to sanitize these yourself on the back end. I'll show where that happens. And so for the reactivity, just simply pass a callback that will update this page state with the newest synced value from the database. And this will automatically send updates whenever there are changes for whatever reason on the backend database of this table. In a similar fashion, same thing you do for props. I define just like a key name called color and num on the backend. And so just callbacks to update the frontend page state. You can also get the ID of the subscription so that you can do... Okay, I'm really bad at live typing. You can unsubscribe at any time or even on destroy here. Very neat to just unsubscribe all props and queries You don have to do this If you just destroy this instance the WebSocket is going to disconnect and so that going to clean up everything on both the front end and the back end. So no need to worry about that. Also, as a side note, in production, you're going to want to use the secure version of WebSockets, because this is built on WebSockets. So let's see, let's see. And the upload files demonstration that I showed similar fashion as the query. This just returns a so you can just pass it the HTML files property that you get from an input files tag and that will prepare it in the special socio file sort of format, I guess you would call that. Anyway, so you can either await that right here or grab this or save down this promise that returns and actually just set up a tracker that will track the progress of this promise being sent out. So the whole data, all the packets in the buffer that need to be sent out, and then you can just await it at some point later. And that's how I get the progress. And a neat other integration was felt here is I'm using the writable store. So I can just pass it the store set function here instead of doing the callback. And then in codes, not that important, but here's the query for the insert. It's the same thing. And again, using the bind value to the property of the object. Very nice and neat, ergonomic. Absolutely love Svelte. And here I can just pass that to the backend and sanitize it there. So let's see. So here's the on input for the color prop. just simply call set prop. You can also do get prop if you ever want to just one-shot grab the value. And again, the bind value works very nicely. Let's just send that in. Same thing for the number. Did I showcase that you can do it in both with these and with these? So, yeah, whatever. The upload files is just unchanged. Very nice, simple. And here's the value of the progress bar there from the writable store. So it's all very nice and compact code. If we look at the backend, this is pretty much the entire part of the backend. It is this hooks.server.ts under source in the SvelteKit app This gets run on the basically supposedly the startup of your app but in practice on a dev server this gets run on the first actual request to the server Doesn matter. I just use it to instantiate the associate server, which is a WebSocket server, get a port. And then pretty much the important thing is the single query function. This is how you hook up any database that you want. I'm currently hosting an SQLite3 database in memory, and I'm just passing it the raw SQLize query function to give it the SQL. And here are the params, so make sure to sanitize those. SQLize here does... basically sanitizes against SQL injections itself, so I don't bother with it here, but you should. Yeah, I live on the edge like a JavaScript dev. And so here is the code for the... validating that the color is correct. so you notice that the color wasn't being shared across clients because it was invalid. It wasn't a full six-digit hex code. And so it only gets propagated to the clients here because of this function, so I validated it. The number is just can be anything. And the file upload is handled through a lifecycle hook handler on the server, and that just, with the utility function, saves it down to the disk, which is right here. UTF supportful, everything, encodings are correct and all that. Very nice stuff. The socio-security class here is used to actually encrypt all of the SQL that you have on your front-end code. Rather, in this particular case, it's used to decrypt it, and you just pass it to the socio-server here, and that will decrypt any encrypted SQL or prop names that are coming in from any client. But how do you actually make sure that there are encrypted versions of your SQL on the front end? You do it through my Vite plugin. Simply just import that and put it in the plugins list, probably ahead of SvelteKit. I haven't tested backwards, but pretty much supplied the same key. And it should encrypt all the front end there. And we can actually take a look at that in the network panel here. You can see it uses the WipeSocket protocol. So for example, this one, you can see that the SQL that actually gets sent to the backend and lives on the frontend is this long encrypted string.

 with a very strong, secure algorithm. You can check it out on the documentation page. For Socio, essentially, it can be read, modified, and the backend server can validate the author of this message. And you can see here, all the messages that go out are these encrypted ones. If you take a look at the sources panel somewhere, there's a plus page in here. You will also see in that raw text here, the raw sources, they're also encrypted sitting on the front end. So that is how I guarantee the safety of this. What else do I have to say about this? So I guess check out the documentation for Svelte, I mean for Socio, because there is a lot that it can do. Many, many, many, many, many things. See if I can just skim this. So you can, at any point, both the client and server can send and receive data. There's actually also a generic communications mechanisms whereby you can define your own sub-protocols and whatever and send whatever. I also have a chat wrapper that uses that mechanism to implement a small, simple, like real-time chat window on your website or on your page if you so wish to use it. But yeah, you can send files forward and back from either end at any time or any kind of generic data. So there's a bunch of different hooks, so you can hook into pretty much any major event that happens on the Socio server. There's rate limiting. There's an admin socket, which makes it incredibly easy to build an admin dashboard page, because you can do the same code that you do on your front end to interact as an admin as well. essentially you can just remote call any of the server's functions with any kind of arguments as long as you allow that there's also authentication there's a per message deflate which is a special sub-protocol of the WebSocket protocol that lets you compress the messages for less data usage there are session timeouts you can actually timeout or delete a user's session at any time that you want from the back end, which is a pain if you ever used session cookies on a large application So just like one call of a function you can do that here Let see so yeah there progress tracking some logging stuff. Essentially, I guess that's it. And as a final note, here is my personal website that I've built also with SvelteKit, Vite, and Socio that tracks the real-time real estate market of my city. so all of this data here is being fetched from an SQLite database that's posted on the file system on a Ubuntu Linode server and there's no HTTP here, all of this data is being fetched through socio and that is broken, it's supposed to say that one person is active right now so adding something like this through a server prop just to see how many people are active right now is dead simple. And I think that's all I have to say. Back to you, I guess. Thank you. You mind staying back for a few questions? Yeah, sure, I guess. Okay, so this is cool. And because this is built on top of WebSockets as a wrapper that makes it simpler to use WebSockets for sends and receives, are there escape hatches that let you use WebSockets directly? Yeah. Let's see if I can show that. So we have a client somewhere. Yeah, we have a client here. For example, here's the client. And you can get the WebSocket from it. Perfect. Or have I not exposed that? Anyway, you can get a bunch of stuff like IPID and whatever. You can do the general communications mechanism as well. Yeah, this is actually a good showcase because last week we talked about real-time communications in SvelteKit. And since Socio uses WebSockets, I assume you must use the adapter node with this. Is that right? uh yeah i believe i do for uh but for production i think i was able to use adapter node for for this website that's on here yeah it must be adapter node because serverless adapters don't support web sockets for example a lot of folks use versell or netlify or cloudflare but maybe cloudflare edge functions supported i'm not sure if you experimented with the edge runtime i looked at some of that technology it seems like versell is working on something that It could be with WebSockets but from what I read about it it like clanky and it would not integrate well with Socio Maybe in the future And Kromov has a question in the chat They wrote is the private key available to the client or is it transformed to a public key for signing the query? How can you prevent someone from sending arbitrary queries with the signing key? So the key should be stored like in an environment variable. For the production website, I use a .env and I just read it from an environment file. This key is not shared anywhere. It just sits in these two files here on your backend. This is asynchronous encryption, I believe it's called. So there's no public key. It's just a private key. Only you get to sign your messages. Thanks for answering. And it looks like because this is running in the root scope of hooks.server.ts, so yeah, it makes sense that Adopter node is being used because this starts up with the server in the hooks file. yeah cool thanks again for showcasing appreciate it all right thanks for having me that was community showcase moving on to this week in discussions there are none but if some discussions come up this is the place they'll be reviewed so let's close off with this week in q and a the first question we received let's get the chat up the first question is how do i add a loading indicator to a page in SvelteKit? A loading indicator. This question comes up because SvelteKit applications, by default, they are server-side rendered, and some users may feel like it takes a while for something to respond. And you want to show some kind of loading indicator because another page has a long load, for example, and it takes some time. And you've done all you could to lower that request limit. So what you can leverage in SvelteKit are a couple of things. Svelte.dev. The first one is the navigating indicator. I think it's a store. Let me see. Navigating. Yeah. So there's a store called navigating you can import, and this will be set to an object when you're navigating, or it'll be set to null when you're not navigating. So this is a store that could be used to show or hide something like a loading indicator. And I do have a demonstration of this in my repository I added one yesterday because I had this example of streaming and sometimes the streaming page takes a while because I had this artificial five-second delay. So in my page I've imported navigating from app stores and then on line 8 if navigating is not null show this loading page indicator. It's very rudimentary, but it gets the job done. Here it is in action. So because this is hosted on Netlify, it does not support streaming with promises. So when I click on streaming promises from server, JavaScript is hydrated. I click on this. The navigating store unlocks this loading page indicator, and then five seconds later, it navigates. So now we're on the second page. If this were a Node.js server, then it would navigate immediately and then download this data and then later show it on the page. So that's one way to have a loading indicator. The second way is with before navigate and after navigate. So in app navigation, there are these lifecycle functions. So if you have some kind of loading indicator that's on your layout and you want to globally represent loading, you can have a before navigate function callback, and that can start showing your loader. And then after the user has navigated, you can use the after navigate callback to stop your loader from appearing on the screen. I do use this as well as some progress bars in my work applications. I think the SvelteKit documentation also uses this to a degree. Like if I navigate from page to page, probably the tutorial uses this more so. Nope, then I must be misremembering. But that's okay. So let's say you had a loading indicator at the top of the page. You can use before navigate and after navigate to show or hide that. And that should answer the question. The next question is, can I have a form action in a layout? Form actions require routes. So let's go there. So form actions are a form HTML element. And without any JavaScript, they have a method, typically post, and an action.

 And the action is always a URL or a path of some kind, such as blog new. And in your form, you can have a submit button or some inputs. It doesn't really matter. The fact is that the action lives in a route. And since SvelteKit uses a directory-based router, you need to make sure that your form action is defined in a page.server.js or page.server.ts. You cannot have a form action in a layout because layouts can cascade. They don't have a defined route because layouts wrap subroutes. So you define your form action in routes such as source routes, login, pageserver.js, and then you have your actions here. It could be a default action. It could be a named action. But important to note is you can have an actual form like this inside of a layout. So in your plus layout.svelte file, you can actually define a form. and this could be like an omnipresent form available on every page and subpage, as long as the form action points to a route that is a pluspage.server.js file where the action's defined, it can work. It can submit. Progressive enhancement may not work as you expect it to because if the layout form happens to be at a different route, then when JavaScript is not present, it will navigate to that route. That why in your action itself you need to have appropriate actions as a callback So at the end of your action it usually appropriate to redirect the user depending if it like a login or some other action then it normal to do throw redirect at the end of your form action. So let's say the form lives in your root page and the layout renders it. The action can be in blog new. And after you write blog new, it can do throw redirect and take you back to the homepage or take you back to the initiator's page. And you can have some kind of hidden field or query parameter like input type equals hidden. And you can use SSR to generate a value of the URL you're currently at. And then you can name this input from. So this is like a little thing you can do. You can have hidden inputs that contain important information like this form was initiated from the root or this form was initiated from login. That way you can tell your redirect where to redirect back to. So the answer to recap is you cannot have a form action in a layout server file, but you can have a form displayed in a layout, as long as the action points to an actual page route. Next question. There is no next questions. That was easy. If anyone has questions in the chat, please feel free to speak up and I'll follow up. But that was really it. Thank you for joining this week in Svelte.