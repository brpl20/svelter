 We are back again with This Week in Svelte. My name is Enrico and joining me is Paolo. Hello everyone. You did it. The agenda is a changelog, quick facts and announcements, a community showcase, followed with discussions and Discord questions and answers. Let's go. Into the changelog. There was, oh, a five minute timer foreshadowing. There is a changelog for SvelteKit 1.23.0. A couple of new features is add warning for mistyped route file names. This is a fun one. And I requested this and fellow contributor patched it for me. Thank you very much. So what does that mean? It means if you have a SvelteKit project like this one, the editor's too wide, and you add a file to your path. Let's say here I'm going to add routes, a common layout, and I'll add a page.svelte file. Obviously, I misspelled it because it should be plus page, but that's okay. So if I do pnpm dev, wait for it. Missing route file prefix. Did you mean plus page.svelte? Located at my repository location, page.svelte. So now if you mistype reserved filenames like layout.svelte, layout.server.js, page.server.js, et cetera, if you're missing a plus or if you add an erroneous plus like plushooks.server.js, any of those common misspellings will now receive a yellow warning in your terminal. Pretty handy. This is really cool because, I mean, it can always happen. Like, in life, lemons happen. In this case, We are doing ourselves the proverbial lemonade. That's right. So the second feature is accept URL in redirect. This is a cool one because when you do throw a redirect in spell kit, normally you would add a URL string. But with this change, you can now create a URL object using, I can never zoom it enough, back to that nightmare scenario. You can make a URL object and assign it to a variable and then pass it in. So this is a URL object instead of a string location.href. This is now a feature. And it a nice touch It one of those quality of life improvement And it more platform idiomatic if we will True, because sometimes you might think, okay, I'll just put a URL in here. Now it works as you, if you can think it, you can do it. That's right. So that could be useful if you want to use the URL from the request. Yeah, I guess you can just throw in a variable already added to your function parameters. So that's another benefit. Patch changes. Adjust the type of navigation type. Thank you for the type changes. And allow logging of page.url during pre-rendering. For some reason, the page store URL cannot be logged when pre-rendering, but now it can. So there's a patch for you. And that's it for the change log. let's go to quick facts and announcements the first quick fact is on the discord svelte server we have new faq threats for frequently asked questions so if you end the help svelte kit or svelte and svelte kit channel or the ecosystem channel you can now check out these new pinned faq channels frequently asked questions are asked and answered in there have a look. Let's go on to some more quick facts. So for quick facts today, we've got bun. So recently, bun version 0.8.0 was announced with explicit support for SvelteKit. This was due to some environment variables not being handled in worker threads, but now bun v 0.8.0 does support For those of you who don't know, Bunn is an alternative runtime for Node.js, kind of like Dino. But it came onto the scene for its alternative approach to what a runtime is. I won't go exhaustively into what Bunn is, but I will say it uses the Safari engine webkit, I think. The webkit's incorrect, but it uses the JS runtime for Safari, and it's written in Zig instead of C++ or other languages. And it's designed to be extremely performant, but it wraps in a bunch. It wraps in a bunch of other features, like it's got a registry package manager built in. It can take your BUN application and put into a single executable for single file execution, things like that But I just want to dive into the SvelteKit support Let make a new Svelte project with BUN and see if it runs And it does run And you see why You use bunx because x is cool Create Svelte at latest Normally you do npm create Svelte, but bunx is their edition of npx. And you would call the create Svelte package directly. Create Svelte is the actual npm package. And if you were to do npm create Svelte, this is just sugar for calling the createSvelte package. So that's a little tidbit for you. BunX create Svelte at latest. You do that. It says, what do you want to call your project? I'll call it this week in Svelte bun. And I want to do the demo app with TypeScript so I don't get tomatoes thrown at my face. And there you go. It's built. I can now go to this week in Svelte bun. I can do bun install and this installs dependencies because bun is also a package manager and I mean just the sheer velocity of logging and I remember Jared which is the main creator of bun telling that basically he got obsessed with velocity because he realized how slow console logging was in JavaScript. And so he made BUN, which should be super fast. Yeah. In fact, you may have noticed my computer is a slow and old computer, yet these dependencies installed very fast, faster, almost as quickly as PNPN, maybe faster. I started a five minute timer because this needs to be a quick fact. So I'm going to quick this fact. Now I can do BUN dev, or I think it's BUN run dev. You got to be explicit. And this starts a local VIT server, 5.1.7.3. So I can now go to local host, 5.1.7.3. And BUN can be your Node.js alternative. It's actually a drop-in replacement for Node.js, so it has the same Node.js APIs. And that's why everything loads and works correctly as your local development server. But now we want to build this and run it on production. So for production, we got to make sure we're using adapter nodes. so I need to open this project. Here it comes. And I need to install adapter node. So, terminal awaken. Terminal awaken Slow computer fast run time bun install dash developer i think svelte slash adapter node here it comes and in my svelte config.js here's the gotcha that i ran into yesterday you need to switch your adapter with adapter node and you also need to go to the adapter options and enable or set. I'm waiting for TypeScript to load. I'm not using adapter bun because it should be a drop and replacement for node. There's polyfill. Polyfill false. There we go. So because bun is sort of congruent with node.js 20 and no longer, you don't have to use the node adapter node polyfills. You only need adapter node polyfills if you're on node.js 18 and below. But if you're on 20 and above, you can turn these off. And for bun, you have to turn them off, and you'll see why. Bun run build. So this will build the production project using adapter node, which should run. I tested this. I'm confident it'll work. And this is using rollup as well, which is a subset of Vite builder tools. And then finally, I can run the production application with bun run build slash index.js. I know you just saw me do this twice. Bun run build is an alias for running the build script in package.json, but also bun run can also look for JavaScript files. So in my builds directory, there's an index.js. Little nuance there, I just wanted to highlight for you. I can actually run JS files directly, and I can. When I press enter, there's the server on port 3000. So back to my browser, local host 3000. This is the production application, and it loads pretty instantly as I navigate from pre-rendered route to server-rendered route. Like Sfertile is a server-rendered route, and yet it loads instantly when I go to it. And this is the BUN runtime. So when you go on a production server, such as a Docker container, you can have BUN installed and run your built AdopterNode application. And that's it. That's the demo. Keep in mind, version 0.8.0 implies it's a pre-release. So this is not v1 yet. This is not a certified stable by the BUN developers. So you may use it at your own risk or try it out today for fun. Yeah, I mean, BUN 1.0 is coming on 7th of September. Yeah. And also fun fact, Colin McDonnell, which is the,

 The author of this post is also the author of Zot, and he's working on Bun too. Yeah, and I see in the chat people were kind of surprised Adapter Node works. And yeah, it does, because it's a drop-in replacement. So that's it for Bun. Let's see how I am for time. With one minute to spare, we did it. Quick fact achieved. The next quick fact is npm next in latest tags. Let me show you something about npm.com. the registry? Is it npmjs? Thank you. npmjs.com. Sure. I spelled .com incorrectly. If we go to create Svelte, this is the create Svelte package you saw earlier. And create Svelte can be aliased with npm create Svelte. If you go to versions, every npm module has some tagged versions as well as numerical versions. So if you get 505, you can install that directly. Most of the time when you start a new SvelteKit application, you call at latest. You should not call at next because next is a tag that's reserved for experimental builds, such as a beta. And if you can see on the left side, next points to version 200 slash next dot 204. It says here there are 300 downloads in the last seven days i a hundred percent don't trust this number nor should you i don't i don't really rely on that but yeah i mean a lot of those downloads are just for bot for example so every website that mimic npmjs actually have to download for example it's sneak or for example socket.dev or I think npm.io is another one. So all those bots download, every CDN downloads your package. So it's kind of meaningless, as Paolo said, because they might be bots, they might be scrapers, they might be registry mirrors. Whatever the case may be, if they're a real person, try to avoid npm create Svelte at Next because that'll get you an old, outdated, and beta version of SvelteKit. You should always do at latest when starting a fresh project or target a particular version like 505. And that true for most people in most cases So yeah know the difference Unfortunately the JavaScript ecosystem is kind of like the Wild West There no official formatter There no official versioning schema but there is a package And as far as the NPM registry goes atlatest is widely regarded as the latest stable version. And atnext is widely regarded as the upcoming experimental version, if there is one. Otherwise, it's sort of an outdated experimental version. No, this is create Svelte 5, not Svelte. Sorry, JB asks in the chat, is this Svelte 5? No, it's not. So if I go to Svelte, oops, Svelte, you can see the versions for Svelte. Latest points to 4.2.0 and next points to 4.0.0 next.3. So if there ever is an experimental Svelte version, you might see it under the next tag. hypothetically. And that's it for quick facts. So the next quick fact is how to increase chances of getting help on Discord or GitHub. This is just a side note. If you ever find yourself asking questions on the internet, especially developer questions, you might wonder how do I increase my chances of someone responding or supporting me? So my advice is, number one, share a reproducible projects, such as a REPL, a Svelte Lab, or a repository. If you have people easily linked to a project that shows your issue, they can very quickly and conveniently support you. Number two, describe your goal. Explain what you're trying to achieve, and then you explain what you tried, because you want to sort of cover the XY problem, xyproblem.info, which means don't ask people your attempted solution explain your problem because then people can support you better and can offer the right solution or an alternative solution that you weren't expecting and that's just a brief summary also be sure to write succinctly use syntax highlighting in discord so in discord you can have a svelte snippet like three backticks script and be sure to use html for for the syntax highlighting. This is supported in Discord desktop. I don't think it works very well in Discord mobile, but the attempt is much appreciated when you share code snippets. Do not share screenshots, because screenshots are difficult to read and difficult to copy and paste. If the person helping you wants to copy paste your code into a REPL, they can more easily do that with a code fence like this Also try to create a minimal reproducible REPL like because obviously if you share your whole project it's always difficult to find what's wrong with it. And also, very often when you are trying to create the minimal reproduction, you will find the error yourself. Because when you create a minimal reproduction, it starts working and then you can compare the minimal reproduction with your code and then you will find what's wrong with your code absolutely a minimal reproduction is the way uh this also helps for like self self-support usually you delete every line of code in a file and then just slowly add back lines until things break this is part of the philosophy of minimal reproductions so definitely do that and that is it for quick facts let's bring down the chat and move on to community showcase come on down please introduce yourself and your project yeah I will do that so I am Suvam and this is the library that i will be sharing today so and servers field kit but honestly like the name is into this because i just didn't knew to how what to call it in essentially so what it allows you to do is it allows you to um it allows you to run server code using this node function right i will show a code like a repo soon enough but first i wanted to show the npm itself inside of this whatever is here it will run on the server only right so that is pretty much it and like there are certain other type of thing like server imports you can import thing from server directly on your browser and all of the server stuff would be hidden from the browser so like the browser would not know know what is in the server but it can just get the return value from the server right and this was uh so when i created i was actually trying to implement something from react world to uh svelte kit so there is this library called blitz which is called a meta meta framework for react actually in this you can use the invoke function to do something similar as it is shown here you can take it out later and so yeah i will show a Quick example two examples. So you get a bit familiar with this So this is a example that I created for this So if I go to space does field so here I will start the server in Dev okay so currently it is showing me login screen because I haven't yet logged in so if I log into this if you can please zoom into your examples so you can see that this so that email doesn't match it is so in real time it is checking if the email matches or not whenever i blur will check if the email matches right so i accidentally put something that is not the email so if i now blur it it doesn't show it but if i then change the email a little bit and then go away it just gets the like sends a request to the server and it says that okay this email doesn't exist and it shows this right and this in the code what I did was so this login page plus space those field so here on blur you can see that i'm just checking if the user exists for the name field this is just a function which i am importing directly from lib user slash user and if i go there the user slash user so here

 you will notice that i am using this server is to import this is something i pretty much like took from uh dino and i was like okay if you are importing something from the server you will prepend that with server is to and the root of this would be from src so src slash lib slash db is what being imported here as a server import also you can import npm through this syntax the typescript is there also and in most of the cases if you import anything from the server you should only use it within node so that nothing gets revealed to the browser whatever is in the server otherwise some stuff can get revealed to the browser if you do not use it in the node and also there are certain aviates to using it without like a node function so here you can see all of this code is just running db functions directly in the code that i am directly importing in the plus page of the login route right so now if i log in here under the hood it uses like for this example it is using web socket right for this example it is using web socket and so what i can do is i can open another browser and go here it is already logged in so i can update my email here bh and it will update in both places because of the ws web socket right it uses the web socket under the hood and it gets the stuff also in this unlike blitzes it it can pretty much have any like so it can pretty much share any type of data type so if i go to plus page does field here you will see i am using session browser so this session go there here i am importing dot slash session and that session so it is using a lot of like db stuff right why not import this as server so it is directly like i am the session and i creating a um writable store out of it and then i just consuming it in the routes right and it just works like that i'm getting all the user data everything from the server without like having to do any fetch or ws request so yeah and the main stuff that this this library does but also what you can do if you so want to and i also have an example for that so this is pretty much the main api right uh you can use any function from your server directly in your browser by just importing it properly or even just using the node function which is as a default i import from the what is it called default export from my library right so yeah and you can also check the other parts here i will link it later on uh chat so another thing is if i control c this i have another example here and example is called like rest because so if i go in the previous one so to use ws i had to have these here i have to had this here and i had to use this web socket function right but because of the way i created it you can actually without using web socket you can actually use this library so in this one i am just using restful functions npm run dev or three so in this one i'm just using restful functions but yet again so yet again i can go in here and i can again update my email so it gets updated everywhere right you can see so yeah and the code is a bit more complicated for this because you are i am just using like graceful function for creating web socket out of i will also send this in the chat pretty much so this is like the code for getting the real time stuff but other than that like i'm doing the same thing here and it all just works as is so yeah that is pretty much the entire thing. So any like, say not anything more that I should add here. Cool. Thank you very much for sharing. So it looks like with the power of WebSockets, you're able to send any data type over the wire. And this includes anything that's like non-serializable, such as symbols and classes. Is that right? Yeah. So currently I am not having symbols because so symbols you can use for a private thing in the browser in the server okay so he thought that symbol i will allow it to be a private thing either it stays in the browser or stays in the server but other than symbols you can send any class or functions very cool and i also oh yeah go ahead one thing that i mentioned at the end was that so in this example i'm actually not even using WS, but I'm just using REST functions, RESTful functions, POST and GET. So this endpoint is just like the WS equivalent of REST. Yeah, you're using SvelteKit endpoints, but it still uses WebSocket somehow. Is that right? It doesn't use WebSocket. It simulates WebSocket, essentially. Okay. Yeah, but it gets the benefits of concurrency, like you shared the email update example on two browsers. Yeah, yeah. I see. I think I will please continue I think I will share the GitHub links here so that everyone can check the examples and run it on their machines very cool yeah that would be all from my side okay Paolo any feedback No I think it pretty cool And uh this kind of experimentation are something that I always enjoy seeing because I feel like doing crazy thing with JavaScript is all fun. And I like the node function that runs code on in node. And I guess this is like this works with a specific adapter, right? Because for example... Yeah, go ahead. Don't worry. So technically speaking, if you want to, you can make it work with anything. But generally, if you just want to use it, you will use it with WebSocket. Right. So that sounds like an adapter node feature. yeah very cool everyone give our speaker a hand wave hand emoji clap emoji and thank you very much for presenting to us okay so i will stop sharing then all righty and we will continue now with this week in svelte we are back and that was community showcase let us proceed to the castle of discussions this week in discussions there was one that stood out to me in particular and if you have any discussion topics for this week it's felt you can always let me know and we'll bring it up in a future week as for today i'd like to talk a little bit about adopting svelte at your workplace because when you're a solo freelance developer you can use any stack you want but how do you persuade your company or team to adopt svelte if they're not using it already is this necessary all the time? No, this is obviously a very personal thing that we enjoy. We want to use the tech stack we love to use every day. So that's sort of the inciting incident that motivates the need for it. But really what it comes down to is the business need. Because when you persuade your team, yeah, you can talk about how cool it is and how developer friendly it is, but you got to tie it to some business value. Unfortunately, it all comes down to that. What sort of techniques do you employ? I have a short list of ideas for you. One of them is you can pitch the fact that Svelte has a low barrier to learning. You can possibly teach or learn Svelte in under a day because of the fantastic learn.svelte.dev repl. It can show you all of the basics and it'll expose you to

 all of the major features of Svelte and SvelteKit in a very well-ingrained browser-based tutorial. You can master the basics, be productive. And also there's this regarding of talent pools. Sometimes you want to hire developers who are already familiar with the framework, but my argument is with Svelte, you don't really need to hire front-end developers who already know Svelte because they can learn it on the job very quickly, perhaps the first day they're hired or even right before. So in that sense, you can say there's a massive talent pool of HTML and CSS fundamental developers who already know the basics of front-end. If they have experience in another JS framework, that could be a plus, but it's not a necessity. So with that line of thinking, you could argue the talent pool is extremely large. It touches all front-end developers. Yeah, absolutely. So I'll put that in here. This is especially true because let's not forget that Svelte is the most loved JavaScript framework. So I guess there are a lot of people that want to work with Svelte. So I feel like the hiring pool is really large. Yeah. In fact, as Paolo said, you can attract people to your company with that in some cases. The second point I want to bring up is fewer lines of code correlates to fewer front-end bugs shipped. Is that 100% true? No, but it's definitely noteworthy. Fewer lines of code somewhat equals fewer bugs shipped, especially front-end bugs. Obviously, the server-side code is up to us, but this means you'll save over the course of a year or two, you're saving lots of development time, which is money saved, because you're paying developers hourly or annually or monthly, and you don't want them to spend their time fixing bugs. you want them to spend their time shipping business features or product features. It's less complex, it's easier to maintain, and it's easier to read and reason about. And it's also easier if someone has to come in your codebase. I feel like it's so much easier to get used to as an adult codebase. I mean, maybe I'm biased, but I feel like being that simple, like to learn, it's also simple to reason about it. Yeah, I'll just make my screen bigger. So yeah, that's true, is you can go and read the code, especially after completing the tutorial Anyone can come in and read it Next point is if you have many short projects you can easily evaluate it So if you at an agency type workshop or you have a lot of internal projects that are weeks at a time, one after the other, you can evaluate it with temporary projects. Not everybody has this luxury. Sometimes you're working at a large business with a very mature long-lived product. That's much harder to experiment or evaluate, but it can happen if your team has the practices in place to allow you to experiment with new tech. But if you are in an agency, then you're more able to experiment. You can say, hey, for this next project, let's try Svelte. And then we'll have a retrospective and move back if needed. So getting that hands-on experimentation is a good way in. There's little to no module decision fatigue. So when it comes to Svelte, little module decision fatigue, I'm referring to the fact that Svelte and SvelteKit have very few dependencies. In some cases, you can install Svelte or SvelteKit, and you can build a full application with just that. You don't have to decide which CSS preprocessor to use. You don't have to decide stateful management because Svelte provides most of those features out of the box. And that means fewer dependencies. And that also means fewer, and let's face it, dependabot PRs on GitHub. You don't want to spend countless hours every month updating your dependencies because you have so many. And sometimes you configure dependabot to 10 PRs maximum, and you're constantly exceeding that threshold with other kinds of frameworks. But it's felt not so much. And this also reduces security vectors, which Paolo talked about a week ago, which means fewer dependencies means fewer chances for being attacked and being vulnerable. Yeah, absolutely. Use Renovate. Yes, Renovate's a good alternative to Dependabot. Next, my final point is a happier development team, which I'm sure Paolo can talk more about. Happier development team, it increases retention. You have fewer architecture decisions. you have more productivity and that can in turn lead to dollars saved as well yeah i can absolutely confirm that this is true we are using svelte at work at main matter and the whole team is happy about it it it very fast to move with svelte and it really is a happier development team Like I used to work with React Native So now I switching to Svelte which is my favorite language So, I mean, I could not be happier, but it's not just me. It's the whole team. Yeah, I use React Native as well. Nothing against it. It's just a different way of working. In the chat, I see Svelte can be added to anything that uses JS. More or less, Svelte is a compiler. So one of the disadvantages to persuading your team to adopt it is the fact that it is a compiler. It's sort of ideally used as a wholesale adoption. You want to start from scratch with Svelte because it's much harder to migrate an existing project to Svelte since it uses a compiler, especially if it's like a PHP project or some other completely different server rendered stack. Then the adoption is much harder because you got to start from scratch usually. I will also add another thing to these things that he has felt he's a very it's in a very unique position because the meta framework is built by the same people that are building the language and this is not true for everyone is kind of becoming true with react and Vercel but there are still two different companies that are taking care of that. And also Svelte is one of the few community-based projects, because, again, React is backed by Facebook. And this means that Facebook, in one way or another, can interfere with the development of React. So if Facebook that is using React needs something, you're pretty much sure that the Facebook team that is working on React will integrate that, while Svelte being completely open source and completely community-driven is something that is, in my opinion, important. That's a very good point. So mostly community-driven with a growing full-time team. So Vercel currently hires three full-time Svelte maintainers, and that list has grown from one to two to three in the past three years. And that's a good trajectory for full-time maintainers. You want a full-time maintainer, but you also want community-driven because that means there's more nuance put into the decision behind APIs and code style which is better than a corporate open framework which is whose APIs are designed and driven by the company needs And the company matters, and I'm sure they have RFCs, and it's good, but it's honestly second priority. And those are the hurdles. If anyone here in the chat faced this discussion in their teams, please share your experiences in the chat, what hurdles you faced, or what positives you've uncovered, and we'll include it to the list here. Otherwise, we'll wrap up with some comments. Coder writes, the code I like to go back to after a long time is Svelte because I don't need to remember any framework specifics, but the same knowledge I always had with HTML, CSS, and JS. That is right, because it's like riding a bike. Svelte code typically has your markup, which is very, like it close, it more closely resembles plain HTML than practically any other framework because it's not JSX. There's no camel case attributes. Everything is more close to HTML with the exception of directives like on event or bind state. The next comment by Cirilla is hard to migrate existing projects, but it's great for new additions to your page and for incremental adoption because it's a compiler. There was a talk at Svelte Summit, I think about embedding it in the PHP app. So that's some good watching for later. Everyone can check that out. so yeah there are other known hurdles but as far as the discussion goes this is a pretty good list so i'll paste this in the chat for you to reference in the future any final comments paulo nope here you go spelt allows me to use js libraries like jquery which are much harder to use in other libraries to use. Yeah, ideally you don't use jQuery in Svelte, but it is possible due to the point here that plain.js and browser-dependent libraries are very easy to consume in Svelte. Scientists were so preoccupied about if it could be done that they didn't stop to think if they should be done. Yeah, we've all been there. Okay, let's move on to one, two, three. this week in questions and answers. And we're going to bring to you some common questions and answers asked in Discord. And what are the answers to them? I'll just move my text edit to the top

 left again, and I'll show you a SvelteLab demonstration. The question this answers is how do I create debounced client-side search that also works without JavaScript and is accessible too? Let's see if I can answer all of that today. So right now my demonstration is running, and the question is how do I build enhanced search right here that works with and without JavaScript. Bring back the chat. Okay. So this example here is called find some flavors, and we're using a search tool to search for flavors and in real time display the flavors down below. I could use an input attribute to hide my examples there. I forgot the attribute name, but it works. And I'll go over the features one by one, but also I just want you to bear in mind page.server.js is used here in this Felkit project. We're not using API endpoints. We're just using load. And I've added an artificial delay here on line nine, which is a promise of one second timeout. So every time I perform a search, you will see a one second delay. And that's on purpose just to showcase what happens during a delay. So what are the features? I'll show you first and then I'll tell you. If I search for cherry and I wait, it'll debounce after about 600 milliseconds and then perform the search for me. Autocomplete equals off. Thank you, Delight. Let's do that for funsies. So if I do autocomplete equals off, it should no longer show the preview. Thank you for that. So now if I do another flavor, I think there's lime in there. Yes. So I typed in li, I did a fuzzy search and it returned lime as a potential flavor. If I do RR, it found cherry and berry because they contain the string RR. And this all happens with client-side JavaScript. The way it works is when I submit the input, there's an on-input event handler with my debounce search being activated. The debounce code is all inline, so it might look a little funky, but debounce search calls the search function after a 400 millisecond timeout, and that's thanks to line 29, the debouncer. Debouncer just means every time I enter a keystroke in the input, it'll reset the 400 millisecond countdown. So if I keep typing and I don let the 400 millisecond countdown to finish it will never search until I stop That what a debouncer does And the debouncer will execute the search function on line 43 which calls e target form request submit. This is kind of a bit much, but at least I avoid the need for using bind this on the form. So instead of calling the form directly, I'm using the event object from the input. e.target.form gives me the HTML element for the parent form. and then request submit is a function available in form that actually triggers the search button. Not to be confused with submit. Submit will call submit, but it'll use like a programmatic submit. Whereas if I used request submit, it'll actually submit the form as if a submit button was pressed. So there's a slight difference there. And then finally, if I actually search with the search button, it immediately searches. You'll notice there was some loading text there. The loading text is displayed conditionally using the navigating store. So the navigating store is imported way above here on line 24. It's a store, part of SvelteKit and app stores. And when navigating is true, it means the page is navigating. It's navigating because I'm not using form actions. I am using the get method. So on line 58, this is my form. And on the right here, it says method equals get. and I did not apply an action attribute here because it's calling get to itself. Right now I'm on the root page slash. So this form submission will get itself and call page.server.js load over and over again. All I'm doing is calling the same page and that's what form get does. Now let's go over the features. So it's a plain search using form method get. The get form submits to the current route causing a reload to fetch the query data And the query data is captured in the input. The input is over here, name equals search. And then in the load function, you can see I'm using URL as a parameter. And I can do URL.searchparams get search. And that will give me the user entered query. So if I type LI, then query equals LI. And then in my flavors array or your respective database call, you can filter accordingly. I just use the plain array. in this case When JS is not present the page submits to itself and then it shows results in a new page load So actual navigation occurs when js is not present when js is present the debouncer is used it navigate to itself invalidate the page and i'm also utilizing a special svelte kit feature down here called data svelte kit keep focus and data svelte kit replace state replace state will not push history state it'll stay on the current page so the back button won't take you back to another search instance this is when JavaScript is present. KeepFocus will keep me on the input. If I do LI and it searches, or RR and it searches, I'm still focused on the input. This is a good quality of life improvement because without that, if I type in LI and it searches and debounces, I'm no longer focused on the input. I have to click on it again just to change my search every time, and that's kind of irritating. But with the power of a hydrated page, we can have KeepFocus. So that way it'll load and be a little nicer. Patrick writes, you should abort the previous request with a abort controller if there is one. Otherwise, you could experience a race condition. That's good. Yeah, this is obviously not a perfect demonstration, but I appreciate feedback like that. So if you can help me understand what a abort controller does, I can learn more about it and write a better demo because I do want to improve. Selfishly, I'm doing this for me. The last feature is page title adapts to found results for screen reader. So the screen reader will navigate. Because we're using a form with the method equals get, this is actually navigating. It's going from page to page. So that means the title needs to be dynamic. On line 53, I have my title in Svelte head, and it's going to look for some flavors. Let me move that a bit. It's going to say find some flavors, and then it'll say page results. Page results is going to be something like found results one, found results two. Yeah, caching is necessary too. So for your respective backend work projects, keep that in mind. So let's see. The page title says, found some flavors, zero flavors. If I type in line, it'll say, find some flavors, one flavor. The title changes. And every time the title changes, your screen reader will read it to you. Let me show you. With voiceover. This is not Safari. Running SvelteLab on Safari is a bit of work but it should work on Brave Let try it out Some Some Unselected So now I going to type in RR R Loading RR Find some. So a few things happened just now. The loading state was a polite ARIA live div, so it said loading, but then it was interrupted by the title change. Now that the title has changed, my screen reader says, find some flavors, two flavors found. This is good. So all I had to do was change the title, and the user of this input can tell that results have been returned. They can also tell when results are loading. Right there, it said loading. And then it says find some flavors, one flavor found. So that's the screen reader aspect of this demo. The final feature is navigating. The navigating store lets me conditionally display the alert that something's loading. And that's everything. Thank you for listening. Let's see what's in the comments below. captain writes keep a cache so editing doesn't keep refreshing refetching yeah i'm refetching results every single time which is obviously inefficient so in your production applications you should implement some form of caching and i think patrick may have been alluding to that this demo is is very inefficient in your demo you can obviously cache uh already searched results i think what patrick is saying is a bit different because what he's saying is that you should abort the previous request whenever a new one comes. And that's because if you are doing a request that for example takes 5 seconds and then you search and you do another request that takes 200 milliseconds, the 200 milliseconds request will come first and then will come the five second one so you will find yourself with outdated data basically but I'm not exactly sure how to abort the navigation and I think Patrick is sharing a snippet of code like because you can do it with fetch quite easily because fetch takes an abort controller as I don't know how to do it in SvelteKit. I see. Patrick shared an example using form use in ads. And it should work with the get method, right? It doesn't work with get method. Like you cannot use the get method.

 is announced with get methods. But I'm pretty sure that SvelteKit handles these by itself. Like if you are trying to navigate to two pages, SvelteKit will abort previous load. I'm quite sure about that. Well, maybe our network inspector can reveal the truth. How many unnecessary requests am I making? Because these are get requests to an HTML page. So let's see how that looks. I'll zoom into my dev tools and I'll try a couple of debounces. So there's a request and I'll do two in rapid succession. I'll do li and then rr. So yeah, it loaded each and every single time. It didn't cancel the previous request, but that's because the enhanced spell code navigation uses underscore data.json to return the found results from server load. Now that I'm here, I can disable JavaScript. and refresh. So with JavaScript disabled, I can type in Lime, and absolutely nothing happens. But at least there's a search button. And it takes me to the resultant page. And this loads an actual 200 response of an actual document, as opposed to an enhanced HTTP request to JSON. And if you want to try the race condition, actually a very simple way of doing it is, for example, to try the wait time inside your load function to the length of the string. So the lengthier the string, the lesser time it will take to load. But I mean, it's complicated to do it now. So we can prepare something for the next episode of this week as well. Yeah, I could dive deeper into this and go into what Patrick and Captain talked about. Let read the comments and wrap it up for today And maybe we can talk more about these optimizations next time So Captain writes a port as I not going to need this result That's true. Ayub says enhanced user control using JavaScript. Captain says different approach to cache. The cache can tie the correct results to each entry, but then allow for backspacing. I think because I'm using get requests, those are automatically cached by the browser. So at least those should be cached, but I have to prove it out. I'm just speaking theoretically. This example of debound search is also achievable with SvelteKit form actions using post requests. There are ways to make it work in other different approaches. I use the get approach because I like how with JavaScript disabled, it's a whole navigation. So if I type in RR and press enter, that means technically so as post, but I don't know if I press the back button, will there be a new form resubmission? Right now I'm in RR. If I press back, it takes me to the Lime results. So it's a slightly different experience with JavaScript, is disabled. I'm not so sure if a post request would be as similar as this. Will SvelteKit ever have in-browser dev tools windows, something similar to Nuxt? I don't have an answer to that, but there is a Svelte inspect tool that maybe we can cover in an upcoming week. There's Svelte inspect, which I don't know the keyboard shortcut for, but the dev server in Vite and Vite plugins Svelte do have something. And you can also use breakpoint debugging as well. That is possible, and it's covered in another YouTube video, which I'll try to remember to include in the description below. Captain finally writes, one to inspect state, the other to take you to the source. Incomparable, but definitely helpful. Yep, developer experience tools are always in the pipeline. But I think we're at time, so I'm going to conclude this meetup. Thank you so much for listening, and I hope we all learned something today. See you next time. Bye bye!