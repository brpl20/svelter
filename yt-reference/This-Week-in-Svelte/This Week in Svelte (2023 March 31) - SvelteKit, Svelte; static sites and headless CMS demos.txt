 Hey everybody, welcome to This Week in Svelte. I am your host today, Enrico, and I'm also hosted and gathered around with fellow Svelteans. I'm sure there's a better name for people of Svelte, but that's the one I chose at the top of my head. Let's get to it. In This Week in Svelte, we talk about the changelog, some quick facts. We have a community showcase today with a special guest I'll introduce in a few minutes, followed by discussion and the common Q&As that I saw hanging around Discord this past week. And there's a lot to learn, so don't waste time with the changelog. What happened in Svelte this past week? I will show you. So let's bring it on screen. We have a changelog. SvelteKit has some new versions, and so does Svelte. starting with SvelteKit. Alrighty, so SvelteKit 1.15.0, we see some, oh, sorry, 14. So 1.14.0 came out this past week with a feature to add hot module reloading to fallback error pages during development. So the fallback error page is error.html, which is an implied page, and now hot module reloading works with those. So if you apply a custom page, you can expect HMR to work. There's a patch to the submitter type on the submit function. I think there's stronger types related to that in version 1.15.0. Good segue. So thanks to some community contributions, the submit function and its respective type will be more helpful when you use a custom enhancer with form actions. That's the summary. So next time we try custom enhancers, you'll notice that some of the types will autocomplete in IntelliSense a bit more robustly. As for patches, there are some Vite-related patches in 1.15. So for example, there were infinite loops happening when certain files were missing. So those have been patched so that error messages are a bit clearer. Some cleanup that most of you, especially me, have not noticed, but that's okay because now we'll never notice it because it's patched. public directory vtconfig is available and some parentheses balances. So just some general cleanup stuff mostly invisible to us but definitely edge cases that have occurred with some users And that is why we more stable today And within the past 24 hours, I noticed a new Svelte release. Let's take a look at that. All right. So on to Svelte. 3.58.0. So last week we covered 3.57, and here's a new one. So the highlights are you can now bind inner text for content editable elements, which should be handy. So content editable is something like a div that the user can freely enter stuff into, and now you can bind to its inner text, which makes reactivity a bit easier to contend with. I have a live demonstration of some of these things, and I know a lot of folks have been saying, hey, when do I get CSS container queries? The answer is now. The time is now for container queries in Svelte. I believe this is due to an underlying parser that Svelte uses. Up till now, container wasn't available due to the dependency. But now that that has been updated, we can all enjoy container queries, and I have a demo of that. Next is some new accessibility warnings. Some of these are self-explanatory and easy to read, like interactive supports focus. I assume that means if you take an element that's not inherently interactive, like a div, and you add a button handler, like a click handler, if it doesn't have a tab index of zero and it's not focusable, I assume this warning will show up. I can probably prove that. So enough talk. More experiments. So here's a Svelte REPL featuring version 3.58.0. And in front of me, I have this live demonstration of container queries, and maybe I'll try to reproduce some of those ally warnings. So first off, I have this box with a red border. On line 8, I called it test, which is not very intuitive, I'm sorry. But the test container has a width and a height of 200 pixels. Contained within there, we have a flex parent with two childs. one and two. With container queries I kind of had to learn this yesterday but now I know that if you specify container type on any element so the main element is an inline size container type the test element or anything with the test class will have a container type of inline size. That allows line 49, the container query, to do its magic. If the width is below 400 pixels, then these classes and these rules will apply. So if I take this browser preview, already you can tell that 1 and 2 are using the flex direction column. So on line 51, flex direction column is already applying to the flex parent. But down here, we have a second flex parent. So these HTML sets are identical. Lines 9 to 16 is the exact same as lines 19 to 26. The only difference is this is nested inside a red box, but down here it's nested inside the main element. So because the main element is greater than 400 pixels, it's using a flex direction of row. That is the default on line 47. If I decrease the width to less than 400 pixels, now it is a column, flex direction column. That's because the flex parent is a child of main and main is the nearest designated container. You can also do more with container queries, but this won't be an exhaustive overview of container queries. Check it out on Mozilla or your favorite tutorial site of choice. The point here is that this box is already below 400 pixels, so the container query applies. Whereas this one is just responsive because it depends on the size of main, which is dynamic. And you can do that now in Svelte. thanks to version 3.58.0. Now, just for fun, let's see if I can make this accessibility warning appear. So if I make an empty div, probably here. Yeah, so the difference between... So JB asks, container looks at the container of flex parent regardless of what that is. That's how I have it set up here. container queries are like a very smart, more powerful media query. Whereas media queries apply to the entire viewport, container queries apply to specific elements So in my case the main element and whatever element contains the test class these are my designated containers And when I specify a container query without a named container, like for example, test or box, you can name your containers, but in my case, I did not name my containers. It'll just automatically apply to the nearest container that has a container type. Yeah, and this is cool because you can make components now like buttons or tabs, and you can make them responsive to containers now rather than the entire viewport, because sometimes you have a button in a card or you have some element in a smaller element, and you want it to be responsive to the parent element. That is exactly what container queries achieves, and it's really useful. As for accessibility warnings, let's try this on click. So if I have an on click, and I say click div. Non-interactive elements with a non-click must be accompanied by key down, key up, key press. Okay, that's typical, and I'm sure that won't be the end of it. It's time to use my superpower, copy paste, on key up. Oh, that's too many equal signs. All right. So this div, it has a key down, it has a key up, it has an unclick, but I did not expose this warning, maybe because I misunderstood it. Ally Interactive supports focus. I'm very curious what this means, so let's find out. It might be, it's related to an ESLint issue. Yes, container queries are very well supported today. I'll also bring that on screen. Interactive supports focus. So if you give something a role, a button, and it's index of zero, that is good. Okay, so maybe it relates to the role. So role equals button. There we go. Elements with button must have a tab index. That's a separate ally warning, but it's still correct. Got to give it a tab index of zero. Now it's properly keyboard interactive. See the classic chromium

 blue halo there it is it's keyboard focusable let's double check the container queries and then move on container so there's there are multiple container queries the the query rule itself is available very broadly I think Opera Mini is discontinued. That might not matter. So container does work everywhere that it does matter on evergreen browsers. And then size, I'm surprised to see UC browser not support that. So I guess there are exceptions. Know your audience and know your browser market share. This one has 82%. Okay. Keep that in mind. Kind of like the has pseudo selector. ThoughtPix asks, am I using Tailwind? No, I have not delved into Tailwind yet. So I write my CSS by hand. But this is just an illustrative example. It doesn't really showcase what I do day to day. Moving on to... Oh yeah, there's one more patch that's very important. So in Svelte, 3580, there is an escaped text area value. During server-side rendering, it was previously possible to execute scripts in a text area value. That led to a cross-site scripting vulnerability, but that has now been patched in 3580. So now text areas are much safer to parse server-side. Good to know. Moving on to Quick Facts. Today in Quick Facts, I have a demonstration for zooming. And this is going to be a little strange because I need audience participation. I need you to tell me if things are working. So let's go to Safari. and this demonstration is about mac os zoom pretty much every operating system has a zoom capability and i talking about this so right now i zooming into my screen Question for the chat Can you see that I zoomed in Is it working Yes, it is. Very good. So my screen share does show that I'm zooming in. What I like to showcase is a lot of people use screen magnifiers. It's a sort of assistive technology. Last Last week I talked about screen readers, but screen magnifiers are also very essential and used by lots of people. And people who use screen magnifiers tend to zoom in a lot, and they also accompany this with a screen reader. Today I'll just show the magnification, not the screen reader accompaniment. And here's how folks navigate the internet. They move their cursor around, they move around the operating system and around the viewport by dragging their mouse. they also use tab navigation. And what I want to focus on today is focus management. So when I press tab, it shows dialogue modal pattern. I press tab again. The page highlights this next link. Because I have two monitors, it's a little strange on Discord, so bear with me. So now I'm focused on add delivery address. When I focus on an element, the operating system moves the screen towards the focused element. If I press spacebar to trigger this button, the modal opens and my screen is focused on the first focusable item. This is something that the web developer had to implement. So when this modal opens, the first element is focused. I'll show you zoomed out just so it's clear. So add delivery address. The first element is focused and I can press tab, tab, tab, tab, tab, tab, tab, cancel. When I cancel, it focuses back on the initiator. So let's show that again zoomed in. This is how someone zoomed in experiences that, and they do zoom in this much. This is not exaggeration. This is how much people zoom in. In fact, they probably zoom in even more. So back to that button where it says add delivery address. I press spacebar. my screen moves to the first element so I can see it and I can say 123 fake street. I press tab on my keyboard If I have a screen reader it also announce what the label is because it really hard to read this as you can tell Oh there it is city If I had a screen reader enabled it would say city Fake town And if I press tab, it keeps navigating until it eventually gets to the buttons. There we go. So this button says verify address, add, and cancel. I'm going to press cancel. Okay, because I'm using two monitors, it's a little funky. But what just happened was the form closed, and I went back to the initiator, which is add delivery address. As developers, front of the front end, we need to make sure that when we take the user's focus away, we need to ensure that the first essential element gets focused. So in this modal example, that happens to be the street input and not the heading because the button has the label add delivery address, but the heading also has the same text, add delivery address. It would be repetitive to focus on the heading. It's possible and sometimes a good idea, but not in this particular context. And when you cancel, you have to return focus to the initiator so that the person using a screen magnifier can return back to the predictable starting point. And this is what focus management is all about. In Svelte, you can achieve this with the tick. So let's go to the documentation. Opening a new tab now, Svelte.dev. I'll try to give an example. So the tick allows you to wait for things to render before doing an action such as focus. It looks like this, a wait tick. I can try to give an example. Live coding. So right now I have this focusable div. I'm going to make a button. And I'll say click to go to heading. and I'll say onClick, and then I'll say heading.focus. I'll get to what that is in a second. Down here I have an h2 heading and I give this a bind this equals heading and a tab index of minus one Minus one means I cannot focus on the heading with my keyboard, but I can focus with JavaScript. Let heading, and we're done. So now I have a button that says click to go to heading, and I have a heading down here to repeat has a tab index of minus one. So my keyboard cannot tab focus on this heading, but I can with JavaScript. Let's prove it. And this might break, so I'll get to that in a sec. So if I focus on the button, it says click to go to heading. I press enter. Oh, and it worked. It's just on my second monitor. There. The heading is highlighted. Very good. I did not need a tick because it's already rendered. If the heading was hidden, I might need a tick. So let's show that again with a tick. But I do want to demonstrate that one last time. So I tab focus. Tab focus. There we go. Sorry, two monitors makes this demo a little weird. I'm focused on click to go to heading. I press enter. And the heading is highlighted, which means a screen reader will read it, and a screen magnifier will move to this heading. But if the heading is hidden, and it appears procedurally, then you've got to do something about that. You can do if, I'll say open, and then I close the if statement, and I'll say let open equals false. And then when you click on this button, let's say I want to do open equals true, heading focus, heading dot focus. That's a standard node element API. So once again, the button is focused, and the button says click to go to heading. I press enter. Interesting. The heading appears, but it is not focused. There's no blue halo. That's because in Svelte, I focus on an element that hasn't been rendered yet. when I do open equals true, there's a race condition. This if statement is applying open equals true. It's rendering, but hasn't rendered by the time dot focus gets called. So that's where you use tick. Await tick.

 to import it. Import tick from Svelte. And I need to make this asynchronous. There we go. Now let's try. I focus on my button. I press enter. And what do you know? The heading has focus. Because the F statement receives the open equals true variable, it renders, it awaits the tick, which means it awaits the event chain or the event loop, and then after it renders, it's focusable. So when you're doing stuff like keyboard interaction and the user clicks on something to make something else render, such as a modal, await tick is your friend, and it's a single line of code brought to you by Svelte. Thank you, Svelte. Let's give Svelte a hand. Moving on to the next topic. So yeah, that was screen magnifiers. Oh, but I have a bonus example. I have a bonus example from gov.uk. Take a look at this. So this is gov.uk elements, also known as the gov.uk design system. I often go to this website as inspiration because gov.uk has fantastic usability research and blogs, and they talk about how to make usable experiences. Since we're talking about screen magnifiers, I wanted to share form errors. And what's fantastic about this example is when this form has errors, there's an alert at the top of the page and skip links to each respective error. So if I highlight the first skip link and press enter, the page focuses on the first error. If I click on the second error, the page jumps and focuses on the second error. Perfect. This is a great form. So one experience to highlight is that. Always have skip links to your error messages. But the second thing is this vertical alignment. There's a text input. And then directly below it, there's a text input. And directly below that is a continue button, left aligned, stacked vertically. Sometimes you have a form that's left aligned and then the submit button's on the right. Sometimes you have two inputs horizontally placed, like name on the left and insurance number on the right But what gov found out through their usability research is it ideal and optimal to stack your forms vertically like this The reason for that is for an easier or more pleasant screen magnifier experience Let me show you. So right now I'm using my screen magnifier and I'm focusing. I'm on the first input and when I press tab it goes to the next input directly below. And if I press tab again, it goes to the continue button directly below. This is good because I'm not getting motion sickness. Many folks who use screen magnifiers that jump around a screen, they do experience motion sickness. And that's part of accessibility. If you have them jumping left to right and up and down to left to right on a form, they're going to get dizzy. But if you do it vertically like this, it's much more pleasant, much more predictable, top to bottom. just like a regular document or regular webpage. So I also recommend keeping your forms left aligned and stacked vertically for a more pleasant screen reader and screen magnifier experience. That's the end of the bonus example. Moving on to Community Showcase. So I have a special guest for you today. Kohei has volunteered to show us Svelte CMS, so come on down to the stage. We're going to talk a bit in the latter half of today about CMSs and static site generation. And our community showcase is going to talk about one such popular CMS that is Markdown-based and how it's configurable and easily deployable. So, Kohei, are you in the house? While they get set up, let's try to open Visual Studio. Your mic is suppressed. Try speaking now While you do that I open my editor I'm going to need this. today, later within the hour, I'm going to showcase a static site and some CMS data gathered from a remote database in order to build a static site. Let's try this again. Invite to speak. all right try to unmute yep so i'm speaking right now i guess yes you are welcome awesome so yeah so let's clear my screen um here I can't looks like it's working almost sorry I need a permission for that while you gather permissions I'll just give you a longer introduction my discord that's okay so yeah kohei has volunteered to showcase sveltea and i'll try to find the github link sveltea is a content management system it is a spiritual successor to some other things that kohei will introduce to you i won't spoil it and sveltea allows you to manage content using markdown and static content so you don't need a remote database, you don't need a remote CMS. This is all locally hosted. And here comes the GitHub link. Okay. Hello. I think now I good Okay so All right just give me a moment to broadcast this And if I disconnect, don't worry, continue without me. Okay, ready when you are. All right. So can you see my screen now? Maybe? Yep, you're ready to go. So, yep, so my name is Kohei. I'm a UX engineer based in Toronto, Canada. I've been using TBEF for a year for several clients' work and it's pretty awesome. It's very good developer experience. I really appreciate that. And yeah, today I want to talk about my recent project called Sbertia CMS. It's a good name right? Sbertia. I'm surprised people never use that name so I took that. So why Sbertia CMS? It's just background. Sbertia CMS idea is not new. actually taken from NetRefy CMS. Yeah, and maybe some people might know about it. It's a headrest, git best, right with CMS. Yeah, but the problem is, it's been inactive for a year. Before, there was an announcement recently, like it's migrated to the CAP, the CMS, but yeah, it's only like recent entry. So it has been abandoned for a year. So a couple of my clients use Netlify CMS and there are some UX issues, internalization issues. So yeah, I've decided to create my own CMS with BERT. So like a year ago, like some dark mode and a quick search and some like a new media library. And stock photo, you can click translation, things like that, because it's like, you know, I'm, you know, I'm a UX designer, UX and front-end developer.

 So that's, yeah, that's, you think there are some quick highlights. And this actually is a spirit application, not a spirit kit. Why that? I can explain. So, the requirement here is make it easier, much easier for Netlify CMS users to migrate to the CMS. Because the original one is, as you see on the screen, it's just only one single script tag. So it's very lightweight git based headless CMS. So I need to replace this script. So that's like a, so everything has to be migrated, has to be compiled to one single CMS.com. How can you do it? I can do it. Just bundle it. So by bitconfig.js Maybe I'm not sure my pronunciation is correct. bitconfig.js So you see like there's a rollup of options input, output is needed. And also I needed to emit CSS force to include CSS in the bundle. So no HTML, no CSS, just one single JavaScript file. This can be done with this config file. And yeah, main.js, like this entry point only has basically three lines. Just import app belt and app belt contains, yeah, of course, the file. file and yeah it's it's really extracted to this document body and yeah that's that's the best way to how to build the one single single page application And yeah let see some in channels also So because there no spare kit I created a simple hash routine router And so for example, you see some highlights in the right-side screen, like hash-collection-posts, or hash-assets, or hash-collection-start, or something like that. And this can be done with this simple router. And I mentioned it here, actually, because I use the same technique to build a browser extension as well. Because like a Chrome extension, FACTS extension, these are only like a local file index.html. You cannot omit the file name. And it's not the server. So yeah, so just use a hash. best routine to navigate paste. And maybe someday I can present that browser extension thing in this display spell, maybe, if I have a chance. So here, so that's interesting, come here is thread component. So instead of writing If else, like five times, because there are five pages here, you can use this Svelte component. And this result is one of the components, or the collection page, content page, Svelte, So it's easier to manage the pages. Next one is, yes, a hash-based routine. Because there's no layout, I created the page content of the page content to include all these sidebar, toolbar, and main content like that. These are named slots This content page has slots size size bar toolbar These can be managed easily with this named slot I can keep the layout when I move to another page. For example, content page, access page. And entry listing. So there are two ways to show the content, simple list or grid, like these screenshots. And again, this diverse component works. Actually the content, these two different layouts, has the same content called entry list item and outer component is either basic grid view or basic list view and I can switch easy to this one of these things with this word component wow that's like a and that this other component some styling and so it's yeah so the content in the content that slots content is the same but just switch this outer component with various components it's magic and field editor so the CMS has as you see their title, date, image, and body is actually marked down it's not implemented yet but there are more than 15 types of field type it's called widget and how can i render that again i can use the third component because yeah these actually this code only has three widgets but there yeah at least 15. so yeah instead of if writing if else 15 times you can yeah this just list widgets in this this const widget object and switch here with the component. That's very magic. I really love it. And some other highlights here, and I have some go to method Like you know SpiritKit has goto method but I created a similar one for Hatch patient navigation And I have SvelteI18N for URI localization internationalization. I only have the English and Japanese at this time, but maybe later we could add some more locales. And what's... And Svirita UI is my own UI library, still ARIA alpha, so I don't recommend using that. But yeah, I decided to build my UI library to implement all the layer accessibility standards. Also, like a file system access API is only supported by Chrome and the Chromium base browser at this time. But yeah, it's a good one for local file editing. And there's some other third party extensions, deep error translation, and some stock photo services like pixels and splash. So, and so because like CMS, this header CMS, like it can be used with any framework, like yeah, like Next.js, ULVNT, Yugo, JK, whatever. But yeah, since this is a community, so people want this with SphereKit maybe. So let's see. So yeah, as I said, it's a headless, Git-based CMS. So all these data is just JSON files, or Yamu, or Tomo, or FrontMountain, the Markdown files. So and it's managed in the Git repository itself. So these like members, blah, blah, blah, JSON, and pages about JSON, home JSON. So it's easy to find this file. And how can I use, how can I be those data, data? You can use import metagraph, but it's not mentioned in the Svelte document because it's a future of VIT.

 Yeah, it's document link is here. And just pass to these files, maybe with this asterisk. So you can use multiple files at once instead of reading one by one. And this file's gonna be object with paths and file content mapping. So you can just JSON parse and putting that this all object or project object. Can then you can use it anywhere in the Svelte file. For example, yeah, I'm just really importing all object. Maybe it's better to load this data in Svelte.js or Svelte.js, but in my case, it doesn't matter because I only use a static adapter and all these pages are static. So I just imported all objects directly in this web page and just iterate over these objects. Yeah, that's all I have. And here's my Git repository. And yeah, it's open source. You can all see all the codes here and some explanations and some limitations, things like that. So please have a look and give it a try. Thank you. Thank you so much for presenting. So that was cool to see. So Sveltea is a successor to Netlify CMS and Nocap. What was the successor to Netlify CMS called? Yeah, it's called probably Decap CMS, I mean. Right, yeah, Decap. And I used Netlify CMS on projects. So for the folks in the chat, this is a tool that you could utilize by dropping a page, like an admin page, in your SvelteKit app. And when you run your SvelteKit app, Sveltea will start up because all it needs is a container HTML page loading the one JavaScript file that Kohei had bundled. And it was really cool showing us that Vite config you had because we all know it possible that Svelte compiles to Vanilla JS And what you achieved is you turned your entire CMS into a single bundle using Vite So that was cool to see. Thanks again. If anyone has questions for Koei, leave them in the chat. And let's move on to this week at Svelte. So take care. I sent the link to my slide deck in the chat. So it's going to be easy. Sounds good. I'm going to pop down the chat. If I disconnect from Discord, don't panic. One second. Moving on to this week in discussions. There might not be enough time for this. Let's see if there is. Yeah, this week in discussion. There was an article shared in the chat. I'll bring it here. It was when JavaScript fails. I'll give a really quick summary and I'll share it in the chat. So here's the link. The point of this article is to highlight that when 3% of your users have a bad experience, we tend to model them as 3% of the entire population of users. We assume that 97% of users have a perfect experience 100% of the time. That's simply not true. It's more like this. and on my screen, there's an animated GIF of sad faces and angry faces and happy faces. What really happens is when 3% of users, it's not really 3% of users, it's 3% of visits. Visits to your site can be broken because JavaScript can fail. JavaScript is not reliable because it relies on HTTP. Sometimes the network has an issue. Sometimes there's a runtime issue. Sometimes it's a combination of those things. So 3% of site visits tend to be broken. and that either leads to frustration or best case scenario, they refresh the page and move on with their day. But that's a best case scenario. And yeah, ad blocks, ad blockers, Chrome browser extensions, a lot of things can impact the viability of a site. And sometimes it's even worse than we can imagine. So the point of this article really is to double down on progressive enhancement. If you can make a site that works without JavaScript with progressive enhancement, then you can cover a very wide array of scenarios, which is important Stalk it helps you achieve this So with server rendering or pre and form actions you can build interactive experiences with hyperlinks I know like plain HTML hyperlinks and form actions that will ensure that if these failures do happen at least it won't be terrible. So this was a great article. It's in the chat. And let's move on to this week in Q&A because the demonstration I have is a big one. So this week in Q&A, I have my text editor here. And what I'm going to showcase is static generated pages, such as a blog, using remote data. I need to show you how that works. So let's bring the chat on screen. Okay. So several people have asked, and there's been a lot of back and forth, how do I build a static page in SvelteKit and how do I fetch data from a remote CMS, like a headless CMS, either using Docker on your machine or using an actual remote hosted CMS. So what I'm going to showcase today is a blog, not a beautiful one, just an illustrative one. Static blog with data, pnvmdev. I'll show you. Let's go here. Alright, so what I have here is a blog. It doesn't look good. I apologize. But this blog is special because when I go to the first blog, it shows the post. When I click home, it goes home. When I go to the second blog, it goes to the second blog. This data, this heading, and this paragraph is generated or it's stored in a remote database. I'm using a API-based headless CMS called Sanity. And Sanity, I only chose it just as demonstration purposes. I wanted something that's completely remotely hosted. It could be anything. I just went with this for the demo. Let's go to examples, sanity. So sanity is something you check into your repository as a dashboard but the actual data is remotely hosted So I run this server as well just to show you where the data lives all right it right here copy paste oh is that how it's gonna be okay so sanity requires you to log in using Google or GitHub. I'll just log into my other browser tab and then I'll bring it back. Okay, here's what Sanity looks like running locally. I have content here, post, author category. Under post, I have my two blog posts. This is the first blog and it takes a while to load because it's actually fetching it remotely. Even the dashboard runs locally with Vite, the data is hosted remotely. The title is first blog, the slug is first blog, and the body is this is my first post. Will there be another? And you saw that earlier here. The title is first blog, the slug is first hyphen blog, and the content is this is my first post. Let's go over and break down how I got this to render. and more importantly, how do you ship this? How do you ship a static generated site with remote data? So under my example site, under routes, we have blog and then we have post. But on the homepage, we have this page.svelte. Here it is. And it uses export-lit data to cycle through each blog post. So in the companion page.server.js, we have a load. And the load does a remote fetch. So on line eight, we do await fetch endpoint, and then I do the special syntax for Sanity's querying API. I just gather all the posts here. This fetch will look different depending on which API-based CMS you use. So don't worry too much about that detail. The fact is you're fetching it in the server.js file. and then you're collating the data and returning it. So it's not a lot of code here. Like you can ignore this because it's just development console logs. Like here I'm console logging the actual fetch content just to make sure it's working. What happens is when you run npm run build or pnpm run build, it's going to,

 to hit this page because this is a route. This home route is in routes, page.svelte. So if I close the server and run pnpm run build, it's building the static site. You can see in action, it's building the JS, the HTML, the CSS. I don't have CSS. Don't worry about it. And it's done. And in the build folder, we have index.html. It actually made the homepage. And there you go. Static HTML with a hyperlink to the first blog post. And under the blog directory, we have firstblog.html. There it is, h2, firstblog, paragraph, this is my first post. This is static HTML. Second blog, same story. We have the second blog and the paragraph. Because SvelteKit, when it builds, it crawls all the hyperlinks. So the hyperlinks get generated from this page. SvelteKit follows slash blog slash slug. It goes to that dynamic route under blog post. This is a dynamic route. And then it calls the respective server.js file to load the endpoint. So these dynamic routes have an endpoint to fetch the individual blog posts, which SvelteKit also traverses. JB asks, is there any JS file under underscore app? Underscore app, where is that? You mean here? Because I'm using the static adapter, you won't see it here per se. I'll show you my Svelte config. There's really nothing special about it. See? So in my Svelte config, I'm using adapter static. It is possible to configure the crawler to pre-render particular routes. I did not have to do that because the homepage route generates hyperlinks and those hyperlinks get crawled automatically. So this is a zero config static website using a remote CMS. It works out because the homepage iterates through each blog post and generates hyperlinks. Those hyperlinks get traversed during build time. And that why it works with zero config or close to zero config I did have to add a layout with const prerender equals true but that only necessary for adapter static Topics asks in the past I encountered a problem with TypeScript When I specify data as page data that I cannot access inner objects I returned from the server. That's generally true with fetches. So yes, when I fetch this endpoint data, you need to type the response in order to get these auto-completions. I did not do that for this demo, but it is possible. Maybe Sanity has a type assistant that can make this a bit more viable. Otherwise, I can type it manually and put a declarations file somewhere as well. JB asks if I want to generate a bunch of static pages so I can have a placeholder page with all kinds of anchor links. Or I can specify those routes in the adapter. Yes, so you can go with either one. as long as you have links to pages that are traversed in non-dynamic routes, it will work. So the home route is not dynamic, which means Svelkit automatically traverses this. But because post is dynamic, Svelkit won't automatically traverse that unless it reaches that dynamic route from a hyperlink like this one. So because this hyperlink does navigate to blog slash some kind of route. Only then will SvelteKit travel through there. If it doesn't, you have to tell it to. So you have to go to SvelteConfig.js. You have to go to your kit config and go to add a new setting for pre-render and entries. And then here, I believe it's an array of strings. So you can tell it which paths to traverse during the pre-render phase, during build time. You can say, hey, please go to this dynamic route. Please go here. That's especially useful for multilingual. If you have a dynamic path for English, French, German, whatever, this is where you specify that if you don't have hyperlinks. But if you do, you can get away with close to zero config like I did. Either way, there's an option for you. So that's the demo of a dynamically generated static site, which looks like this. This is static HTML. I can put it on GitHub pages or any static host I want, which is really great. So you can have a remote CMS, you can collaborate as a team, but then you can also ship this wonderful static site with very low server costs That one of the benefits of using Svelkit to generate your pages And it just works So that the advantage of pre stuff However, I have more stuff to share. So sometimes in Svelkit, you get page cannot be pre-rendered. There's a particular warning you may come across when pre-rendering. I will show you the official docs for that. So it's under here. So this is the page options document on SvelteKit under core concepts. Here it tells you how to pre-render your site, but sometimes you need to troubleshoot it. So there is a troubleshooting section here. Sometimes you'll get an error that says the following routes were marked as pre-renderable, but were not pre-rendered. And here's a very succinct explanation why, but the important thing to note is some things cannot be pre-rendered, such as form actions. Form actions require server-side logic, so if I were to add a form action and try to pre-render that route, it will not pre-render. And sometimes, if you have conditional display logic, it will also not pre-render. Let's see if I can reproduce such an error. So here's my blog. It works. and it's pre-rendered. If I go to my homepage and add some dynamic content, like if data.questionmark person, this is really contrived, person is here, and then close that, what'll happen? So I have a type error, which is good because data does not export the person property. Pnpm dev. All right. So dev mode usually works without complaining. Let's refresh. Yeah, it's not showing the person, rightfully so. I could add an else statement. no person let's go to the home page there it says no person if i try to build this now let's see what happens pnpm built i hope there an error at least that my understanding oh it worked okay i suppose it worked because it runs through the loader once and depending on how that happens this will render There are some scenarios where if you have conditional logic where the if expression doesn't totally resolve as true or false, you might get a pre-render error because the rule about pre-rendering is all visitors who come to a page must see the exact same content. If something is conditionally changed during build time, it is not a candidate for pre-rendering. This example failed probably because this can only resolve as one outcome. That's probably why it's okay. Usually another example is like if production, like if you're on production, only render this. If you're in development, only render that. This is also pre-renderable. Some things are not pre-renderable depending on how complex the expression is, but I failed to illustrate that. All right, so we're almost at time. Let's see if I can cover any last words. Beat, multi-page. Yeah, that's about it. I also have a pre-rendered route here called a gallery, so I want to show that off. So back to the page, I have a gallery. Ooh, it's very broken. so the gallery has a home page and it supposedly oh yeah because the servers are running here's the gallery there we go so i have a gallery of two images if i click on this felt icon it goes to a page called slash gallery slash favicon and if i go back and click the javascript logo it goes to slash gallery slash javascript This is a generated gallery using dynamic routes and static site building. What it does is if you go to gallery, page.server.js, it will load. Sorry, this is the image route. If I go to the gallery homepage, in the gallery homepage, we have an array of images. And in this file, we're using the Node.js file system module. The file system will read the static folder. So in my static folder, I have two PNG files. File system will read the two PNG files and generate a list of links on the gallery homepage through this each loop. That's cool. And under the image dynamic route, it'll take the parameter and return that image so that

 on the image page, we can say image source forward slash data.image. And that is why this is pre-renderable. So this is a gallery that's dynamically generated at build time using static files locally on your system using the file system module. So now I showcased file system module. I showcased remote API-based CMS and Kohei showed a local Git-based CMS. Git-based meaning you can have your content checked into your repository, and as content changes, your site generates locally. These are all great ways to manage the content of your site and generate them dynamically. And that's the end of our show. Thank you so much for listening. I will send... Leave your feedback. I'll send you a feedback form, and have a great day.