 Hello, everybody. Welcome to This Week in Svelte. My name is Enrico. I am your host for today, and we're here to have some fun together, have a nice casual Friday, talk about what happened in Svelte this past week, but also what discussions were had in the Svelte Discord. This is a full audience participation event, so you can talk to me in text chat on Discord or voice chat as well. Feel free to raise your hand at any point during the meetup, and you're welcome to speak on stage with me. With that said, let's get into it. This week, there are a lot of updates. So the agenda for today is the change log, which we actually have a large amount of changes in both Svelte and SvelteKit to discuss. We'll go over some quick facts, and then we'll have a community showcase, which I'll introduce our guest speaker to later, followed by this week in discussions and this week in Q&A. And although I curate the topics for this meetup, everyone who participates is welcome to provide me some suggestions. If there's something you would like to share at this meetup or something you'd like me to cover at this meetup, let me know. Talk in the chat. Give me a direct message, whatever you're comfortable with. I will also share an anonymous feedback survey at the end of this meetup. So let's get to it, starting with the change log. And this time, I'm going to go a little bit deeper than usual. So let's get to it. In the change log, we have Svelte 3.56.0. And as you can see here, there are a lot of new features, almost too many to go over. But I will highlight some of the things that stood out to me, and I'll give some live demonstrations of some of these new changes. So let's get started. The first one is new accessibility warnings that I will just cover first, such as aria-active-descendant-has-tab-index. So this is great to make sure that if something has the proper tab index set up, that it'll warn you otherwise if it isn't. So a little reminder, let's say you have a button. And by default, almost all interactive HTML elements have a tab index of one, an implicit tab index of one. You don't have to explicitly add these. They're all given to you for free. But you could do something like set a tab index of minus 1 Minus 1 indicates that it focusable with JavaScript but it not focusable with the keyboard And there are some scenarios where that favorable You can also do zero I believe zero means not focusable whatsoever. And then you can also do two, three, four, five, six to change the order, but I recommend you don't do that. Either way, whichever tabbed nix you do, Svelte will now more intelligently warn you that you're doing the appropriate one given the context. Another one is role supports ARIA props. This one's an interesting one. If you're like me and you use some component libraries, you may have noticed upgrading to this version will suddenly give you this warning. That's because if you have something like a list item and you give it a ARIA disabled, I know this sounds really strange, but if you do ARIA disabled on a list item, this new warning will pop up and say, hey, you're not supposed to do that because this list item has an implied role of list item. Even if you don't explicitly give it this role, this is the implied role. And now Svelte will warn you that, hey, this ARIA disabled prop is not appropriate for the implied role of list item. Pretty cool. So now it'll watch out for the nice role to ARIA attribute relationships. Next we have stop immediate propagation. So this is a new event modifier to make life a little easier. As you know, we have events. So if you do button on click, for example, on click is an event handler. Right now it's forwarding events in this demonstration. But if I do like a handler, then this is good too, because after the user clicks on the button, the handler gets executed. You can also do pipe events, such as this new one, stop immediate propagation. This is just shorthand for event.stop immediate propagation. So now it's felt you can do this with the pipe, but the old way would be you do onclick, you add your handler, and then in your handler, you would have to set up your event to do something like e.stop event stop immediate propagation. Well, rather than type it on notepad, why don't we bring up a demonstration? Let's go. So here's a demonstration. Okay Don worry about the warning I put that there on purpose So in this demonstration we have on line 16 we have a label and we have an input So we don't want to call other event handlers, so we use stop immediate propagation to do this. So for example, if I go to the input label and it's focused, then it'll call this console log. So right now it says focused. So when I click on the label again, the console will print out focused. That is because I have two focus handlers, one here and another one here. Svelte allows you to set up multiple handlers. And the order matters. So in this input, I define the first on focus to call handle focus, and then the second on focus to handle the do thing function. You'll notice that do thing prints to the console, and it's supposed to say do thing, but the console did not print. That is thanks to stop immediate propagation. If I remove this pipe handler and focus on the input, it says focused as well as do thing. So both events fired as it should, and they fire from left to right. The first focus handler gets called, followed directly by the second one. But if I stop immediate propagation, the pipe should go after focus. There we go. Only the first one gets called, the event does not propagate, and then the follow-up event does not occur. That is one thing you can do with this shorthand. The next demonstration is the accessibility warning for implied role. So as mentioned in my notepad, I have ARIA disabled, and the implied role is list item. That's why down here, the yellow warning says it's not supported. So if I delete this ARIA disabled, the warning goes away, the compiler is happy, and the compiler just increased our Accessibility Lighthouse score to 100 and other goodies like that, and people are very happy. And that's the demo, but we have more stuff to talk about. There a read utility for writable stores down here What does this mean It means you can set up a writable store in Svelte in this version but you can also make a writable store become readable with this new utility So if I go to writable stores, I'm not sure how experienced I am with writable stores, but you import writable, you create a store like this. So here it's setting count to a writable store with the initial value of zero. And that you can rewrite to this. You can subscribe to it using dollar sign notation. You can change it. You can call dot set. Here's dot set. You're setting it to one. But the newest feature is about making it readable, which I think is down here. So this is the new read-only function. By passing it a writable store to read-only, you can have a, I guess it's a derived store. Correct me if I'm wrong, chat. Here in the example, we're setting a writable store to the value of one, and then the readable store to a read-only version of that writable store. Maybe you need this for your various applications, but it's there for you now in version 356.0. there's also new stuff like yeah it's a reference to writable but read only so you can still subscribe to it with dot subscribe you can still use dollar sign notation and your application will react to changes but you cannot write to the read only variant of the writable store so that's a answer to blixen in the chat i should read your chat out loud apologies So next is natural width and natural height can be bindable. Let's see if I can demo that really fast. If I do div, let's try bind natural width. There we go. And I have to bind this to a variable, so I'll call it let width, and I'll bind it here. It's not a derived store. Only with image. Okay, in the chat, Patrick wrote, it's not a derived store, it just returns a subscribe method of the writable. Thank you for clarifying, Patrick. So yes, the read-only helper is, it's not a derived store because derived stores are different. They're their own thing.

 But it is a read-only store that is reactive, as far as I can tell. You can subscribe to it all the same, using dollar sign notation or the explicit dot subscribe. So natural width can only be combined to image. I knew that. So image, give it an alt, just for now. And so now we should have a width. And I can probably react to this, console.log width. and it has a width of zero. Cool. That is bindable. I don't have an image to demonstrate with, but it's correctly showing zero. The next change log feature. There are so many features. There are some new data attributes. We have SvelteKit replace state and SvelteKit keep focus. So these are now typed, which means if you're using the Svelte VS Code extension, you will get autocomplete for these things. And I'll actually showcase this later in the meetup. I have a SvelteKit demonstration for forms. So stay tuned if you want to see progressively enhanced array attributes and forms. So many features. All right, we're going to do a speed round. Compute node dimensions immediately before crossfading. So there's a few bug fixes in here. And if you're using Svelte transitions, I think in previous versions, When something appeared on the page, depending on the dimensions of the node, it would jump in or pop in very awkwardly or very jarringly. But in this new version, things are calculated before crossfading, so things like that should be smoother. Infinite invalidation loop and Svelte component. Other bug fixes and edge cases were patched, so that's good to see. We have you combined to offset height and it will update initially. Very good. global selectors are validated so i think if you write illegal css statements i couldn't reproduce this but this looks like if you use global then it should be a little harder to write impossible css selectors and you'll get proper validations no refer is less zealous i think previous versions of svelte would would notice whether or not you're using no refer and say okay you must also use it in other ways. Now it's like, okay, we're less opinionated about that. You use no refer the way you intend to. Some erroneous accessibility warnings are now gone on things such as video ARIA hidden Because yeah that legal You should be able to ARIA hide a video without the compiler screaming too loud. Check value equality for input type search and input type URL. OK. Okay. Do not select disabled option by default when the initial bound value is undefined. Handle add HTML tags inside template tags. I think template is used for web components. So now if you have add HTML and you're building a Svelte component into a web component, this should be possible now. So that's cool. Ensure after update is not called after on destroy. that makes sense because when you call on destroy that should be the finality of your component so this should be suppressed improve handling of inert attribute i don't know what improve handling means but i'm happy to see inert get some treatment inert is cool because you can do something like set any htmo element to inert this is a global attribute and if i do li inert hello then i cannot click on this. I can click on this label, I can highlight it, but now this list item is inert. If I delete the inert attribute, I can now select this. So why is this useful? Setting something to inert makes them completely unusable to assistive technology, which you might want to do by design. The best example is a modal. If you want a modal to pop up, you want that modal to be in the global scope of your HTML. Let's say, for example, div. Let's pretend this div is a modal. When the modal is open, you'll want to programmatically set the rest of your page to inert. So this should be inert. Everything should be inert. Obviously not this complicatedness. Something like main, you'd have a main element. I can just learn to spell. and then all your content would go inside the main. And then your div would be just outside of that. So your main could be inert. All of its children would therefore be inert. And your modal would be active. When your modal is closed, you remove the inert attribute and the rest of your page is active. This is useful because with screen readers and with keyboard navigation, you don want to escape the modal easily You want to be able to focus on the modal stay in the modal and this is one attribute that lets you achieve that So not particular to the change log but I thought I'd showcase what a nerd does. It's really useful. Reduce use of template literals and server-side rendering output for better performance. Okay, cool. I noticed that a bunch of attempts were made in this change release to make Svelte Svelteier, shipping less JavaScript when compiling, trying to determine if a Svelte component, depending on what's being assigned, deserves to have things like the Svelte invalidate function. I'm talking about this thing here. Most Svelte components come with this if you have any assignments. Here, invalidate. And unfortunately, version 3.56 had a regression, but don't worry because it was patched in the next version, also released this week. The regression is somewhere down here, but don't worry, it's patched. Fixed race condition. Allow assignable property to a const when destructuring. Okay, assigning to a property of a const. I'm curious what that is. I see. Okay, so this should be possible now. I guess that was a JavaScript feature that was missing, but is now back. Match browser behavior for decoding malformed HTML entities. I guess some malformed entities weren't being rendered correctly, so that's been adjusted. CSP compatibility. Sorry, I don't know what that is. Maybe some of the chat can translate. Optimize felt element output code for static tag and static attribute. Don't throw. how's the chat doing? Okay. Clear inputs when bind group value is set to undefined. So now bind group. If you set multiple check boxes or multiple radio boxes with bind group, setting them to undefined should clear all of the respective inputs now. So that's handy. You can set a single bindable element to undefined and all of your check boxes and radio buttons will be cleared, fix handling of nested arrays with keydeach containing non-keydeach. OK, so now you can have nested each loops. And utilizing keys should be more efficient or sorry more reliable And that brings us to the next version of Svelte 3 Where was that? Yeah, the buggy reactive statement optimization. I noticed this past week some folks upgraded to 3.56 and noticed some things were broken. But this specific thing here that I'm highlighting patches that. They reverted the experimental change. It was an attempt to make Svelte more efficient by removing some code when a string literal was assigned. So for example, if I do let thing equals static string, I believe the change was to not make this reactive. But because it's a let assignment, it's always reassignable. Maybe if it were const thing equals static string, then it should not need to be reactive. So yeah, there's some complexities there with the compiler trying to help ship less JavaScript code if it detects things are not going to be reactive. So for now, that is not going to happen, but more will be looked into there, especially in Svelte version 4. Svelte document is a new element. So if you wish to target Svelte document, you can now. And why would you? I'll tell you why. because of one particularly useful feature, visibility change. So if you wish to target visibility change on document, now you can with Svelte document coming to a Svelte near you. Accessibility warning, no interactive element to interactive role. I love me some warnings. Give me all the warnings. Stop intro transition from triggering incorrectly. this relates to, well, this sounds related to the other improvements to transitions. So it's nice to see that things like dimensions and race conditions are being handled better and better. So you can see more reliable transitions. Support a computed and literal properties when destructuring objects in the template. Let's see that. When I destructure an array, OK, so it's destructuring within an each loop. But now this should be possible. I did something similar to this, but I didn't do destructuring. In an each loop, let's show you a demo. Thank you.

 Garim from chat. Yeah, it sounds like some things are being patched. But now that we're seeing more regular releases of Svelte, I am confident that'll be handled. Maybe you can link to the GitHub issue. So let's talk about this each loop. When you write in each loop, it's possible to set initial values, which is something I enjoy doing. so if I do each I can say pets and I can have an array of pets up here I don't recommend you do it this way but you'll see what I mean let pets is undefined so I can do pets as pet and I can do p i let pet and the result of that is it only iterates over array like objects This breaks. I expected it to break, but you can also do something crazy like that. So now I can do pets, and if pets is undefined, I can do this array. Or if you want to be fancy, you can do nullish coalescing. And if pets is defined, or if it's truthy, then we can loop over it. If it's not defined, we will pass in an empty array so that at least it doesn't break and you have absolutely nothing. Because the array is empty, this paragraph will not render. But this is not directly related to the changelog feature. Over here, this is about destructuring. So here the person passes in an array of items, and after the as call, you can destructure it. This is now possible. Pretty nifty. style directive precedence over style attribute cool you can mix and match style colon with style equals and whatever's in style colon will have priority and that's that's really useful it's uh i do recommend using style colon and class colon because this will give you two benefits one you can conditionally render styles on server-side rendering and the second advantage is you have better IntelliSense, and the Svelte compiler will be more aware of your class usage. What I mean by that is you can have a variable of classes, like let classes equals button pink and then down here you can have a button with class equals classes pink button So this is not good And if I do style, I can say dot button, padding, one rim, 0.5 rim. There's the button. It works. The classes do render. and for some reason I'm not getting warnings. Maybe I'm misremembering, but the good news is the class is being recognized even though it's defined way up here in JavaScript. This is less reliable than if I were to use the class colon feature. So if I do class, I can do class equals button. Oh no, the Chinese keyboard. Sorry about that, button. And then I do class colon button pink. equals true. This is cool because button pink is now recognized and you get good IntelliSense. Maybe you're not in this felt repo, but on VS Code or your various IDE of choice, this will give you proper IntelliSense and a warning probably here in the style tag. It'll say, hey, button pink is called here, but it's not defined here. Or the other way around, if I don't use button pink, it'll say, hey, button pink is defined down here in style, but it's not being used anywhere. So that's the benefit. All right, almost done. Account for bind group members being spread across multiple control flow blocks. Sounds good. More patches, more tasty. Revert buggy reactive statement, and we went over that already. So there you go. That's the Svelte changelog. I recommend going up to 357 to get this regression patch. And then we can move on to SvelteKit changes way over here. Let's press the letter T, go to kit changelog, and we made it. SvelteKit 1.12. Minor changes. In the chat, Brittany wrote, the class feature is actually something I've been waiting on. Which class feature? give us a little snippet So the feature for SvelteKit 1 is expose submitter in use enhance submit function Submitter this sounds like something Kareem opened in the GitHub issue Thank you for that Kareem So now if you use use enhance you can access the submitter So if a button in your form submits the form, you can now access that button element and its HTML node via the submitter prop. Next is data Svelkit keep focus and data Svelkit replace date are available. What does that do? You also need Svelte 3.56 for type checking. Okay. Duly noted. Keep focus means when you click on a link and it navigates, after navigation, the link remained focused. And for this feature, replace date, this is about history. So if JavaScript is enabled and you do client-side navigation, Replace date allows you to click on a link, navigate to a page, but it doesn't push states to your history, which means when you press the browser back button, you don't go back to the previous page. You go back to the previous, previous page because the state was replaced at the top of the history stack. This is useful for things like tabular navigation. Let's say you're on GitHub, which I am, and you go to a pull request like this random one. Let's say I want to click on files changed. I do that. It's a tab and the URL changes. If I click the browser back button, it correctly goes to conversation. But if for some reason you don't want to do that, let's say you want to click on files changed and you want to click back, and the back button should go to pull requests instead. This is about maintaining history. So I believe with this new change, replace date, that should achieve that goal. And so back to the chat, Brittany wrote classes defined in JavaScript. So if I understand you correctly, it would be lovely, I guess, if you can define classes in JavaScript and the Svelte compiler somehow recognizes that. Yeah, I think someone on Discord earlier today wrote to Kev, we can all dream big, right? And we're all dreamers here. So let's do it. Let's get it going. Let's make some pull requests. And that is it. We have patches. Don't start debugger in 404s. Handle source set attributes. So I believe that source set is an image attribute which wasn working correctly with comma values but now it should Allow tsconfig to extend multiple configs This is awesome if you using a model repository and you have multiple TypeScript configs in multiple folders Now your SvelteKit tsconfig can extend both the generated tsconfig as well as your other various model repo tsconfigs. I suppose that's one use case for it, but let me know in the chat if you have a use case for this. Update Undici to 5.21. I haven't looked at the changelog for Undici, but it's always good to stay up to date and renovate your dependencies because you don't want to be caught with vulnerabilities or broken regressions. So thank you for upgrading Undici. If you adopt Svelkit 1.12, you also get newest Undici. Undici is the node side fetch utility. And that's it for the changelog. Let me know in the chat if you have any questions about this, and we'll move on to the next topic. So Dominic wrote in the chat, that's the best use case for it. Previously, you had to do gymnastics for extending other TS configs from the generated config. No more with TS5. Okay, so this is a TypeScript 5.0 feature. I wasn't aware. TypeScript 5.0 released recently. So if you're all updating to that, then that, I suppose, enables the multiple TS config extensions. So that's pretty nifty. Okay, where is my agenda? Moving on to quick facts. Ooh, it's been half an hour of changelog facts. And now I present to you even more facts. I'm actually going to breeze through this one. So we're going to make this a quick one. I'm going to do reactive destructuring. So here is a REPL submitted by... Hang on. Okay, here's a REPL. This was submitted to me by Mohamed Kaizen. Thank you for that. Are they with us today? Not sure. Oh, yeah, they're there. Oh, hello, Mohamed. So thank you for sending me this REPL. And in here, we're demonstrating the usefulness of destructuring reactive props. So here we have a store counter, and we can set the interval to every one second or other seconds.

 In example 1.svelte, we have options here set to an object. And then when you do destructuring on line 8, here we're taking this function which returns an object and we're destructuring counter and show. But this only runs once. Doing it like this will not make your props reactive. So if you are subscribing or utilizing counter and show, like down here, for example, well, the counter is a store. So that's going to be reactive. But generally speaking, destructuring variables, if they're just static variables, they won't be reactive. Whereas doing something like this is reactive. You use a dollar sign for the labeled syntax. you have to wrap the entire statement in a set of parentheses, and then you do your destructuring of counter and show. This will be reactive, but I feel like I'm solving a puzzle. But this function is not working. So show is not executable because it's not a defined function. Very interesting use of optional chaining. I haven't seen that too often. But then in example three, it looks like we take it back home, and we have the same destructuring statement, dollar sign label statement, set of parentheses and destructuring. Both counter and show should be reactive and this works after adding reactive declarations to the function. Okay, so I guess my awesome function is doing something there. So the thing to highlight here really is this is the proper way to do reactive statements And by the way, anyone is welcome to join me on the stage in voice chat if you wish, or text in the chat if you'd like to. So thank you, Mohamed, for sending this quick fact. The fact is, if you do destructuring, do remember the parentheses and the dollar sign, because this will make sure your destructured variables are reactive. So if these things change, then so will the rest of your consumption of that. If you using SvelteKit and you have something like export data then your option is to use this destructuring syntax for data or to call data attributes directly which I prefer to do For example data or data Oh yeah thank you Mohamed I forgot to look at the console Okay. So in the console it says this will update every two seconds. And where does that render? Here it is. So the show function will print to the console. And in my main application, I suppose here I would have to uncomment the other examples. So that's the default example. This is the example with reactive declarations. The console is empty, though. But if I do reactive declarations and reactive declarations function, the console says this updates every two seconds. because I'm playing a game of this and that. What's the difference? Okay, so since show is being called as is, it's not working, but here we're using the label statement. Now if I update the interval to 1, the console log prints again because show is being called reactively. and update it to 3, it says 3. And if I use the previous example, update this to 3, nothing happens because it's not reactive. Wow, very advanced example. Thank you again, Mohamed, and I'll share this in the chat. Reactive destructuring. And there you go. That was a quick fact. Now let's move on to the next topic. I think I closed my slideshow. There we go. Okay, and now for the moment that a bunch of you have been waiting for. It's the community showcase for today's Friday. And onto the stage, I will invite a special guest, Clancy. Clancy is going to talk to us about their Svelte project called Miyagi. So Clancy whenever you ready raise your hand and join the stage with me Hello there. Hello and welcome. How about you give us an introduction of who you are and what you made? Yeah, thanks for having me. My name is Christian and I'm a part of a team with two developers, one UX designer and one agile coach, which is me. And we develop a fast and easy to use Scrum tool called Miyagi using SvelteKit and Superbase. And yeah, Superbase provides us with scalable servers, a PostgreSQL database and with autification. so you can use a Miyagi account or a GitHub account or in future many other accounts for login. Cool. Do you have a live demonstration for us today? Yeah, I can show you something. Whenever you're ready, you can share your screen and I'll give you the signal. Okay. So if you can see it right now, when you visit miyagi.digital, you will be greeted with one of Mr. Miyagi's most iconic quotes before logging in. Like Mr. Miyagi, we too believe that big power comes with less motion. So we try to build Miyagi in a way that you can set up a new product backlog within some seconds, like example for here. So when you log in, you will get to the product backlog settings page. Then you can set up a new product. And then you can basically start already. You can add some stories to your backlog, and you can create sprints. Like here, you can create a new sprint just by drag and drop. I can also show you an example with some more stuff in it so here we have like our current sprint up top then we have one planned sprint and let's add another planned sprint so now we have two sprints here we can configure it so we can set a goal or how long the duration will be and we can also use drag and drop to prioritize these stories within the sprints or send it to another sprint and yeah we have like three views three perspectives like this is the backlog view then we have the sprint view for your daily stand up meeting for example we have here basically the stories and within the stories we have tasks and the tasks you can claim just also per drag and drop it will automatically be assigned to your user but you can also assign it to other users if you want to you can add some text And on the last page, we have some analytics. So you can basically see what is the performance of my team, what was in to-do, in progress, and done. And you can also change from story points, metrics, to task count. Yeah, and this is basically my Miyagi for now. We are planning to add some more features in the future, but this will be the MVP. It's currently free so everyone is welcomed to try it out to test it. You can always push the feedback button and add some feedback that will be very nice for us to make progress with Miyagi and if there are any questions I'm happy to answer. Otherwise you can contact me also via Discord. Very cool. Thank you, Clancy, for demoing. Everybody give Clancy a hand. I'm sure there are at least six emojis that have a hand in them. So drop a hand. I have a question for you. Which SvelteKit feature did you use the most in this project? Since I'm not the technician, I can't answer the exact thing. but what we find very attractive is the real-time updates. So if I change here something, it will be immediately updated to any other task board, unlike other programs like Jira or something that have a delay in it. So that's very cool, I think. Okay.

 Very nice. Thank you for sharing. So if you can, please add a link to Miyagi in the chat so that everyone can have a look. And thank you for demonstrating. If anyone has any further questions for Clancy, feel free to drop a message in the chat. Thank you again, Clancy. That was our community showcase for today. Next up is this week in discussions. This week in discussions was about TypeScript versus JSDoc. And I'm a very optimistic person when it comes to these things. I don't think there's, I don't subscribe to one over the other. I like to see what is useful for my needs. And I can see how one option is useful for other people's needs. So the general idea here is TypeScript and JSDoc. I don't like to say TypeScript versus. It's just TypeScript and JSDoc. Because both of these tools achieve a lot of similar things. Perhaps together we can draw a Venn diagram. I don't have a Venn diagram software. Maybe I should teach myself Excalodraw for another day. But for now, I'll just say both of these things do type checking. Both of these things do intelligence via the TS server. Both of these things allow you to ship with confidence. And maybe you can think of some other benefits that are common between the two. So for those of you who don't know, maybe some of you learned TypeScript before JSDoc or vice versa. I can give a rundown later today, or even now. I'm going to demonstrate this SvelteKit application I'm currently working on just for you. So here I am using JSDoc and I'm using the Svelte extension. And the key thing about JSDoc is it's JavaScript, not TypeScript, but it allows you to do things like this on line one. So on line one, I define the type using the JSDoc at type syntax. and between TypeScript and JavaScript you can do both of these things this is defined as actions and I believe with the latest Svelte extension in VS Code you don't have to type your backend functions anymore especially the loader I think it's automatically typed and to prove that if I go to page and I hover my form it knows it knows that it action data and that a Svelte extension feature I could explicitly type this with TypeScript or JS doc It achieves the same goal. Add type, import, and then I do types.action data. It's dollar sign types. There we go. And I hover the form. It also knows it's action data. So you get the same benefits of TypeScript with JSDoc. You do the type checking. You've got the IntelliSense. So if I do form.something, there you go. It autocompletes items, pets, success. These are things I have defined in my form action. So for example, return items, return pets. Because it's in the return statement, IntelliSense has me covered. form.pets is autocompleted, and the pets has its type defined down here. So if you choose JSDoc, you have all those benefits as well. But there are differences, and I'm sure some of you are probably screaming at me because you know the difference, and I will repeat them back to you. The differences are TypeScript uses a compiler. And when it uses a compiler, it can do more powerful things ahead of build time. Alexander writes, totally unrelated, but what's that search bar located atop of VS Code? I don't know. And I'm scared to click on it, but I think this looks like a global search toolbar. I think the newest VS Code has this toggled on for me. Maybe other VS Code installations has this toggled off. I am not too sure. Hello, JBJB. So TypeScript, if you use TypeScript, it is a compiler, which means if you make a mistake and your tsconfig is set up in a strict manner, my tsconfig is default. But if you add strictness to your tsconfig or jsconfig, then you can have the compiler totally fail and prevent you from shipping on code that is not type safe. So some people like that benefit, especially if they're on a large team, because they want their teammates to make pull requests that fail in CI. Because the continuous integration will say hey TypeScript failed to build because you used a bad type and they don want to ship that software So JS doc I believe does not have that benefit but it might actually have that benefit now I did not research this Maybe in TypeScript version 5, you can configure JSDoc with a similar level of strictness. I don't have the answer. Maybe some of the chat does. And that's really it. That's the key difference. So what is your use case or what is your experience with JSDoc? and Dominic writes in the chat, you can use SvelteCheck. That is a very good point. Maybe in my continuous integration, I should start using SvelteCheck. That is also very handy because Svelte itself will not only check if all your Svelte code is correct, it'll also check if the types used in your .Svelte files are correct as well. So yeah, shout out to SvelteCheck. I should use it more often. It also depends on where you are in your team projects. There are some debatable arguments that TypeScript slows you down. And I'm new to TypeScript. I started using it about a year ago. I've been using JavaScript. I've been using a bit of JSDoc. I think SvelteKit really catapulted me into using JSDoc more and more. I don't know if TypeScript allows you to document your elements as optimistically. When I say optimistically, I mean let name. Like I define a name. And JavaScript doesn't care if it's typed or not. It'll happily use any unless I configure tsconfig otherwise. But if I'm in JS doc already, I can start documenting this. I can say name of the person. And then on a new line, I can say at type string in braces. So when I hover name, it's documented. It says name of the person. And it tells me that the type is a string. It also has warnings. So down here in my code, I can say div name div. And if I hover the name, it's documented name of the person and it's typed. I'm not sure if I were to use TypeScript, would I be able to document this without JS doc? So what I do in my personal projects or my work projects is I tend to document the important stuff. I don't document every little variable. I just document the ones that matter the most for the page. Obscure in the chat asks, does using TypeScript eliminate the need for JS doc? I'm not sure. I think the key difference is JS doc allows you to document JS doc is for documentation I don think TypeScript has a documentation feature I think you need to use JS doc to write notes like this one But I think the TypeScript documentation themselves also cover JS doc. I'll show you. TypeScript. So if we go to TypeScript, typescriptlang.org, You go to the docs, there's a section for JSDoc reference. This is because TypeScript is a compiler, TypeScript is a language server, TypeScript is a way to type your JavaScript, and it has full compatibility with JSDoc. Sometimes there's drift, sometimes they'll ship a TypeScript feature before they ship a JSDoc feature, but JSDoc is fully supported. When you especially use these types here to type your functions or type your variables, the TypeScript language server will recognize these things, as I demonstrated. And Kenthropic shared another website. Let's open it. tsdoc.org. Ah, yes. This is what I was looking for. So tsdoc is for documenting TypeScript code. this looks identical to JSDoc but I suppose there are some key differences such as remarks I'm not sure if that's a TSDoc feature or a JSDoc feature but this looks like JSDoc syntax and this gives you I guess a standardized way to document things but I'm not sure if this is a first party tool like within the circle of Microsoft or if this is a community project or some other thing either way I'm glad to see it because documenting your functions and variables is super useful for the use case I've demonstrated here. You're knee-deep in Svelte code, you see a function or you see a variable, you want to hover it and immediately understand it. And if you look here, I don't understand what pet is. But if I hover pets, I also don't know what pets is. Can I document these? Let's see if I can. So pets is defined here. Let's see if I can do this. the pets. And then if I go here, yeah, it's not showing me on hover. It shows me here. It says pet. Click to show two definitions. Interesting. Yeah,

 There's some nuance there with inferred types and also SvelteKit's generated type system. But generally speaking, it's nice to see that functions can be documented and you can see in another file what that function is without having to jump from file to file. I don't really, I don't particularly enjoy opening multiple files at once. I like to have one file open at a time. And being able to see documentation and types just by hovering is very handy. I think a lot of folks enjoy hovered annotations as well. But this takes away the need to jump between files. And since Svelte files are single file components, they all contain JavaScript, CSS, and HTML. That's even fewer files to jump between. So thank you, Svelte. So that's really the key difference. So in conclusion, TypeScript and JSDoc, both are handy. Both are ways of working. And does TypeScript slow you down? I got to address the elephant in the room. Is JSDoc not type safe enough? Maybe. Is TypeScript something that slows you down? Also maybe. Because let's say you're on a large team and you're working on a mature product and you've been iterating on this product for at least a year or two. TypeScript is probably a very good option because you have full team type safety and you get build errors with Svelte check and with the TypeScript compiler. But what if you're at a startup or you're an early stage product development And I'm strictly talking about full stack applications. There's another side to this conversation about library maintenance. So depending on what you're building and how big your team is and how early in development you are, I would argue that JSDoc is a good choice because you have the type safety. You can adopt it on an as needed basis. And you don't have to wrestle with types as often, especially if you're like me and you're not super experienced. So what I'm getting away with is I don't have unit tests yet. I really want to, but at least I can use JSDoc type annotations to ensure that the IO, the input-output of my functions and my variables, are type safe. And as I demonstrated last Friday, type safety does not guarantee stability. That's why unit tests can help, but I won't go too deep into that right now. So there you go. There's pros and cons, and sometimes it's better for a library. Sometimes one option is better for full stack development. And if you have a really powerful laptop that can do things like trpc and really robust TypeScript checks then go for it Dominic in the chat wrote if you use descriptive JSDoc make sure you keep them up to date Misleading outdated JSDoc comments are worse than no comments. Good call out. Ghost writes, if the argument is that JSDoc makes it easier to have type safety, then surely that makes JSDoc less type safe. Yeah, I agree with that statement. So JS doc by default is not strict on what you type because it does have inferred types thanks to the TypeScript server, but it does not encourage you to type everything unlike TypeScript. So TypeScript does give you that added safety as a configurable measure, which is definitely useful for mature products. But yeah, and Ghost, you're pretty much echoing my sentiment as well. I think we both agree that if you're on a team and you're iterating a lot and your product is past the moderate maturity stage, then there's a lot of arguments in favor of TypeScript. And I agree with that sentiment. JB writes, TypeScript makes it easier to write code without typos, especially if you use templates. Maybe it should be called typoscript because it prevents you from writing typos. I agree it does prevent you from writing typos everything is auto-completed you get red squigglies if you spell things wrong and this is a good segue to what's in front of me so I have this project here and I'm just going to delete these irrelevant lines of code and with three minutes left. I will make a quick demonstration. Okay, so let's go to localhost 5173. So this is my this weekend's felt demonstration called progressively enhanced form that can add or remove inputs. Welcome to the dynamic form. How many pets do you have? Zero. One. Two. This is kind of redundant, but the cool thing here is you can write down your pet's name like Richter and you can click add pet name and that adds an input like Tom. And this works without JavaScript. So if I go to my dev tools which is really small it says dev tools for ants Go to disable JavaScript Refresh the page JavaScript is broken That okay Oh dear. Name is not defined. I did this. I did this. Don't worry. We'll delete that. Oh look, it does a strikethrough. Thank you. Text editor. Okay, what's the error now? Okay, it's just recompiling. There we go. JavaScript is disabled. JavaScript, yeah, it's disabled. So if I go to add pet name, the page does a full reload, and the new text input is added. So I can say Steve. I can say Richter. I can add another pet. And hey, look, it remembered Steve. It remembered Richter. And now I can enter a third pet, like Polly. And it's working. I can even click on remove pet. If I remove Richter, it has Steve, it has Polly. What came up a lot in Discord was how do I make a form with arrays? And this is the answer to that. At least this is my answer. How did I achieve this? I achieved it by having an each loop. And I'm using the form element here. So export that form. I'm using the form prop. And when I click on add pet over here, it's using button, form action, add pet. So I'm using SvelteKit form actions. And in the add pet action, I gather form elements. I extract all the items. I configure the pets. So this does add pet, which means I spread all the current pets using the name pet name. And then I add an empty one. And then I return it. I return all the items, including the values already entered in them, and then I repopulate them on the server rendered page. Notice that pet name on line 48 has brackets. This isn't totally necessary because form items.getAll will get all of the elements with a matching name. The brackets is just a convention for Node.js to indicate it's an array. If you're using a special backend handler, such as PHP or some other special handler, then this has special meaning. But I'm using it in this application purely as convention. It doesn't have special meaning per se, but that's how you do it. So you could have an array of values and in your front end you sort of have multiple inputs And this corresponds to an array of values in your backend when you use formdata And it works without JavaScript So here you have a SvelteKit progressively enhanced form with array elements. You can add or remove items. You can retain entered fields when the page reloads, and you can submit it. I will share this repository in the chat. I think it's on GitHub under the etrain slash this week in Svelte. And it's not pushed yet. I will push the feature commit soon. JB asks, what are the names of dynamic input fields? The answer is here, name equals pet name. And I use bracket notation just to indicate it's an array. It doesn't really do anything special. I'm still using the platform. I'm using standard, the form items, API. I'm not using any library that did not install any dependencies. This is all standard Node.js and browser features. Also standard SvelteKit form actions. There are ways to probably improve the developer experience, but I'm happy that I can get away with this with only a handful of lines of code. And I will share the source code once I push the commit. I have to clean this up a bit. On a form submit, is it legal to use multiple same names? It is. So because this is on an each loop, necessarily this name, pet name, will be repeated. But because they're submitted in order and they're serialized, then the order that they're submitted or they appear on the HTML page is the order they are read in the backend, so long as you use get all. What's cool about get all is it returns an array. So when you type in get all pet name, it gives you an array of values that look something like this. Steve Richter. Like that. It's just a plain array. Okay, and that's it for the demo. And I'll wrap it up by reading out loud Dominic's final message. TypeScript JS in TypeScript. Rich talked about it somewhere recently. SvelteKit is built with type checked JavaScript. This allows us to ship SvelteKit without a build step. The npm package literally contains the source directory, and your projects are using that. This pattern has proven to be great for us, and it's the next major Svelte is probably going to follow the approach. You don't need source maps. For Svelte applications, the benefits may be less obvious, but not having to deal with the TypeScript compiler can be a good idea.

 be liberating. So yeah, that's why I called the discussion TypeScript and JavaScript. And I know someone hasn't brought this up yet, but another cool thing you can do in SvelteKit projects is under lib, make a new file, call it types.d.ts. And here you can do full TypeScript. You can do const export interface person. And you can say name string. For example, you can do full TypeScript in this file, and using JS doc, you can use these types. So I can go here, say const person equals nothing, and I can type this. At type import $lib types dot person. See that autocomplete in action? So if I hover person, person's declared, but it's value never used, name is missing. See, I got TypeScript. It's working. So if I define name Rico it happy It not the value is declared but never used but the TypeScript server is happy The red squigglies are gone I got away with JSDoc and TypeScript and that why I called it TypeScript and JSDoc. You can use both. You can go all in on one. You can go all in on the other, or you can combine them. I personally like to combine them, but I think as my team grows, as my project grows, I might start adopting more TypeScript. As Dominic rightfully pointed out, There are certain advantages when doing full stack development versus library development versus compiler or tool development. There are just pros and cons that you have to evaluate on a case-by-case basis. And that's our job as developers, right? What's the annoying but truest answer to all questions? The answer is it depends. And with that said, thank you very much for listening. and please leave feedback. I will share a feedback form in the chat right now. And thank you so much for joining me in this week in Svelte. Have a good day.