 Hello, everybody. It is September 15th, 2023, and you've made it to This Week in Svelte. My name is Enrico, and joining me is Paolo. Hello, everyone. Sorry for last week's absence, but I hope you missed me. And welcome, Karim. Hello, everyone. That's right. And This Week in Svelte likes to summarize things that happened around the Svelte Discord, such as the changelog, quick facts and announcements, community showcase, followed with discussions and questions and answers. Let us begin with the changelog. So we got a release recently of SvelteKit 1.25.0 featuring something exciting, server endpoint catch-all method handler, fallback, and Kareem will give a demo in a couple of minutes. Following that is allow calling fetch for any scheme. And I already forgot what this meant, but the scheme I think refers to... I'm cheating. I read it yesterday. Basically, exactly. You can fetch with data dot endpoints before it was not possible. That's right. So now we're using backend fetch in SvelteKit. You can use any kind of URI object by the looks of it. Yeah, exactly. And this is also like, it's super interesting to me because we often forgot about this kind of URL because they are just used, for example, sometimes when you want to inline something inside an image. But it's actually really fun to play with these kind of things. You can do data, XML, UTF-8, and just write your SVG there. It's quite interesting. Sometimes it's pretty useful. I believe it. I used to write inline SVGs this way. In CSS background image, you can do just an inline SVG URI. Yeah, exactly. Okay, now let's move on to this new SvelteKit feature called the fallback handler. So in server endpoints plus server.js or .ts, let's turn on TypeScript mode. There you go. See, .ts. You can export post, get, but also as per the RFC spec for HTTP methods. you can do practically any method you can dream up And so with the fallback handler you can catch those extra methods Yeah Also this is very interesting for example to use for I don know a proxy handler so that you don't have to define every single function. So if you want, you can just use fallback and then proxy every request to another server. Indeed. So let's move on to Kareem's example karim what do we got for us um yeah so it's just a quick use case i wanted to demonstrate uh because i was the one requesting the feature is this a feature that has existed in astro for quite a while um but in swerkit up until now you couldn't really take over the complete routing like you could create a route with rest parameters or just a single parameter but you could never also take over the method routing. Yeah, so this is very useful to completely take over the routing. And personally, I'm a friend of, I'm not sure if you've seen it, but the Slack API, they mix the design. They mix RESTful design and RPC design. So they create an API that handles both get and post methods. But in order to do this in a single Swaggit handler, we weren't able to. You had to expose several handlers in Swaggit. And yeah, this is just a demo of how you can do the same thing in an API, similar to how Slack does it. So it looks complicated, but it's very easy. So you just take the path name, you split it, and if you go to the next slide, you can see what the functions object actually looks like. So you have a functions object, users inside you have just methods, a function, an API function that you want to create. And inside that, you just define getPost, whatever handlers, and then a request to slash API slash users dot whatever method or something else. It could be yeah just it mirrors your object your functions object That request the path name is then mapped to the function inside the object and it works for every method. Whereas before in SWAT gets, what was it, 1.24? You would have to define server handlers for every method. One. Yeah, I'm not sure if that makes sense. Well, I can follow. Which is a very simple route, essentially. Right. So I have source, routes, API, and then a dynamic path for function, followed with the definition of the server endpoints. If I were to call slash API slash users, what would happen? Users.create, for example. Users.project.create, something like that. So Slack also defines your API. It's very useful, very simple. So in that method, that string is then mapped to your object. But if SwagKit didn't have a farback method, a farback handler, you could only take over get requests or post requests, but never all methods. I see now. Yeah, I mean, you could do it, but probably you have to do a lot more code. Like you have to split for every get request and then find all the get requests inside the filter. Yeah, it's much more cumbersome. And I also think it's very cool, like this style of writing your handlers. It's quite interesting, in my opinion, because it's very... And the motivation behind this is, I think you've probably seen it on Discord, had a few issues, questions about this. Creating APIs in Spark is not so great because if you create a REST API, for example, you have to create a user's directory and then a plus server file. And then you create a user's directory and an ID directory and another plus server file. And this is, it gets quite tedious. So I tend to, if I create an API in Sparkit, have one handler and that handles all the routing. Yeah, until now it was impossible. It was possible in Astro, but now it's also possible in Sparkit because you can take over all HEP methods Yeah it very interesting And again it much more if we want declarative and we crave for declarative things So one last question, Karim. What's the difference between this function, which is in the same file as this function? Oh, so this is supposed to be the same file and I just hit it. so it fits into one slide. So this fallback method, fallback handler, is the same as on the second slide. I see. And how do you get the FN param? I see you're not extracting params from the event request. I am in here. Oh. Oh, let me check. well that's okay i assume that it's implied okay yeah that's fine yeah it's not really necessary here um because you could take the full string but yeah you could you could also use the fn parameter actually uh-oh willow just posted some breaking news so with with that said let's wrap up the example. Thank you so much, Karim, for putting this together. Okay, that was the changelog. Now for some quick facts and announcements. What is in the chat? Let's get the chat up here right now. Everyone hold the phone. I think you don't want to miss this. Let's give everyone a few seconds to just call everyone here because we really don't want to miss this oh wow everybody I can't add everyone that's illegal on the discord but I can just read the headline something magical is coming we've got something to show you is this not too early oh this is official see look Karim wait is it official yeah abort abort ghost what's happening next teaser page for next Wednesday

 So I guess we can abort. Hmm. Hmm. Okay, we'll come back to this. Ghosts, Rilla, please validate what's going on. And in the meantime, we got some quick facts. I might have to delete that from the YouTube recording. I don't know. But one of you can confirm if this is official or not, and I'll put it back on screen. So moving on to quick facts. Comprehensive guide on how to control streaming with promises. This is a blog post by Jeff Rich. I'll post it in the Slack. Sorry, in Discord. This is not Slack. So here's a cool blog post by Jeff Rich. It's about conditionally streaming data in SvelteKit. So as some of you may be aware, SvelteKit comes with streaming with promises. And what Jeff Rich has provided is a set of patterns that you can use to best take advantage of streaming with promises. To skim over the examples, you can, for example, conditionally, you can conditionally await like this. So here, a nested, when you return something from load and it's nested, you can either return a promise, like slow data is a regular promise, or you can await it immediately. So that's one way to decide, hey, I want this to be shown to the user with full SSR, or if it's a slow request, I want to stream it. So that's one technique. Another one further down is promise.race. So for example, if something might take a short amount of time, you can SSR it fully. Or if it takes a long time, you can conditionally pass in the promise and do regular streaming with promises. There's also loading it conditionally if you don't have JavaScript. So there's isDataRequest, which is an available parameter in the load method. IsDataRequest means JS hydration has occurred and enhanced navigation is available to the user. So if it is set to true, you can pass in the promise. If it is set to false, then that implies it's a first-time page request or it's a user that does not have JavaScript. So you can await it server-side. Because of the caveat that streaming with promises requires client-side JS to function. You can check out the rest of the blog. It's pretty nice. Yeah, I think this last bit of information is very important because obviously we should always build progressive and unsaid application. And streaming with Promises while very very cool like it very interesting always had this bit of like like this sketch that if the user does not have JavaScript enabled that request is never fulfilled and so if it's actually some information that it's important for the user it might be worth to like do this kind of thing so that you can get a very fast and very fast and quick load time when you are navigating with javascript and so you know that you have javascript to await that promise. And a much more slow navigation, but that has all the information when you don't, you are not sure if your user has JavaScript or not. Indeed. Moving on to the next quick fact. This is a hat tip to Chromov. Thank you for sharing this article on how to ask for tech support. This is good learnings for all developers. If you ever ask for support online, this is a great concise article to give you some valuable tips on what to do and what not to do. So I'll share that in the chat and you can take a look. The next quick fact is there was a recent Siren Streams hosted by Brittany. Take a look at that. It's now on YouTube featuring Sam from Prismic. So you can catch up with the news. And the next quick fact is another YouTube video from the channel Joy of Code. Thank you, Matija, for this demonstration on how to use JavaScript libraries with Svelte. So if you ever have to use something that relies on browser or window, this will give you some tips and tricks on how to very easily import them in your Svelte files. Yeah, and it also shows one of the strengths of Svelte, because given that it's this easy to use JavaScript libraries inside Svelte, like we already said it a lot of time but virtually like the whole Svelte ecosystem is the whole JavaScript ecosystem indeed so I just got the go ahead from Cirilla we have some breaking news pretend this is the first time you're hearing about it today what's this? on the Svelte blog something magical is coming we got something to show you we think you going to like it Join us on Wednesday September 20th for a glimpse at the future of Svelte Oh and that the entire blog Okay there no scroll bar Well, hopefully we did not reveal much. Yeah, let's look at the URL, though, for some Easter eggs. Svelte.dev slash blog slash runes. Hmm. Hmm. Hmm. Well, that's all there is to say about that. Thank you for joining in on... Thank you for joining my TED Talk. Thank you for quick facts and announcements. Let's move on to a very special guest today for Community Showcase. Come on down, raise your hand, join us on stage. Welcome. Hello. Hey. Nice to see you. Can you give yourself a brief introduction and share what you're going to share today? Yeah, so my name is Nassau. I'm a hobbyist builder, as I saw in recent Hacker News comments. I really like this term. I just like building software in general, and I really like Svelte for this. And recently, I realized Svelte was kind of missing a function, like a Svelte utility function that is really similar to derived but with an extra thing to it and i like to like share uh what i discovered kind of uh and just basically share and let me know what you think i guess sure all right so is it big enough is it readable yes it's very clear all right so here i have a small REPL and basically it's just a sort of like cart thing where I can add items and change the price, change the quantity, and I have a total that's computed here. Now the thing is here I have a little colored box that updates every time a subcomponent gets updated and the idea here is you have the classical store here with that is just a writable with an array of items where each item is an object with a price and a quantity. And the idea here is whenever I change an item I actually changing the entire store that stores all of my items and that causes every single item to redraw and of course it not ideal and there are many ways around that one way is to say kind of sort of cache the values individually so that svelte can can do the diffing on primitives. But I realized what if each item could be its own store instead? What if instead of having an object, I could just have writables and nest the stores this way? And this is something that many people, well, many attempts have been made to do this. But I realized when you do this, you quickly run into a problem. And that problem is whenever you derived state from that store, then you need a way to basically from the derived callback return another store because then you have nested stores and you're going to find another store when you derive the original state, but derived only expects you to return the final value basically. and I realized what if derived actually let you return another store and this is exactly what I built so here I have the exact same example but instead of having a writable with objects I have a writable with other writables inside and then I have this little bound function thing here that is basically doing what I had before, but now from the callback, I can return another store. And here it turns out I'm using derived again, but it could be any store. I could be returning like the first item, for example. And now all my items, instead of having the values derived from the store directly, they instead get their own little store that corresponds to their own little item that they are displaying. And now, because when I change an item, I'm only changing that one store that corresponds to that item, only that one item gets updated. And then the total gets computed, same as before. And this is basically the entire package. And I have it available as svelte-bound-store on NPM.

 So you can grab it if you want. And I realized, it turns out it kind of reminds me of Monad. Because this little bind thing that I have, the bound function, it takes a store. So let's pretend M here is a store. So for those who are not really acquainted with functional programming or Haskell syntax, basically this means I have a function which takes some value here and that takes another value here and then this is the final return value basically. And this is basically the signature of my bound function. So I have this input store which if I go back here would be the original store and then I have this callback and it takes the value that's inside of the store and being the store thing and returns another store for a different value. And this is exactly the same as derived, which is similar to fmap. So here we can recognize sort of, if you squint, you will recognize derived because you have the callback function, which takes a value and returns another value and you have the store. It's just the order is different, but it's virtually the same thing. Derive takes a store, a callback, and returns a readable over the value returned by that callback somewhere. Yeah. And I found this pretty interesting, and this is actually where the name came from, bound, because this function here is typically referred to as monadic bind operator. operator. That's pretty much all I had to say. It's available on GitHub on naso slash svelte bounce store. You can also find it on npm, as I said. There's the link. And I'm pretty sure there's a lot of things you can do with it. It's just another primitive. Svelte has derived, but this is sort of like a more general derived that also allows you to return a store. You could implement derived with this just by returning a readable. So it's just a new thing to play with. And there are many things you can do with it I pretty sure I just did not explore it to its full potential But yeah that pretty much all I have to say Very cool. Thank you for presenting. So we'll take some rounds, maybe ask some questions. Yeah, I have a question. I want to see how it's used. Like, how are you using Total inside your code then? Oh, yeah. So I have this result component, and here I'm just importing total. The same as before with the normal store, where it's just computed using just derived. Here I have result, and I just import it as a store again. It's just a value. Okay, so total is a regular derived store, but your monadic bound store, that's being used in the rendering, right? yeah basically total is the same type in both cases it's uh so if i was in typescript total would be a readable number and it's the same thing bound returns a readable number here it's it's it's just that if i had to rewrite the previous one i can actually make the change here it's really simple um i instead of derived i would have bound and then here i can return a readable and i have an equivalent thing now the only thing is i have to import readable I have to import readable as well yeah and now I have rewrote derived using bound and readable so it's the same thing basically bound returns the same type basically but then to have the same feature where each item only gets updated when it's really updated i don't have to change my store and this is something like i could have the writable here and everything and then we land to this final code and basically whenever you have nested stores you kind of have to do the thing where you return a store from within the sort of derived thing and here it called bound because i just couldn name it derived again so let see if I follow this correctly You have an array of stores right Yeah And this allows you to add multiple array elements to a single writable, but only re-render when one of them updates. Yeah, because I have stores within stores. Oh, wow. This could be an object as well. Yeah. And obviously, I'm seeing that you are exporting also a function to ease the experience of writing to these of stores, right? Yeah, I have add and remove item. I have them in both cases. This is the buttons. They just call those. And they are pretty much unchanged. I think the only difference is in one case, when I add an item, I just add an object. But in the other case, because I work with a deep store, with stores within stores, I have to push a new writable. Because each item will be its own little store. Because in the past, I thought of having an array of stores or an object of stores. but then I got basically let down by the fact that if you have an array or an object of stores you can use basically the magic syntax from Svelte to those stores and that's what's basically like yeah good point so so what I did here because I ran into the this exact problem here So what happens here is when I iterate over my items, here item is a store. So I cannot use it directly. I cannot do this. I cannot do that because Svelte is going to tell me that stores must be declared at the top level of the component. So instead, I just give my component the store. And within the component, I use the syntax. And this is okay for Svelte because now it's at the top level. There is actually a package. I forgot the name of it. There is a package that exports a component that's like, I think it's called subscribe or something, and it lets you subscribe to a store without creating a new component, basically. So maybe this could be useful as well. Yeah it very interesting Wow Any final words Karim Well I played around with this myself too because especially if I had some apps I was working on and they were, like, very big, something like websites, website builders, where you have a very big JSON structure. Yeah. And, yeah, it's not ideal. in Swift. So I've kind of given up on it. But you can do very fancy things with stores. I think the main disadvantage is just you have to either destructure the nested stores or do this component trick. Yeah. And the idea here I had is because for a bigger app, you would have a bigger store with many, many other stores. And the idea is each component could just compute just the state it needs using bound, sort of like derived. And you could just create a store that is only subscribed to the piece of states that are relevant to that component. Because bound will take care of subscribing and unsubscribing from the stores that are actually being returned here. if, for example, you reuse a different store. It will take care of that. So yeah, this, that as well. Very cool. I think the bigger your JSON structure is, the more likely, or the more you want to listen to a specific property inside the store. But yeah, it's not easy, at least currently in SWOT. Well, that was a cool presentation. everybody giving us so a hand. We got hand emojis that clap, that high five. Bring them on screen. Thank you so much for showing me this room within a room, this store within a store. I've seen it all now. Thank you, everyone. Thank you, too. All righty. And with that said, I'm going to bring us back to this week in Svelte. That was Community Showcase. We're bringing to you now this week in discussions. I didn't have one but Paolo inspired me maybe we can discuss briefly the decision making behind

 what should be progressively enhanced, what should work without JavaScript, and what excusably doesn't have to. How does that sound? Yeah, it's very interesting. And I think everything should work without JavaScript. No, I mean, whenever I approach these kind of things, I always try to make as much as possible work without JavaScript because obviously the more you can use without JavaScript and enhance with it, the more the user will be able to use your application in every case. Obviously, there are concerns, like for example, imagine if Figma should work without JavaScript. It could be done, for example. I mean, every time you click, it updates the URL and you move a component and everything is a form or a link. But obviously, this will not work and will not scale well. But I think except for applications like, for example, I don't know, video calls. I think the more you can make work without JavaScript, the better, obviously. Yeah, so I guess the excuse lies in applications. Funny enough, you remind me of Google Maps in the early days. Before you can pan around and move maps around, you would have to click on a north-south-east-west arrow button, and then that would send a server request to re-fetch the page and render the new tiles on the screen. So for a long time, things like mapping services worked without JavaScript. But since they've been enhanced, it's, of course, way more intuitive and faster if you have the right human computer interface devices at your disposal. And nowadays we have touch devices, too. But I guess the line gets less blurry when you isolate what is an application versus what is a traditional remotely hosted website app. this is what we're talking about mainly, because if something runs on board, such as an embedded device, a Android or iOS application, or anything that's generally offline, then you don't have to worry as much about network conditions For example we constantly worry about network conditions in the works without JS world because sometimes JavaScript won load or it fail or there be an error And then you hope that your fallback or your server rendered HTML does everything the user needs, especially in a CRUD, especially in a typical static website. You want things to work without JS as much as possible. But when it's on Android and iOS, everything is pre-downloaded, pre-compiled, and running locally on the machine. So in a WebView container, you can almost 100% trust that everything's going to run, hopefully error-free, and making those work without JS isn't completely necessary. Does that sound agreeable? Yeah, I guess so. It makes total sense. Obviously, there's also the trade-off, because if you are building an application, but in the meantime you want to use the same code base for a website obviously despite the fact that you are shipping an Android application you have to take care of the fact that it should run also without JavaScript Okay, last example for fun What about Discord? Should Discord work without JS? That's probably not possible at least not as interactively. You need WebSockets and everything, and those are JavaScript APIs. Yeah, so we're referring to core functionality. So being able to navigate in channels, forums, and type messages and chat with people, could that basic functionality work with Node.js and should it? Maybe. Possibly. Because it's not always an installed app. It's also a website. You can run Discord on a web browser. Real-time chat. Yeah, no, that won't work. Applications, I think what they usually do is they have a service worker that when you first load the page, it tries to download everything that's necessary to run offline. And after that, you don't really have to worry about it. But simple websites where when you navigate to a new page, they usually request new resources. And, yeah, in that case, it's a different use case. Yeah, it definitely falls more on the side of applications than websites. I mean at the end of the day what I think is that should you spend your like should Discord spend resources to make Discord work offline Probably not so much, but I think if they do, it's better for everyone. I would appreciate being able to use Discord without JavaScript, even if this means that my page has to reload every five seconds to download new messages, even if this means that every time I submit a message, I get a page refresh. And I mean, obviously, it can be announced with JavaScript, because let's be honest, today, most people have JavaScript after a while, because obviously while you are downloading your JavaScript, you don't have JavaScript. But being able to use it, to use something, even if you don't have JavaScript enabled, it's a cool win, in my opinion, when it's doable. Again, should the business decision choose to always spend time and money to make everything work without JavaScript? I don't know. Probably not. But it would be cool. Yeah. Yeah, that sounds agreeable, especially because the primary, well, I don't have data. So this is totally made up statistics. I'm sure Discord is used in the Electron or iOS and Android form and not as commonly used on the web form. But either way, yeah, if something requires JS, the least they can do is load something and then say, hey, you need JavaScript or click to refresh or are you connected? those things, which Karim brought up as PWA service workers. I mean, there's also like, you can set up a meta header that will refresh the page every tot seconds. So it can be done. Yeah, and there's also a WASM. So Naso in the chat brought up WebAssembly. A lot more stuff is going to be possible. I think there was a tool called WASM. I don't know how to spell this, and I hope I spelled it correctly. I actually don't know what this is, but it should theoretically let you run any code anywhere, whether it's via Docker or just a cross-compiled application within a web WASM environment. I don know much about it but it sounds exciting Is that backend code Yeah like I said I not an expert on this topic Should, like, how would you load WASM in the browser if you don't have JavaScript? I guess I don't know anything about WASM. Yeah, maybe you do need JavaScript for that, so forget I said anything. imagine just streaming entire bytecode over the wire and instead of writing it rendering html you got an application somehow in your web browser but one can dream risky but cool i think i mean like java outlets was basically these that's right well fair enough i think we i think we're all like reasonable when it comes to this topic because yes, if something is mostly remote web-based, then yeah, you got to put in some procedures in place for progressive enhancement. That's definitely encouraged. But when it comes to something that's more application-like and largely interactive, especially if it's deployed to native or embedded devices, then it's not needed either at all or not as much. So that's a fair argument. No hot takes anywhere here. So let's move on. to this week in questions and answers. I've got one question and hopefully an answer. The question I'm going to answer today is how do I serialize form data? Speaking of progressive enhancement, so serializing form data in SvelteKit, a lot of you are familiar with form actions. Form actions are great because the developer experience is nice. You get to use traditional HTML forms and you get to progressively enhance them. But sometimes, sometimes you want to make a fetch request to a form action, either because the encoding type is different or something else. And what's funny about that is a few things, which I will now demonstrate. So in my This Week in Svelte repository, I will share source code later. Let's take a look at what I mean. So there is an example with JS forms. So here I have a form. Let me start the server. And this is a very small page.

 Notice it has a form on line 27. I can never zoom in enough. I need to hold myself accountable to zooming in. On line 27, we have a form, and instead of submitting it using form actions, I'm using an onSubmitPreventDefault handler called handleSubmit. In my example, I'm not uploading files. I'm not changing the encoding type of the fetch request, but the handle submit makes a fetch to the current endpoint, which is slash JS form. That's the location of this directory. It makes a post and it sends in the form data manually. What's interesting about receiving the request is it's being encoded using a tool called devalue. I will share that on my screen now. So under the hood, SvelteKit will send majority of its responses using this devalue tool, which is like a more advanced JSON.stringify. And the responses look a little different. I'll show you. localhost 5173 slash JS form Okay so here my favorite pizza form I need to tell the world and let them know what my favorite pizza is which spoiler it all made up I keep the network inspector open because you going to see some stuff My favorite pizza is pineapple. Made up. It's all made up. And in the request list here, we have JS form. And take a look at the response. Let's zoom in some more. So in the response, we have a data key value pair with a stringified response that's serialized. And it's not exactly a JavaScript object. So if I ran JSON.parse on this, it wouldn't be useful. So what I need to do to make use of this is I have to call a built-in method called deserialize. So this is imported from SvelteKit's app forms. and deserialize will take the devalued JSON string and deserialize it for me. That way I can call await response.txt, pass that into deserialize, and then I'll have a parse data object, which looks like this. Pineapple. It looks like this. Success true. In my backend form action, it only a few lines of code The default form action will console log the pizza param from the form data and it will return success true And success true looks like that And it looks good in the client because I ran deserialize. So that's it. So once again, just to recap why you might need this. If you're calling a form action in SvelteKit manually using JavaScript like this, and for reasons such as different encoding type, because I think the default encoding type is, where's my notes? It is multi-part form data. That's the default. If you want to do something like application JSON or some other form encoding type, then this is for you. You'll want to deserialize the response. And that's that. So let's share some links in the chat. We've got... Yeah, just I think like the reason why you need to deserialize is because SvelteKit under the hood is using devalue, which is a wonderful library. Still, like, it's written by Rich Harris. And this basically takes care because when you send things over the wire, obviously a lot of things does not get serialized correctly For example dates for example like devalue is also the library responsible for streaming promises that we get because it's actually the library that is doing the job of serializing a promise, which is something that is not a trivial task. And so I think desrealize actually make use of devalue to deserialize the answer that you get from the value. Yep, that's right. Also, special thank you and hat tip to Patrick. Thank you in the chat for exposing me to this deserialize method that I wasn't aware of until today. So that's in the documentation, app forms deserialize. Let's share some links in the chat. We've got docs and we've got demo code. And there you have it. So that is it. Let's wrap up. Thank you, everybody, for participating. Have a great Friday. Bye-bye, everyone. See you next time.