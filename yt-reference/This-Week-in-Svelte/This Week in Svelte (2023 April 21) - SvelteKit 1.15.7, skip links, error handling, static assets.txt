 Hey everybody, welcome to This Week in Svelte. I am your host today, Enrico, and we're going to talk about all the cool things that happened here on the Svelte Discord, some changelog stuff related to SvelteKit, and other cool stuff too. Feel free to have audience participation. You can always speak to me with your voice and join me on the stage, or you can use text chat. Let's go! The agenda as usual is the changelog for Svelte-related projects, some quick facts, a community showcase, We don't have one today. Don't worry about it. And this week in discussions, followed by this week in Q&A. And let's begin with the changelog. Okay, there's my VS Code, and there's my browser. So in the changelog today, I can see I have some preemptive stuff showing, but we're going to focus on SvelteKit. Version 1.15.6 came out this past week. I'm not zoomed in enough. More zoom. So SvelteKit 1.15.6 features a few fixes, such as relative path fix for rendered assets when a base path is set. So there has been some inconsistencies with relative path updates. So when you import things such as an image or other path-related imports, sometimes the base path wouldn't apply correctly, but now it should. handle hook properly redirects due to form action event if you have a form action and then your hooks.server.js handle hook intercepts the form action to perform a redirect sometimes the redirect wouldn't happen due to some circumstances but now it should so you can still rely on your handle hook for redirects in fact we're going to talk about error handling later today so redirects comes to mind and then lastly the before navigate hook whether it's running a layout or a page will no longer intercept for download style links. So if you have an anchor link that is actually a download link, the before and navigate hook will no longer run and intercept that because you're not actually navigating, you're downloading. And then SvelteKit 1.15.7, the noteworthy change here is embedded mode fixes. And I believe embedded mode is things like serving SvelteKit as an iframe. Sometimes if you have multiple SvelteKit applications served in multiple iframes There were some issues with the way it would build but in this patch release those issues should be no longer an issue And we have some other niceties related to a lot of under-the-hood stuff that people don't generally interact with, so patches galore. Good to see patches. And that is the change log. Moving on to quick facts. This might actually be quick, and they may actually be facts. So today in quick facts, we've got an accessibility tip. Today I will talk about skip links. Skip links such as this example here on the Canada.ca website. A skip link means when you focus on a web page, such as you navigate it for the first time, or you go to a page from a search result, and the page is loaded. When you press the tab button, and you have the page focused, the first thing that'll show up is a skip link up here. And these skip links are deliberately put there by a developer and or designer content practitioner. so what I'm trying to demonstrate is the very first thing I can tab focus on is this appearing link I'll zoom in a lot there we go it says skip to main content when I press enter key it jumps to the first focusable element you can also use it to focus on the first main content and I wouldn't be surprised if this main content happens to be the main element and yes, it's within main, which is good enough. I'll make that a little larger. There we go. So this skip link. Come on, skip link. I think. There we go. Now if I zoom into DevTools, Let's try that one more time. Okay, so the first skip link says skip to main content. And when I press enter, it focuses on this element. And this element is nested inside of main. And that does the job really well. Because when you using a keyboard to navigate a website such as with a screen reader or even without a screen reader you do a lot of navigation to other pages So for example if I look at this webpage I navigate to the page, the page loads, and I have to press tab to begin navigating. The skip link is handy because I can jump straight to the main content. I don't want to tab through these bread crumb links. I don't want to tab through the navigation, the search. I don't want to tab through all of those things every time I navigate. So the skip link facilitates to making your browsing experience a little bit more efficient. And this website happens to have two skip links. So I'll show you both of them. The first one is skip to main content, which as you saw is the main content the user is most interested in. The second skip link is about government, which is the footer of the page. All you really need is a single skip link and that gets the job done. One skip link to the main content is adequate. If you have like four or five or seven skip links, that almost feels like a navigation. You should not do that because skip links are meant to make your experience more efficient and not make a second navigation menu. The whole point of them is to skip navigation menus. So one will do the job. I have a demonstration of how I achieved a skip link in Svelte. So I have my Svelte Lab demonstration here. And I'll open this in a new window to make it more like a real web page. And the first time I press tab on my keyboard, the skip link shows up where it says skip to main content. I press enter and it doesn't do anything. Nothing is immediately focused, but on the top you see the hash main in the address bar. So let's look at the source code on what I'm trying to achieve and how I did that using Svelte. So here's the skip link. It says at the top, we have an anchor link, which is the skip link. Then we have a header HTML section followed by a main. The main element has an ID of main. It's repetitive, but it gets the job done because the skip link way up here has a hyper ref of hash main. So this hash link will skip to the main element. And it also says skip to main content. By default, it's invisible because skip links don't necessarily have to be always visible. They can only be visible on focus, and that's also good enough. So the CSS to achieve that is I made it absolute positioned That way it always visible no matter what the size of the display is whether it mobile or desktop You can trust its responsiveness And the top position is just above the top of the viewport And the default transform, I use translate y negative 200%. It could be negative 1,000%. That's okay. The whole point is that it's invisible by being off the viewport screen. And then the skip link focus CSS sets the translate y to 0%. that is why pressing tab makes it visible because when it gets focused even though it's way off screen it appears on screen so people with screen magnifiers or sighted users can see the skip length the moment is visible and that's very good so that's skip links everybody what other tidbits or facts can I share? So there's the demo, and there's also more details available on the WebAIM website. I'll share all of these links in a moment. So on WebAIM, this is a very good accessibility resource. They have this section here on skip navigation links where they talk in detail about all the different tidbits and facts you need to take into account when making your skip links, such as don't make too many and how to make them appear off screen. So I'll share that in the chat and then we'll move on. If anyone has any questions or want to share their experiences, it's always a good time to raise your hand or type in the chat. And here's my Svelte Lab demonstration. You can have that too. And if you're interested in Canada.ca, you can have that as well. All righty. So that was a quick fact for skip links. Next, we're going to move on to Community Showcase. I don't have one, but this could be you. If you have a library or a special Svelte tool you'd like to share with the community, I can present with you here at This Week in Svelte. So reach out to me if you'd like to showcase your project. And now we're on this week in discussions. We might just fly right through this. That's okay. We're here for a good time. Not a long time. So this week in discussions, we got...

 Nothing really in-depth, no in-depth discussions, but we do have some very interesting tidbits. Several people have shared some cool news and such, and I'm going to bring it to you. First off is the node 20 changelog. It's navigating. Okay. so right now node.js is i guess it's worth mentioning node.js and the version it's currently at so right now node.js has a long-term support version of 18 and the latest is 20. 20 is not yet blessed with the lts suffix long-term support i still believe if i'm not mistaken is the blessing given by Red Hat. Red Hat will say, hey, this version of Node is enterprise ready. It has long-term support commitments, and we trust it and we use it on production. Once they get that signal, then the Node.js foundation can mark it as LTS. So 18 is still the approved production ready, enterprise ready version. 20 is currently the latest, but because it's an even numbered version of Node, it will eventually become the LTS version. And then 21 will be the experimental. So since 20 is fairly green, fairly new, it's a .0.0, and we all feel a little differently about adopting .0 versions of stuff. I usually wait for .1 or .2. But in Node 20, we have some interesting new features. First off is the ESM loader thread. So you can have ESM loader hooks that will apply on a dedicated thread according to this changelog. I don't know what that means in technical detail, but it sounds like something Vite can perhaps take advantage of. Maybe you can have your main thread in V8 run your application or your build, such as your rollup build, and then your worker thread or your loader thread can do some background tasks. I'm not sure what the potential here is, but multiple threads is always multiple potential. Another cool fact is the single executable called ADA, I think. No, that's ADA is the URL parser. Preparing single executable apps requires injecting a blob. So I'm not sure how long single executable apps have been around, but in version 20, it's more talked about. This means you can have a Node application contain your JavaScript files and ship as a single binary to macOS to Windows Linux And kind of like how with Golang you can ship in executable or a C or any native language you can ship a single executable to be run in a native operating system. This is different from Electron or Tori or Wales because Tori, for example, is a Rust wrapper of various operating system shells. And if you have a SvelteKit application shipped to Tori, then it runs the system web view. So in my case, I'm using macOS. And if I build the Tori app on macOS, it will run Safari behind the scenes because that's the browser shipped with my operating system. And Safari will render my SvelteKit application while Tori makes it a single executable package. And now Node.js can prepare single executable applications. The trade-off is it's a full V8 executable, so it's still 58 megabytes minimum, something around that size. But whereas Golang and Tari apps are around 5 or 10 megabytes minimum. So a future I'd like to see is perhaps you can ship a Node.js application with or without a browser web view, such as a system tray app. So on the top here, I have a bunch of system tray applications. Maybe you can use Node to ship a native system tray application without an interface. The potential is pretty interesting, so I thought I'd share that. And then the V8 engine is upgraded. I'm not sure if there's performance improvements, but at least there are upgrades. So version 11.3 of the V8 engine is wrapped inside of Node 20. Another interesting tidbit is this extension that has been shared around in multiple communities. the Pretty TypeScript Errors VS Code extension. I tried this out and I like it. I like how it takes this TypeScript error window that you typically see. Like here, there's this plain text TypeScript error and it's kind of difficult to read. And this extension tries to use some syntax highlighting, some space to make things easier to read. And so far, it's really good. And I'll probably showcase some of that in my text editor. I was using it a bit for some project work. We're going to talk about error handling in a few minutes. And if I were to make a type error like shipping this as a number or as a literal number and I hover the type error Oh my computer fans are turning on Type number is not assignable to type string. That's the typical error. And then below here is the pretty error. Type number is not assignable to type string. Oh, it's green. It's got a background. It's somehow more readable. But that's a very simple example. For more complex type errors, it really starts to shine. And then another tidbit is Rich Harris delivered a talk this past week. It's called Hot Takes on the Web. I have to share all of these in the chat. So here's the Node 20 changelog. Here is the pretty TypeScript errors extension. And here's Rich Harris's talk on Hot Takes on the Web. Check out the video. There are lots of reply videos, you could say. A lot of other YouTubers are watching this video and giving their takes on it. So it's also fun to follow up and watch those and get a nice, well-rounded opinion on stuff. I think it talks about how edge networks, and this is just one cherry-picked example, how edge networks can bring computer processing closer to the user and give them a better experience. That's one of the several takes brought into this. So check it out sometime. Add it to your watch list. And then finally, Vite 4.3 was announced. Here's the blog post. The main shout out here in the blog is about speed improvements. Everyone likes a bar graph, right? As soon as I showed this to a coworker, they asked me, hey, why are they going down? They're like upside down bar graphs. I guess it's because it showcases the climb towards better performance. See in this first example, 71% less time to do a Babel cold start. I guess Vite is really living up to its name, and it's becoming even Vite-ier. So enjoy Vite 4.3.0, and I think a patch came out, 4.3.1, so I'm going to adopt it now that it has a .1 release. Under the HUD, there's also source map improvements, but I'm still trying to get debugging to work with breakpoints. Maybe in an upcoming meetup, if I successfully get that going, I'll definitely showcase it, but not today. And that is all for this week in discussions If anyone wants to talk about any of these points feel free to raise your hand or type in the chat Let not stall because this week in Q&A is the final section of today's chat. Let's talk about Q&A. On Discord, there were some very common questions and answers, and I'm going to hopefully provide answers to them. The first one being, How do you do error handling and logging in SvelteKit? So I have an answer to that. So in SvelteKit, and any application really, you have almost four combinations of error types. You have expected errors, you have unexpected errors, you have server-side errors, and you have client-side errors. Those are the four types, more or less. and Spelkid gives you various tools to handle all four of these things and I'm going to help you provide context so like where do the errors occur and how can you handle them so in this very basic client-side example I have a error handling page called error handling and what I'm trying to do is showcase a fetch request on the client that handles an error that occurs on the server so here's my server endpoint it's a post endpoint and what i tried and what i'm trying to do in my page is make a post request and this post request immediately throws an error error is a function provided by speltkit for easy expected error handling this is an expected error because we the developers put this into the code and we throw it because we intend to throw it and handle it ourselves. So the error status code is 400, and the messages can let you do that. So let's run this application and see what it looks like. Localist 5173, thank you. Okay. So here's the error handling prototype. All it is is a single button. When I click it, it'll send a post request. And the post request is complete. The message reads out.

 let you do that. So what's interesting about this expected error is the error was thrown intentionally by my endpoint, and my client handled it. I did not navigate to an error page. I did not render an unknown error. I handled the error myself. I kept the user on the page I want to keep them on, and I still displayed a user-friendly message to them. And that's typically what you want to do with the error function. So in SvelteKit, error is a great place for you to provide a user-friendly error. This is something you want your users to read and take potential action on, such as please contact an admin or try refreshing. You can give them various tips or ways to remediate the situation. Zanju asks, could the state of a chosen image in SvelteKit be saved using an input? I am familiar with the snapshot API. Currently, the method used is to upload the image to the server and save the URL in the snapshot API. Could the state of a chosen image... Interesting. That sounds like a separate question, but I'll give you my short one-sentence answer if I can. Typically, you want to upload an image, and once the image is already uploaded, you can save its URL in a snapshot, just like how you described, but the answer is likely it depends. So I'm sure other people in the chat will provide their takes as well and help you out a bit. So back to error handling. This is an expected error. An unexpected error is something that you did not really handle. And I'll show you what Svelkit does in those cases. So over here, I have an object on line two. I set it to an empty object and I called it OBJ. On line 23, I'm going to uncomment this, and it says error page because I'm intentionally causing problems. obj.error.message. This won't work, and my error is... Error does not exist on type object. So this will cause a rendering error. Because I have server-side rendering turned on, that is the default, something's going to happen when I refresh. It says 500. Whoops! Why did this happen? So in SvelteKit if an error occurs the first time you parse a page and the page is parsed with server rendering or pre by traversing the script at the top level it evaluate OBJ it evaluate fetched message it evaluate the function it won run the function so any errors that happen inside fetch something won occur during server rendering It just says, hey, a function's here. Okay, I got this. It just does top-level evaluation. And then here in the HTML, it tries to render the strings. So obj.error.message, that's a problem. That's an unexpected error. And when an unexpected error occurs, you get an error page. By default in Svelkit, if you don't have an error rendering page set up, it'll provide one for you. The default can be overridden using source slash error.html, or you can provide a custom error page. Maybe I could do that right now. So if I add a plus error.svelte, and then I give it some text, the default is page.status. I'll just say my error page, just so everyone knows it's obvious. And if I refresh, It still renders the default. I'll restart my server. This may not work because I'm in a route that has a layout error. Sorry, it's a page error. And let's see the terminal. Yeah, so the terminal reads, can't read properties of undefined reading message. Yep, that's the error that I caused on line 23 up here. and this is going to go up a level. So I probably have to make an error.svelte in my root, not to be confused with routes. And here's something different might happen. There, it says my error page. So because this did not happen in the load method, it happened in the page, I have to create my plus error.svelte page one directory up, and that's why this gets rendered. And I keep using the word render because the URL says slash error handling. This plus error.svelte page is not a page with a separate route. It's just something that renders instead of the route your user tried to go to. I tried to go to the error handling route but there was an unexpected error So my pluserror page will get rendered instead of the page I wanted to render So it's all about rendering when it comes to pluserror.svelte. Okay, next is differences between SSR and client-side in Svelte files. so in Svelte files your errors can occur when you're pre-rendering or when you're server rendering if you're pre-rendering your SvelteKit application into a static site then it won't build because you have these errors here so you have to take care of them otherwise pre-rendering won't work at all and when it comes to server side rendering you'll have these error fallback pages that can occur. I'm not sure if a static site supports error pages, but I can look into that later. And throw error, just to recap, is an expected error. You can use this in your server-side logic, such as an endpoint or even in a load method, and this will return an expected error. In your hooks, we have the handle hook. Let's look at that. so here's hooks.server.js and in here's felkit provides the handle hook which intercepts every request whether it's requesting a page or requesting an endpoint the handle hook will get called in both of those cases and you should not throw errors in the handle hook at least you should understand what happens when you do so if i throw an expected error here it's actually treated as a fatal error. Because it's intercepting something like a page load, the following happens. Fake fatal error, 400. I can change the status code to whatever I want. So I can change this to 500. There, 500. Fake fatal error. If you throw an error, an expected one or an unexpected one, it will be treated as fatal. You might be thinking, if I load a page and it has a backend load method, will it not render the pluserror.svelte page that I have? It won't because you threw an error before the load function could process. So SvelteKit intentionally is not going to handle that for you It not going to be aware of whether it an endpoint you fetching or a page load that rendering Let look at the chat Philippe asks is there any development or existing solutions for translated routes in Spellkit? Yeah, there is. So there's optional endpoints. This is a little tangent, but I can show you. so in routing I think they're called optional parameters so in Svelkit you can have I know this is probably not exactly what you're asking but just so you're aware if you put two brackets around your parameter it becomes optional which means you can render something like English slash home or French slash home But if there's double brackets, you can render slash home or English slash home because this parameter is optional. You can have a route with or without it. When it comes to translations, it's up to you how you want the underlying page to render. So in your example, domain.com slash about us, you can do redirects. You can redirect the user from one page to the other. if you want them to see a particular page, you can analyze their browser agent and then do a redirect according to that. And I think that's possible server-side using the browser language preferences. But maybe I'll go in depth at another meetup. Sanju asks, what is the most effective way to use custom fonts in the static folder? I might cover a bit of that very soon, so I'll come back to that. Weavedale asks, does Felkit have built-in error logging or do you use Sentry for that? Right. So that's a good segue to logging. Back to the demo, back to the fake fatal error. So as I was getting into error handling, there's a handle error hook as well. This is available in hooks.server.js and hooks.client.js. Handle error is a hook that gets called when an unexpected error gets thrown. So here I have a console error that says demo unhandled error, and then I pass in the error. So if I do that, let's see what happens. So I'll go to my page. I have to undo this fatal error first. So I'll comment that out.

 Okay. There's my page. And I'm going to pay close attention to the console while I do this. I'm going to do this rendering error one more time. See what happens. Refresh. It says my error page. And let's look at the terminal. Go direct my hooks. So on line 14, it says demo unhandled error. And in my console, it says demo unhandled error. This means my handle error hook successfully was called when I performed an unexpected front-end or server-side rendering error handling. I say server-side because this is hooks.server.js, and this error occurred during server-side rendering. Therefore, it was caught in my hooks.server.js handle error hook. That's a lot of words in a sentence. Wow. But it works. So here you can do things like basic logging. I used console.error. If your backend is like a Node application, then this might be good enough because you can look at your backend, you can see the logs, you can scan them manually. If you want to utilize a logging service such as Sentry, then here you can log the error as well to your logging service. But that's only for unexpected errors. If you have an expected error, which you also want your logging service to handle, SvelteKit does not provide any automation for that. You have to add it yourself, which is not super tedious. So for example, on line five here, I'm throwing the expected error. I can also log stuff. I can do console.error, or I can use my logging service function here, so such as sentry handle error. And here you can log your error before you throw the error or throw or redirect. But that's how you perform logging for expected errors. So if you do want to log everything, expected and unexpected, these are the considerations you need to make. When you throw expected errors, log them manually. When you have unexpected errors, you can use handle error to hook into those unexpected errors and then log universally throughout your application. All unexpected errors can pipe through here. And that's logging. Hopefully that answers the question. Feel free to ask more or get some clarification from me. Moving on to you can log handled errors in the third tool Yep that the answer So that error handling at Svelkit Hopefully I covered all four aspects for server client unexpected expected and logging. All of these considerations for error handling is available to you in Svelkit. Let's move on to something someone else had asked about static asset handling. I got something for you. Oh, Sanju asks, Are there plans for SvelteKit to introduce a feature similar to Next's metadata API, which is designed to enhance SEO? I'm not sure about that, but SEO really is, maybe this is a bad take, but I think SEO is just something you handle on your own. So in Svelte already, like since version 3, you've had Svelte head. So for example, my layout, you can do Svelte head. and you can provide your meta stuff here, and you can adjust them according to your needs. I know that's very basic, and it's not a library-driven approach, but I don't think this is something Svelkin intends to resolve. I don't speak on behalf of that team, by the way. I'm not representing the maintainer's perspective, and nor am I on any steering committees. But you can, of course, handle SEO manually the way you normally do. If you have some library recommendations, maybe someone out there has made one, but I don't have an answer on top of my head. So let's talk about static assets for a moment. So in my demonstration, I have to navigate to loading images. So I've got an images page here with a cat. And this cat is loaded as a static image. And then below that, we've got another cat. This is loaded via import. The difference between the two is how they're loaded onto a page. So let's look at some Svelte code. So over here in loading images, I know what some of you may already be thinking. Wow, that you're really respecting white space here with your prettier config. Yeah, I know. I apologize for the angle bracket positioning. For those who don't know, this is Prettier's white space sensitivity setting, which is on by default. I just have my columns at a very narrow width In my text editor it 60 characters per width so that why it breaking the way it is Don mind me The thing that more interesting though is how I'm loading these cats. So let's compress things a bit, and that way you can see the important parts. On line two, we have import cat from libcate2.jpg. And on line 26, this is the imported cat. This is not a SvelteKit feature. This is a Vite feature. So in Vite, when you import static assets, such as JPEGs, they become hashed links, and they can also perform things like processing. You can pipe them through a Vite plugin. You can do things like, hey, take this JPEG, compress it to level 50 compression, convert it to a WebP. You can do all sorts of things with Vite as long as you're importing. In my case, I'm doing very rudimentary importing. this cat variable becomes a resolved URL during the production build. Not just JPEG, every static asset. I think it works on SVG, PNG, all sorts of formats. And there are various Vite plugins that will do some compression for you. I won't showcase those plugins, but I just want you to be aware that they exist. So what does this mean? I'm going to do a production build. I already have a production build. So I'll do PNPM preview. And we're going to look at the production build together. All right, here it comes. So here's the production build. And take a look at this image URL. So highlighting down here, this is the image element. and the source is immutableassetscaddy2.hash.jpg. So here the hash, it says D9C6728A. Not sure if you can read that, but that's the hash that Vite provides for you. It knows that this image is this particular file size, is this particular compression level. It generates a hash for you, which is very helpful for cache busting. So if I ever change this image or resize it and ship my application again, that hash will change and it will get invalidated. So the next time a user navigates to this page and this cat image for some reason changes, so will the hash and the user will receive the new image So that important because the alternative is static loading And that the other example So the static cat is here. Image on line 7, image source equals slash catty1.jpg. Where is this located? I'll tell you. It's located under source. Nope. It's located under static. So here's the cat. and it's located in the static folder provided by SvelteKit. SvelteKit resolves this as any static assets to be used as is. So if you put your cat in the static folder, the URL needs to be called relative to the built application. I'll show you what I mean. So under loading images, on line 7, the URL I'm using is slash catty1.jpg. I am not. Some people get hung up on this. I'm not using slash static slash caddy1.jpg. Don't do that because static, everything inside static, it gets copy pasted into your final build. And if you see in my build folder, client, there it is. So caddy1.jpg is actually in the resolved root of your built application. If you're using base URLs, then the base URL should get prepended for imported assets. But that's the distinction. Don't use the static folder as part of the path. And because it's catty1.jpg and I go to my page, let's take a look at the resolved URL. It is also predictably catty1.jpg. There's no hash because I did not import this. I did not process this through Vite. I did not perform any modifications to the image. I am using it statically. I am using it as is. The disadvantage is it doesn't have a hash, so there's no cache busting. If a user comes to the page and for some reason this image has changed, they'll likely cache it and they'll likely not get the newest image until they do a hard refresh or after the cache times out after a certain set of time dictated by your gateway or your server or your reverse proxy. But the advantage to the static folder is you can trust that they are used as is. This is commonly used for font loading. someone asked about fonts, you could put your fonts inside the static folder and you can call your fonts using the root relative link pattern as demonstrated here. You can use images here as well, but do keep in mind the caveats. There's pros and cons to

 static versus imported. And that is static import handling. Let's look at the chat. So yeah, Sanju asked only JPEG and the answer is no, it should work for any file type. Rogue Yoshi asks, cool, I was thinking about learning how to utilize VEAT for pre-processing. Wish I knew this was happening sooner. Yes, we are recording this. This is live and I will share it on YouTube after so you can always catch up. So that is that, Sanju asks, so then I can use lib path to store images for my blog. Which approach do you recommend? Well, I always recommend it depends. Let's see if I remember the shortcut. Is it option two? Yes, I did it. The keyboard shortcut for trademark is option two. It depends. If your blog has images that don't change very often, you can put them in static or in lib, whatever's more convenient. If you're using a headless CMS, then of course you'll put all your images in a bucket or in a media handler or a DAM. So it really depends. If it's a rudimentary blog, then it doesn't really make a difference to the user, especially if the images don't change very often. But I think the recommended approach from me is use lib because if you're making a blog and you're just putting images in your repository, you could put the images in the repository as is, put them in lib import using import statements and I do recommend search through the Vite plugins and try to get an image compressor That way you can make sure your images are optimized Perhaps you can have them served as WebP format For example, let's look at the plugins. So under Awesome Vite, there's a lot of plugins here. And there is some plugins related to images. there's image tools, image presets give them all a look, see how maintained they are image min, image optimizer if you run these plugins through your v.config.js they can compress your imports for you so every time you do a static build, let's say you have a pre-rendered static blog then these plugins are extra useful because they're from your repository or from a remote source and you can compress them by the time your production build is ready so that's the answer cool and that's it for that's it for this week in Q&A does anyone have any final questions if not I will wrap up going once going twice and that is all thank you very much for attending It was a short one, but it was a good one. I'll see you next time. Also, please stay behind and I have some feedback that I'd like to gather. Bye-bye.