 Welcome everyone to this week in Svelte. Today I will be your host, I am Paolo, and for today I will be your only host, Enrico is watching us from the crowd. So the agenda is the usual agenda, there will be the changelog, spoiler, there will be no changelog, some quick fact or announcement. There will be no community showcase today, but we will have a weekly discussion and a small Q&A. So let's start with the changelog that, as I've said, we have no. But, I mean, not because our maintainers are not working, but because obviously they are pretty involved in the development of Svelte 5. So we are not getting any release this week, but we can move to quick fact and announcement. And I will share you a bit of links with you, because first thing first, a small, very small announcement, but like it's happening VidConf like SvelteKit is based on Vid and it's our safe and our proud bundler and VidConf it's actually watching like it's actually live right now don't leave this week is well for go watch VidConf because it's a live stream it's a It's a 48-hour live stream that you can watch later with no problem. And it will actually, like, replay everything so that you have a full day to watch it. But there are a lot of very interesting talk. There are a lot of very interesting speakers. So whenever you have time, go take a look at VidConf because it's very, very interesting. Let go ahead and talk about the second announcement that we want to make And it a weekly reminder that Svelte Summit will happen on November 11th It our B annually I guess proud conference It the virtual Svelte conference It will happen again on November 11, 2023. And also there is a call for proposal open. So if you want to speak at a conference, make sure to submit your talk because it's always cool and we can talk about Svelte. Do we know time? There's no time. yet, but I mean, I'm sure a lot of details will come when we approach the date. And there is also another small quick fact that I wanted to show you, showcase, and it's based on this tweet by Mattia, which is something that he learned yesterday. Mattia is Joy of Code He's one of the best Svelte creators And what he learned is that Sometimes in Svelte order matters And the reason he realized this Is because he created this very quick test For a video he's working on Where he basically created an action and he dispatched an event as soon as the action ran. And he was trying to do something like this with useGrid and onGrid console logging and it was not working. And the reason because it doesn't work is because Svelte actually apply various things on the elements sequentially. So here I have a small REPL that replicated basically what Mattia was doing. And so as you can see I registering the event myEvent on this div and then console logging my event received And then I using events soon Events soon is an action that basically just create a custom event and dispatch the event on the node. So this actually works fine because we are getting the console log. but if I try to register the action before, the console log actually vanishes. And the reason because it works like this works is because Svelte will go ahead and try to register this action and as soon as this action is registered, the event is dispatched. And to this moment, the event is not like you don't have a listener for the event yet. So this is also something that is there is a page on on the Svelte docs that talks about this, because this is also true, for example, for bind value. Like if you bind a value and then add an event listener, it can create some problem. There is also, again, there is also a page regarding this in the docs. I will make sure to link in the video description. So this is very, very interesting because you have to make sure that, for example, if you want to list, Like, this is not a very common thing to do because usually you just, in your actions, you just want to register events. But if for some reason you want to dispatch an event on the creation, for example, you have to be wary of the fact that registering an action and then registering the event listener can cause this problem, basically. I think like Captain Codeman is saying that Prettier Plug-in Force Belt ensure the correct order. And I have to be frank. I never actually thought of this because usually I try to put my listeners before. So I actually never thought of this. But obviously, if it is, please, please, please use the Prettier Plug-in Force Belt. I mean it will make your code look prettier pun intended and it will also help with these kind of things And it also interesting because I mean not everyone knows that you can actually just dispatch custom event This is a very simple action, but it's also showcasing the capabilities of ZVALT actions because you get the node that you're applying your action to, and then you can dispatch an event on that node. And this is actually just JavaScript. Like this is plain JavaScript. And you can dispatch an event on basically everything and then you can list them on that specific event. And as you can see, it's very, very easy. And if you want, like we are here, so we are dancing, let's dance. If you want, you can also pass a detail here. So this is an init for the custom event. and if you want to pass a detail, like for example, inside the action, this will actually be present inside the event. So if you do event and then you do a.detail, you will actually get the string here. So that's one way that you can pass information from and to the action. Sorry for being, I mean, zoomed out. So, recapping, basically, if you register, JB is asking the use is declared after the on, is that the issue? Actually, this is the fix. The issue would be if the use would be declared before the on event. and the reason because this is an issue is because you are declaring the use and as soon as the use is declared this event is dispatched and you are not like you have not registered a listener yet so this is the problem like in this case as you can see there's no console log because this is declared before the event so if i declare it after it works and what i was showcasing is that you can create a custom event and the custom event it's actually my event and then you can pass a detail that will be present in the

 e.detail. So you can access the event, which is a custom event, and the detail is what you are passing back. Yeah, CaptainCodeman is actually saying, don't raise event when something is rendered. So normally you'd raise events when there is some kind of interaction and he's right. Obviously, this was just to showcase a little thing that maybe someone doesn't know about Svelte and the fact that Svelte will actually follow this declaration on the element sequentially. So this is something that it's important to know about Svelte because obviously this is a bit of a stretch, but this can happen. Sometimes it can bite you if you don't know that everything goes sequentially in Svelte. So if it ever happens that you are not receiving an event that you are expecting to receive or if something doesn't work, try also to think about the order that you are declaring this thing. So very interesting little fact. Let's move to, so as we said, there is no community showcase, unfortunately. And obviously, like, if you want to showcase something that you have worked on, feel free to reach either here on Discord. You can tag me at Pablo Pang. You can contact me, DM me, DM Enrico. And we will showcase your work inside this week in Svelte. So there's no community showcase today. But there is a discussion. So this week in discussion. And this is some discussion that it's a bit more generic. It's not very Svelte-focused. but I want to have your opinion on this because this is something that I might or might not be working on for SvelteKit. And it's HTTP client hints. So what are HTTP client hints This is an experimental HTTP request header It something that I don think it supported anywhere Let me see Yeah we don even have actually a proper can I use basically But this basically it's an header that allows your server to request a bit more information to the client. So let's say that on your server, you need to know the preferred color scheme of your clients because maybe you want to render in dark mode and you don't want the usual flicker that can happen. So for example, you send the HTML for the light mode and then you switch to the dark mode. Now, all of this is also kind of fixed by CSS. Like in CSS, you can use the prefers color scheme media query to actually present the content in a proper way. But this also apply to something else. For example, it might apply to, I don't know, you want to show the button with the correct icon, for example. So sometimes it's useful to have information about the client that is visiting your website on the server, because then you can render something differently based on what the actual client has. So there is this accept ch, HTTP client ints, basically, which is a header that you can specify. And this basically means that when this will be implemented by browsers, the browser will actually send you the information about the client. So for example, you can get the information about the preference media feature, the device client so for example how many how memory the width the viewport width of the client if the user has it trying to save data so you can maybe send a minified version of the page. So this is very, very interesting, but right now there's no way of using this header. So I can hear you ask why you're showing us this, because there is a way to do this today. And it's not very, it's not very, how can I say? I mean, basically these, like to have these, we can abuse the fact that cookies will be sent to the server. So how can we abuse this? Well, we can, I will show you in Svelte Club. What we can do is that inside our app.html, which is the file that basically will be served by SvelteKit, what we can do is that we can check, we can add a very small inline script of JavaScript. script. And given how HTML is rendered, this script will be run as soon as the HTML render, like as soon as the browser render this script, the script inside will be run. And this is very useful because inside this script, what we can do is we can do our checks. So I don't I want to see the device width. So I can do window.inner width. And what I can do is that I can actually set a cookie with this information. And once I set the cookie with this information, I can get access to this information on the client. The only issue is that, I mean, on the server, The only issue is that if the browser is getting this, I already sent the HTML from the server to the client. So what we could do is we can set the cookie document it equal to For example client with equal this thing So this is actually setting the cookie as soon as the page load and then I can do Window dot location dot reload Actually, I will have to like, because this will reload the page every time. So what I would really need to do is I will need to check if document.cookie. So I will check if inside cookie, there is already a client with cookie. So a very quick ways to check if there's already includes these because so basically this is checking if document.cookie includes client with so if the cookie is already set if it's not already set I'm setting the cookie and I can reload the page window.location.reload now why this works because basically when i get this information like the server send this page to the client as soon as the the client gets this information it starts to render the html the head the script tag and once it hits the script tag it will actually run this code So if the cookie is not set, it will set the cookie and reload the page. And the user will actually never see this part of the page because the page is already reloading. So the server now has information about this cookie because it has information about client width is now being set. and when we render the page again, this if will prevent the page from reload. But now again, we have this information on the server. So obviously this is a bit finicky, like you have to do this for every part, every information that you want.

 want and that's why again i may or may not have the idea of building a library to make this very very simple in svelte kit but the thing that i want to know like the discussion that i want to start is is these can this be considered profiling because after all you are sending information about the client to the server. So this can really well be abused. And I would like to know what do you think about this? Obviously, if someone wants to join the stake with me to talk about this, feel free to do it. Otherwise, just write on the chat and we can go ahead and listen to this. So, okay. Okay, Captain Codeman just sent some links, which I thought was related to this, but it's still related to use events. And we can actually take a look at these, because those are a couple of issues that... Sorry, I should probably zoom in a bit more, sorry. We should probably see the message link because these are a couple of issues that I would like to open, but Discord is preventing me to do it. Okay, I'm getting here. Okay, sorting component or element props. So this is actually some issue that is open on the Prettier plugin for Svelte. and I think it's about sorting the props inside the client component it's still open so I don't think it's yet ready I don't think it's actually exactly Tldr from CaptainCodeman Prettier does not sort them but you can use an ESLint rule Okay so there is an ESLint rule that allows you to sort your Svelte component properties And this is really, really cool. So ESLint also comes, basically, when you create a new Svelte application, you have the option to select yesLint. So please do it so that you can have this wonderful rule to order your attributes. So very interesting. Thanks for the finding, Captain Coleman. And again, we can go ahead if anyone has some ideas about these, about client hints. We can talk about that. Otherwise, we can move to this week in Q&A, which I will go here. So I will go ahead and move to this week in Q&A. And here also there will be a small little thing. It's a small Svelte repo that I will open. Okay, just a moment. And this is some, it's an interesting store that I've created this week. And it's basically a way to create a task, which is a store that has a lot of useful information about an Async function. So this is a basic Async function, which just await for two seconds. And then if there is, like if mat.random is greater than dot five, it throws an error. Otherwise, it's returned another random number. So this is, obviously, you can fetch from an API here. You can do whatever you want. But this small task, what it does is that it returns the function itself so that you can see here I can call the function. but this fetch data is also a store So if you try to access this store you have useful information about fetching the fetching data So you can see if the fetch data is loading you can see what the last successful value, like when these async function actually return something and if there is an error. So this can be useful, for example, for if you have an autocomplete and you want to show the old results while the fetch is in progress. So as you can see, like if I try to do fetch, is loading become true. And then this time was successful. So I get the last successful. And now I can also like continue fetching and I get an error. But I also like I also still have the last successful, the last successful information. So if I try to fetch again, it's loading is true. And now last successful is different. So this is very interesting because, again, you can always have the last successful value from this async function. You can know if it's loading or not. And you can know if there is an error. How this thing is made? Well, it's very simple. It's a writable store. So I create a writable store with this information. I have to create this merge function because I want to just update some values of this store. So I just create this very basic merge function where I use the update method from the writable. I get the old object. I spread the old object and then spread the new object that is passed in so that I can override these values, basically. So in this case, now I create an async function, which is the actual value that I will return. Whenever someone calls this function I will set isLoading to true and error to null I will await the original function which is passed in and I will do that inside a try catch So that basically if this value, like if this await actually works, I merge isLoading is false. So I set isLoading to false, and I set the last successful to value so that you can actually have the correct value. And then I also return the value so that, for example, if you want to grab this information by just calling this fetch data, you can also do it. And then I do something interesting. I set retval.subscribe to the subscribe of this writable. The reason why I do this is because in Svelte, everything that has a subscribe function that returns an unsubscribe function, it's actually a store. So even though this is a function, remember, in JavaScript, everything is an object. So in this case, I can add a property to this object and I've decided to add this retval.subscribe, which allows you to basically use this function as a store. Then I just simply return retval. The result is that now you can have this function and you can just call this function normally. And then I can also access this fetch data with a dollar to access the information about the store. In this case, the store contains isLoading, lastSuccessful and error. this is pretty interesting in my opinion but one thing that i like even more is that i actually like this is a very simple store but still it's a bit finicky to get to get it right like you have to update to create this merge function you have to update the object inside it i mean it's it's a bit finicky, but I've also decided to port these to runes. So if I go to rcc.lol slash task dash runes, this is the same

 thing using runes. I had to add these because until 15 minutes ago, there was a small bug in the Svelte REPL, but now I can actually do this. I can remove this. Options, sorry. Okay, so now this is using runes and I am doing basically the same thing, but notice I'm not using dollar sign to access this. So I am actually accessing the properties on the fetch data itself. So it's a tiny bit nicer. And here's how the implementation goes. And as you can see, in my opinion, this is much more clean. Like I declare three states and then I create these RETVAL function. And instead of merging in a global object, I'm just setting the value. the value. Like I'm doing isLoadingTrue, error is null, isLoading is false, lastSuccessful is value, isLoading is false, error is E. And then the only thing that I have to do, this is something that it might be, it might seem obscure, but it's actually pretty simple. It's actually just normal JavaScript. So, object.getOnPropertyDescriptor, this is just a way to declare getters and setters in a much more readable way. And given that these values are just meant to be get and not set, I can also just use get. I get last successful, return last successful, get is loading, return is loading, get error, return error. And then I attach these properties to the actual object, to the function. So this is basically the same thing that I was doing before, attaching the subscribe to the actual function, but doing with object.define properties. And then I return the retval And this works just the same Like is loading true last successful is loading true and last successful it works is loading true. I'm still not getting an error, but I promise that here we go, here's the error. So this works the same and it's a nice way to actually get a function a function and get the information about the function inside all tied up inside a very useful function. So let me know what do you think about this and I think there's also a discussion happening about Redux. We don't use that in Sbelt. So... Okay, so the discussion started because JBJB said runes are nice, they are signals, but for medium up I suggest people just use Redux with belt. yes I mean Captain Codeman said Redux life is too short to go back to that and I mean Redux is a bit bloated like Redux it was the main way to have a safe way to access state in React and I mean yeah it's a bit bloated like you have to write a lot of code, it got better over time because now it has Redux toolkit, which is a way to write stores in Redux that actually like ease the developer experience. But I'd argue that personally, I think like with runes especially, but even today with stores, you have a native way in Svelte to handle your data. And stores can get really complex. Like you can really create a custom store that allows you to have a lot of flexibility because one of the main selling point of Redux is the fact that you can actually have a clear part of your data inside your application, because every state will pass through Redux. but you can actually achieve the same thing in Svelte using stores very, very easily writing a custom store. So by going back, like if I go back to the Svelte REPL, like if you create a custom store, let's create a very quick custom store. So custom, I can import Brightable from Svelte store. And I can import Brightable. And if you want to write a custom store, what you should do is basically is you create a store. You can just get this subscribe from like const, oh, sorry, const subscribe. Oh, I'm actually writing in a .svelte file. That's why I'm not getting autocomplete. So you can do writable. Writable. And this is an object, for example. and then you can actually export const custom and you can export the subscribe and this basically allows Svelte to access this custom store as a store so I can actually, for example, import custom from custom So if I import custom from here and I show it here, like I can do this, json.stringify$custom. This is actually, let's do now two just to make sure. So this is actually my custom store And what I can do is I can attach methods to this object that I can use to actually modify my state So for example, a classic thing that like the hello world of Redux is the counter which starts with zero. And then you can pass an action. Like for example, usually in Redux, you create basically a mega switch that you can actually test something. So for example, let's create an action and you get the type of action and the payload, for example. And so inside this action in Redux, what you should do is probably do a switch on the type and if it's, I don't know, increment what you will do is if it's increment you will do we also need to get the update. What you will do is update old. You can do old.counter plus equal payload and then you can return old so that Svelte knows I get an unexpected token I don't know where. Yeah, I'll just switch what I'm doing wrong. I guess... I mean... Okay, apparently I cannot remember how to write a switch. It's been some time from the last time I wrote... Oh, maybe it's because it's type. No, it should work right. It's worth fine. Let's do increment. And let's do the same thing, basically. I can do this and I can remove my switch, which is not working. And so now basically what I can do is inside here, I can create a button to call this action, add,

 onClick is equal to... And I can do custom.action increment one. And now by calling these custom.action, I actually should be getting the type, Maybe I'm doing something wrong. Yeah. Okay, it was a typo. This actually should be increment and this should be increment too. So now I can add this and I mean the flow of information is always through this action. So this is the hello world Redux basically and it's very easy to create something similar to Redux if you want to have it in Svelte. But I say I argue like you can be much more flexible with Svelte Store So I would probably just use Svelte Store Genomics Store Svelte with Redux is not hard. Obviously, it's not hard. I just feel that like as Captain Codeman was saying that Redux is a lot of things like, but I mean, if you are used to Redux, you can definitely use Redux with that source. Okay, everyone. I guess that was it for today. It was a bit shorter, probably. So that's all I got. If you have any comments, if you have any feedback, any topic ideas, if you have a community showcase that you want to showcase, please contact us, either me or Enrico. I hope you enjoyed this weekend's belt. And have a good rest of the week until next week.