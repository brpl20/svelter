 Hello, everybody. Welcome to This Week in Svelte. My name is Enrico, and I am your host today. And today is April 14th, 2023. Let's talk about what happened this past week or two, because last week we didn't have an event. And let's see what went around the community of Svelte and in particular some questions and answers that flew around on the Svelte Discord. As usual, our agenda includes the changelog, what happened around Svelte and SvelteKit in particular. and quick facts followed by a special community showcase that I will introduce in a few minutes and then this week in discussions, finally finishing off with this week in Q&A. And let's begin with the changelog. Okay, let's bring the chat on screen. So in the changelog, there were a few patch releases made for SvelteKit, starting with version 1.15.1. There was a security advisory made, an official one, and if you click through the link, you can see the details of the advisory, but the patch has been made in version 1.15.1. So next time you run NPM audit and you notice that there's some security vulnerability, this is the reason for that. So as long as you're patched on 1.15.1, you'll have that, but fast on the heels of that security advisory is a second security advisory. So as long as you're patched on 1.15.2, you'll have the patches for these two security advisories. So exciting. Let's get past that and move to 1.15.3, where we have a fix made for preventing duplicate CSS files. Thank you to the maintainers. 1.15.4 has a couple more patches. One is to gracefully handle failures in hook.server.js. And the source map ignore list This is an interesting one. So there's an upcoming version of Vite, and I don't have 100% insight, but my understanding is Vite 4.3, which is currently in beta or preview. This will include some improvements to source mapping. This should theoretically allow us to have better debugging tools within our text editors. So especially in Visual Studio Code, you may be able to use source maps with Vite to do step breakpoint debugging That currently already possible with Svelte if you use the Node Inspector And if you attach to a Node instance you can use something such as Chrome DevTools to step through JavaScript code for debugging But I think the tooling around this should improve in V4.3. Maybe I'll do a special video on that. You can also check out Tanley Howe's videos on Svelte debugging. And then finally, 1.15.5. We have display warnings for multiple pages and name slots. What's interesting is it was possible to have a pluspage.svelte file and a pluspage.layout file coexist. But thanks to this patch, you will now get a very special compiler warning suggesting, hey, maybe don't do that. You should only have one pluspage.svelte per rep. So the cool thing about having a compiler is all the lovely warnings we get to prevent us and save us from ourselves. The next patch here is some unhandled header values were crashing Svelkit, but no longer. So thank you to that, to the maintainers. The unhandled exceptions with invalid header values. There was a certain regex matcher that would crash Svelkit, a very contrived situation, sometimes some common ones, depending on who you are. But the good news is that is patched. So come on down to 1.15.5 and get your free patches. And that's it for the changelog. Let's move on to quick facts. Maybe guaranteed quick, sometimes guaranteed as facts. So here in quick facts, we have more Discord chat. First off is a public service announcement. Did you know that learn.svelte.dev is ready? Let's bring it on screen. Okay, open too many browser tabs. So this website, learn.svelte.dev, is the new and improved full stack tutorial for learning Svelte and SvelteKit. It was subtly mentioned at this past front-end master's tutorial featuring Rich Harris. So if you check it out here you notice that all of the tutorials are complete and ready for you to learn even more about Svelte and SvelteKit What really cool about this website is if you using Chromium or Firefox I think Safari doesn yet support web containers You will be able to run Node.js in your browser, kind of like StackBlitz or literally like StackBlitz, since web container is their technology that they open sourced. So what's great about learning Svelte today is you have all these great awesome tools. This way you can run a server in your browser, don't have to download a text editor. You can be totally new to Svelte and you don't have to go through a complex environment setup. Oh, I need cookies enabled. Okay, let's do that. Cookies. Allow. Allow. Reload. Yes, I'm in a private window, so cookies are pretty important for this to work. And there it comes. Yikes. That's okay. I can demonstrate this later, but check this out in your free time. Just make sure you got cookies enabled or you're running in a regular browser window. And then down here, you'll get an iframe preview of everything. So that's cool. Yeah, web containers don't work properly in private. And I think this is a distant early warning for something to come today. moving on to more quick facts stores let's talk about Svelte stores so on Svelte.dev there is this concept called stores and we have writable stores, readable stores, derived stores all of these stores are very useful developer friendly JavaScript objects that also have some reactive functionality and some subscription functionality The thing I want to share that came up a few times on Discord this week was stores do not persist in between page refreshes. Stores are not persisting data. For that, you'll need either local storage, a proper database, a caching layer, session storage, cookies. You need some kind of mechanism to persist data in between page reloads. So if you close a browser tab and reopen it, all of these stores start from zero. But if you want persistent, yes. Thank you, Kenthropic. If you want persisting storage, you'll need a persisting database. So that your public service announcement The next quick fact is in TypeScript a variable used in a callback may throw a might error Let me show you what that is. So this is something I faced recently, and a couple others have as well. So here in TypeScript, sometimes you'll have a callback function. So on line six, I have this map method. And in map, I've inserted an anonymous function for the callback. And here it says test.groups may be null or may be undefined. Here it says test.groups is possibly undefined. Even though on line five, I test for it. I say if test optional chain.groups. For sure, this is not undefined. So the confusion happens where it's like, hey, in this nested if, I've definitely proven it's not undefined. So the reason it does this is because in TypeScript, it doesn't know if at the point in time a callback function gets called if something is undefined. Sometimes a callback function can be defined outside of the scope. So if I say const callback equals my function, it starts to be a little clearer what's going on. So I put it inside the map, and the same issue arises for the reason. Test.groups is tested on line 9 now, but on line 6, it's not tested. So what I need to do is make a non-null assertion, which is something that I believe only TypeScript can do. This is not yet available in JS doc typing. So what you do is you add an exclamation mark. And there you go. The exclamation mark is the non-null assertion. You're telling your code, hey, I promise this is not null. I am sure, trust me, this is a human developer telling TypeScript, hey, I got this. It's really not undefined. Believe me. So with that said, use discretion because the compiler is like, okay, hands in the air if you say so. I'm not going to thoroughly type check this because you're telling me it's not undefined. So that's on us. Optional chain link, of course, helps a great deal because if test is undefined, it will not call the the property inside of it. So I only need the non-null assertion at the end of groups. Or I can even use more optional chaining. Really, it's up to you what you decide, given the context

 you're working under. So check out non-null assertions. That was a quick fact. Our next quick fact is how to make an accessible button. Ooh, I've prepared a special present for everybody. Take a look at this. More optional chaining, more good? Maybe. Is the chat on screen? Yes, it is. Okay, so today in quick facts, I want to cover, I like to cover at least one accessibility topic every week. And today we're talking about accessible buttons. Accessible buttons, I don't claim to be an expert, by the way, but I just want to go and share some of the common considerations I have when making a button. And I hope you do as well. So let's go over these, this seven pronged approach. And I also have some resources to share with you on that. And speaking of resources, I should share this TypeScript Playground in the chat. There, you can play with that. So the accessible button considerations are, one, make sure that in all states, there is a high enough contrast. When I say all states, I'm referring to the up state. So when I don't hover with my mouse and I don't focus with my keyboard, the text against the background has a high enough contrast. The Web Content Accessibility Guidelines AA calls for, I believe, a 7 to 1 ratio of contrast. And I've achieved that with my dark green background and almost white text. If you see in my CSS, I decided to go with this, which is white with an opacity of 0.9. It's what I just decided, but at least the contrast is there. The next consideration is for all states. When I hover it, notice when my cursor hovers it, the text color becomes totally white with 100% opacity, and the background becomes a bit darker. The point here is that there should be adequate contrast between the hover state and the up state. You should go for that by default. That way you don't have to worry about too much high contrast mode after the fact. It saves you a step. Number two, indication when it's a link. So some people, this is very debatable, and I won't start an accessibility war right here, right now but sometimes people like to put links inside buttons like this third one here And it a good idea to underline all of your links but since it inside of a button it has that clickable affordance already So arguably you've achieved a lot so far. And thanks to some fellow Svelte Lodas, I learned that adding an icon to indicate that it's a link is also very helpful. So I've adopted that here. And when I hover, my cursor becomes a pointer, the link underlines, there is even more indication that it's a link, although arguably having it underlined by default is even better. The point here is that it's a link and visually can tell it's a link. Hovering is less important nowadays. It's still important, but I'd say 80 to 99% of users are on touch devices, particularly phones. If you're on a touch device, what you see is what you get. So right on my screen, I won't know that its underline until I actually touch it. So when I touch it, you have an active state. In my case, I've given the active state a thick green border, and we'll get into that next. Number four, keyboard outline. So when I tab focus, I press the tab button on my keyboard. It's outlined. It's got a two-pixel border offset by a couple of pixels, and as I tab through, the border is apparent. Number five, multiline and text zoom. This is important. So multiline, the second button demonstrates that if the text is too large, it has to be able to go over the next line. A common fault that people have with buttons is they give them a restricted height. So if I give this button a height of 40 pixels, then this happens. And that's no bueno. You want to be able to support multiline. And the easiest way to do that is simply not to define the height. Let it go to multiline. Just let it happen. TextZoom is in the same vein as this issue. So if I go to my browser tools, settings, and I go to appearance, and down here it says font size. Let me zoom into the settings. See, zooming, it's important all the time. Right now my font size is medium, which by most browser standards is 16 pixels against a 100% baseline. If I switch the font size to very large, see what happens. I going to make this particularly specific So I switch from medium And notice how the first button is one line But if I switch to very large, the first button is now multi-line. Sometimes you have a button inside of a card or inside of a very narrow container. This is where changing the font size in a browser, which users definitely do, will impact multi-line capability. So by accounting for that, you're allowing users with modified text sizes to still read the button. This is different from zooming in. So if I press Command-Minus or Command-Plus, that's page zoom. Page zoom is different from font increase. So in my button, I decided to make the font size, well, that's the default, one REM unit. The max width of my button is 25 characters. If I increase the font size on my browser, this 25CH value will proportionally expand to that. 25 characters width on a small font will still be 25 characters width in a large font. So take advantage of the character unit if you can. Next is right to left and multilingual. I don't have a demonstration of that now, but I do want you to consider this. If you support multiline, you're already doing a great job at supporting multilingual. Sometimes you have a button or call to action in English, such as go somewhere or create document. But when you change it to French, you need a lot more space because words in French tend to be a bit longer. So by supporting multiline, you're also doing great at supporting multilingual. Number seven is high contrast. High contrast can mean a couple of different things, and I have some extra resources to share here. High contrast on Windows 10 and Windows 11 in particular means on Windows 10, the buttons render as a specific color. So if I open this article, there's a screenshot showcasing this. Adrian Rosselli, great website, great writer. Go here and you can learn a lot about accessibility. So in Windows high contrast mode, trying to find the button example. I think it's in the beginning actually. So in this first screenshot, what Windows tends to do on purpose, and I'll share a link in the chat, so don't you worry, notice that everything in yellow is a hyperlink, and everything in blue is a button. So what Windows 10 and Windows 11 do on purpose is they make all the buttons purple all the legs are yellow And you can also change the colors and customize it but this is the default So as long as you're using an HTML button, you get this for free. You get the borders for free, you get the background colors for free. And this article goes in depth to explain that this is merely inversion of color. It's not necessarily high contrast. So speaking of high contrast, I did something. Down at the bottom, I have a media query for prefers contrast more. By default, I made sure my buttons have decent contrast, but you can actually go a bit above and beyond. So on macOS, we have display settings under accessibility. So if I go to display, increase contrast, I have now set macOS to high contrast mode, which is different from Windows inverted colors mode. I can invert the colors, but that's not a very good demonstration. It doesn't do what you think it does. But the thing I am showcasing is these borders. So now that I've enabled macOS high contrast, I've created these gigantic focus borders. And I think that does a decent job. It's better than nothing at increasing the contrast when the user demands it. The style of the page hasn't changed. macOS does not provide override styles the way Windows 10 and Windows 11 does. But at least you have this media query. Prefers contrast more, and you can do something like increase the outline size. The article here does not recommend changing the colors of your page. let the user on Windows do that themselves. In general, you should let the users use their assistive technologies the way they want to. And this is a sweeping statement to say, if you have ever seen a website with an accessibility overlay, like a button that says, hey, click here for accessibility options, that's wrong. That's us dictating what the user needs. We should instead use these baseline styles so that the user can use their assistive technologies the way they prefer. And with that said, that is the quick fact, rough overview of how to make an accessible button. I will share this in the chat. And in this Svelte REPL, there are links to Adrian Rosselli's article on line 16 and a very cool YouTube video on line 17 for you to learn more. Check it out. Sorry. Hello. Hello. Welcome. So please introduce yourselves to everyone. Okay. I am Paolo Ricciuti or Pablo Pang. I'm Antonio Sarcevic.

 And we both love Svelte. Yeah. And that's why we built our hackathon project, which is called Svelte Lab. And we announced it two or three days ago. And we are going to present it today. So this is Svelte Lab. And first thing first, a bit of history. Because, again, we both love Svelte. And when the hackathon was announced, we thought of participating together and we started to think about what we could do for the hackathon. And we started to think about what we love about Svelte. And one thing that we both loved was the Svelte REPL because it's easy, it's simple. you can just go there and have the full power of Svelte at your disposal. It's very minimal, and it's perfect for rapid experimentation. And we both use this Svelte for Apple every time. But at the same time, it had some problem. Like, for example, if you are using TypeScript, and let's be honest, who is not using TypeScript today? If you are using TypeScript and you try to paste something in TypeScript inside the REPL, it doesn't work. And you don't have dark mode. I mean, what? And also, today, the preferred way to build Svelte application is through SvelteKit. And inside the REPL, you don't have access to a lot of things that SvelteKit provides you, like the source, like the navigation. And maybe you want to try out something about SvelteKit. So you want to be something for SvelteKit and not just for Svelte. And so we thought maybe we can take the basic REPL and enhance it. And so we thought of building SvelteLab, which is a SvelteKit REPL, a supercharged SvelteKit REPL, because again we took the Svelte REPL as an inspiration and then we implemented a lot of features and commodities that are tailored towards SvelteKit development And now Antonio will show you some of those features. Yeah, so the most important part is this is way too bright. So we can just click this button to change the theme preference so everybody can choose the theme they like. I actually prefer light theme most of the time, so don't raise the pitchforks, but I'm going to use light theme for now. But you can pick the dark theme and be like a cool hackerman while experimenting with your Svelte code. Next, I think, is really important, and it drives me crazy when using the REPL, if I have the code messy, and I think it's really hard to read. so we added this format option we can just clean the code so you can read it again and yeah get going and yeah we have this command palette where these features are available from the keyboard so we can use keyboard navigation up and down arrows to check out these different features the most important part And that was nice to have features, but the most important part is having the ability to use the SvelteKit framework. So we have the page server file, which returns data from the load function, and we can just change this, accept it in our plus page Svelte component. Here we accept the data, and then we can access the data that's passed. And so we can experiment with SvelteKit patterns in this REPL. We can also have stuff like layout files. So you can have a slot and then you have the layout back. And we can create new routes easily. So we just create a new folder by using slashes. So now the plus page got created in the about folder. and here we can just hello about right and now in the layout we can add some navigation so we can navigate between the pages so this works we can also use this bar here up top to directly navigate to about Right And we also have access to the self So for example, we want to display the current path name. We can just import the page store from app, dollar app. Stores. I think that should be right. Yeah, and now we see the current path name. And one thing that's missing, sadly, currently, because the StackBlitz web containers don't support them yet because of some iframe issues, but we can't use form actions right now because we are having to set some headers and this messes with the form submission, so this is a limitation right now. But maybe one day we can also have the power of form actions. And okay, so we try to tailor the experience to SvelteKit development, so we added these helpful icons so you can recognize by the icon what type of file you're working in currently so they don't mesh together. You don't have just the Svelte icon. You actually see this is the layout file and it's a bit easier. We also have instant access to the documentation. So if you click this button right here, it opens the command palette, and we can search for stuff like the layout, plus layout file, or the hook. And when you press it, you can quickly open the documentation. All right. And then, just for the end, I'm going to show you a couple of more neat features. We can create new routes. so here you can define what route you're going to add so let's do blah and we're going to need a page plus field and a server and we're going to add an arrow page and then you just click the button and all the files get created so you don't have to do it manually we can also if you want to start the project with some integrations built in already we can also start a new project with template so you can For example, if you want to use Taywind, you can do that. You can open a new TypeScript project. Just click the button and then it will reload the REPL with TypeScript already installed and enabled All right we also have the Svelte Add which is a community project to easily add integrations So for example, if you want to add SCSS or CoffeeScript or MD-SWACs, you just press this button and it will add it using the terminal. You can open it here. And yeah, it's running the Svelte Add command. alright also one thing that I will never use but maybe some people will we have vim key bindings and it's easier to close you can just click outside or click this button and we also have this neat thing where you can hide the clutter of your config files by just choosing this toggle config files and now the file tree starts from the source folder so it's a bit less messy and you can concentrate on the actual code you write. All right, that was about it. Try it out on svetlab.dev. Wonderful. Thank you so much for presenting. Does anyone have questions? I see the chat is firing up. Please lend a hand. Give some hand emojis to our presenters. There was some discussion briefly about the text editor of choice. So it looks like you went with CodeMirror6 instead of Monaco. So I believe, or you can confirm, does CodeMirror support cell phone virtual keyboards? Yes, it does. And we choose it also because of this, because, I mean, I'm a bit biased because I love programming on my phone. So when we were building these, I kind of insisted about the fact that we have to make it mobile friendly. yes i think these felt maintainers had a similar conclusion drawn when they were choosing their next text editor so i believe learn.svelte.dev also works on a phone so great that you made that choice i also oftentimes i'm on discord on my phone and i want to help people but i can't always type code on my phone but with tools like this i can so thank you for that contribution look at the fire emojis coming on in svelte lab is great because it's pretty much stack splits but tailor are made for your SvelteKit development experience. It's very easy and fast to add TypeScript as you showcased and other common adders. I believe you have tight integration with SvelteAd. That was literally what you used, right? Yeah. Yeah, we use the community SvelteAd package.

 You also mentioned form actions a few minutes ago. I think on StackBlitz, if you disable SvelteKit CRLF, it should work to submit form actions. Maybe it'll work on SvelteLab as well. I haven't tried that. It should probably work also. We are using a web container API under the hood. So basically, if it works on StackBlitz, it will probably work on SvelteLab. Yeah, that's my workaround, because sometimes I make StackBlitz form actions, and it's like, oh, just make it insecure, and it works for now. Obviously, don't do that in production. Yeah, also don't use SvelteLab for production, of course. We store the data. You can store the repls in your profile, but those are stored as plain text, so don't put any secrets in there. For sure. Do you also store user data on GIST or some other storage? We are using PocketBase in the background. Okay, so if I make a project on SvelteLab, then my file is received in PocketBase. Yes. okay very cool awesome thank you so much for your showcase everyone here is really happy to see this i can't even count the emojis on the screen right now and with that said thanks for having us yeah thank you so much and come back again take care thank you very much right so let's move on to this week in discussions so in discussions moving on ahead there was a brief conversation about progressive enhancement and a couple of conversations and threads that happened were what is progressive enhancement also how can Svelte encourage more progressive enhancement obviously the number one remark is form actions so I'll go over my definition of progressive enhancement but I don't claim to be an expert. I do want to hear from you in the audience. You can come on stage or chat. Tell me what your definition of progressive enhancement is as I go along this discussion. So let me share Discord chat and go to my resource. So my definition, I'm not sure if there's a global or universally accepted one. If there is, please share it. The SvelteKit documentation links to this guide And long story short if your website works without JavaScript it is technically progressively enhanced So I put that into my personal definition which is a progressively enhanced website is something that has a baseline that supports all browsers, or at least all evergreen browsers, but it can be enhanced when a browser supports a certain feature, or if JavaScript is enabled. So my personal mental definition is it works without JavaScript. However, there are other acceptable definitions, especially if the context changes to, let's say, a mobile app or something served in a native wrapper like Electron, then progressive enhancement can mean a different thing depending on the platform it's running on. So this website is shared quite a bit on the SvelteKit docs as well as learn.svelte.dev. And one thing that I kind of confuse it with sometimes is this term called graceful degradation. Back in the early 2010s, 2005, around that time, we were still working with Internet Exploder 10, Internet Exploder 11. And sometimes you need something to work on the coolest browsers of that day, but it also needs to work on the browsers of yesteryear. So what you could do in those circumstances is present something that's cool on Chromium or Firefox, and then gracefully degrade it once a user on Internet Exploder 10 is viewing your web experience. And that also kind of entails making it work without JavaScript, but in a lot of cases, it's CSS compatibility. At the time, things like Flexbox did not work universally. So you would have to present, you'd have to like conditionally check for Internet Explorer, conditionally load a CSS file that specifically worked for those browsers. Yeah. So according to my notes, we have an example. Enhanced form actions submit without JavaScript. So in SvelteKit, we have form actions. This is one of those encouraged practices that SvelteKit provides and tries to evangelize. Form actions are both an easier developer experience, but also it helps your users to submit things when JavaScript fails under those many circumstances. I, for one, build things at an enterprise, and when a VPN breaks down and a page either fails to hydrate or takes a really long time to hydrate, I am also a victim of some of these circumstances. But with SvelteKit Form Actions, it works. And with the use enhance functionality, it works even better when JavaScript is actually available The second example is smooth scrolling in CSS I referring to smooth scrolling So this is not true today, but it's the only example I remember distinctly. There was a time when CSS scroll behavior only worked on some browsers but not others. I consider this a progressive enhancement, especially in that day and age from about five or eight years ago, where you can set CSS scroll behavior smooth. I think there's a document on MDN right here. So there is a scroll behavior smooth effect you can set on a page. So when you hit an anchor link, it'll smoothly scroll to these anchors. If your web browser at the time, in this example, if your web browser did not support smooth scrolling, the anchor link still worked. The anchor link still jumped to the content. But with smooth scrolling enabled, the browsers that do support it, support it very well. So when it comes to progressive enhancement, what is your definition? Do you want to come on stage and tell me about it? Is there maybe something I missed? Because I would love to learn more as well. I am selfishly hosting this week in Svelte so that I can learn new stuff from all of you. let's bring the chat on screen it is on screen nope no takers okay well i hope that in general we all agree that sometimes javascript fails there is a spell kit feature that's worth mentioning streaming with promises which i enjoy i think it's really cool streaming with promises was mentioned a couple weeks ago but it's worth bringing up time and time again because streaming with promises allows you to take your load function and return a nested promise. So these promises at the high level of the object will resolve in parallel before the page renders. But this nested promise will begin in the load function and then immediately return the page so that when you call on your page data.streamed, you can use the await template, and you can asynchronously wait for the results to finish. This is really cool because the request starts in the backend So 100 milliseconds or even three seconds later depending on your network connection by the time you load this page this stream could be resolved by the time the page loads However, you need JavaScript for this to work. So that's why the documentation recommends not to use this if the content is very important. And that's true for all cases. So down here it says, it only works with JS is enabled. You should avoid returning nested promises from the universal load if the page is server rendered. And another capability concern is if you're using AWS Lambda serverless functions, such as Netlify functions or cell functions. I believe edge functions do support streaming, but ordinary functions based on Lambdas do not. But that's okay. Svelkid will know that, and it will await the promises in the backend for you. Is this a progressive enhancement? I'm not sure. I really hope. One thing that this leads me to hope towards is web browsers supporting a lot more primitives, a lot more HTML-enhanced functionality that works without JavaScript. And an example of that is the details element. So details looks like this. Before details existed, we would have to write accordions ourself using JavaScript. But now this interaction and this toggle behavior is built into an HTML primitive. What I'd like to see as the years go by is more HTML primitives supporting comprehensive interactivity without JavaScript necessary. This is something I really look forward to. So something like streaming with promises, I hope, maybe, can be achieved with HTML. Maybe there's a way for the web browser to just know and understand handling network requests in a rich fashion without you needing to write the JS to do it. But also, more importantly, the user-facing interactions. So things like multi-search, combo boxes, I want to see more of that put into an HTML primitive. Only time will tell, though. And that's all I can say for today on progressive enhancement. Accordion are not accessible as accordion, though, says Pablo. Care to elaborate? Maybe share an example? And feel free to come on stage, but we'll come back to your comment. Details is not accessible as an accordion. Yeah. Not sure what that means, but if you add a little bit more detail,

 I'll come back to it. So what's next on the agenda? This week in questions and answers. Oh yeah, we have something fun to share. Let me bring down the Discord chat. So this week in questions and answers, at this segment I talk about what has commonly happened and since two weeks has passed, I've noticed we had a very wide variety of questions and I wanted to prepare something related to error handling, maybe next week, sorry, not today. But today I can talk about the toggle problem. Okay, so Pablo shared an article. Let's take a look. Why details is not an accordion. Okay, what's the thesis? What's the 140 character tweet? Summary is a button and buttons eat Samantha. Well, this looks like a fun read. I'll have to take this back. Thank you for sharing. I'll even post this in the YouTube comments below. I'm happy to learn more things. So for today's This Week in Svelte, we have what's called the toggle problem. Also, check out Joy of Code on YouTube. They did a great video recently on toggle problems, and I'm here to showcase two different strategies and two different scenarios. So the toggle problem or the toggle challenge is how do you utilize context equals module? And I'll bring the docs up for reference. In Svelte, we have this concept of script context equals module. I will share that in a demonstration. We also have context down here. Get context. Okay, here it is. We also have setContext, we have getContext, and we have stores. And we're going to merge all three of these Svelte concepts together to come up with a toggle component. And I will go over how these Svelte features work as well. So the first one is the toggle problem with highlighting groups with separate state And the second one is using context equals module So I start here In Svelte or in this demonstration I have two groups of components. On lines nine, I have highlight group, and on line 18, I have a second highlight group. It's the same component twice, each with three highlight buttons. When I click on a highlight button in group one, it turns yellow. When I click on a third or second highlight button, it turns on and the previous one turns off. If I go to group two, that highlight button turns on and the one in the group one turns off. The reason this happens is because I am holding the ID state of the toggled highlight button inside of this script. So lines one to four is a script block using context equals module, not to be confused with the regular script block. In a Svelte file, the script block is where you put your JavaScript in your local state. In script context equals module, this is what Svelte provides to you to give you access to a JavaScript module context. In a JavaScript module, and I'm afraid to use the word singleton, so I'll just throw this out here lightly, anything exported or defined in a module is only defined once in your entire application, kind of like a singleton. So in script context equals module, I'm defining a writable store called highlighted. I've imported writable from Svelte store. And on line three, I'm defining highlighted equals a blank string, a writable store. Anything defined in context equals module is not reactive. So if I put this highlighted variable somewhere in my HTML markup, I cannot change highlighted really and expect it to be reactive. However, since writable stores in Svelte are JavaScript functions, I can use this to achieve some reactivity. So let's break this down. I have a button on the page, and when I click the button, it calls handleClick. And handleClick will check the highlighted state, and highlight is defined on line 8. This is the local highlighted state, and it toggles the highlight class on line 22, defined below, which sets the background to yellow. When highlight is true then the highlight class is applied On line 14 I using the dollar sign to subscribe to the highlighted store The highlighted store is defined on line 3, and I'm setting it to the ID. The ID of this button, each individual button, has an ID defined on line 7, and it's just a random number. I'm using the math.random multiplied by the date. This should be adequately random for these needs. If these two IDs ever match, then wow, I win. Hopefully not today, though. And then lastly, if the highlighted store changes on line 9, the local highlight variable will change and be reactive to the change in the highlighted store. That occurs when I click on another highlight button. If I set highlighted to equal ID on this button, it unsets the ID, and then this statement will be called. So right now this button is yellow. Now this button is not yellow. The first button is yellow. And then down here, it's no longer yellow. So this is how context equals module shares state for all instances of a component on a page. On this page, I have the highlight component used six times, three up here and three down here. It doesn't matter how many times I use it on a page. There's only one highlighted store because it's defined in context equals module. So if you are okay with this, if you want a component to have one shared state across all instances, this is for you. If you want something different, then you can use something different. Check this out. If I highlight group one's highlight, the state is shared only among that group, and group two has its own separate state. So this highlight group and this highlight group have their own independent state. This is achieved slightly differently from the previous example. So in this example, there is no context equals module, but there is set context. So back to the app note that highlight group is the parent component highlight is the child So if I go to the parent component on line five I set a store called highlighted and then I set context And this is one of those powerful svelte features that a lot of folks speak highly about. Being able to take a store and put it inside of context helps you share a store and reuse it for all child components. So here I'm setting a key called highlighted to a store called highlighted. And then finally in the child component, I'm calling getContext. On line four, the highlighted variable is retrieving the highlighted store from the context above. And what's cool about Svelte getContext is it has to work in the root scope. This is why things do work in a server rendered fashion. And like in the previous example, I have the ID set to a random number, and when I click on a button, the handle click is called, and the Svelte store is subscribed. It sets it to a new object, which makes it reactive. I'm using the assignment here, which is reactive. And if any other IDs, any other highlight.svelte components on the page will have themselves unset thanks to line 9. So the local highlight variable is reactive to the changes in the highlighted store defined in the parent context. So in summary, two instances of a component on a page, separate independent state management, and the second strategy is context equals module so that all instances of a component on a page have one shared state. Two strategies. Choose a strategy. I will share these in the chat. Feel free to participate. Raise your hand. Voice chat. Text chat. Ask questions. I am here for you. Okay, so both examples are shared in the chat. and with that said and done, I'm going to wrap it up. So let's see. Show notes are complete. And that is it. Thank you very much for participating. Please stick around and I'll share a feedback form and have a great week.