 Hello, everybody. Welcome to This Week in Svelte. My name is Enrico, and joining me is Paolo. Hi, everyone. And a special guest, Hunterbyte. Hello, everybody. We made it. And as you can probably guess, today we have a couple of agenda items. One is quick facts and announcements, and the other one is runes, runes, and more runes. Starting with announcements. First off, did you know that Svelte Summit has been announced? Take a look at this. I'll also post it in the chat. There's a call for papers, and it's going to happen on November 11th, 2023. So stay tuned, subscribe, join the newsletter, and join us at Svelte Summit. I literally can't wait. And also, the call for proposal is open. So if you want to talk at the Svelte Summit, feel free to submit a call for proposal. I have to hurry and get on that. And that is it for quick facts and announcements. And now it's time for runes. Get ready for Svelte 5 runes. What can the compiler do this time? So today is the 22nd of September, 2023. And on Wednesday, a couple of days ago, there was an official announcement for what's coming to Svelte 5, and they're called runes. Let's get into what they are, and what they replace, and what they hope to accomplish. And your feedback will be highly valuable throughout this, so let's get started. First, a disclaimer. Everything about runes is a work in progress. It's all subject to change, but the maintainers are monitoring your feedback. So if you're joining us on Discord, you may have seen the Svelte 5 runes chat channel. If you're on YouTube, or Reddit, or elsewhere, pretty much everywhere people gather and talk are being closely monitored. Soon there may be a formalized RFC process and there may be actual pre-releases you can install and try locally. So until then, just bear in mind, this is very early alpha stage. So let's get to it. Oh, yeah, by the way, the official announcement is here. Svelte.dev blog runes. In case you don't have it, here you go in the chat. Now you have it. Okay So what problems are rune solving It solves several problems but I trying to summarize this as succinctly as I can And I think the first one is client performance which is runtime rendering and bundle sizes. Second is less magical commandeering of JavaScript concepts. So what you're familiar with in Svelte 3 and 4 is things like export let prop name, which although it's a JavaScript concept, it has special meaning in Svelte files. Another one is top-level variables like letmyvariable or letcatname. If you define a variable top-level, it's not just a JavaScript variable, it's a special reactive svelte variable. With runes, the magic is taken away from JavaScript concepts and put into your hands. Third, more maintainable svelte code and fewer syntactical sinkholes. So this is very case-by-case, but also it is largely assumed that people face problems with the current Svelte code and Runes hopes to achieve some solutions. And on the right is a performance benchmark preview. So it's not official yet, but you can see that there's a dramatic improvement in runtime performance between Svelte 5 and Svelte 4. And in some cases, faster than vanilla JS. How is this possible? Well, everything is possible when you have Dominic working on it. Obviously, like the compiler, where it's able to write very performant JavaScript code. So it's not just vanilla JavaScript. It's very performant vanilla JavaScript. That's right. And to read this tiny tweet that's in the corner, Rich Harris wrote, what happens when true ADM, which is Dominic Ganaway, joins your team? Performance isn't even the most exciting part. Svelte 5 is going to be radical, and I can't wait to share more. And now more has been shared. So meet the runes so far. We've got $state, $derived, $effect, as well as $effect.pre, and props. What do these do? State is your trustee primitive for reactive state, so assignments are still reactive. Highlighted in the snippet below, you have your top-level variables, and you make them reactive by explicitly casting the rune state. In your code below in the markup, I have an input called bindValue. So anytime this input changes, the name variable also changes and causes a re-render. So assignments and binding are both still reactive. That concept of Svelte has retained Yeah I mean it really important in my opinion to showcase the fact that literally you the only thing that you have to change is add dollar sign state between like before word like this is the basic hello word and like there's no much to change inside if you use runes inside svelte files that's right this replaces the implied behavior of top level variables. Previously in Svelte 4, let name would be reactive by default, and it would cause re-renders when reassigned. But now you must cast the state rune, otherwise it will not be reactive. And this state rune also implements signals. So this is Svelte's way of saving you from writing boilerplate, but also getting signal reactivity. Next is derived. Derived updates from tracked stateful variables. It is SSR friendly because this will run when you server side render your component and it partially replaces the current dollar sign colon labeled syntax. So in this highlighted example, we have a name at the top and then full name is a derived state that depends on the name variable and does other things to it. So you are full name. This paragraph below will render Thomas Anderson from a certain movie that you might know. one. Next is props. So instead of using export let, you were going to do a props rune, which is currently there's a single props plural rune. And with this, you can destructure all of your props in your component. So in this example, label and type are being destructured from props. There's also a TypeScript syntax for this, which I don't have demonstrated here, but you can pass in a generic type to the right-hand side of props to type it. And label and type are used below in the markup. So here the type attribute is being applied to input and the label value is being applied to the children of label. And that's how props look. Next is effect and effect.pre. Effect runs after the component mounts. So this is not going to be server rendered. This is strictly runtime. It automatically tracks stateful variables and props, and you can opt into untrack and remove dependencies. So much like how derived partially replaces dollar sign colon, you now have the effect rune, which replaces the remaining features of dollar sign colon labeled statements. Highlighted below is the effect example You pass in a function The value variable here is automatically tracked as a dependency So anytime value gets reassigned this effect will rerun unless you untrack the value using an if statement or using the untrack helper method. One important note here is that, like, obviously state gets tracked on accessing. so it's very important to be tricked enough of not accessing the state that you don't need for example if you do dollar sign sum plus plus you are effectively accessing the state and signing the state so doing dollar sign sum plus plus inside an effect it's very dangerous if you don't use an untrack oh it's dangerous if you do not untrack yeah exactly okay that's it for the runes that's really it but there are other svelte 5 goodies that go along with the runes one of them is signals so the the state rune does create signals which is a new way to achieve proactive state updates and efficient re-renders but also with none of the boilerplate. I don't have a bad example of signals, but let's just say instead of writing two or three or four lines of code to set up every individual signal, you can do that with a single rune. And this should achieve those really ridiculous benchmarks you saw earlier when it comes to runtime performance and rendering. Next is backwards compatibility. And this could be currently proposed as a short-term backwards compatibility. So for example, when projects adopt Svelte 5, they can write and consume components written with or without runes. So a Svelte 5 project can import a Svelte 5 component, and if that Svelte 5 component uses runes, it will work. If it does not use runes, it will also work. And supposedly a Svelte 4 component that also does not use runes will also work. Upgrading to Svelte 5 will not immediately make your code break because it's backwards compatible or plans to be. There's time to adopt runes and code mods are planned so you can automatically refactor your code using a code mod but you will not see a deprecation warning until at the earliest svelte 6 this is uh directly taken from the documentation of the faq in the official blog post yeah and also again svelte 6 will bring you deprecation warnings but it will be a little bit more than a little bit more than a little bit

 will still be back compatible. So do you have a lot of time to move to Svelte 5? True, but as part of the proposal of runes, the plan is to eventually remove the old way of doing reactivity and have it exclusively in runes mode. This is eventual, like Svelte 7 or 8. Yeah, exactly. It's far in the future. And the next point is you may not need stores because state can be used in modules or functions. I have a demo. So in this live REPL, and I can never zoom in enough. There we go. In this demonstration, this shows how stateful variables can become like stores in the current way. So in this demo, you minimize this window a bit. I want to change my cat name to something else. If I click on this button, it updates. It updates because I have this constructor function that I export from a stores.js file. And in that file, this function, even though it's not a .svelte file, it's a .js file, I can still use runes. I'm using the state rune on line 2 to make name reactive. And I also return an object with a getter. This returns the name value and a function change name. So keep in mind these two things. We have a getter called name and a function called change name. In the app, I consume by composing the cat object. In the paragraph, I show the label using cat.name, and the .name makes use of the getter. And then I can use cat.change name to pass in a new name, and this will do the reactive assignment. Is this more code than writing a writable? Yes. Is Felt5 planning to add a helper function to simplify this boilerplate? Probably yes as well. Hey, Enrico, I'm not sure, I guess, what the cadence is, but could I share real quick? I've kind of, this seems like a spoiler for a video that I'm working on today, but I've kind of rewritten some of the, you know, writable, readable, derived store functions that you import from Svelte in the, you know, rune syntax, right? So you could copy these over to your app and use them in a similar fashion. You want me to show those sometime today? Yeah for sure Let get into that in a couple of minutes Cool Okay So I just rapid firing going through like the primer of stuff and I had to bite as an awesome demo to share right after this. So your feedback is important. Just to reiterate, try to learn and understand runes and provide the feedback you can. Try the REPL. Definitely get hands-on experience with this. Write down some components. Try the runes out for yourself, and also share your thoughts on Discord or anywhere where the moderators and maintainers are watching. Share your thoughts. Describe the kinds of apps you make. We want to get as many perspectives as possible. If you're new to Svelte, that's extremely valuable. If you're a veteran of Svelte, that's also extremely valuable. We want to hear what kinds of apps you're making. We want to hear about the kind of problems you run into and whether or not Runes helps you and solves these issues. And we'll get into our personal use cases in a moment. But first, I want to tackle some frequently asked questions that we came across on the Svelte Discord. One of them is, by the way, there is an official FAQ. So at this link here, there is an official FAQ. Please read through them. For example, what does runes do? Is it a breaking change? Some of that is already summarized here, but now you know. But the first FAQ is, since export let some variable equal state does not work, will we have to write boilerplate? So this question comes about if you're in a JavaScript file and you want to create like a store using the state rune, you cannot because the state rune makes a variable. It doesn't make an object or a function that you can use references to point towards, unlike a writable. A writable store returns a function or a writable contract, whereas state returns an actual variable. That is why this syntax above will not work. I'll just pause for dramatic moments but there is a plan to write some wrappers around this and I'm sure Hunter Byte will share related examples here so this way if you do want to make a writable like store using state we may be able to provide functions is the context API going to stay yes and I have a demonstration of that as well so a function is needed in place of stores but that may be simplified in the future. And personally, I can see why variables defined with state cannot be passed in via context. It's because there's no object reference. And I'll show you the toggle problem. In the toggle problem here you click on a button Only one button at a time can be highlighted And I have multiple highlights on the page So down here in group two I have a separate toggle But they have independent state from each other. And this is using context. So in the highlight group, on line four, we have this highlight value function. And then on line 11, we instantiate it and then pass it in via context. Currently in Svelte 4, this code here from lines 4 to 11 can be simplified to a single writable store. So this is more code for now. But the fact is you can't pass in a state rune directly into set context. If you do so, it's just a static value. There's no way to update it. So it has to be this object reference that gets passed in. That's sort of like one of the underlying features of Svelte 5 is to lean more into JavaScript without commandeering some of its known features. And then in highlight.svelte, we're using getContext to get that highlighted function by reference, and I'll be able to transform and reassign highlighted. So on line 11, highlighted.value can be assigned to something, and this will hold state for this one instance of the toggle. Because here we have a getter called getValue and a setter called setValue. and this is plain JavaScript. That's not runes. That's just JavaScript. Highlight.value equals this and the setter gets called. And highlight.value can be derived on line seven so that I can have a plain highlight variable here that is used below in the class. So that's just a shortened example. Next question is, Does Svelte language server run on TypeScript and JavaScript files? There's no official word on this, but it's likely yes, because anywhere runes can be used, you should probably hope that the Svelte language server will give you some hints and guidance. So probably yes, but no official word yet. Can you have reactive arrays with state? Hmm. Can arrays or objects be reactive by the key instead of the whole reassignment? Hmm. This is an incomplete slide, but that's okay. because I'm about to lean on Hunt a Byte for some demo. Yeah actually speaking of these two questions you can absolutely do this because again like signals works by tracking whenever you access something so you just need to create a signal for every key of the object or for every element of the array so obviously this will make use of some helper function but you can definitely create arrays and object reactive by keys instead of like the whole object. And it's actually recommended because this way, if you happen to change something inside an array, Svelte doesn't have to re-render the whole list, for example, but can surgically apply something to that specific element. Cool. Let's get into some hands-on demos. So Hunter, do you feel ready? Yeah, yeah, I'm ready. Okay. I can't share my screen. Okay, there we go. I got to do my system settings here. I haven't shared yet on... Meantime, there is Adler, which is asking a question. Is possible to use TypeScript generic type with props? And the answer is yes. There is a generic for props to specify what are your props. And fun fact, if you are not using TypeScript, but jsdoc as TypeScript. You can also do that. And I discovered this this morning, basically. Instead of passing a generic, you can just type your jsdoc. So you put your jsdoc comment, you do at type and specify the type that you want. And this will make TypeScript infer correctly the typing of your props. Okay, let's read the chat for some more questions while, oh, Hunter is back. Hello. Okay, so this tweet here, a lot of people, again, the extra dollar sign state to declare reactivity piece. I think this Greg Johnston, who is not related to me in any way, as far as I know, discusses, you know, DX is how simple is the most complex scenario, not how simple is the least complex scenario, right? So I want you guys to keep that in mind as we kind of go through these examples. But I've been working on a video that I hopefully will have out today. It kind of compares. Everybody can see this, right? I don't need to zoom in further. That's good. You good here? Okay. Kind of compares. So when you make the comparison.

 And so I've seen often the comparison of, you know, import writable from Svelte slash store, and then doing something like dog is writable dog versus having to do the cat getter and setter setup that Enrico just did. Right. And this is not a fair comparison because under the hood, writable is not a rune. It's you have to import it and it's a whole function in and of itself. And I have a comparison here. So when you compare those two, what you're really comparing is this, which is the writable function that Svelte provides to us, right? And it's likely they would provide some type of helpers. So all of this, and I would gander to bet that I don't even really know what this is doing most of the time or part of the time, right? Now, there are still places where you want to use stores, which we'll talk about here in a second. But you're comparing this beast right here, all of this, to this, right? And so that's what you have to think about when you're making those two comparisons there. But I've prepared like these little helpers here. And I'm still working through them. And I'm still trying to make sure I'm doing everything the right way. I could probably use like derived here. But basically, this is supposed to be how you could get most of the same functionality that you could out of a store with the signals and the rune syntax in Svelte 5. So like the ref here, again, I'm assuming we're going to have some kind of name that we commonly use to identify this basic setup here. I know Rich has used boxed. I believe it's probably just to avoid the confusion with view or to not, you know, intermix the two too much. But this is basically a writable store, right? The writable function, when you call that, this is going to generate a reactive value that you can access with dot value. You can set by mutating the value. This is read only. So by not providing a setter, you now have just a read. You can't mutate it from outside of this function here. And then derived, again, I'm pretty sure I could use derived here, the $derived, but I need to mess with it a bit more. But what we're doing here is, again, similar to the derived store function where it takes in a store and then a callback, which has access to the value of the store currently and is able to essentially return a readable of that. And so in this states file here this could drastically be simplified of course but I wanted to demonstrate the common I guess complaints or the common gripes about Svelte 5 in that being able to declare state in other modules and export it move it around in a few different components So here we're defining a theme and then we're defining a theme color, which is derived from the theme. And this is just going to change the color of this text here. And inside of the header, I'm importing both the theme and the theme color. and I can still use this, you know, imagine this dollar sign or this dot value here is actually just like a store where you would just do a dollar sign theme color. You do dot value, right? Instead. But it still functions the same way. I can still mutate it the same way. And actually it becomes greatly simpler when you start doing complex updates with them as well. And then the theme switcher also uses that same theme from states. And I just have this little function here, which just checks the theme's value and updates it whenever they click toggle. So when I click toggle theme here, you can see that it's switching the color and the text up there in the top right. And those components are just imported here like so. So like these helpers here, again, I would hope that some of these are provided by Svelte, but if not, then I'll create a library if you really want to import them in super easily and use them like so. Yeah, that's what I had to share today. I'm still working on refining it. for a video but cool again yeah of course this is states.js so basically every time i call ref here i'm essentially calling you compare this to saying writable right derived same thing as derived from svelte similar right i don't want to say same because they're not the same but very very similar for most cases yeah and i see like like i think it's rain life i don't know know if it's you because i can't see your name i'm streamer mode but like he said it doesn't sound fair to exclude that part from the comparison the room still include extra code after being compiled just like the stores and this is true but like the point that i think hanta is trying to make is that exactly like svelte provides you with upwritable which is all of these like all this code and you don have to write this code It provided to you by Svelte Svelte will provide probably a box or a ref where you can just use these like just you today use a writable And you don have to think of the writable code just like you don have to think of the ref code Indeed. It's possible that helpers like this. So like Hunter just shared the helpers.js and states.js helper utilities. it's possible that Svelte 5 will introduce some of these as well so that some of the boilerplate can be abstracted away. And it also depends on your use cases because the things I'm most excited to talk about today are everyone in the chat, like your use cases with current Svelte concepts and what you'd like to see simplified and how much runes has an impact on you personally and in your day-to-day. Also, if you're new to Svelte, do you feel like things like opt-in reactivity and other stuff can affect you? So keep that in the back of your mind as we go through this discussion. And I think we have a couple more code demos to share. And then I really want to read the chat out loud. So Paolo, did you have a demo? I think I have. Just wait a moment. I have to recover it. I basically ported one of my old stores from stores to rooms. And it's very simple. it's about history the history store okay so this was a very simple link to a repel that actually it's not mine I just modified a bit this is the the tweet where I basically took these and modified a bit and this is basically a a tweet to have a runify helpers so that's what i was talking about before in this case basically this is a an helper function that allows you to pass in an object and you get an object back where you basically use like each single element of this it's a room so So it's, as you can see, again, it's not very complex. I know it may seem a lot of code. It may seem complex but at the end of the day it just looping over like it checking the object If it an array you just call this function again on it and you return it if it not an array and it an object you just create a new state for that object and then you loop over the key of that object and you runify that key so in this case for example once you pass, for example, happy true and sad true, you create a rune state, like you cast a rune to get a state for happy, you cast a rune to get a state for sad, and then you stick it with object.define property and a getter and a setter, and you have to stick enumerable to make possible to JSON stringify it, and then you return it. And if it's something else, you just return an object. So, I mean, it's 25 lines of code that you will likely never touch again. And this will allow you to have fine-grained reactivity over a whole object. And this is important because, again, you can go ahead. I have probably to zoom a bit, but you can modify this. And this gets also modified. You can move this. And this is all fine-grained. so this is I think a very good thing that it's that easy to create an helper and again this may come with Svelte 5 with Svelte 5 we might already get something like this so it's very important before jumping to conclusion like okay I don't like vault anymore because of this, don't worry because, again, work in progress. Expect bugs, but also expect this API to change. And what... Yeah, sorry. And what Enrico was talking about is, let's try an experiment. So, if you have some store or something that you don't know how to convert to runes, you can send your store in a REPL preferably. And we can try together to make this store using runes. So I don't know if some of you have some piece of code that wants to look at. Yeah. Ping Paolo in the chat if you would

 like Paolo to live code or live refactor your store. It seems like Runify solves a advanced use case. Does this also apply to each loops in Svelte? So can you each loop over something and update one of the values without re-rendering the entire loop? Yes, you can. There's also in the doc, if you see, there is functions and there is this selector. And this basically allows to better have a grasp of, like, this allows this selected.current to be, like, when you run this code, we can actually do it in the REPL. It's the logo. Click on the preview, top left. Okay. I didn't know. So as you can see now, this is basically like you have the current and this basically it's a performance optimization. So with this selector, you can basically select an item. So doing selected.setItem, what you are doing is this selected will contain this item. and it will be done in a performant way. So this is a quick performance optimization that you can do inside each loop. But again, yes, when you are accessing something inside an effect or inside an each loop, reactivity will only be triggered when you access something when you actually access something and as Enrico said, the runify example which may seem very complex it's not actually like it's not actually probably what you want most of the time because these like this is might get important if you have a huge object and you want to access a leaf of this object in a performant way But most of the time you will probably write normal Svelte component So as we said, if you are just, let me reset. If you are just writing like this is the normal hello world, to make this use rune, you just have to do this. so by my experience running like trying to test the runes inside the the preview i noticed that if you are using state inside as that component the code will not be much different from svelte 4 the the real like gotcha probably of the of the runes are when the state needs to be shared between files and even then it's a very small gotcha because you just have to remember that if you want to pass this state to another file you have to wrap it in a getter I don't know if people are sending oh I see, yeah Nasso sent you a link further up for the bound store and PaoloKey please zoom in we can never zoom in enough zooming out. I was zooming out because it was impossible to read the Runify but I was zooming. Okay, and please share a link in the chat to the Runify demo. Some people were asking for that. Absolutely. While you do that, I think now is a good time to get into discussions around who does this impact and what benefits it can bring. And I want to get a few perspectives onto here. For example, there's library maintainers. There are crowd application developers. There are highly interactive experience developers. So like segueing from Paolo's demonstration, it seems like that optimizes for the use case of having very interactive data or interactive complex visuals in front of you. And reassigning an object that big can be very expensive and svelte for. Whereas with fine-grained reactivity, you can click on a few buttons and update just one part of it with very minimal if not no boilerplate does that seem like the answer to that scenario if you yeah exactly yeah hunter by the way would you have any insights to these complex interactivity examples well my biggest thing is when what I think this really helps address is like when you need stores that use the values of other stores that use the value of other stores like when you're using them outside of the context of a component it's not as simple as being able to throw a dollar sign in front of it and get the value, right? You have to run through an update. You have to, and so that means you need to intercept the original update. That way you can then get like, so say that I wanted to create like a store or some type of higher order store where I pass in a store to that higher order store and it keeps track of the previous value of the store. So as the store updates the previous value like that, it would return a store essentially with the previous value of that store. Again, a use case for this might be if you're building some type of thing and you want to do like an undo button, right? Relatively simply. For any arbitrary store, you want to keep track of the previous state of that store. And so to do that, you basically have to write some custom store logic where you intercept the update from that store, set another store within that update, and then return them back. And it just becomes really messy. Whereas with, you know, the getter and setter ref example that I showed, you can just add a second state up there to that or pass in a ref or whatever, right? Higher order ref, whatever we're going to call them and just update the state whenever the set function is called. Right. So it's like it really becomes complex when you have deeply nested stores or stores that are consumed by their stores that are consumed by their stores. I think will really pay off for some of the libraries. Very cool. So yeah, that's like the library perspective. And also, I didn't think, that sounds almost like, I lack experience here, but I'm just throwing you this word out there. It's like RxJS, where you want to be able to traverse changes in the store or changes in a variable, and things like an undo button and tracking that state can be more than possible with runes. Is that right? Yeah, again, it's possible with stores. And I was just trying to find the thing I was working on yesterday where I implemented it, but I've had so many rebels, I've lost all the links. I going to have to rewrite it But again when you start to see even just the last previous value if you just want to look at that as a very basic example you can already start to see the divergence or in complexity that you have to understand from like if you using stores versus you're using reps boxes signals uh whatever you're going to call whatever we're going to call them um in swap five and then if you wanted to track you know the last two values or the last three, that's where it really starts to become complex. And you're like 10 levels deep with updates of updates of updates of updates just to access the current value of that store. On top of that, you have to essentially make the store that you're updating a custom store as well so that you can intercept the update. So it becomes a bit much. I see. And Legrish, thank you for correcting me. RxJS is closer to stores than runes. Yeah, I guess I was oversimplifying my comparison because the way stores today are written is probably resembling closer to RxJS. But with these helper utilities and these wrappers around the state rune, you can achieve similar functionality but with better reactivity and performance. Did I summarize that well? Yes, 100%. I hope so. You're talking to me. I'm talking to everybody. But yeah, I'm actually the imposter in the room. So I want to segue to an open discussion. So everybody in the chat, feel free to join us on stage if you wish to use your microphone. Otherwise, we're now accepting questions and live discussion. So the thing I want to talk about is a personal one. As a Svelte user myself, I make mostly CRUD applications, mostly user event-driven applications. And all of the benefits shared by you and Paolo, although very valuable, don't apply at all to my use cases at work and my day-to-day. I usually write pages that contain some content or data tables, and I want to react to button presses, form actions, and very basic stuff. I actually never wrote a store before because I never had the need. And some of you in the chat, I saw some of you writing examples of stores and derived stores being fairly straightforward for most cases because you have like a handful of stores and then a handful of derived stores, and that's like seven lines of code, but they're not nested. They're just top level and they interact with each other because they're derived. So I want to hear from you in the chat. Do runes help you write your code bases better? And these are the scenarios that Paolo and Hunter weren't particularly talking about. These are just.

 the basic uses of Svelte, the basic pages and components. So I want to hear from you in the chat. And maybe we can do a quick poll in the chat. Let me just catch up on the chat right now. So what is everyone talking about? RxJS and stores are observables. Runes are not. Hugo says, my questions about Svelte 5 are related to Svelte Kit. One, how will built-in stores work? Page, navigating, et cetera. Two, has any effort been made to integrate with Svelte Kit? and three, will this mean SvelteKit 2 is coming soon? Reason I'm asking is because Svelte is great, but building apps is done through SvelteKit, not Svelte alone. Yes. So this is something I can resonate with. So there's no official word on SvelteKit 2. There's no official word on runes and stores, such as the ever-useful page store provided by SvelteKit. But I can imagine that if Svelte 5 runes were to play a role in SvelteKit, I think our end-user experiences may not change very much. In fact, if the page store becomes something like a page rune, then perhaps you would drop the dollar syntax. But there's zero official word on any of this. So I'm just speculating what SvelteKit 2 might look like. But I would imagine it would not change very much, if at all. I suppose if Svelte runes are the future and stores are on their way out, then there might be some syntactical changes. For example, you can't use the autosubscribe shorthand for stores, theoretically at least. so yeah not a very satisfying answer but it's the one i have further down we see nasa writes i actually tabbed into the server to ask if anyone was building a non-crud application because it felt to me like felt was optimized for classic applications and we got a couple reactions there yeah let's get some emojis in the chat give nasa a thumbs up or let's see what other types of projects you're making so let me type a poll in the chat what kind of apps are you making static library three a crud four and enrico honestly like up until i started to i guess dabble with the UI library piece with Melt and Shadzee and Svelte and all that Like I had rarely needed stories as well If mostly again I think someone mentioned like a light mode toggle that was a really good use case for them as well as, again, if one of your, if you're doing, like, Firestore or SubaBase Real-Time when you want to have those subscriptions set up. But, like, it was, so I honestly never saw, again, if I had never dabbled into, I guess, more reactive UI type of stuff, then I would definitely see how this update would be kind of like, why are we doing this to me as well, probably six, seven months ago. I see. So let's bring that Melt UI perspective in here. So when it comes to application development, which you also do, do you find that if you weren't working on a library, you wouldn't quite immediately see the benefits of runes? 100%. Yeah, I wouldn't. and and uh yeah i think that's that's been one of the things too that i'm excited about it because i feel like it's going to increase adoption of i think other one of the things i see is it as a negative of the runes is oh it's like react now or oh it's like view now or oh it's like solid js now and i don't think any i don't think those are necessarily bad things um that they're i guess similar in a sense of like syntax i guess you could say um because that means other people that may have been on the fence about Svelte. They are very interested in Svelte, but it was just so vastly different and they'd have to relearn all these terms. Whereas again, obviously use effect and r effect aren't the same thing, but they can be compared to one another, right? It would be easier to make that jump, which would then invite more people into the Svelte ecosystem and is more familiar to people who have built incredible libraries for other frameworks or other languages to come into Svelte and be able to increase the adoption of it. I think it's a win. Yeah, that's an interesting insight. We can talk more at length about the perspective of veteran Svelte users, new Svelte users, and also people looking at from the outside, people not using frameworks or using other frameworks, and what their impressions of Svelte were versus their impression of Svelte with runes. Definitely perspectives have changed, mostly positive from what I've seen around the internet. But I also want to address the chat directly. There's a couple of messages above. Pardon me, I have your name censored due to streamer mode, but I writes, from a business perspective, runes are great. People will have a hard time moving away from a Svelte codebase after they riddle all their vanilla JS with runes People will have a hard time moving away from a spell codebase Oh that almost sounds semi Props add boilerplate I had the opposite impression. So my question for everybody in the chat now is, I posted some options here. Answer in the chat number one, if you are primarily a library developer. Two, if you're a static site developer. Three, a crud developer. Four, highly interactive developer. Or five, other. I want to hear from you, all 55 of you, just to see what sort of applications are you building today, Wisfelt, most of your time. And then we can talk deeply about how runes influences your impressions and perhaps some niceties it might bring. Okay, the chat is now flooding. I see a lot of number fours and threes, which is three is for crud, four is highly interactive. Yeah, when I say highly interactive, I mean like there's a lot of things you're rendering on the page on a button press. It's a highly visual, perhaps even graphical application. Things that require a ton of state change. If it's just like you click one button and one thing has changed, then I wouldn't consider that highly interactive. That's just sprinkles of reactivity. Let's see what else people have. Some people are, very few people are library developers, and that's generally true. Like libraries serve a large developer base of hundreds, if not thousands of developers. So that makes sense just statistically speaking. There are fewer library developers than there are application developers or cred developers or what have you. Scrolling further down, I see mostly three and four, a little bit of two. Two is the static site, like a marketing site with maybe one or two interactive pieces, maybe a single form action, like a contact form. That's mostly category two. Nobody said category five, which makes me a little proud that I captured such a wide net. But some people are generalists that do a little bit of everything evenly. Perhaps you are a developer lead and you're building internal tools. Yeah, I'm just doing the Twitch thing. Sorry now. So emojis are always fun. Okay. So I get the impression that most of you are writing applications. And I want to hear from all of you really what what has been your now that you heard this chat and this primer and you read the blog and you tried runes out for yourself can you name one or two of your biggest optimistic impressions or perhaps some things that didn sit well with you that you wish can change or backpedal? Whatever the case may be, you can talk openly about it. You can also join us on stage if you like. Let's read some comments first. Oh, writes, should have used emoji reactions. Yep, sorry. Blake says, I also develop static stuff, but I prefer other tools. That is true. Captain says, 60 FPS interactive canvas stuff. That is highly interactive. Hugo says, if my one library of 50 lines counts, I am a lib developer. But are you a library developer primarily? Do you spend most of your work week doing library stuff? Didier writes, use this message for an emoji vocal. Thank you for that. So now we have a new poll above with emoji reactions. That's a bit easier to process. And it looks like the winner is still CRUD and highly interactive apps by a large margin. Some static, but not as much. RainLife says I mostly use React, but there's also a mix of CRUDs and static or interactive apps. Wish we would switch to Svelte. Yes. okay so we have a big question in the chat currently we are planning to rebuild a website that receives a million users per day the website was initially built as a cms and is going to have a large number of components we are trying to decide between two front-end frameworks oh is this like a business question or a svelte runes question i sorry i can't help you with that if it's a business question. You might want to bring it into the forum channels. Ibi writes, optimistic impressions, fine-grained reactivity, especially with lists, distinction between derived and effect. Yeah, one of the things in the primer slideshow we talked about earlier was how the dollar sign labeled syntax is like doing double duty. One, it is server rendered. Two, it is derived values. And three, it is effects. Okay, that's triple duty. Who knew? But yes, with the rune separation, you can probably more easily learn and read and understand what's happening. And I have a bit of survivorship bias. Maybe I like the labeled syntax because I understand it and I'm used to it, but I want to listen carefully to your insights as veterans and newcomers of Svelte. Tante Kun says, I feel like...

 I showed props too much today. Effect is not my favorite. Keep it as the labeled syntax, but make it work only on the client, not the server. I see. The effect already runs on the client, only on the client. I think what they meant is the dollar labeled syntax, it does run with server-side rendering. Yes, yes. But make it only run the client. That's an interesting proposition with potentially big ripple effects. Everett says, I know this is a bit off topic. I wonder if Sol5 will implement tan stack query. I'm asking because Solid and maybe other frameworks are implementing their own versions right into the framework itself. I don't have an answer to that, but I think related to the demos Paolo and Hunter shared, yeah, perhaps some helper libraries can or will be made. Ibi has some criticisms. One, the syntax does not bring joy. to effect.pre does not bring joy and getters and setters feel, I assume feels boilerplate-y. Don't let me put words in your mouth though. So feel free to clarify your points. Isis, has the team thought of splitting out runes into a framework agnostic compiler like MobX? I'm not familiar with MobX, but the idea of it being a different compiler is something that they can probably take back because I assume your thought is this feels so dramatically different that it probably deserves to be its own library or framework. You can correct me if that's your actual impression and maybe we can distill that into a proposal for the maintainers. Ibi says, I still don't get where you'd use nested effects. I'm not sure either, but I think for those of you who voted for as a highly interactive web application developer, maybe you can help out Ibi by providing some perspective. I personally don't have my own perspective because I'm mostly a CRUD developer, just basic event-driven applications. Next is, Valerie says, is it safe to start a new project with Svelte 5? It's actually impossible to start a new project with Svelte 5 because it doesn't exist yet. Once the maintainers ship a pre-release or a beta release, then you'll be able to try it locally. Masso says, I build interactive apps My apps state is pretty big Runes seem very good to only re when small bits have changed I concerned about how far I can go in terms of customizing the state logic I see a hand raised I'll get to you. My app is mostly local, and what would be the backend in a traditional app is actually a WebAssembly module. In my case, I have some custom store logic to wire the two. Wow. that sounds like highly interactive very complex object state in stores and i guess overall do you feel like runes helps you with that or is it just meh like what's your impression and a couple more comments d says i'm using an object to stuff as much of the gui defaults as possible i think runes will make my life much better interesting i like the stuff that has been shown but i agree i think it does make a trade-off for less complex use cases, which can be annoying to some people. Very good, like. So, with that said, I invite you to the stage. Please join us. Hey, can you guys hear me? Yes, I can. Welcome. All right, cool. What would you like to share? Yeah, so I think it's tough to explain it in the chat, so I guess I just wanted to hop up on stage and maybe talk a little bit about my use case, which I don't really see it often talked about, but I come from like a, well, my, my most recent stint was a few years in Flutter. And there's obviously a bunch of state management issues with, with Flutter. And there's still, you know, there's different libraries and stuff that are competing for what the best way to do it is. So, you know, what, what I've ended up kind of learning in the few years that I've done this is that you really want to separate like your business logic, right? And try to make a hard line between that and your UI, right? And so with Flutter, you know, there's different ways that you can do that. But one of the most popular ways is using like a RxJS equivalent. So you basically create like this really intelligent business logic layer. It has no notion of UI components at all. It's pulling from different APIs if it needs to. It's zipping them together. It's doing a race condition between this API and the next API and whatever one comes first. And all of these really complex things that you can really only do with like a full out observable library, something that has operators and stuff. And so you know by the time it gets to your actual UI you really just kind of wiring into this highly reactive like business layer right And it's very, you know, the UI code stays incredibly clean because it's really just these little wires that, okay, all of this crazy stuff's happening in the business layer. I'm doing all this crazy observable stuff, but really I'm just wiring it to this local variable here. And whenever that changes, I just want to re-render that little component. So, you know, the way that I would be using runes is the thing that worries me is that it's going to start promoting people to use runes in their business layer. and for I guess my first question would be that would then if you're if you're creating your business layer using ruins you would then have to use the Svelte compiler right to to actually build that what what should otherwise be vanilla javascript or vanilla typescript you'd have to use um the Svelte compiler to actually build that business layer right so you become kind of locked into Svelte right and and things are always changing right so if you could if you're designing this incredibly complex app and Svelte goes away tomorrow, you want to be able to reuse your business layer, right? So that's my first question. And then my second question would be with stores, it's super easy right now to tie to an RxJS observable. And, you know, I'm wondering how that would look with runes. I see. Paolo, by the way, you still with us? yes i'm trying to port this example spalo is speed running this port yes okay so yeah can i get your name by the way or pseudoname uh yeah it's just paul hey paul welcome so i think um i'm not i'm definitely not the best person to talk to when it comes to rxjs i have no experience but i can talk a bit about your first question which is is it good for your business when we say business, you probably mean the main application you write for your job. Correct me if I'm wrong. And let me see if I can remember or rephrase the question. Is it about does Svelte provide lock or do runes provide a problem when it comes to porting code Did I remember right Yeah if somebody decides to start implementing all of their business logic using runes is that portable to if they decide to move to the next latest and greatest framework, right? Yeah, portable. That's technically, I think that's still an issue no matter if using React or Solid. Once you use something and your application is written with that framework, then porting is probably going to be a remake no matter what. Well, the business logic itself should be completely framework agnostic, right? The actual pulling from the APIs, deciding, you know, crunching the data, deciding all that kind of stuff, and then having some final observable variable that you then pass off to your UI framework. But that core business layer should have no notion of UI. I see. So this is a client-facing thing, right? Well, and that's the worry is that runes offer you. Runes, to me, it's like runes are compiler flags that, you know, if it's almost like if it's really going to produce this awesome, super efficient, compiled reactive signal reactive code, you know, I actually could consider using it in my business layer, right? Right. Even, you know, and that's why I asked the question of, you know, is it possible to split out the runes compilation or the runes compiler into its own thing that doesn't depend on Svelte? Because really what you have here is, you know, you have an opportunity to create like a very highly reactive pure JS compiler. Right. And then you can then consider using runes in your business layer and then actually wire them up to React components if you wanted to. So it would be kind of like this hard line between the runes compilation and creating pure JS reactive code and then just having an adapter that would seamlessly work with Svelte because Svelte 5 supports that. But then you can also use React or really anything else. I see. So you're sort of proposing instead of tightly coupling runes with Svelte, maybe make a library that's sort of competing with RxJS. Is that right? Yeah. I mean, that's the thing is RxJS offers the operators, right? But it's not compiled, right? So it doesn't have the smarts to know how to create really, really efficient reactive code. I mean, that's the trait.

 But with runes, you have this opportunity to wire things together because it gets compiled and have it be super, super efficient. And then the tradeoff, obviously, is not having debounce in all these crazy operators that RxJS offers. But then again, you could just add that maybe as a runtime library after the fact. But yeah, that's basically what I'm proposing. Okay, that's interesting. I think the maintainers or a handful of them are in the chat listening. So that's a proposal they can keep in mind. Maybe what you're proposing is keep the Svelte 4 way of working, but also abstract away runes into this universal tool that can give Svelte the power of signals that's opt-in or any other application. Is that right? Yeah. Yeah. And that way, if you choose to use runes in your business layer, you're not technically tied to a certain framework, UI framework, which is a big no-no, at least for me, which we've gone over. But yeah, that's basically it. So thanks. Thanks for letting me express that. That's definitely, it was hard to get that out via text. So yeah, thanks for letting me up on stage. Yeah, you're welcome. I'm glad I understood. Thanks. Cool. So we're going to wrap up soon, but I do want to give the opportunity for one more speaker or question. So let me just catch up on the chat and I'll close off with a poll. I do want to get everyone's like current impression of runes before we sign off. So let's see. i agree with this point uh let's see not just portability but testability it seems that people are are receptive to what paul proposed a minute ago so that's good to see in the chat and would astro provide what paul is looking for i'm not too sure does astro have an rxjs like compiler i don't know chroma wrote you can still isolate your business logic in normal js modules if you want to expose them through runes like today i suppose because runes are available in JS files, maybe they have a point. Captain says, similar to database choice, abstracting things for potential reuse, switching versus embracing specific tech for features and dev speed. Yeah, this is the whole microservices mindset, because if you want parts of your application to be independent, then you can easily switch out your front-end framework. And for some people, that's a must. Naso says, the concern is how easy it is to connect the business part to the reactive part. Yeah, I can't imagine what Paul is writing, but it seems to be like a really complicated perhaps data business insights application I just throwing ideas out there I can imagine scenarios where yeah the longevity of that business logic must surpass the longevity of any of the other parts especially in the front end. Tante-kun says, I want to speak about runes from my perspective as a component library author. Sure. Come on down. Hey, can you hear me? Yes, go ahead. okay so I write a library it's called I don't know how to pronounce it you can find it on GitHub actually it's basically like a wrapper around melt UI but styled with material design so runes don't the effect rune it's kind of annoying for me because it's a little boilerplate. Can you open the GitHub repo for a second? I want to show you an example. All the way down, you can find that I have a lot of reactive statements because MeltUI uses stores. So when the prop changes, I need to somehow tell Melt to update the store. I have at least five, six, seven reactive statements for each component. and so the effect prop, sorry, the effect room makes it a little too boilerplate to do it, which is why I'm not a fan. But the prop spoon, it really, really helps because look at the prop declaration of, like, scroll up. I have, like, one prop for each melt option, and And I want these to be required because I'm giving them default value, so I have to take the $props and do it required, and then for each prop I have to write export let, the name of the prop, and then declare the type equals the default value and it gets really annoying really fast. $props makes this super easy. spoiler plate I only have to declare the type ones and it's just way better I don't understand how anyone thinks export that any better than the new dollar props I just really like it I see are you reusing types in the new props rune is that why you like the props rune Yes I don have to declare the props like eight nine times and the export that eight nine times It's super annoying. I see. I was speaking to the meld UI component authors, and sorry, not component, the library authors, and I was speaking to them about how maybe runes can make using melt easier in components so that we don't have to do the reactive statements at the end to update the props. Maybe runes can help with that. I'm excited if that's possible. They weren't sure yet. Okay. Please, for posterity, please add your proposal to the chat. That way we can refer back to it and the maintainers can see. thank you for coming on stage with us so i think we're going to wrap up soon paulo how how is your refactor going i mean i i think i kind of almost finished i am trying to understand like there's some weird thing going on but i we can wrap up and i can share these in this very chart as soon as I finish it. It shouldn't take me too long. And obviously, for the moment, I just basically rewrote the writable and the derived to make this work quickly. Sorry. Can you zoom in? To make this work quickly. So for the moment, I mean, this might be written better because there's a lot of dot value laying around. I am pretty sure that this can be rewritten to remove some of these. And for the moment, again, I just used, like I just wrote basically the derived and the writable to make this work. So I will definitely share this version as soon as I finish this. And I will definitely share a much more cleaned up version where you don't have to write generic functions and you can write specific functions. And this will definitely help with clarity. Cool Hold on to those URLs because they are ephemeral So maybe in the YouTube description below we share Paolo refined example And I going to close off now with a final poll Here it comes Please emoji react to this poll. What do you think of runes? Are they one, exciting? Two, okay. Three, meh, I can use the current or of the runes way. Number four, I prefer the current way. Or five, I really dislike runes. Please add your emoji reactions. This is not a comprehensive survey. Obviously, it would be ideal if I could profile everybody about the kinds of applications you write, your experience levels, and as well as your impression of runes. But this is just a very informal quick poll just to see. Yeah, six not decided. Go ahead. Put in the number six if you're not sure. We're putting the five people on the list. yes we are keeping track of everyone who's not liking runes and we will get like there will be consequences it's fine no we do want this this statistic as well because if you don't like runes and we know then we can find you in the chat and we can talk to you about it because we want to see what examples you've shared and a lot of the things people shared in this felt five runes chat channel has been mostly constructive from the majority of people have shared their experiences where runes fall short or where it really helps with their workflows we want to hear from you yeah absolutely and obviously as we said this is a work in progress so obviously i was joking before but this is actually a way to skew the the future of the svelte framework because if you have use cases where runes does not work or where something else could work better please please please share them so that we can like talk about this like I said we but I should have said the maintainers because obviously it's up to them yeah Paolo and I don't know everything we're just here to make sure that things are understood and things are and people are being heard that's our goal today okay the poll is mostly over we got 17 people saying they're excited for runes we've got nine people saying runes are okay we've got no one on the fence

 Oh, actually, I guess number three is you're on the fence, but option six is you're on the fence as well. Four people are on the fence or undecided. And three people prefer the current way in Svelte 3 and 4, and a couple of people dislike runes. And that's okay. We wanted to hear from you because if there are deal breakers, it's important to bring those up because there is time to change things. There's time to improve things. This is a very early impression. the Svelte maintainers went through allegedly 60 or so iterations of runes internally so they wanted to present to you with their best foot forward what they think can be the future of Svelte so that now we can have this quality conversation and with that said we're done all of this just to say thank you so much for this conversation and the conversation's not over yet so stay tuned everywhere you learn about Svelte and we'll talk to you next time bye for now