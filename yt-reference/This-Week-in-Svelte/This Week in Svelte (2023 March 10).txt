 Hello. Welcome to This Week in Svelte. This is a hopefully weekly event where myself and some potential co-hosts talk about the various things, conversations, questions, and announcements that happened here on Discord. My name is Enrico. I'm one of the ambassadors of the Svelte Discord, and I'm just here to have a good time, learn a thing or two, share things that I find to be interesting, but also learn from you as well. okay and that brings us to the agenda first we'll get started with the change log and then we'll move on to some quick facts that i'm just here to share with you and in about 10 to 15 minutes we'll have a community showcase by by a couple of our members i'll introduce them in a few minutes following that will be some discussions and then finally the common questions and answers that happened this past week. And with that said, let's get to it. Can't hear me? Oh. Okay, yeah, the microphone's working. You can hear my voice, but you just can't hear the computer fans. I was scared for a moment. First time recording. You know how it is? Okay. So let's get to it. The change log. And as I bring it on screen, I'm going to also record the Discord chat. So when this eventually goes on YouTube, you'll see everyone's chat. So what's up with the change log? We've got a new Create Svelte prompt. Let me show you. Also this past week on YouTube, the Svelte Society channel had released a monthly dev talk. I think it's there on their channel. So if you go to Svelte Society's YouTube channel under live, you'll see a very recent dev vlog featuring Rich Harris. This occurred a few days ago, and there will be another one in four weeks. So this is hopefully going to be a monthly thing. Check out Svelte Society on YouTube to subscribe, but also here on Discord you can find the event details as well Now for the changelog log there a new create svelte prompt Let me show you So let get the terminal going Okay I just go to one of my folders and check this out. So in the terminal there is a new a new way to start a Svelte project with some interesting new prompts. They're going to look something like this. So you do npm. We'll do pnpm. It depends. Is someone in the chat going to make fun of my npm message? I'll use npm. npm create at Svelte. Sorry, create Svelte at latest. And things look a little bit different if you haven't used this in a couple weeks. So you install the latest Create Svelte. And then it prompts you for your project name. I'll call this Create Demo. And then it asks you for your template. I'll do Skeleton. And then it asks you if you want to do TypeScript. I'm a bit of a chaotic person, so I'll use JSDoc. And then lastly, there's this new interesting prompt that is a bit lesser known. And I want to highlight how to navigate this. So we've added a description here. You can use arrow keys to go up and down and decide if you want VTest with Spacebar or ESLint. And you can toggle that on with Spacebar. Or you can toggle them all off. Once you've selected your preferences, press the Enter key. And then your project is now scaffolded. So that's the newest prompt. It's not really this week, but it's like last week's thing. I just thought I'd go over that because several people have asked about it. And now you know. And that's the change log. Next up is quick facts. Guaranteed to be quick may be guaranteed to be facts. So the quick facts. First off, we have link options. So over here, I'll bring it on screen. So did you know that in SvelteKit you have several link options available to you So in the documentation under Advanced go to Link Options And these are some data attributes that you can add to your hyperlinks For example, well, not just hyperlinks. So in this example, you can preload data. And that is added to the body tag. But there's also some hyperlink effects you can add, such as SvelteKit Reload. So what this does is usually in a typical SvelteKit application, once the page is loaded and hydrated and JavaScript is present, as long as you do not disable client-side rendering or deactivate JavaScript, then it'll progressively enhance out of the box, which means when you navigate from page to page, you'll have things like invalidation put into effect. And there's a document on invalidation here within the SvelteKit docs. But in addition to that, this data attribute will force the hyperlink to reload everything. So it's like telling your SvelteKit application, I want this hyperlink to invalidate all, except without using JavaScript. It's just a strong, informative thing. Invalidate all, just for quick reference, is something you trigger with JavaScript to call every load function up the cascade of nested layouts and pages. So if you're on a page and it has one layout or that layout has several parent layouts, you can count on invalidate all to invalidate every load function and then call them once again. So it's like emulating a full page load. If the user were to hit Control-Shift-R, Command-Shift-R, depending on their browser OS, and do a full hard refresh, this emulates that effect. But you can also do that with Data, Svelte, and Reload. But I won't go over all of these in details. I just want to share the fact that link options are a thing. It's a quick fact. Quick facts, everybody. The next quick fact is cross-component communication. some folks have been asking what's the best way to communicate between components and have a demonstration let's zoom in okay so the short answer is you can use felt stores you can use forwarded events in some cases you can use context with stores but I just want to go over the two most common tools in your tool belt if it felt kit and you communicating between layouts and components you typically want custom events or more likely stores So here I have a layout or rather imagine this is a layout, and imagine this is a page. If you want a button to focus on the search input, I have two demonstrations for that. The first one is using event forwarding. So here on Line 28, it says, let me zoom in some more. Why not? More zooming. If you ask me to zoom, I will zoom. This button is just a button forwarding onClick, which is necessary. And thanks to line 1's onClick, I can use it in the paired component to pass in a handler. And the handler on line 13 will call search.focus. And on line 17, I wrote bind this equals search. My variable search is now an element instance. So clicking on I want to search focuses on the input. Very good. So let's say you have a search input on your layout in the header area. This is one way to communicate between these two separate components, between a layout and a page. The second is using a store. On line 33, let's add some new lines and let's close this banner. There we go. On line 33, we have a store button. And I'm not using events. I'm just calling the component. But what is this component doing? Well, this is the store button. It has a button element. And then on click, I'm calling a function, anonymously described here. And then it subscribes to focus search store and then calls focus. Focus search store is in my store file. It's a writable store. And it defaults to nothing. So what's really happening? So the store button imports the store, and then the app that's felt on line 6 imports it as well. And then on line 11, I wrote a reactive statement to assign the search variable to focus search store. Okay, let me know if my brain is getting twisted up. But on line 17, we know that search is an HTML node instance of this input. And on line 10, it'll eventually become that once the page is loaded and mounted. So the reason I have a reactive statement is to avoid erase condition. This will be null at first, but it will eventually be a node instance eventually. It will update the store, the store will be activated, and then clicking on it works as expected.

 There you go, two ways to communicate between components. If you have any questions about any of these, let me know in the chat and let's move on. The next is a bit of a demonstration on accessibility. I wanna do this every week, so let's see if I can do one now. I created a project called this week in Svelte and I'm using PMPM. There's some, oh, Chinese, oops, Chinese keyboard. Okay, PMPM run dev. There we go. So now I'm going to showcase an accessibility demo. Yeah, I'll share it in the chat in a moment. So in the chat, I will share this cross-component REPL. There you go. And I'll also share this repository in a moment. Just got to bring it on screen. Local host. Alrighty. So what I'm going to demonstrate, first time using this guest browser, is the importance of underlining your hyperlinks. I'm using the Chrome Dev Tools, which has a rendering feature down here. So right now I'm in the console. If I go to Vendoring and I scroll down to Emulate Vision Deficiencies, over here you have a few options like Blurred Vision, see it blurs the page for you, Protonopia, which emulates red color blindness deficiency. I'm going to select Achromatopsia, which will turn the page into grayscale. So these emulation options are great if you want to test your site in grayscale or with various color blindness. I spoke to a friend who has Prototopia, and they told me that these emulations don't perfectly resemble what it's like to live with Prototopia. So don't consider these a 100% certain way to test these deficiencies, but they're better than nothing. So let's focus on achromatopsia. If I go to links on a page, here's the page. Pop quiz. Can you find the hyperlinks on this page? I give you 10 seconds Can you tell me the label Which one is a hyperlink? Alright, let's identify them using the keyboard. So the first hyperlink is everyone you know, and the second hyperlink is settle. And that's it, those are the only two. However, maybe you have really good screens with very good contrast. Not everyone does, and some people are outside, or some people have different vision deficiencies. And this is exactly why underlining your hyperlinks is so important, because color alone does not distinguish these two interactive features. So let's make a fix. Oh no, I changed repositories. hang on, let's go back to this weekend's felt yeah, it's very hard to see so I have this open source repository I will share in the chat as well called this weekend's felt and I'm going to make a patch release so I have my CSS files on the left and I'm running this computer at 5 frames per second Not just on Discord, but in real life right in front of me. Here we go. So I have my color, font weight, and finally a text decoration underlined. Let's see what the page looks like now. And if Vite does its thing, it should just be underlined. Oh, it won't be because Vite closed. I closed it. And pnpm run dev. Am I using pnpm? I am. Ixy asks are you demoing an accessibility test in VS Code? not today but I'm always down to test stuff maybe next week I'll do a voiceover lesson that'll be fun I'm using everything I'm using Yarn and PMPM and NPM I'm using everything I have to it's complicated but the good news is here it is here's the underline this is good we can ship it So I make a commit and away we go And this is a fix Add real compliance This is a fix because accessibility issues are not accessibility issues they are bugs You must label them as bugs and fix them as bugs Git push And we good So this is found at github slash get you trained slash this loop in Svelte. And as these weeks go by, I'll add more demonstrations and examples. Here's the link. Alrighty. That was a quick-ish fact. guaranteed to be maybe guaranteed to be quick maybe guaranteed to be fax the next demo is Chrome 111 check this out let's bring it on screen so lots of browsers have had exciting releases I won't discount Firefox or Safari they've been doing some cool stuff but in Chrome 111 there was a new edition called transitions API. This is not stable. It's not available everywhere. In fact, let's go to caniuse.com because it's our favorite resource. And let's go to transition API and take a quick look at this. I think it's this one, navigation API transition. So Chrome had it under a flag in 110, fully released in 111 stable. And Edge, of course, is a Chromium consumer, so it has it, but Firefox and Safari don't yet. So it's still not stable. It hasn't met massive adoption, but you can still use it as a progressive enhancement. And I know I'm presenting at five frames per second, so I will just share this in the chat, and you can check out this demonstration. The demonstration being, I don't think JavaScript is used, but this will allow you to do animations and transitions between two static pages. so like this one is slash how I fixed my transform and if I go back, the hyperlink changes and all of these are separate static HTML pages but they have, oh yeah, thank you Patrick let's double check that view transition there we go, ooh, that's much more accurate I see red but that's okay We'll see green eventually. And I'll share the demonstration here in the chat. Try it out on Chrome 111 today Alright what other quick facts do we have That the last one So thank you for listening to Quick Facts And let's go back to the slides where I introduce our community showcase. So today I have invited a couple of special guests. We've got Spidey Zack and their associate Quantasium. And they're going to demonstrate a new markdown tool, I believe. Why don't you both raise your hands and join the stage with me? Hello. Hello. Hey. Hey, welcome. So I'm going to stop showing my screen, and let's take a look at what you have to share with us today. Want to tell us a bit about what you built it and why you built it? Right. So we are building a, I guess you call it a Markdown compiler. So it allows you to write Markdown in Svelte or other JS libraries, and it will compile it at build time to HTML. Very cool. Do you want to have slides to share with us? Yeah. And we also have a quick live demonstration, too, that I can just show. Very nice. So can you guys see the presentation? Yep, we're just getting it on screen. Ready? Ready when you are. Okay, so... Welcome to our presentation about Chroma. A simple framework for integrating Markdown with Svelte and other UI frameworks. So, Chroma lets you write Markdown in frameworks like Svelte with Chroma tags. which are surrounded by square brackets. As you can see on the slide, Chroma will automatically compile your markdown to HTML at runtime while keeping Svelte code, so allowing the TXT variable to be compiled by Svelte. So you can see here that we have Svelte code with, for example, a dynamic variable TXT. And then you can see when it gets compiled, the chroma will allow you to replace the curly braces for TXT with the value of TXT.

 To tell Chroma where to compile your markdown, you use a square bracket tag as shown on the... Oh, wait, what? I think you wrote the wrong thing. Okay, whatever. Chroma tags are bracket tags that the Chroma compiler will look for at build time and replace them with compiled markdowns. So there we have an example of what Chroma tags look like. Yeah, it will automatically extract the code from these bracket tags and replace them with the equivalent HTML. You can also use external Chroma tags to import a separate markdown file into your code by making the tag a void tag and adding the source attribute. As you've seen in the example, Chroma will import txt.md, compile it, and insert it into your code. By default, Chroma will count the number of... Yeah. I think you went to the wrong tag. Yeah. Sorry about that. So, by default, Chroma will count the number of spaces before your first line of Markdown, and it will subtract it from each of the following lines because Markdown is a tab-sensitive language. However, if you need to have a code block on the first line, which requires an extra tab, you can use the clause code, which is currently the pipe character, to tell Chroma how many spaces it should remove. Chroma will use the spaces specified by the clause code at runtime and remove the clause code at runtime. So you can see here that Chroma will find that clause code, and it will see that there are four spaces before it, and it will remove those four spaces from all your compiled markdown. Also, if you need to have a pipe at the beginning of your markdown without wanting to define the clause code, you can escape it by reshitting it with a black slash. A quick note, so currently any CSS that you have will affect the compiled markdown? So Chroma does Chroma work currently Massive progress has been made on Chroma but it still been only under active development for about a week and so there still a long way to go Many features will be buggy or will downright fail at the current moment but the entire framework should be ready by April 17th Yeah, we'll be submitting this for the Svelte packet. Chroma is built with Vite, which itself is built on Rollup and Svelte, as well as other GIS UI frameworks. It also uses DOM, purify, and tsdom for added security so that it won't interfere with the scripts. No injection attacks or cross-site scripting attacks. Yeah. Currently, you can use Chroma through two main ways, the command line interface and the static compiler. So for the command line interface, you would run npm create add chroma.js, and it would ask you some prompts and then scaffold a basic V project with chroma and the chosen framework, so let's say Svelte. Or you can use the static compiler with an npx command to compile your chroma from a source directory to an output directory. Okay, so roadmap. So our next plans for Chroma are to first finish up the CLI and the base compiler and documentation. We will also write a custom compiler and use inline CSS. So for example, for code blocks, currently there is nothing that actually happens, but we will be writing inline CSS or some kind of style sheet so that it actually somewhat renders in the browser. And we might also write a frontend JSCDN for purely static projects, and a compiler powered by WebAssembly and AssemblyScript, which will result in faster runtime and compile time. And yeah, that's our presentation. And I can give you a live demonstration real quick. I'm not my screen's a little wide so I'm not completely sure if you guys can see this but I'll zoom in a little so here we just have so we going to use the static compiler for HTML right now so we just have this basic HTML script and here we have an example of chroma tags with some markdown inside and we have an external chroma tag This is just to test out some JavaScript to make sure that our static compiler keeps all the files that you need. Here's our external Markdown file, and then we have a simple CSS to demonstrate the effects of CSS. So we can run the Chroma compiler on this. and then we get this out folder and this you can see here it compiled all of our chroma and our markdown into html tags so now we can go view it in the browser and as you can see here we get this as our output so yeah that's basically it awesome thank you two for joining everyone give them a hand uh there are several emojis that exist with hands in them give them a hand thank you so much for presenting thank you and if anyone has questions uh go to the chat and spidey and quintasium i recommend you share your repository in the chat as well so folks can check out Chroma. And with that said, thank you for your community showcase and good luck at the hackathon. If anyone else has a community showcase, reach out to me and I'll include you at the next This Week in Svelte. Let's take a look at the chat and then continue with the show. Yep, thank you chat for giving the hands. All right, moving ahead. let's take a look at the show notes. So after Community Showcase comes Discussions. Let's get to it. This week in Discussions, I've got to show my screen donut. One moment. And we're back. All right so this week in discussions we have there was a recent share of the Astro blog on framework and site performance in the wild I bring it on screen and I share it in the chat as well Interesting blog, investigating current web framework performance. And I admit I skimmed it, but the takeaway was, what are some high-traffic websites today using the various front-end frameworks? how are they performing, and what inferences could they find. And this is a bit of an interesting take. Let me share this in the chat. There we go. So when you scroll down to the data and the frameworks, they compare things like Astro, Gatsby, Next, Nuxt, Remix, and SvelteKit. And there's also some WordPress examples. and CWD or CWV is core web vitals. So they ran Google's core web vitals assessment against many, many websites. And on average, they found that Astro performs at the top and then it goes down from there. However, they themselves called out some flaws with the data because age factors in as well as adoption and maturity. So it's no coincidence that the older something is, the lower it may perform due to the high volume of sites and the high complexity and nuances and best practices being followed over time. So as older frameworks fall to the wayside in this diagram, it doesn't necessarily indicate that the frameworks themselves are bad. It's almost always the case of how you wield it and how you make use of it. so the reason why this came up in discussions and why I'm showcasing it today is we want to sort of highlight the correlations and maybe call out like how could we improve these statistics and do these statistics really matter when you measure it at this scale it kind of does because if you look at can I use and you look at how it analyzes browser market share for example chrome Chrome 110 is 7.25%, Chrome 111 is 0.03%. These are just tiny indicators of how over time adoption market share increases. And since Astro and Svelkit are both very, very new, you tend to attract the enthusiast crowd first and some early adopter workplace

 this second. Personally, I come from one of those early adopter workplaces because I'm on a small, nimble team that can adopt something new. And we tend to, well, who can say other than myself, but we tend to try our best to build things that are performant and follow best practices. But it doesn't really matter which of these you use because almost none of them restrain you from best practices, such as good caching, parallel server requests, things like that. So I was wondering, what do you think, chat, of this article? Did anyone read this? Did you have any interesting takeaways? Let's see if I can focus on the chat. And I have. but my second inference is I think an interesting follow-up to this article that I would like to see is what do these frameworks do to encourage best practices or discourage bad practices and some things that come to mind are things like obfuscation it's easy to discourage a bad practice if you either don't document it or make it really difficult to find or make it really difficult to execute. For example, Svelte achieves this because its reactivity is very difficult to make not performant. It's very difficult to slow down. Once you create an assignment in Svelte, you can pretty much most of the time rely on that to react when it's supposed to. It's things like that. What do these frameworks and front-end tools do to both encourage it either by force or obfuscation. So in the chat we have, if Astro wrote it, yeah, it's a bit biased. But Astro themselves called this out. I'm not bashing it. I enjoy Astro. It's just that they also mentioned it in the conclusion down below. Limitations to this methodology. So, for example, they called out publicly available data sets that are ever-growing. and it only attract homepages. And what's another one? It says unexplored is the impact of their age. So yeah, I sort of doubled down the age, but it's also mentioned here. So they not ignorant of that fact It just the presentation is very green so to speak Well that it If there not much else to say we can move on to Q and A Alrighty. This week in questions and answers. Hopefully YouTube will automatically add flags to the video so that you can jump to these sections. If you're watching this on YouTube, of course it's recorded. Of course it is. So the Q&A we have, I'll bring it on screen, is how do I... Well, I was going to look up debugging resource maps and Vite, but I ran out of time. So maybe in an upcoming week, I'll dive into that. So there's one example I can share today. And it's right here. And I might have a few more. I'll just have to check my REPL bank. Yeah, sorry, XE, I don't have a debugging topic for today. but I will definitely keep looking into it. If anyone has topic requests, you know who to talk to. So, and yeah, I can probably preview that. The demo in front of my screen here is called Tooltip Breakout of the Box. So what's happening in this demonstration is you have a card on line four, and then you have a tooltip on line eight. And what's interesting about the tooltip or the popover is it's red, and visually it's breaking out of the box, even though the card class has overflow hidden. So this is kind of some CSS magic going on. Usually when you see overflow hidden, you assume that this box will get cut off, and it should, and it did until I did some things. On line eight, we have popover wrapper, which sets the position to absolute, and then the popover, which sets it to relative. So we have a couple of nested divs. And this is how you circumvent overflow hidden when you have a popover that needs to break out and show the full box. So this was solved a few weeks ago and I just thought I share that with everyone here I paste that in the chat Pretty nifty trick Alright, now let's go to the bank, to the Svelte Repo bank. I may have another common Q&As. There's inject styles, and I did go over cross-component communication, and reactive functions. So let's start with injecting styles. This was answered earlier today. This is a really bad color. So let me just make the color white. There we go. So what's happening here is back in a few years ago or a few five years ago, So I was working on a Drupal website, and the only way to customize the website was by writing CSS in a text box and then publishing your CSS to modify the website. So if you're building a website like that, where your end users can only or have access to the CSS, and you sort of want to save that in a database and inject it on the page, this is one way to do it. I don't know if it's the best way, but it's certainly one way. So on line four, let's assume you have a sanitized string here that contains style HTML and some CSS. This works because on line eight, we're using addHTMLStyles, and we're applying the styles on the page, making this button the color blue. If I delete that, it's the default button styles. And if I bring it back, you're styling your page. So the button here has a class BTN, and the user-provided styles targets the class BTN. and this sort of works as a loaded style sheet. Is this the best thing to do? It really depends on your use case. Like if you're doing database strings to client-side injection, yeah, this is one way. If you're building a static site, you probably want to compile your database strings into .css files that are actually cacheable and loadable. It really depends on your use case, but long story short, this is one way to inject styles. The style tag is necessary. Yeah, it should be sanitized. So a little red flag here, do make sure your strings are sanitized. I don't know if addHTML evaluates JavaScript because if it does that dangerous So because it a user provided style yeah you gotta go out of your way to sanitize this But instead if you were to do a file write and make this a file that static then you can trust the browser to handle it more safely. So I think that's the approach I would recommend. But as always, it depends. The answer to every development question is it depends. The next REPL is reactive functions. Let me bring that on screen. Oh yeah, I also made a game. But I'll show that in a moment. So we have tree view, vanilla library. Yep, almost running out of examples. of examples. But that's okay. So what I might do is end this early. If anyone in the chat has any common questions that they saw this week, we could try solving it real-time. Otherwise, I'll bring up one last example. 3, 2, yeah here's one. Take a look at this. So I'll share this in the chat like I promised. There is your inject styles and then the next example is dot components. It's broken, so we'll do some real-time debugging. Alrighty. So in different frameworks, you're probably used to the idea of dot elements like this. You have a select and a select dot option. And I broke it because... Yeah, because this is not the best way to do it. Usually you want to make a placeholder like index. or component index, I'll call that, .js, and you can do export select or default as select from select. import so that's

 I'll delete the below statement. What this is trying to achieve is making some sort of dot component that allows you to nest or contain multiple components in a single component. I'll go over the pros and cons in a moment. So I'm going to import them both, and then I'm going to export a combined one. I can say select dot select option equals select option. This may not work, but we'll try. export, select, and then over here we'll import again. Import, select, component index. Export, default, select. Yeah, I'm not using the default at the moment. I was going to do a named export, but we'll do default. Alright, it's broken still because the name is wrong. So option is actually select option. And now it still broken So this is select option this is select Oh yeah because I was trying to be fancy and import it this way So let's not do that. As you can see, the first con has presented itself. One, look at all of this boilerplate and setup you have to do just to achieve .components. Assuming I do get it right, this is sort of the repetitive thing you need to go over. If you're maintaining a component library with a lot of these, then you'll end up with a lot of something like this. The second disadvantage is the select component will include the .components as part of the JavaScript bundle, whether or not you use it. So if it's possible for your end users to do this, and do something like select items equals an array, then the JavaScript you ship will still include that option component, even if they're not being used. I don't think tree shaking is smart enough to know that a method as part of this export is not being applied. But the advantage, I guess, is there's some sort of developer experience advantage where you have all the components in a single import. It's one import statement. But my personal preference is to keep it separate. So you have something like this. What is the advantage of import star as lib The advantage there is you take your named exports So in the chat down here we have what the advantage of import star as lib It allows you to take all the named exports and convert it to a single variable. That's one reason. So let's import the select. Oh, maybe the imports have to be in a certain order. Don't worry about it. import select from select on Svelte. And then import select option from select option. I don't know why I'm getting these errors, but I'll delete this file because I no longer, well, I'll just comment it out, delete it. And then finally I can do select option. And it's probably saying empty because it needs a slot, so I'll say hello. Nope. Wow. So no worries. I didn't prepare this. But the idea is separate components is often better because you can compose your pages a lot more easily by importing what you need and not importing what you don need And if you do happen to have an index file that can import both of these then you can go for that as well And there you have it So dot components versus regular components. Well, that's all the time I have. So let's take a look at the chat one last time. If you have a normal index and then the user uses the star import, yeah, that's true too. So ideally you can have a much more pleasant experience if you do import select, select option. It's still not dot notation, and you can say select an implied index.js. You can delete that in some cases. Something like this is good too, because everything's a named export and it's a one or two imports. So it's only a few extra characters, but you get the benefits of tree shaking, you get the benefits of deliberate composition, something like lines 9, 10, 11, where you deliberately compose your views using just the components you want to use. And with that said, I will wrap it up. So thank you everyone for joining this week in Svelte. If the recording worked correctly, then you're probably watching this on YouTube right now, and I thank you for sticking to the end. Have a nice day, everyone. Bye-bye. Thank you.