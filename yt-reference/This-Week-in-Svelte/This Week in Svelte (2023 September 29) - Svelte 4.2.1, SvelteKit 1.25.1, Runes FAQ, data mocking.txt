 Okay, welcome everyone in this dark version of This Week in Svelte, and that's just because I am presenting my screen. I am Paolo, and joining me there is Enrico. Hey everybody! And today I will be your host, and this is This Week in Svelte. So let's begin with the usual agenda. So here's the agenda for today. We have the changelog and we have a changelog both for Svelte and for SvelteKit. We have some quick fact and announcement. We have no community showcase and we have a probably long this week discussion and we have a bit of a Q&A. So, let's begin with the changelog. We can go to the changelog in Svelte, which has a lot of things, actually. So, we have update style directive when style attribute is present and it's updated via an object prop. Let's see what all of this is about. Oh, I guess this is a long one. I don't know. Do you have some insight on these, Enrico? Yeah, so I looked over some of these things, and a lot of this has to do with the Svelte element tool. So on the fourth bullet point, there were issues with, and I think the same person made like two or three pull requests. They were about spread attributes with props and the dynamic this. So if you go to issue 9.1.1.2, you'll see two issues were closed related to that. It's 9092. Okay. Yes. So in the issue example, there was a dynamic this variable in 9092. Okay. Yeah, right here. So notice how it's like sveltelement, this equals div, it's all good. But in the second code snippet, also let's zoom in a bit. In the second code snippet, this equals div, which is like a div string, which could also be a variable. For some reason, that was not applying correctly in svelte4. So Svelte 4.2.1 addresses dynamic this in conjunction with spread props. So those two things should now work together nicely. Oh, this is very interesting. Yeah, it's a bit of an edge case that I myself don't run into, but glad to see it. Yeah I mean one thing I noticed in our weekly run on the releases is that to this day I guess probably 90 of the issue are very edge cases And, I mean, it's good because this means that Svelte is stable. Yeah, it captures like a large portion of developers. We also have silence false positive reactive component warning. We can take a look at these. So I guess, yeah, I guess this is some warning from Vite. yeah okay i guess this is for svelte component that probably is trying to import something which is in a variable i don't know if you have more insight on this enrico yeah i looked over just the upper issues so overall this patch svelte 4.2.1 covers mostly edge cases that a few people run into. And it looks like the pull requests were contributed by community members this time around. So it's good to see that there are fixes there. And on the bottom two, there was an indeterminate issue with HTML attributes, which I suppose typings have been improved as well. Some of you may know or are a user of the Svelte HTML or Svelte elements types. So this might be a good thing for you to depend on more. For example, if you make a component and you want to type the $props attribute, you probably make extensive use of Svelte elements, which is the HTML types for HTML attributes, such as button or anything under the sun. Yeah. So without the indeterminate issue, it's good. Yeah. As you can see, indeterminate is an attribute that you can specify on the input of type checkbox to have a checkbox that is in an indeterminate state. So also very interesting, the fact that bind indeterminate is valid. So, but by now this is fixed. So if you never run into this issue, don't worry, because you will never run into this issue. And let's move on the SvelteKit changelog, which is fix correct line numbers in stack trace This was actually a fix in VIT I guess When you have an error in VIT it will basically try to use the source map to show you the correct line number. And this basically avoid calling these SSR fix stack trace in SSR. I also like, I know these because these actually involve an issue that I opened, actually a PR that I opened that I closed because these fixed stack trace could throw. And so this was a problem that it was now solved by avoiding calling these while also providing good SSR stack trace. Correctly return 404 when navigating to a missing page and the root layout fetches a pre-rendered endpoint. Again, this is a very edge case. So, okay, so you have a specific 404 instead of a 500 error when the layout fetch a pre-rendered endpoint and return internal server error. for pre-rendering websites. This is also cool. Allow optional param in middle root. This is also, like before, it was not possible to have a middle root with an optional param. And I read through this, and basically this allows you to have middle optional parameter if you have a matcher. Basically, these allow you to have a matcher for the middle type. And if the middle type, like, avoid confusion, you can actually have an optional parameter in the middle of the route. And obviously, there are some chore, like update undici, which is the fetching library. Yeah, it looks like in the chat, Moby was very happy to see the first changelog fix in SpellKit. So that's cool. And also the Undychi upgrade, it looks like it has support for HTTP2 now. I looked through the Undychi change login. I guess I should not be too baffled because usually a fetch request is singular. I not an expert in networking but it cool to see that the newest Undychi does support HTTP 2 in your fetch requests Yeah I mean obviously as you said it always probably a request but it always nice to have it because also I think we are heading through HTTP 3, right? Probably. It was about time that we could actually use HTTP 2 in fetch. So let's move to quick fact and announcement. And the quick fact that we want to share today is this video by none other than Rich Harris that launched his YouTube channel. And I will share this in the chat for your viewing pleasure. And on this video, basically, Rich tries to address something like what's the deal with getters and setters because if you have followed the introduction of runes you have probably seen these probably somewhat obscure syntax like JavaScript syntax about getters and setters and here Rich is trying to explain why gathers and setters are needed with runes. So it's a very interesting video and we hope that you will enjoy it. Let's move on to this week in discussion. I will present again. Again, we don't have a community showcase, unfortunately, but we have this week in discussion And the main discussion that we want to have is about this page, which is the frequently asked question in the preview. Like this is the docs of the Svelte 5 preview. And we have some update on this frequently asked question, which is very important because obviously a lot of you like this is a change. is obviously that you will have a lot of questions, but some of these are very frequently asked. And so we have this page to help us. One thing I wanna highlight on this page is on the third heading, breaking changes in migration. I'll go there and then zoom in a bit so that the side nav

 hidden. So what happened is since last week, I'll zoom in some more, please. Since last week, the breaking changes section on this page has updated. So it's a little bit clearer now what is planned to be deprecated in Svelte 5, 6, and 7, and what sort of Svelte patterns and features are here to stay. So below here, it says, no, but really, am I going to have to rewrite everything? And it says, our current plan is to have some or all features that runes make unnecessary, like let style reactivity, the labeled syntax $, $ props, and $ $ rest props will be deprecated in Svelte 6 and removed in Svelte 7. But don't worry, that won't happen for some time. It will provide automatic migration tooling. There are no plans to deprecate on mount or stores at the current time. And I think that sentence is critical. A lot of people asked in Svelte for the past week in our Discord channels, is on mount going away? Are stores going away and the definitive or official answer here at least for now is no on mount is here to stay stores are here to stay yeah absolutely this is very crucial and also like even the rest of the things that will be deprecated uh is it's important to notice that it will be deprecated in svelte 6 so you will get deprecation warning in svelte 6 which is nowhere near because even svelte 5 maybe we can get Svelte 5 by the end of the year but we are not sure yet so Svelte 5 it's a long way Svelte 6 it's even longer Svelte 7 where you will probably not be able to use those things anymore it's way way ahead so don't worry about rewriting all of your components all those things will be here um yeah and just to address the chat hugo's and oh writes uh why are stores staying and to paolo's point we're not sure the timeline wise when svelte 6 or 7 will come out it could be a year it could be 18 months it could be less than that i don't have an official word and really no one knows the future because svelte releases aren't an aren't an as ready basis but to answer the question about why are stores staying, I can give you a theory. And that is stores, especially writable stores, are very easy to create for single variables When it comes to like reactive objects or reactive arrays I predict that runes will overtake that need Because if you want an object to have fine grained reactivity doing that the runes way is probably more performant and also more maintainable. But for a single one-off variable, especially passed through context, I think there's nothing easier than a writable store. It's a single line of code. That also implies that the dollar sign store automatic subscription syntax is probably staying too for that reason. But I think the use cases for stores are becoming narrower and like one-off single variables, while the use cases for ruins are becoming wider. What do you think, Paolo? Yeah, absolutely. Obviously, like, I also think that they don't plan to deprecate stores because, I mean, they are a different thing. And maybe someone has an actual use case for stores and forcing them to rewrite everything in runes might be too much. So that's probably another reason why they plan to not deprecate stores. And I think it's a good thing because, I mean, we have choices. And also, as Captain Codeman said, you have the star stop. The star stop, I can't remember the last word, but it's basically the function that gets executed when the first subscriber subscribe to the store and when the last subscriber unsubscribe from the store, which is something that currently it's not possible with rooms. So there are small differences. And again, as you've said, Enrico, not everyone has to be, not everything has to be fine-grained reactivity. Because if you have just a single variable, you might not care about fine-grained reactivity. I don't know if there's something else that we want to talk about it. For example, this I think is something that gets also asked a lot, which is why can't we keep the old syntax? We have some reasons because, for example, the label syntax does not play well with TypeScript. You have no way of defining a type Also for example for effects Effect needs to return a function and is not possible with the labeled syntax And obviously, this is also like, this is something that we as a Svelte developer took for granted and now we are used to this syntax, but it might be confusing for newcomers. So having a clear function call, and I'm using air quotes because it's not properly a function call, can help newcomers to better understand the lifecycle, basically. Yeah, and I think this will be updated more and more as discussions happen. Because right now, runes are perceptively this primitive when it comes to writing reactivity in your client-side code. and I say primitive because it lacks helper functions. It lacks some wrappers to remove boilerplate, but it looks like those are emerging architectures that are coming from discussions. And I would not be surprised if this gets updated with new features and wrappers by the Svelte core team. So as we discuss more of our use cases and our shortcomings, then keep in mind this is a work in progress. I can't even call it alpha because there's no official NPM package. But this should be updated as we go along, and we'll keep you posted too. Yeah, absolutely. This is also very important because I get that these changes are scary because, I mean, you have to rewrite something, you have to maybe change the syntax of something, and when you are used to some kind of syntax, it might be daunting to do that. But one thing that I come to the realization is that this is a super work in progress. I mean, it's written here and it's true. Like, it's really a work in progress. And I think this is also like an interesting way of getting feedback, like give the user base the ability to get their hand dirty so that we can actually realize what is needed for the actual release. So I am very confident that all those discussions that are happening in the Svelte 5 runes channel here on Discord or on Twitter they are all pretty much watched like an effect Every time there's a new discussion, I'm pretty sure maintainers are notified so that they can actually take a look at everything and have a good discussion about what's needed for actual release of Svelte 5. And I think there was also Tante-kun that had a discussion about runes. So if you want to join on stage, feel free to raise your hand. We will give you the shareability. And here we go. Hey, can you hear me? Yes, absolutely. Yes, welcome. Thank you. Great, so I wanted to talk about how runes make it easier to write reusable components. Okay, so I have an example from my library. It's a slider component written in the old syntax. So this is what you would typically do. Oh, sorry, typo here. So typically you would just define the props type. Okay, extend the HTML element you're using under the hood to have properly typed REST props. And like initially you might think, okay, I'm going to define my props like this. So export let value define the type. But this is not correct. Like the types are wrong. This is typed as number array or undefined. Why? Because this is optional, right? So it has a default value, but the type is wrong. So how you might want to fix that is you do required around the type and use that required type. But see, this is really annoying and really repetitive. And yeah, you might argue like, okay, this is a number. TypeScript can just infer the type. This is a Boolean. Like, yeah, okay. It's not always that simple. And sometimes I actually forget to put one of these props in the types here. So using the types,

 like the source of truth, is actually much better because I'm sure that I typed it correctly. Otherwise, it will just type error. So how this might look in the new syntax, okay, you define the type the same way, but you declare the type once. And with the destructuring syntax, TypeScript can correctly infer that, okay, you have given value a default value. So this cannot be undefined anymore. So this is typed correctly as a number array. And the rest of the component is basically the same. We have some reactive statements here. I just changed the dollar label to dollar effect, and it looks exactly the same. I thought that I would hate this more initially, but I don't mind it, honestly, that much. But then I thought to myself, okay, why not go all the way? Why not utilize runes completely? So Melt, this uses Melt under the hood. You can't actually install Melt in the REPL, so I just mocked the functions here to just return the same interface. So I thought to myself, okay, what if Melt under the hood instead of relying on stores? Because look, this effect thing, This only exists because Melt uses stores under the hood. So you need to tell Melt to update the store whenever the prop changes. But if Melt somehow utilizes runes, and we have like, this is imaginary syntax, of course, we have like $ref that just compiles to a getter and a setter. This makes things a lot easier because then reactivity is no longer constrained to the scope of the component. You can just pass the ref and the underlying melt library can just update the ref directly and your component updates. No more dollar effect for every single prop. But that's like, again, this is me imagining what a syntax for a dollar ref could be. so this isn't actual correct code at least not yet but the pushback mainly with dollar props was with more simple components So I also brought in a simpler example with toggle. It only has two props. And yeah, export let here works really nice. It's not that repetitive. And there are booleans, so there's no need for type annotations. but like even with the new uh even with the new uh syntax it's it's actually still easier you just do this let press the equal fall disable equal false and spread the rest of the props you don't need to learn about a magical uh dollar dollar rest props thing like when i first saw this i was like wait what the hell what is this what does it do i have and yeah i did look at the spell docs and I understood it but this is weird syntax like this is this looks like magic can we all just agree that $res props is weird yeah and yeah that's that's just I feel like there's a lot of hidden potential that we haven't uncovered yet like especially with this example like doing $ref like that this is really nice if we can if the Melt library can actually utilize runes like that. It would make the experience of writing components so much easier. Yeah, I agree. And I think, like, I'm pretty sure that Melt will be using runes because this is something that especially benefits, like runes are a tool that especially benefits complex stores. And obviously, like, Melt, it's a whole complex store. Like, the whole Melt code base, it's a whole complex store. Yeah, I actually, like, sorry, I just wanted to say, like, I looked at the, I was making NPR, and I looked at the source code, and they basically reinvented this whole thing. They have, like, some effect function that runs whenever the store changes. They reinvented runes to make it work. Yeah, absolutely. Hey can I take a look at toggle Ah okay Yeah line 9 Line 9 So line nine we defining our props and we're exposing rest props using traditional destructuring syntax. One thing that I enjoy about line by line props is the ability to document them. I'm a heavy JS doc user, I know. But what I like to do is above every prop, like export let, pressed, export let, disabled. Right above that, I can add JS docs so that when you hover the prop elsewhere in your markup, you can see documentation for that. It also helps with generating documentation with Svelte, which is a library for taking your components or your .svelte files and generating declaration files along with documentation. I'm not sure using $props if it's possible to document your exported props. So with the old syntax, if you had $props, you would put your documentation here, not here. Otherwise, it wouldn't work. You don't really need that, though, when you write extends HTML button attributes. If you're extending something else, then yeah, it's necessary to write an interface. Yeah, but almost all of my components need to do this. There are just wrappers around an HTML element, so I want the users to be able to pass in any prop. Otherwise, I'm just constraining the API for no reason. Yep, I totally get your use case. Yeah. For the simpler use cases where you just, okay, don't need this. This is perfectly fine. I actually used to enjoy this coming from React. But when I started working on my library, I started to really hate export let because of the interface export let. the whole thing is just really repetitive and annoying. Yep, I totally get your use case. And this makes a lot of sense. I guess what I'm partially proposing is a dollar sign prop in addition to dollar sign props, plural. So we can have two rooms perhaps to define line by line props or multiple props in a single line like you do here with the structuring syntax. And I tend to avoid line four, which is the interface for props extending HTML attributes because usually my components have multiple elements. In your example, toggle.svelte, you have a button in your markup, but usually when I write components, I have more than just a button. I have a div here a label there or something else And can only apply to one element Whereas if you do something like the overload props I forgot what the pattern name is called, but you can actually have a prop be the HTML attributes that you want to spread into a target element on your markup. Oh, yeah, yeah. Something like what MI does. Cast-through props. They have props for every element that they wrap inside. yeah i know what you're talking about yeah so i feel like both of us can be satisfied if there were to exist a dollar sign prop rune that is singular in addition to the one you're showing here uh yeah but you would like have to find a way to do rest props with uh so you'd like have another rune for rest props is i mean how would you do that with dollar prop i don't know i haven't Yeah, actually, one more thing. So let me just open VS Code for a minute. So I had this really dumb bug. Okay, can you see VS Code here? Yeah, go ahead. So this is specific to my component, but I'm passing something as a slot. Okay, so usually, what I like to do is rather than do builder equals this, I like to define the value and then pass it down because I might want to do, I might have multiple slots that receive the builder. So I like the nicer shorthand syntax, right? Like this, this is nice. But here's the really annoying part. This doesn't update. Why? because this updates whenever orientation updates here. So if you put the reactive statement here, whenever this updates, this doesn't. This needs to be after orientation, the effect here, basically. So this is a really, really weird thing about Svelte's... What are they called? the dollar label. Yeah, yeah. This is really annoying. And I didn't understand why this even happened until I saw the

 there was the in the ruins page somewhere they had an example where you would set a variable and it wouldn't update because the order of the declarative sorry, the order of the dollar labels sorry, I forgot its name the order matters here, it's what I'm trying to say it's a foot gun this is one of the main things that they wanted to fix with runes, basically. And the reason why this doesn't work is because the label syntax, so the reactive assignment, that was the thing that you were trying to remember, just runs once per tick, basically. So if you update something and then you update something else in another reactive assignment uh like the first thing will get the sink basically so yeah this will be fixed with with runes uh yeah uh i just uh it's not obvious that's what i'm trying to say like i personally have it's a code style it's not important i just do the react uh sorry i just do derived props first then effects that doesn't work so i do now i do effects then uh derived props for everything to just work correctly yeah no you're completely right like the fact that is like this doesn't work it's not immediate especially when you come from the like from the usual way of thing working like the fact that if you are using $ colon you will expect that variable to always be in sync with the right side of the assignment so this is a very interesting point yeah that's all I have to say today thanks for having me thank you so much I also like your VS Code theme with the line numbers in order Thank you It actually it named it a Svelte theme It called Svelte Dark I think Yeah it Svelte Dark It really nice I just I post it in chat Thank you Thanks again And if anyone else wants to speak on stage you can always raise your hand That was an interesting bit of insight by Dante Koon Thank you. Absolutely. And yeah, if you want to speak on stage, feel free to raise your hand. Or obviously, if you have questions, if you have discussion, feel free to share them in chat and we can answer that. You're reading what I'm reading? Yeah, I'm reading that. Okay, you say that you would like to release Svelte 5 this year. When submitting a PR to Svelte right now, you are told that you may want to wait until Svelte 5 is released before submitting your changes. Does this mean that there won't be any realistic chance to get your changes into Svelte before the end of the year next year? I really don't know because the main point is that neither me or Enrico are actually Svelte maintainers we are just here to showcase Svelte so we actually don't know what's the plan I think they are working hard on Svelte 5 so obviously depending on the change it might be unfruitfully to have a PR merge now because if that PR then gets basically removed by the fact that Svelte 5 is released it might be better to wait. Obviously, again, it all depends on the changes, I guess. Because if you have a very important bug that is blocking your production release I bet Svelte maintainers will actually be probably very interested in solving that bug. Yeah, that's my interpretation as well. I don't have an official word or insight on the long-term support of Svelte 4 before, during, and after Svelte 5's release. but I assume that any contributions, whether it's new tickets, RFCs, or pull requests related to Svelte 4 might only be considered if they're one, small, two, a patch, or a bug fix. And that's about it. If anybody wants to introduce something, some radical change, like a new way to spread click handlers or automatically forward all handlers like big things like that will very likely be postponed for after Svelte 5 like a Svelte 5 feature release I don think anyone is going to accept that or review that for Svelte 4 at this time This is just my interpretation. Like Paolo said, we're not maintainers. Yeah, absolutely. Obviously, like there are big changes coming to Svelte. So it might be even like merging other changes might be a reason why Svelte 5 comes later. Because if you then have to adapt Svelte 5 to these new big changes, it can be problematic. So I bet for bug fixes and small features, maintainers will probably just take a look at your PR. With maybe a bit more, a bit less, they will take a bit more time because obviously they are actively working on Svelte 5. But I bet that they will take a look. Okay. Yep, that's as far as I know, discussion-wise. If anybody has other questions, otherwise we can go ahead and talk about this week in Q&A. And for this week in Q&A, there's actually a question that I can answer, probably, hopefully, which is, how can I in a very simple way mock my data in SvelteKit? And I want to showcase something. So I will actually, I have to remove these and I will bring my VS code here and I will zoom in. Let me see whenever you see enough. And I will explain all this mess that it's here. So what is this basically? In SvelteKit, SvelteKit, it's a very unique piece of software because you are using like this is an isomorphic application. And this means that it runs on the server. It runs on the client. It's a full stack framework. So you are writing the server code in SvelteKit you writing the client code in SvelteKit And this poses some problem when you are trying to test your application because there's no real way of testing the whole things as a one. So you can test the frontend, but then you are like, for some client, for some frontend framework, like for example, Ember or even React, you can very much mock the whole server and just test the front end. And this is useful because by mocking the back end, you can pretty much return every data that you want to your front end. And that's cool. With SvelteKit, it's a bit more difficult because you have the ability to write code both in the front end and in the back end. And so you have to move this line between what you are testing, because if you want to test your whole application, you should move your line between from between the client and the server to between the server and the database, which is something that you are probably not running in SvelteKit. So what I come up with when it happened, this thing, is a very interesting way of mocking your data because there are mocking libraries. There are, for example, MockServiceWorker, which is very, very cool. But maybe you don't want to install MockServiceWorker and set up the whole service worker thing to make this work. So a very simple way to make this work is this one. So as you can see here in the load function, I'm not actually doing any logic. And this is important because this way your get data, it's actually like separated and very well tested. Like the load function, it's pretty much a very small, simple unit that you can test. And at the end of the day, what you care about is your data. So if you can get your data, it's fine. So I have this data folder where I return, for example, a fetch. So I can fetch this placeholder, JSON placeholder thing, and return the response.

 And this is, as I've said, separated by my actual server. On the client, I'm just JSON stringified and with no problem. But one interesting bit is that together with my get data here, I get this other get data, which returns a mocked data. So here, basically, I have the same structure from my data folder, and I return the same function, but with mocked data. So how does this end up inside my root? And this is another interesting bit, in my opinion, because in the Svelte config, you can define an alias. In this case, I'm defining the alias as $data that point to source data, which is my folder, basically. This is my folder. And this means that when you run your SvelteKit build tool, what happens is that a TS config is created with the paths pointing to that library. And this is actually created by the VIT SvelteKit plugin. So what you can do inside your Playwright config, it's actually like I'm running the build with mode test. So what I'm telling is that I want to run this build function in test mode. And when you do that, basically what VIT does, it allow you to get the environment from this And if I run this basically I'm setting mocking to true. And what I do then is that inside my simple mock, which is a bit plugin, I do a very simple thing. So this is a bit plugin that I've wrote. And basically the only thing that it does is that it enforced post to basically tell VIT, okay, run this after SvelteKit runs. And then it changes the config loading the .env. So if this .env.mocking is true, what it does is that it changes the alias. So instead of having $data pointing to source data, it points this $data to .source.data, underscore, underscore, mocks, underscore, underscore. So this means that when you build your application for production, this is not actually run because the .emv that it's loaded is this one and here mocking is false. But when you run your test like this, this .env gets loaded, mocking is true. And so the actual data comes from this very folder. And this is very interesting because again, in this way you can have a defined mock for your data. And basically you cannot care about where the data comes from. Like at the end of the day, inside your server, you do not care about where you get this data. You just know that you want to get the data. So this is a very simple way to mocking your data. I don know if you have questions because it can get quite complicated So if you have questions feel free to ask And I will push these as soon as we finish this episode so that you can access these in this WiccansVault repository. So if you have any questions, feel free to ask. Enrico, I don't know if you have any questions about this. I do. Can you show me dash dash mode test? That is something that I know Vite has as a feature. I never understood it, but it looks like mode test will read in the .env.test file, and that's a built-in VIT feature, right? Yeah, exactly. When you run some VIT command, you can specify a mode, and this mode basically gets not only read the .env.mode, so you can literally call this whatever, like you can call banana, and then have a .tmv.banana. Wow. And you also get these inside your VIT plugin. So inside here, you read the mode. And so here is loading the .tmv of that mode. So this is literally whatever things you put inside the mode. I see. So you're listening to the mode flag, but it's your feet plugin that actually puts it to use. Yeah, exactly. Okay. It's an interesting idea. So this whole SvelteKit project is designed and structured around the idea of your load functions being very minimal and only calling business logic from external modules and having this folder convention of underscore underscore mocks inside every module folder. That way you can switch between testing mode and production mode. Is that right? Yeah, exactly. Basically, these mocks mimic the same data structure, and it has to mimic the same export function. And this allows you to have basic mocks for everything inside your data And I think this is like I mean this forces you to have a precise structure for your getting data, basically. And this can get tedious. But at the end of the day, I think this is actually like, it allows you to write code that is much more structured. And so this allows you to better test your application. interesting captain right wrote a one-liner that you could do alternatively in your page dot server.ts yeah exactly export get data as load from dollar sign data that's very cool very cool yeah if you're if you're an intermediate playwright user this is like an interesting alternative to typical network mocking in playwright where i think on every unit test or using a before test hook, you could tell Playwright to mock your data source at the network level or HTTP level. But using this structure, it's more like config as code and there's more predictable results. This might be more intuitive, especially if you're on a team. Do you have any team experience with this problem? We started experimenting with this, but we have not yet used this. And we actually plan to write some library to better ease this experience. So that, for example, like I can see your name, but I see a M dot dot dot that's asking, can you have more than one mock for different scenarios? And with this very setup, it's not possible. So you just have one way, but we are actually planning to study a way to make possible to seed your data, basically. So we are experimenting a bit at work with this. Thank you for having us. And I can see you, or at least hear you, the next, this week in Svelte. .