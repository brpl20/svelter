 Hello, everybody. Welcome to This Week in Svelte. My name is Enrico, and let's go! The changelog is coming up first, followed by quick facts, community showcase, discussions, and questions and answers. Here we'll talk about all the things happening around the Svelte Discord. Beginning with the changelog, we have a patch release for SvelteKit, version 1.24.1, in which we can mark aborted and canceled navigations as handled. This is for things like using the navigation API. So let's show you that. I think the navigation module has things like callback handlers for abort. And there were bugs about, there were bugs related to aborting the controller in navigation, but those have been patched. I don't see them in the docs right away, but the pull request has the full details. So that's it for version 1.24.1. I think the second issue has a more straightforward example. Navigation was canceled, thrown in console. So in this code example, you call before navigate, and then the navigation parameter includes a cancel method. It used to throw an error, but now no longer. Yes, you're on TV. Let's take a look at the chat. Yep, we all love good old bug patches. And that's the changelog for Friday, September 8. Moving on to quick facts and announcements. The first quick fact is a personal take. Here are a couple of attributes that are not deprecated in HTML, but I think they should be. The first one is the global attribute title and the input attribute placeholder. I will now demonstrate what these do and a better alternative. So if we go to the Svelte REPL, Svelte.dev slash REPL. Some of you may be familiar with these. The first one is title. You can add this globally to any HTML element, such as this is my title. And what I want to discourage or say is this is not very useful information for several reasons. So when I hover Hello World with my mouse cursor you might notice this tiny gray text underneath it If I zoom in you might see it better This is my title. And this is problematic for a number of reasons. One, look how small it is. Two, you need a pointer device just to activate it. Three, when you're magnified like I just was, it may not appear on the screen, so you may not even get a chance to read it. However, some screen readers can read it. But the last and worst offense is if you're on a touch device like a phone, it's almost impossible to activate the title without a screen reader. So if only redundant information is ever appropriate for this, then maybe you should not put information in here ever. Alternatives to title is to just show the text on the screen. Let's bring up the chat while I go through this. yeah so an alternative to title is have that information i think a common use case might be like a tooltip for an input we're going to get to inputs in a moment i'll use an implied label and add an input and i'll say my input and if you wanted some extra text around here you might be tempted to add a title, like around a span here, and say, insert your name, add your name. And that's not a very useful help. Instead, you can include this important text in the label itself. And now everybody benefits. You can even do a line break after, keep it all nice and left aligned. And all of your hint text related to what the title was useful for can just be shown on screen. So if you're on a cell phone, desktop, screen reader, zoomed in, you have all the information in front of you. So yeah, try not to use title. The second tip was about placeholder. So inputs have a placeholder attribute right here. And here you can insert things like your name. I have to spell it correctly. So placeholder with an E. The disadvantage to placeholders is, First of all, it's gray text by default. The contrast is very low. You could modify this with CSS to be black text, but the problem with black text is it looks like it's already filled, so the user won't know whether or not to fill it. Now if I enter something like Enrico the placeholder gone So placeholder is not an adequate replacement of an actual label See here it says your name and I fill it with Richter the dog Now I don't know what this input is for, because the placeholder is invisible. So instead of a placeholder, just use a label, and try not to use placeholder. The end. Feel free to enter in the chat your thoughts and feelings on title and placeholder. Those are mine. So not deprecated, but probably they should be. The next quick fact is as of an hour ago, I believe, bun 1.0 was dropped. I won't dwell on this for long, but congratulations to the bun team on your release. Bun is an alternative to Node.js. It features complete drop-in replacements for Node.js. It has most of the APIs you'll ever need for a full stack application. you can check out the blog post here. It does work with SvelteKit if you use Adapter Node and you set the polyfails to false in the adapter settings. There you go. And in the adapter settings, I'm referring to Adapter Node. So if you actually want to run BUN on production, you can use the Node Adapter and be sure to set polyfill to false in the adapter settings. And you should be able to run this with Bun. And there you go. That's the Bun announcement. Let's move on to community showcase. Bring it down in the chat. Alrighty. So joining me on the stage is Chrome Love. Say hi to everybody and introduce yourself. Hello, everyone. My name is Stanislav. And yeah, I've been part of the community for a little bit. And I'm really glad to be able to be here to have a little community showcase. Yeah, so this is going to be like a mini talk and a mini demo about Capacitor. And I'm going to go through exactly what it is. So Capacitor is basically a way to package like a project, a site that's built with web technologies into a mobile app. And then you can upload the app to the iOS and Android stores, just like any other native app And Capacitor is also an ecosystem So it a collection of plugins that allow you to do native stuff So from web we can access we can do a lot from web, but we can't, for example, create an Android widget, but with a Capacitor plugin, suddenly we can do native stuff without having to write a bunch of native code. And Capacitor is also a collection of CLI tools for managing and building your apps. So if we compare Capacitor to a few of the other options that exist that are not native, so you decide you don't want to do native development, so maybe you want to do a PWA, Progressive Web App, you're going to run into some limitations. You can't submit just the Progressive Web App to the iOS App Store, to Google, to the Android Store. You actually can't even have a tool called Bubble Wrap that lets you automate the process, iOS, they're very like, you know, decided on the native aspect of their apps. So they don't have anything like that. And the progressive web app also doesn't support all the APIs that Capacitor does, because technically Capacitor can run native code and it can support basically anything that the native app can do. So if, you know, whatever, if the browser doesn't support geolocation, and then your PVA cannot work, for example, before the browser supports it. And if you compare it to React Native or Svelte Native, the big difference is that when you're using React Native or Svelte Native, you're not really using HTML and CSS. They have their own view layer that transfers into native views that translates your React or Svelte called to native views. And that's just basically having to learn a brand new thing. so you can't use just like normal HTML and CSS. So this is kind of like an exploded view of how Capacitor works. So like at the top, if we start with the green box, we have this like Capacitor wrapper. That one like wraps your whole app and it becomes like a native application. But inside you have like your actual app. So Capacitor is not a web view. It's not like you say, you tell it to go to like google.com and it just like loads that in the browser. Instead, Capacity actually takes the built output of your site. We're using adapter statics, so we get HTML, CSS, and JavaScript. And then it actually puts those files into the app itself.

 So it has the same kind of restrictions or limitations as native apps, where if you need a new component or something, you can't just push that. You have to create a new app version and add that new functionality. But it's also quite good because I think personal opinion, I think it makes it easier to pass the review process at Apple and Android. because basically if you just make a WebView app, they don't know. Tomorrow that domain can point to something completely different. But when you make an app with Capacitor, they know what the logic will look like. They know that that logic is mutable and it will never change without a new app release. And so the last part of the Capacitor trifecta is the plugin bridge. And that's the people write plugins in native Java or Swift code that they can then expose to the front-end parts of capacitor so that we can do cool native stuff from JavaScript, basically. Yeah, and I thought I would show a quick little demo. And I'm going to try to keep it brief, but then, Ricky, you have to tell me if I'm really bad on time. so I have a project here, I already kind of pre-configured it because it's going to be a short demo so far in this project, what I've done is basically I've made a very very simple project in SvelteKit and I've added, I've changed to Adaptor Staptic and I've added a capacitor itself, like there are some setup instructions for it but you can follow their official guide, it's nothing like super crazy. And then I just want to show you kind of how the development experience looks. So when you add like iOS and Android, you're still using native stuff. So this is going to be kind of small. I'm going to start Xcode, which is the kind of Apple development environment. We're not really going to use it for anything. All we're going to do is just is start the app. So first, I'm going to go ahead and do npm run dev, just completely normal stuff. And then I'm going to go go ahead and start the app from Xcode. So this will actually like as you can see on the right side it actually starts up a virtual iPhone and it gonna go ahead and start up my app here As you can see I made a beautiful little counter app here And so I said that the capacitor when you are like deploying the app, it builds all of your artifacts, HTML, CSS, and everything into the app. But when you're developing, it is a web view. So this is actually just showing this phone is showing a web view into my development environment. All right, so we have our app, And we can see it looks kind of good. I'm ready to deploy this at App Store, but there's like a few small bugs. Like for example, maybe it's a bit hard to see, but up here, the text is the wrong color. You see, like I want it to be white because my background is white. So how can we fix that? Well, as I mentioned, Capacitor has a bunch of plugins. So it has a plugin called Status Bar. So with this I can actually manipulate the native because this top bar is a native part of the iOS system. It's not part of my app. So all I have to do is I'm going to go ahead and install this dependency, the status bar dependency. Here we go. and this is going to pull in the like JavaScript bridge and also like the actual native code required to make functionality work and then I run the special npx cap sync command. This is actually gonna do a little bit of piping behind the scenes and install these plugins into the Xcode project and then let's see what the kind of API looks like okay so you import status bar and style so let's go ahead and do that that is there and let's see how to actually set the status bar color set status bar style dark all right so we have this little snippet here status bar set style so we can let's say on mount we're just going to go ahead and change the style to dark since we run this npx cap sync command i'm going to go ahead and just restart the app because you need to restart it every time you do you add any kind of new native code see here here. Alright and then I gonna go ahead and save these changes And as you saw there the top text turned white And that is because we added the status bar plugin. So if I change this to, let's see, light, then it's going to be the wrong color again, like it was from the beginning. And as you can maybe see, there is also really good TypeScript support as well. All right, so let's do one more thing with this app. Right now, if you start the app and you kind of like close out of it, and then you come back, you know, we're not retaining the count, but maybe you want to like, you're counting something very important that you want to save that count for the future. Let's try to like make it so that when you start the app, the count goes back to what it was before. So again, there's a plugin called Capacitor Preferences. and it provides a very basic key value store. This is not maybe what you would use if you were to store a lot of data. There are SQLite plugins for that, which I know Karim will probably be happy to hear. But for just super basic small data like user tokens or something, this is perfect. So let's go ahead and install the preferences plugin. So go ahead and do that again. And then we need to sync the plugins we have. there we go and I'm going to start um best sorry I'm going to start self-cap again and then let's look at the um what we have here so uh we have this preferences.set and preferences.get api so let's go ahead and add that so I'm going to import preferences and then maybe this is not how you would do it in a production app, but I'm going to cheat a little bit and just go ahead and in on mount, well, first of all, we need to save the count. So let's go ahead and we have this handy on click. This actually, this triggers every time the count changes. So we see here, one, two. And let's go ahead and every time the count changes, we're going to go ahead and persist the count itself So we going to go ahead and in here we going to go ahead and set the count to let see count and this one actually takes a string and only a string so we have to do, to cast it to string here. Okay, so now we're saving, every time we're counting, we're going to be like saving that in the background, but now we need to also recall when we start the app and we're gonna go ahead and do that here on mount so the api is just preferences.get let's see here so we're gonna go ahead and take that value out the key is count here and we're going to go ahead and change the value itself when we start out. So if there's a value, we're going to go ahead and parse it because it's going to be like null or something if it's not set. Otherwise, we're going to just set it to zero. All right, let's see if that works. So I think I'm going to also restart the app one more time to make sure that this new preferences plugin has been loaded. You saw it right away. It actually worked. So it started at 3. So if I were to do something like this, so now it's 12. I'm going to go and force close out of the app. It's actually going to swipe it away so it gets closed. Come back. And as we see, it retains it because we saved it in the preferences. API, which is a native iOS and Android API that is being used under the covers, so to speak. The last thing I wanted to kind of show in the demo was, okay, so this is great. Like, how can I debug the stuff that is happening inside this like virtual device or even a physical device? Well, both iOS and Safari allow you to actually attach to the devices. I'm going to just show you how it works and so far it's going to be a little bit small. So I'm going up to the develop tab and here the actual, in this case, my simulator shows up in the list and I can go ahead and just click this. And now I have just a console window that will mirror what's happening that is connected to what's

 happening in the simulator. So when I, it's going to be, let's see here, if I add something like a console log every time we click, hello world count, then let's see here, so that it's down here. So every time we click, we can see here that the console log is happening. Great. That's the demo. And I have one final slide left that I want to talk about. Because this is just the tiniest, tiniest of demos. There's a lot more to this. How to set it up for production, how to build the... For iOS it's called IPA files and for Android it's called AAB files, like the actual files you need to upload to publish your app, how to register it on the Google and Play Store, how to use other plugins. You can write your own plugins as well. So I have this repo below. It is kind of like the starter that I just showed you. And it is just like a basic project with a pastor setup. And there's links in the project to a bunch of different blog posts on how to do specific things like how to use GitHub Actions, for example, to build your iOS and Android bundles automatically so you don't have to do it yourself. Yeah, and that's it for the presentation. But I was hoping that if there are any questions, we could have time to talk about those. What do you say, Enrico? Awesome. Thank you so much for presenting. And yeah, the audience had several questions, and I'll collate them for you. So before we get to the chat questions, some fundamental messages are Capacitor seems to be a WebView container, so it allows you to write any HTML framework and ship it to a native device. Is that correct? Yes, that is correct. Yeah, and it comes with, I saw you using pods, which is like a CLI tool for the iPhone, and that lets you install native controllers that you call using the JavaScript API on your Svelte pages. Is that right? The CocoaPod stuff is kind of hidden away from you. All you have to do is run MPM install on the plugin you want to install, like the status bar or preferences plugin. And then when you run this MPX cap sync it will actually run CocoaPods for you in the background and install the dependencies you need yeah that the only friction part when you install new native dependencies then yeah you got to run a capacitor sync seems like yeah that's correct okay and i saw you using xcode just for the sake of running an iphone simulator is there a way to use a physical device when testing? Yeah, definitely. So they have some CLI tool where you can just run this. It's called MPX cap open or something and it's supposed to launch like a simulator or a physical device if you have one connected. I just use Xcode because it's easier. But how you would do this for a physical device, so it's going to be a little bit small again, but like up here in Xcode, there is like a list of devices and these are all simulators. But if I were to connect a physical device to my Mac, then it would show up in this list. And then I would just press play, just like I did. And it would start on the physical device. I see. But in order to make that solution, you need to go? There's a tiny bit more to it, which is that Apple has certain signing requirements for physical devices. For example, I think you have to be an Apple developer to actually run apps on a physical device. you have to pay that $100 toll or price, whatever you want to call it. But you don't need that for the simulator. Okay, very cool. So let's address some of the chat questions. Scrolling further up, I saw... If I mispronounce anyone's username, just correct me in the chat and I'll get it right. So I think Mosier brought up some comparisons to Svelte Native and Capacitor. You already covered that fundamental difference, which is Svelte native uses native views, which is like a Svelte-like experience, but it isn't actually HTML. And they were asking if they can bring in component libraries. So in the case of Capacitor, because it's entirely web-based and using Svelte, it sounds like definitely, yes, you can use things like Flowbyte. Oh, definitely. Yeah, you can use anything. And the team behind Capacitor, Ionic, they have their own kind of framework. and I even believe there is a Svelte port for it let's see here that Tom has done and yeah this is basically exactly what you would expect just a bunch of components that you can use without having to write them yourself Great. And if anyone in the chat has questions I didn't bring up, now's your chance to ask a last minute question. From my personal experience, I have used React Native and Expo. And Expo sort of has this wrapper developer experience so that you don't need to run Xcode and Android Studio to test on your local device. but it looks like Capacitor doesn't have that yet. So if you want to test on an iPhone, you require a MacBook and Xcode. Is that right? Yeah, they have a, like, it's the same thing as with Expo. They have kind of like a commercial building service. So if you don't want to test on like a local device, you can just go ahead and send your app to their service and they can even automate like the whole thing with TestFlight and the equivalent on Android, the testing kind of stuff. I have not tried it. But yeah, I think if you're developing an app, I think sooner or later you're going to have to have a physical device to test it on because it's just really hard. Some things also don't work in the simulator. Notifications is a great example. Notifications don't work in a simulator on iOS and I don't think on Android either. Because they're not real devices. They don't have Google or Android or iOS serial number that is required to differentiate them. Makes sense. And you mentioned the App Store reviews. Usually, like in my experience, when you submit an iPhone app, it takes like a week or so to get it reviewed and published. Does Capacitor allow you to make over-the-air updates? Yeah, again, they do have this. I mentioned that when you build an app, you can't really change it because what's in there is in there. But they have a commercial service. I think there's also third-party commercial services that let you do over-their updates in the sense that you don't have to submit a new... Every time you want to make a change, you want to add a new page or something. In my experience, when you submit an update, it's usually pretty quick. I think that there is some automation going on. last time I updated my Android and iOS apps, it took less than an hour to get the update approved So there probably some I don think it as bad as maybe some people are making it out to be that you can do you know over updates and i think it it it um safer also for i for apple and android to not have to deal with with apps that can just sporadically completely change like one day it's a one day it's a reading app the next day it's a casino app like those are the kind of challenges they are facing which is which is hard for them great thank you for answering we'll take one last question from bonsai tari lets you build the front end with svelte kit but the back end has to be in rust as of now and it's meant for cross-platform development did you get a chance to compare tari versus capacitor it seems like they're the same experience because tari is also a webview wrapper yeah when i started with my with the app that i have been working on that this like tari web sorry, the Atari app. Atari was for desktop, but they do have some sort of app version. And when I started with my project, that wasn't even like a thing yet because that was like eight or nine months ago. Having tried it, I assume it's going to be very similar. Like what's really powerful with Capacitor is that they have this long, they have been around for a long time and there are plugins to do a lot of things. Like if you want to do maps or geolocation or notifications, and probably with a smaller ecosystem, then with Tower, it's probably going to take a while for it to catch up. And maybe you're going to have to write a lot of stuff yourself before it catches up, if that makes sense. Totally does. Thank you again for presenting. Everybody give Chrome of a hand. Thank you so much for presenting today. Thanks for having me. Clap emojis, any emoji with a hand in it. I will bring back my screen and we'll get back to this week in Svelte. Do this week in discussions. there wasn't much uh cohesive discussion that i can pull from discord but i do have something in store it is about how do you ensure your team is supported and feels productive so this topic may not resonate with everybody how do you ensure your team is supported and productive this is kind of like in the lens of a tech lead but also it's relevant if you are if you are not a lead and you are on a team. So in the chat, just a raise of hands, enter one in the chat if you're on a team. Enter two if you're solo. I'm curious who here works day to day on a team. Yeah, a little bit of both, that works too.

 So a lot of solo developers. Three? What is three? Anyone on a team? Number one for team, number two for solo. One plus two equals three. Ah, yes. Very good. Wow, a lot of solo developers. I see. Okay, then I'll make this quick because maybe we should change the topic to what's it like to stay productive on the solo team. Well, you do what is comfortable for you. But the talking points I can relate for today is as a lead, try to make sure your coworkers ask for help when they're stuck on something for more than an hour. And the term that I sometimes use is spinning the wheels. So for example, you talk to your coworker and you say, hey, are you spinning your wheels? Are you stuck hitting your head against the wall? You're not sure how to proceed? That's when you got to ask for help. because if they're stuck for more than an hour or half a day, then it's not productive for the whole team. They're not learning anything and progress is not being made. So it's a very important thing to ask for help if you need it. Number two, if you're a team member, make sure you ask for help, but also learn the concepts that you use frequently. So it's not always necessary to memorize syntax or steps, but it is important to learn things when you come across it day to day or week by week. So for example, if you do have a notepad in front of you and you're taking notes of the things you learn at your workplace, you have to also dedicate time to revisit and learn those things, not just reference them as needed, especially if it's like day to day or week by week. Of course, speaking for myself, I do occasional DevOps like once a month or every two months. I'm not going to memorize Docker Swarm. I often reference it. But if I do it weekly or more often, then spending an hour, half a day actually learning the tool inside and out is going to make me more productive. So yeah, there's a trade-off when it comes to putting in the effort in learning versus memorizing. And if anyone in the chat has anything to add, then we'll proceed to the next part. Yeah, and that's it. Ensuring your team is productive. So let go back to the next topic which is this week in questions and answers I have one answer to your questions on the Discord Bringing back the chat one last time. The question for this week is, how do you reuse props and types across two or more components? Let me show you. So sometimes you have two or more components and you want to reuse their props and types because either they share it or you have a parent and child component with the exact same props, or you just have a collection of slightly variant components and you want to reuse their props and their types without having to enter export let prop name over and over again. Well, here's your answer. Let me just double check my screen. Okay, we're good. Take a look at this. So in this demonstration, I have a collection of buttons. And I will share, this is my This Week in Svelte repository. I'll leave a link in the chat later. So this part is, you have a button, and you have a shared prop, which is called kind. And the kind prop can be primary or secondary. You want the consumer experience of that component to be something like this. You have your button, and you want to set the kind to either be primary or secondary. And here you can see IntelliSense. You can see type safety. You can see red squigglies. You want this. How do you get this? Let's get rid of this useless title. Go away. So the button component there, if you're using TypeScript in your Svelte file, lang equals TypeScript, then line three, you can set your props interface to extend a shared interface. On line two, I'm importing the shared interface from a file down here called types.ts. And in this folder called shared buttons, I have three buttons, all reusing this interface called shared button props. And it does a couple of things. One, it uses HTML button attributes from Svelte Elements so that all of the button attributes are available. And it sets a custom property called kind, and it can either be primary or secondary. So the button on line 8, it sets the primary CSS class based on the presence of primary, which makes the background color red. I have a second button here called cool button The cool button is exactly the same I know kind of a strange example but it sets the background to green when it primary Let me show you what that looks like. Five, one, seven, three. Is Vite started? There it is. So in my component playground, you can see a regular button, a cool button, and a JS talk button. I'm going to show you what they all do. So the regular button, the primary prop is set. Let's go back and forth. So in my page, kind equals primary, regular button. We have a cool button. The kind equals primary, and it's a cool button. but the background color is green on the cool button, but red on the regular button. But the styles aren't what matter. What you're here for are the types. So both of these components have a kind prop. And the reason it works is because we're not using export let kind in the component definition. We're using the props interface. So on line seven, we're spreading the Svelte props special tool here. so all props I could pass into button will be passed in to it. So if I also do control space, you can see the IntelliSense for all available button stuff. So I can even do type equals button. There's type IntelliSense for these attributes as well because the shared button type is extending HTML button attributes. So I have type IntelliSense for the button as well as for the custom kind prop. And that is why the props are shared. So there's a, some people have fear over this utilization. So in the cool button, I'm also doing the spread operator with props. In the official Svelte documentation, there is a concerning message about using dot dot dot props. I will show you. So here you can, in any Svelte file, you can use $$ props to spread any amount of props, but there are performance implications It says here using props will not perform as well as references to a specific prop because the changes to any prop will cause Feltz to recheck all usages of props So this is only a concern if you're changing these props very often. So if you're doing a single server rendered button view and you're changing it never again, or perhaps you're changing it on a user event, like once every minute or once every second, If you're not looping through some changes and changing things like these really often, like multiple times per millisecond, that performance overhead is not really a concern. But if you are changing some of these props very, very often, then yes, there will be a performance hit. So watch out. Now that that was the TypeScript example, I have a surprise JSDoc example. So let's say you're authoring your Svelte component and you're not using TypeScript. You're not using script lang equals TypeScript. That's okay. You can also type your reusable props. So in this jsdoc button on line two, I'm spreading props again, and I'm applying the class primary. What you require to make this work is a jsdoc button.svelte.declarations.ts. So now I have these two files working together to give me these types. There is a reference here on the Svelte documentation. I will share that in the chat. as long as you're exporting a companion class, in my case, export default class JS doc button, I can extend my shared types. So I'm extending Svelte component and then I'm passing in the generic type shared button props. Shared button props is the one being imported from the shared types over here in which kind is defined as a union string of primary or secondary. So finally, to bring it all home, I got a red squiggly I have to deal with. What does the red squiggly say? It says kind is missing from type. Okay, let's put it in. So I'll type in kind equals primary. The red squigglies are gone. We did it, everybody. And now my JSoc button is styled. We did it. And that is how you reuse props and types across two or more components. Is the button example real world? Definitely not. This is almost a code smell, to be honest. A more real world example is you have a parent component that has the same exact props as child components, and you want the parent to overwrite.

 override or be the default of its children. So you can use set context to pass that in. That's more realistic, but unfortunately not the demo for today. And I will share this in the chat. I have a repository with these examples right here. Here you go. And now let's wrap up. thank you everybody for participating and thanks again to our guest speaker we'll see you again next time bye for now