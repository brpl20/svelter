 It is time for This Week in Svelte. Here today with me is Karim. Welcome. Hello everyone. Hello. Let's go. By the way, my name is Enrico and the agenda for today is the changelog. Quick facts and announcements, community showcase, followed by discussions and Q&A. So let's go with the changelog. Today is June 23rd, 2023, and you guessed it, there's some Svelte changes to be had. We'll start with SvelteKit and then we'll move on to talk about the big one, Svelte4. So in SvelteKit, we've got some patches starting at 20.3, 1.20.3. Some dependencies were removed. This is probably related to the underlying dependencies in Svelte. I don't want to make too many assumptions, but hey, fewer dependencies is good. Types are no longer imported from SvelteInternal. Did you know Svelte 4 no longer exposes Svelte internal? Interesting, keep it in mind. Don't skip rest parameter matchers when there's a non-matching optional parameter. Good to see some improvements there. Matchers are widely used. Fetch respects headers from provided request. Very nice. In 1.20.4, remove reference to TinyGlob related to the other TinyGlob down there. I guess it was just a leftover, so now both leftovers are finished. fridge is empty and then in 1.20.5 more patches synchronous invalidate invocations cool allow rest params to be empty in resolve path and I think resolve path is one of the kit modules let's double check resolve path yes I was gonna share this anyway but resolve path is a module that allows you to construct paths this is useful if you want to pass something into go to go to is another module and sometimes in goto you want to pass a URL string and sometimes you want to replace the dynamic paths and that's what resolve path helps you do. So the patch here is rest params can be empty correctly closed dialogues when form is enhanced and pre-compressed filter. What's that? I see. Okay so this is like an NPM related pre So if anyone experienced that 1 should have you covered Let's move on to Svelte. So a couple days ago, I think it was Wednesday morning, Svelte 4 was released. Well, morning my time. Everyone has a different morning, right? And the Svelte repository also had a bit of renovations happening. So down here, you'll see packages. And in here, there's the monorepo style, similar to SvelteKit. Playground and Svelte are separated. And here you'll find the Svelte source code, along with the Svelte changelog. And that brings us to Svelte 4. Big congratulations to the team and the maintainers. Thank you so much for your hard work. I believe this got really serious starting in February 2023, around February, because that's when the last major feature released to SvelteKit was made. that was streaming with promises. Shortly after that, it was like, okay, let's all focus on Svelte 4 and it's been a ride and we've got lots of goodies to share. So I won't go over these line by line per se, but I will talk about like the high level changes in Svelte 4 starting with reduced package size. So there's developer facing improvements and there's maintainer facing changes. I'll start first with the developer facing improvements. Everyone here in the chat with me, that's us. where the developer is using Svelte. How does Svelte 4 impact us? First of all, this is mostly a maintenance release because they're preparing for Svelte 5. Svelte 5 will be the big one, possibly a rewrite, possibly some style changes, but Svelte 4 had to be made this way to prepare for Svelte 5 for easier comparisons, benchmarks, and of course, easier maintainer friendliness. So as far as developer facing improvements go, the minimum node version is node 16 and the minimum webpack version is webpack 5, although I wouldn't be surprised if webpack stops receiving support by Svelte 5. That's my prediction, so my words, not theirs. And then overall there's a reduced package size. There's also a blog post about Svelte 4. You can see it on the new website. Don't worry, that's not a stream delay. That's how long it takes my tabs to open. Svelte has been revamped Thank you so much to Puru who worked on this very well for the past four months Very consistent design I like it a lot and I sure you like it too It got search It's got a new ripple. It's got dark mode. Everyone give Peru a hand. Thank you so much for these docs. And on these docs, there's a blog. So when the Svelte 4 blog was written, there were some highlights here about performance and package size. The actual package difference between Svelte 3 and Svelte 4 is 10 megabytes. I gotta zoom in way more. There we go. Oh we see this snazzy mobile nav. I'll just go here. 10.6 megabytes. That's how large Svelte 3 was. Now it's 2.8 megabytes with Svelte 4. So npm install and all those package managers should be speedier. And the actual shipped code that is built has decreased in size as well. So the example made on this SvelteKit documentation, it went from 126 kilobytes to 110. So you can anticipate smaller shipped built code for your applications made with Svelte. And that's awesome. Perhaps we'll even see the legendary single file application for embedded devices or something, because file size is a big deal in that space. But for actual cloud-hosted web applications, for the majority of Svelte users, this is also a big deal. Nice to see it. So that's it, there's performance related changes for the package size itself. The next change is a breaking change related to transitions. I know I'm skipping most of these, but I'm just gonna go to the highlights. Local is now the default for transitions. And it's not listed here. I think it's because global is the new parameter. No, that's okay, I have a demonstration. Here is the new dark mode, Svelte Repo. I'll use light mode because I'm a bridge troll and I enjoy the light or something, I don't know. So in Svelte 4, local is the default for animations. So if I delete this global flag, then this transition will fly in. It doesn't work because I need to demonstrate What is the difference exactly between local and global? I actually did not know this till yesterday because I hardly use transitions for my applications but the people need to know On line 14 I have this outer wrapper this outer flag if visible info and then on line 16 I have this inner flag So the difference is, if one of these is set to visible, then that's considered a global change. I'm specifically referring to line 14. So I'll set that to true, making it visible by default. I'll set visible transition to false. So now these three lines, this paragraph here, is set to false. And when I change this to visible transition, and I click on it, it animates in, it animates out. I'll try it again in case the frame rates are bad. So this paragraph is a local transition. When I change visible transition, it animates. Now if I change this checkmark binding to visible info, look what happens. Nothing. Now if I set this inner to true, and I do it again, there's no animations to be had. The reason this does not animate is because the outer condition is changing, and the inner condition is this fly animation only triggers locally. So because I'm changing this outer one, which is technically a global change, then there's no animation to be had. If I explicitly set this to global, and then do it again, it pops in the first paragraph and it flies in the second paragraph. Global allows both local and global animations to take effect, but local only allows local animations to take effect. And that's the difference. I'll share this REPL down below. You can follow the code comments to try it out yourself. I think this is a quality of life improvement because the vast majority of Svelte users generally prefer to make things local. So now local is the default for that reason. That's a breaking change. If you're like me and you don't use transitions, then less refactoring for you, I suppose. All righty. What else is different for the developer piece and changes? There is web component authoring has improved. I don't have a demonstration, but Svelte can be used to build custom web components.

 And apparently the authoring experience has improved quite a bit. I don't have an demonstration or an example, but I did try this about a few months ago. Traditionally in Svelte 3, when you write a write component, you're restricted or confined to the way you write certain things. For example, in the script lock, you have export let something. And I think you need to do a Svelte options and set the tag equal to some skewer tag. And you can't use Campbell case. There were several restrictions to the way the props were named, there were restrictions to the way the tag was named. I think some of these things have been improved so that you don't have to worry so much anymore in Svelte 4. I don't have too many examples here, but I think you could write more Svelte-like code when authoring web components now in Svelte 4 and you did in Svelte 3. So that has been a big change if you're a web component author. Next is go to DefinitionWorks. I might try this out later. I'm gonna actually demonstrate like how to upgrade your saw your application from Svelte 3 to 4 so stay tuned for that There's the new website of course. Let's tour it a bit more So search works just like in the SvelteKit website. Hey, this is SvelteKit. That was a test You can go to things like get context search works, it's a Everything is split up with a new information architecture It's very good to run down top to bottom if you click on tutorial takes you officially to learn.svelte.dev. That is the new official tutorial. I think the old tutorial is still lingering only for compatibility reasons with Safari. Safari doesn't support web containers. Learn.svelte.dev utilizes web containers brought to you by Stackputs. So both tutorials exist but this one is the new canonical serious one. This is where you go to learn Svelte. It's okay Puru, everything's working. It's me who has to worry about things breaking. Speaking of breaking, I'm not even sharing the Discord chat. There we go. So yeah, the website's great. It's a great resource. It has a mobile-friendly navigation as well. Try it out. The next feature is the migration guide. So let's go there. This is the last thing I'll cover. So on the official documentation down at the bottom under miscellaneous there is the Svelte 4 Migration Guide This is probably what you be reading over the next few weeks when you upgrade your applications to Svelte 4 They go over the minimum requirements the things you need to account for but I going to show you the happy path What happens if you run npx Svelte migrate latest Svelte 4? I'll show you. So I have a repository that you may have seen before. It's called this week in Svelte. And I use pnpm as my package manager, but that's okay. And I'll show you why. So I ran pnpm outdated just to see like what's new compared to before and after. Right now I'm running Svelte 3.59.2. The latest is Svelte 4. There are some peer dependency requirements for Svelte check and for Vite plugin Svelte. And this migration script will handle all of these things. And I will show you how. So I'm gonna enter npx svelte migrate at latest Svelte 4. this is the command it doesn't matter if i use pnpm or yarn or npm npx is okay to use here because this will do a code modification to your project it will not actually install svelte 4 it will just modify your package.json so you don't have to worry about interference with your respective block file i will run it and spoiler it's not going to work perfectly due to my unique issues but i will just just show you how to deal with them. So first it asks, it's going to modify the current directory, my git branch, my git source is clean, I don't have any unsaved changes, so I'm okay to do this. I'm going to proceed. Then it asks you which directories you want to codemod. So in my repository, I only want to modify the root. I do have some other like nested repositories, I don't want to deal with that. I just want to upgrade source, perhaps static, build is redundant, So I'll press up and down arrows and spacebar to select or deselect these. And I'm good with these three folders. Enter. And it asks me, do you want to add the global modifier for the transitions, which I showed you a few minutes ago? In my case, I don't need backwards compatibility. But if I'm a library developer, I need to be more careful when I choose this option. So in my case, I'll do no. And it's done. What just happened? So the only thing I changed in this repository is my package.json. Let's go over some of these changes. Vite plugin Svelte upgraded to 2.4.1. That is a necessary minimum version Svelte has been upgraded to 4 Prettier plugin Svelte 2 svelte check typescript is now version 5 instead of 504 not a big deal because it a caray version so this modified my package.json but it did not install anything which is fine so this means that every one of you can use the npx script just like i did and now i can finally do pnvm install to actually get svelte to actually try things out. And I'll read the chat while this happens. Pablo writes, we're upgrading SvelteLab to Svelte4 templates. Yes, we all look forward to that. Zarela writes, I wonder if it's more confusing that all folders were selected initially. What do you folks think? Yes, please offer your feedback as I go through this demonstration. So the first road, the first issue I run into here is peer dependency issues were found. So it says here, Grail, Testing Library Svelte, ESLint plugin. I'll ask for Svelte 3, but installed is Svelte 4. I'm not sure why Svelte Check and Svelte Pre-Process has this issue, but for these other libraries, this is sort of out of our domain. I need to wait for Testing Library, for example, to change their peer dependencies to Svelte 4. Since Svelte 4 came out this week, it might take a little bit of time for open source projects to actually update their peer dependencies and then mitigate these problems. You can safely ignore these sometimes, but if you depend on a library such as a component library that uses Svelte 3 transitions, for example, then some things may break for you. In my case, it shouldn't. So let's try one more PNPM outdated. That's not how you spell that. There we go. and historically this has taken me more than two seconds, unfortunately. But what I'm going to do... Oh, it worked. So let's see. Let's see if there's any Svelte related updates here. Svelte check. There's a patch upgrade here I can get. There's a VEETS plugin Svelte upgrade. There's a Svelte kit upgrade. I think I'll do PNPM upgrade Svelte check for now. That's only when I want to show the difference and see what happens. Okay, so I still get peer dependency issues with Svelte check which depends on Svelte preprocess which has an unmet peer dependency I sure that would get patched either today or soon But it might still work So if I do pnpm dev and run my application which is a SvelteKit application let's see what happens when it's live. I suspect it'll just work, and we'll all see that together. So, so far no build issues, no runtime issues. I can even navigate. There's my playground, links on the page, progressively enhanced form with lots of pets and lots of debug info. Everything's working. And that's to be expected because the differences between Svelte 3 and 4 are mostly minor, unless, of course, you have a unique situation. If I run build, I also predict this may work, but I haven't actually tried. If anyone has questions about this entire migration process, let me know in the chat. So yeah, with some minor warnings not related to Svelte 4, everything built just fine. I can even run preview. And it should be golden. Ports 4, 1, 7, 3, yes. So we can have to do, we can do a production example. on port 4173. There we go. Yeah, my debug scripts are gone. Thank you, dead code elimination. That's unrelated, but pretty cool to see. Yeah. Everything's working. So be sure to test your applications when you upgrade because sometimes those peer dependency warnings are not a big deal, especially if you're not relying on anything using the new Svelte 4 transitions. As long as nothing is very dependent on Svelte 4, you should be okay until those libraries actually upgrade. Speaking of upgrading, if you're like me and you actually do maintain a library, then here are some of the things you may run into. I'm actually in the process today of adding Svelte 4 to Carbon. So Carbon component Svelte is something I help maintain. And this is not an announcement, it's just an example. I'm here to show you that in package.json, I'm going to add a peer dependency, and I'm saying Svelte is targeting Coray 3.20 or 4. So if you're using 3.20 or higher, or version 4 of Svelte or higher,

 then carbon should work with your projects. Yeah, it's a remnant, not necessarily a decision moving forward. Don't worry. But likewise, this is what you should look for when you're trying to investigate your dependencies should or should not be compatible with Svelte 4. This is a signal to consumers of carbon that it should work with Svelte 4. This is not released yet. It's still a work in progress. Speaking of work in progress, Another thing you can't expect is type definitions to change. So for example, in this DTS file, the only change that was made here is Svelte component was imported from Svelte instead of the deprecated Svelte component typed. In Svelte 4, Svelte component typed still works, but it's deprecated. So I'm working to migrate everything to Svelte component. And there you have it. That's just one thing I ran into. Another thing I ran into is lots of local transitions. So here, for example, we have this image using transition fade local. After running the migration script for Svelte 4, this local was deleted because local is the new default. However, because this is a library of components and I want it to be compatible with Svelte 3, I'm gonna add local anyway. Even though it's redundant for Svelte 4, it's necessary for Svelte 3 for backwards compatibility. So yeah, that's a good example of like library maintenance related to Svelte 4. And let's move on to the next tidbit. Maintainer facing changes. So I'll just breeze through this. So the biggest deal I'd say for Svelte 4 that's sort of under the hood and not relevant to our day-to-day are the inner maintainer facing changes. So like I brought up a moment ago, the Svelte repository has been renovated a bit. It's more of a monorepo style. The source code is written in JavaScript and JS doc for typing, and this will help the maintainers greatly with local testing, getting contributions, and of course, comparing it with Svelte 5. So once the road to Svelte 5 commences, which it has, then this should help a lot. Second to that is there are long DTS files, thanks to DTS buddy, and this should help with code editor suggestions I going to try one out right now So if I open a page over here let see what happens when I import something I'm going to do pnpn.dev. Just checking the chat. Cirilla suggests keeping Svelte component typed. I am curious why. I think Svelte component was introduced in version 3, wasn't it? Let me know if it's available or not. So I'm going to import on mount. So I've got my script here, and then if I do on mount, there it is, and it imports correctly. This has always worked for me more or less, but this should work more consistently now on Svelte 4 and if I option click on this import it should take me to the definition. Svelte source runtime internal onbound. I believe this is correct behavior. So now if you go to definition it'll actually take you to the source code and because the source code is written in JavaScript and JS doc it is the literal source code and not a built code from TypeScript. So this way if you ever are curious about the inner workings of something this will work the way you expect it to. Okay I'll double check SvelteComponentTyped. Maybe I'll keep using the deprecated thing. So back to Cyrilla's comment I should probably use SvelteComponentTyped due to behavior changes. So maybe I won't commit and save SvelteComponent just yet but I will test these out before I actually ship it. It's always good to test. Alrighty. So that's it for Svelte 4. What do you think, Karim? Anything you'd like to point out or is it all good? That's great. Personally, this little store update is the most exciting for me, but also the reduction in and bundle size. Yes, I'll find my way back to there, but you're right, the store contract has changed. Is that right Yeah it changed slightly but we have to in when we talk about web sockets later I mentioned the use case Sounds good Yeah, lots of guides here. So I'll link you in the chat to migration guide if I haven't already. Thank you. And let's move on to quick facts and announcements. That slide transition broke, I'm sorry. The quick facts for today include a Svelte Radio Talk and the official Svelte 4 announcement happened a couple of days ago featuring Simon, one of the core maintainers, and Puru, our favorite website developer. Check it out here on YouTube. So if you want to go over some official Svelte news, there you'll have it. Secondly, there's a great resource I found on testing components. There was a high demand. People wanted this show to showcase how to test components, how to test slots, and I actually found a really great guide on that that can probably do a better job than me. So check that out too. It's called Davey Pond Svelte Component Test Recipes. I'm actually going to show you a couple of examples. So this test recipes repository shows you how you can test your Svelte components with some excellent examples and a helper library. The biggest demand I noticed is testing slots. So down here there's an example with a helper library called Svelte HDM. If you import Svelte HDM to your tests, you'll be able to do this syntax to render a Svelte component and also render slots. And you can do things like test the content of your slots. That's pretty cool. So if you're really big into component testing, this is for sure something you would like to check out. And that's it for quick facts. Wow, those facts were quick. And now for community showcase and microtalks. No microtalks today, but there's a cool YouTube video to compliment even more Svelte knowledge I just saw this morning. you to Mathia aka Joy of Code for making this video on the new Svelte 4 changes. So if you'd like to see some extra details and tidbits I did not go over there a nice video for you It only 10 minutes long Moving on to this week in discussions There's one or two discussions here. There's a browser API coming along and it's a popover API. Let's check it out. So popover is over here and popover is not yet widely available. When it comes to these bleeding edge features, I usually like to wait a few months after it's been released to all major browsers. So it's in technical preview in Safari. It's under a flag in Firefox and Opera, site unseen. There's also Opera 1, which is Chromium based, I think. I don't see it on this list here. iOS is coming soon on iOS 17. Wow, so many goats in the chat. Are we on a farm? Okay, let's take a look at the MDN article for Popover. There's actually a few examples of what Popover is and why we should look forward to it. Here they come. So this is like this landing page. I'll share this in the chat. This is like a bunch of popover examples. And if you go to the basic declarative example here, you'll see some HTML. Wait for it. There we go. There's no JavaScript. So here we have button popover target is my popover. Then down here's a hidden div with the ID of my popover. If I click on show popover, there's the popover right there. And if I go to hide popover, it's gone. This is a very primitive example, but the cool thing here is you don't need JavaScript to use it. So these are just HTML attributes to specify the target and the target action and the actual popover attribute here in the target popover holder or wrapper. There is a JavaScript API as well, but this is cool because you don't need it sometimes. And a popover is not a hover effect, it's a click effect. So you actually have to click your content to see it. Related to that though, is sometimes you wanna make menu items that work on hover.

 and a cool article was shared with me thank you hat tip to captain codeman because i want to share that with all of you as well so when it comes to contextual menus that are like a few layers deep hovering can become frustrating so take a look at this diagram example i'm going to zoom in there we go usually when you put your mouse over contextual menus like this you can hover it here and as you As you drag your mouse, trying to reach the right contextual menu, you might accidentally move your cursor down to the next item. And when you do that, this context menu disappears. Usually people mitigate this by using a timeout saying like, oh, if I hover away, to have a debounce of like 300 to 600 milliseconds, that way there's a chance for the user to move their mouse quickly enough. So that's a bit flawed. But an improvement or an idea to that is to add a literal div triangle to be part of the pop the pop out hover so if using a context menu with a mouse or a pointing device or a trackball then designing your pop out menu to have this triangular target area can also help too because if i hover labels for example and move my cursor as long as i'm within this invisible triangle the menu will stay open and you don't have to implement debancers or timeouts this is just one way to make things a bit more usable so that's something to keep in mind not entirely pop-out related but it can be if using hover effects so that was cool the next discussion is there is no discussion let's move on to Q&A so this week in Q&A Karim has helped put together something for all of you it's about web sockets with SvelteKit. So the question is, can I use WebSockets with SvelteKit? What's the answer? So yeah, I extended this a little bit to the question of like how we can do real-time stuff in SvelteKit in general and there are like two essentially Now just to consider WebSockets and server-sync events. WebSockets are even more popular but you heard of them more than server events and they differ in how they have to be implemented especially on the server side and what kind of features they offer So the most important things summarized are that WebSockets work, they're bidirectional, meaning that they work between server and client, and both server and client can accept and receive or send and receive messages, whereas service and events just, you know, essentially, like the name says, you're emitting events on the server to the client. And, yeah, WebSockets work over the TCP protocol, which is very important, because this is why it's kind of difficult, but a little bit more work to actually get a WebSocket server up and running and integrate it into a SWAT kit up if you want to do this on the backend. and server-send events just work over HTTP, which is what we use all the time. Yet another point, no events by default. So what this means is that with a WebSocket, you're just sending data, sending and receiving data. The server-send events protocol, however, is very simple. I think it has four or five properties, an ID for the event, a name that you can give the event, then the actual data, and a time or something. So you can emit events and you can listen to specific events or all events on the client. If you send an ID, the browser will, if the connection is interrupted, send the last ID it received when it's reconnecting in a special header special headers so that you know on the server where the client left off and you can push any events that the client may have missed while he was disconnected. Yeah, both can send text, but WebSockets can also send array buffers. So I think in most cases you will just send stringify JSON anyway. The other prime example for a WebSocket app is a chat app where you're always receiving or you want to receive messages from the server, but also send messages to the server for the same connection Theoretically you could also do this with server events so you could have a connection from the server to the client and whenever someone sends you a message, you receive them and show them, and if you want to send a message to other users, you can just make another HTTP request separately using fetch, or, yeah, fetch, but it's more performant to just do this over one single socket connection because you don't have to open and close connections all the time. Yeah, or a collaboration app. So there is, for example, TODRAW. If you know this app, it's like a Canvas app where many people can collaborate on one thing. So you're changing things and you have to push and send the updates to the other users and other users are sending you updates. It's a bidirectional connection. And service and events are really great if you want to receive messages from what's happening on the server or in your database. And the client, the user, doesn't really have to or necessarily have to react in any way. So you can use this to push any toast notifications, for example, or maybe something like a live ticker, Twitter, for example, a Twitter timeline that should update in real time. a dashboard app where, I don't know, let's say you have a table that you want to update whenever someone buys something. Or I think GitHub discussion stuff does. So when you're commenting or when you're on a page and your comments, you could have a server-sent events connection. And yeah, when someone posts a new comment, you could update the page automatically. without having to do with the page. Yeah, on the next slide, there is an overview of how WebSockets would be implemented to SwagKit. So this is why it's just, it works over TCP, the TCP protocol. So you need a separate server. And there are three ways how you can do this. So you can just create a separate app using new web sockets is one way, which is a very high performance web server written in C I think it used by Bunn and it known to be very good for WebSockets and the HTTP stuff You can use that, or you just use Node.js, and then a middleware or something. Not a middleware, but there are WebSocket packages. Dino, I think, supports WebSockets by default. I don't remember, but it's something you can use, of course, too. or another approach is if your code, like your WebSocket code, is shared or your SwagKit backend and your WebSocket stuff shares a lot of code, then you might want to sketch essentially your SwagKit app and your WebSocket server together into one app so you're able to share the code code and you can do this adapter node and the where is a custom server feature um where you essentially compile a swell kit to a middleware and you mount that middleware in an express app and where you can also have your web socket server and on the client side um it's very simple so this is um how it now works in in swell kit it is very similar in in sweats or sweat for it is very similar in SWORD3, but now in SWORD4, what we can do is we can have readable, and that readable now gets the set and update function passed. I think in SWORD3, it was only the update, only the set function, and the update function is useful if we have an array, and we don't want to overwrite that array all the time using sets, so we need access to the update function. We just create a web socket server a web socket connection using the web socket interface which is built into the browsers then we listen for events um and in the in these and what you don't see here but in the event listener this is where you would just call updates um to to update the stores for value and then we just return a function that closes the web circuit so now every time you import the store and use it, the store will automatically connect to the server and also close automatically if there are no subscribers. So it's very easy. You don't have to think about when to open the connection, when to close it. The store will just connect automatically and close when you use the store.

 So if you're on a page where you don't import the store and you don't use the connection, there's no connection, it's closed. The next slide, server set events. This is why it's so easy to do, because it works over HTTP. We can just return a readable stream as a response in a plus server.js endpoint. And yeah, a readable stream is essentially just just a text response that never ends. So inside our start function, we get a controller and we can just push text in a specific format that I'm not going to cover now, but it's very easy. It has like, yeah, four properties, ID, name, or event, and data. And data could be stringified JSON usually. And on the client, it's almost the same as with WebZockets. So you have a event source. instead of a WebSocket that you open. There is one use case that is a little bit like, you know, the chatGPT. The way it works is you type something into the input and send your prompt, and it makes, I think, a post request. And it makes a post request with your text as the body of the request, and the server returns an SSE stream, but it closes the stream once the result has been fully returned. The problem is, or the small issue is that event source, there's nothing in the SSE specification that says SSE can only work over a certain HTTP method. So event source always uses, it always makes a GET request. that means that if you actually want to make a post request you can't do that with the inbuilt event source and yeah if you're building something like a chat gpt like app where you actually want to make a post request there are one or two packages that you can look up and they replace the event source and they work exactly the same but you can make an actual post request and then on the server side in your SWATKit endpoint. So get the body, process the body, and then return a SSE stream and close it once you done For that you need another package Yeah, then the last slide has some other options listed. So there's socket.io, which is very popular. Or it used to be very popular, but it isn't as relevant today because it was very popular in the early days of WebSockets where WebSockets were not supported or browsers, and it was able to fall back to just HTTP and polling. But it also has an event-based system implemented on top of WebSockets. So it works similarly to SSE. Instead of just pushing data to the client, you can make an event. And, yeah, the events can have names. You can put connections into rooms, which is very useful in order to implement isolated chat rooms. But these rooms are really just a map and a set. So you can do this yourself, too, if you're using SSE, for example, or something else, just raw WebSockets. Pusher is another service. Personally, I've never used it, but it comes up all the time. LiveBlock is something new, we're just used to, yeah, in collaboration apps. These technologies all work over WebSockets. And in that case, if you use them, you don't really have to do with the internals of WebSockets because they just have an SDK that you use. Firebase has a real-time database. pocketbase also allows you to stream I think changes from your database to your front end again you don't use the web socket interface in that case you just use the SDK and superbase has another similar SDK that it can use yeah that's essentially it cool and I believe pocketbase uses server syntax is that right? that I actually don't know I'm not sure Okay, obviously we can all confirm. So for these listed options, these third-party providers, this is compatible with any SvelteKit adapter, right? Because your client connects to them directly? Everything except Socket.io because Socket.io has a server part and a client part. So the server part allows you to create a WebSocket server that would have to be implemented in a separate app Socket is a NPM module that you install on your Node server Yeah, exactly. Okay. And if you are self-hosting, like using a written-from-scratch WebSocket server or Socket.io, then you must use either Adapter or Node. But I think Edge servers work as well with that, right? Yeah, yeah, yeah. So I have never tried it, but Cloudflare is just Edge. And Cloudflare workers, they allow you to have a web sockets. You can use web sockets with Cloudflare workers. And Cloudflare workers also power is oversell Edge. And they say on the page, oversell, it says it has no timeout. So an Edge function can run for as long as necessary. So theoretically, it could work. but I've never tried it. Yeah. And I don't know how it affects billing. Yeah, this is a great introduction though. So for any of you wanting to implement service and events or WebSockets, keep in mind your infrastructure. If you want to run these sockets yourself, you'll probably need a Node runtime, Deno, Deno runtime, or an Edge server. But if you're using a serverless provider such as Netlify or Vercel without the Edge runtime, then it probably won't work and you need a third-party provider such as Firebase or these other options. Yeah, exactly. Cool. Thank you so much for answering that Q&A. The next Q&A, and probably the last one, is way down here. How do I authorize users? This comes up time and time. How do I authorize users? Also known as how do I protect routes? and the answer to that is don't use layout because layout loaders are cached pretty hard and you cannot safely assume that when you log out a user and you destroy the session that your layout load will invalidate for you. So what I mean by that is you have loaders in SvelteKit and you know you have page loaders you also have layout data that can load. I don't think layout is the appropriate place for you to authorize your users. So when you're loading data in a layout, this is probably not the best place for you to authorize the user, such as look up their role in your backend or return sensitive data. Instead you should most likely run this on a per page basis or using the handle hook in your hooks file And if you loading privileged data you need to redirect users in order to safely invalidate the data. So if you happen to be using a layout to return sensitive data, then it should also somehow, I think when you log out the user, you probably should do a redirect or be very careful to call invalidate all if you're doing pure client-side navigation, because invalidate all will force the load method to be called again in your layouts. So this is all very sensitive stuff, but there's a related discussion on GitHub you can check out over here if you want to learn more about protecting your users and your data. The discussion is called add layout guards, but there's a lot of linked tickets and issues related to this subject of being careful not to use layout for the wrong purposes, such as authorization. Check that out too. Link is in the chat. Speaking of chat, let's just double check the chat here. C writes, I prefer SSE over server client post and for ease of development. Yeah, and I think Karim, you're also a big fan of servers and events because your Svelte storage are simple and your back end code is simpler too. That's a big reason to use that. And then C writes, I think what confuses people is that page load for a route runs runs regardless of whether there's a slot to render in. Yeah, if you do use a layout load there's other considerations to be made such as await parent using parent I think. Await, yeah down here there's an example of await parent. If your page has a parent layout you can call await parent in the load function to force the layout function to be called, but this creates a waterfall of requests. So this is also like a space you don't want to find yourself in if you can avoid it. Layout is great for UI, absolutely. But when it comes specifically to like protecting data and authorizing users, layout should be avoided. That's my recommendation. There's also the handle hook. So the handle hook is called at every request. But since I had mentioned the layout load gets cached pretty hard, like when you navigate from page to page, the layout won't get called again unless a layout dependency gets called, or if you call it validate all. So that also means when you run handle, this handle will get called before the first time

 layout load is called, but not subsequent times. So here you can actually make authorizations on a global level, so that anytime a user loads a page or refreshes a page, then this will get called first, and you can perform authorizations in your handle. So this is a great place for that, also mentioned in the GitHub discussion link there. And we're gonna close off now. And that's it. Thank you for tuning into this week in Svelte. Have a great day, and I'll see you next time.