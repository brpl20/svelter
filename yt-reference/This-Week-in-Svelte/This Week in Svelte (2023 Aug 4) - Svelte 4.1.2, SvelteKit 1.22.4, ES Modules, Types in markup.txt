 Hello! You've made it to this week in Svelte. I am your co-host Enrico and joining me is Paolo. Hi everyone. Good day. And the agenda, as per usual, is a changelog, quick facts and announcements. We have a community showcase, followed by discussions and questions and answers. Let's get started. It's changelog time. all right the chat is on screen and the changelog starts with svelte kit 1.22.4 and these are really small patches very self-explanatory prevent duplicate module preload or should i say time to explain this changelog duplicate module preload i think was referring to the links in the header some for some reason they were preloaded twice but that's been patched They're using the rail module preload strategy. I'll bring that on screen for... Basically, they preload the link. You can specify what you know that you will need, and this module will be pre-fetched, right? Yeah, and I think the issue was some of these were duplicated, but no longer. So the module preload strategy is back. Next, elaborate credentialed fetch behavior. For those of you using very advanced fetch headers, such as credentials include or credentials same origin, now the credentials include method will behave as expected. And this is because Felkit wraps undicifetch, and some of these considerations had to be made by hand. R asks, do we have imperative API for module preload? imperative API, sort of. I don't think so. I don't know if you can override the Svelkit-provided strategies. I'm not aware, nor have I looked into this. But I can take a quick naive search, see if there's such a setting, but I don't believe so. Preload strategy. Options related to the build output. So by default, it's module preload, and it looks like preload.js and preload.mjs are optional. So if by imperative API you mean config there this I post it in the chat I don know if there a way to declare each module or each page strategy but if you curious about that maybe there a GitHub issue We can look into it another day. All right, next is Svelte, 4.1.2. Allow child elements with slot attribute within Svelte element. I tried to reproduce this, but it turns out this is a custom elements fix, not a Svelte fix. For example, I can't say it better than they did. When you're developing with slots like this one, here a Svelte element is being used and you can give it a tag name and give it a default slot. This works. It works in all versions of Svelte, but for some reason compiling this to a custom web element had issues, but now that's been patched. Wow, that's really, really edgy. like a super edge case. Kind of, but the component library maintainer has justified themselves because sometimes you want a custom Svelte element with a name slot or a default slot and this would error for web components, but now it's been patched. So that's good. Yeah, I mean, it's obviously better to have been patched than not. I was just very, I always curious How do you find such small edge cases? Yeah, well, if you throw enough people at it, every edge case will come up eventually. Obviously, obviously. Next, data star SVG attributes work correctly. I don't think this is a web components patch, but a generic one by Paolo Ricciuti. I know you. Yeah, yeah, I know this. Yeah, this is something that I actually encountered. like basically there was, you get a type error if you try to pass data slash something to an SVG because there was a missing type and it's a very, very small PR, very cheap PR. I just had one line of types basically. Yeah, and I guess a change set. So thanks for that. and that's the change log let's move on to quick facts and announcements how many facts can I provide today So one of them is more of a question than a quick fact and that is what are ES modules? I won't go deep dive into this. There are lots of better explained articles than this, but ES modules were sort of a modern standard introduced around 2017 for JavaScript because JavaScript for a long time has not had a proper module system. There were common JS modules in the past, such as the require statement. And I think when the ES modules were introduced, they used the new import syntax. And the key difference between the two is require is just in time and import is sort of pre-compiled. So for example, if you have a file that says import something from somewhere and you have another import, import my component from something that's felt. If this is how your imports are written, then Node.js will eagerly compile the imports. But if you use the old CJS syntax, the behavior would be different, such as require. And I see someone would like to speak on the stage. Come on down. Hello. Hi. So as I'm saying, there's require. And if you had require statements like const module equals require module, and you had a bunch of these at the top of your JavaScript file, they would be paused and loaded one by one. So they would not be equally compiled, but they would just load one at a time. Try your microphone again. We'll let you know if we hear you. Yeah, also, one other key difference is the fact that being statically analyzed, you can't dynamically import something. I mean, now there is the dynamic import way of doing it in an asynchronous way. But like with require, you could literally do if some condition equals true, then require module and this is not possible with imports but it's possible with dynamic imports. That right So the dynamic import like import with parentheses this returns a promise So if you await it you can sort of have the classic style of coding if something await import as you used to with var equals require something But the main question people were asking is, what are ES modules? How does this impact global scope? and when you load a module in a javascript module whether it's in node.js or in the browser they're not really global until they're imported in the file and then they're like accessible to that file so if i were to do a module like this and i'll bring up my code editor for better explanation one more zoom there we go so i do import something from somewhere maybe my text editor will recognize this as javascript and it does one more zoom and then i do something if i access something this is available now to this file i won't have access to this in the window document so if i'm in a web browser and i do window dot something like a really global variable, this will not really work. So in Svelte and ES module projects like SvelteKit and Vite and Node.js, this is the short, short version of what are modules and how do they work. So that's all I'll say for now. Next. And also I think another important thing to say about modules is that whenever you import them, all the file, all all the code inside the module once per time like if you import the same model from two files it would be still important still executed once by the way to our guest are you coding if you want to try your microphone again now's a good chance otherwise i don't think we can hear you unfortunately you can try rejoining the stage if you prefer I have another quick fact. Quick fact number two. You can use JS doc to type things in your markup. So for example, for those of you people who like to use TypeScript, we all like TypeScript, we can do that in our script

 tag, but we cannot do it in our markup. TypeScript syntax won't work here. So for example, if I do like this statement here, I can't use a return type like colon string because the compiler doesn't recognize the syntax and it breaks. But you can use JSDoc. So here in my button house, I am typing the cat event by preceding it with type detail name Tom, and this is a static event. So now when I hover it, I get my IntelliSense. JSDoc does work in your markup. So if you want to type your markup, this is how you can do it. And I have a second example. This is really interesting. Yes. So down here, I gave myself, this is past Enrico saying, show everyone the as constrick. Okay, I'll show you. So we have const person equals name string, but the name is written as peers. So when I do my IntelliSense here, I don't want it to be name string. I want it to be name equals peers. So you do JSDoc at type const, but I'm not done. The secret sauce is you got to ensure that the following statement is wrapped in parentheses. And this is the equivalent of TypeScript as const. So I have an unexpected token. That's probably my fault. Const person type const. Oh, that's correct. I think too many braces. Yeah, too many braces. No, I think... Oh, I forgot the last brace. It was a wrong order of braces. Okay, it's good now. So now when I have her name, it says peers. So this is the TypeScript as const syntax equivalent in JSDoc. You just do type const and you wrap your following statement in parentheses. So this works in Svelte markup. Yeah. I didn't even know that you could do this in JS doc. Like it's always something that I used to live by. Like whenever I had to write JS doc, I always wanted as const and I didn't know that this was a thing. But it's also much more interesting the fact that you can type things in JS doc inside the markup And does this works with TypeScript too Because if you using TypeScript and not JS doc to type your files, even if there is a JS doc comment, it does not recognize the type. So does it does this inside the markup? If the question is, can I use TypeScript syntax in HTML in Svelte files? The answer is no. Since the Svelte compiler doesn't understand TypeScript today, you can't. However, because the TypeScript server is running, and lots of people already know this. If you're a TypeScript user, you've probably already run into this where you tried to type something in your markup and you know you can't. The solution is to use JS doc. Because the TypeScript server is running, JS doc will work because it's a fully compatible syntax because it's just comments. So if I did this as const like this, it won't work because this syntax is not supported. Only JavaScript is supported for now. So that's why the JSTOCK solution works in the HTML markup. Can Svelte let me use TypeScript in my CSS? I've seen some open GitHub issues related to that. I don't have an answer, though. next quick fact is vs code extension command show compiled code so hat tip to sorella for showing this in the q a section on discord if you go to any svelte file like this one you can go command shift p and do svelte show compiled code and then this happens let me bring this in a better view it's the compiled Svelte code but I don't like the way it's shown in my editor, there we go so now you can have a preview of what the Svelte compiler will output this is the actual Svelte output of the page and it's all built into your code editor pretty cool and there's a couple of announcements go ahead Paolo No, I was just saying that this is very cool because I also think that if you really want to shine in using a framework understanding the internals can really be beneficial Like if you can look at the compiled code and understand why Svelte component works I really feel like you can shine in using Svelte Indeed. Hey everybody, can you hear me? Yes. Yes. Right now I fixed my mic. I just wanted to see a note about the ES modules. So, the ES modules, you can lazy load them too. When you're trying to use ES modules, you can lazy load them too, but common ES modules cannot. Okay. So let's see if we can break that down a bit. We're all familiar with, you have a function, And when you lazy load ES modules, you're supposed to do an async function and await an import. Yeah, I think await loading of the ES module, yes. Is this considered lazy loading? Yeah, I think it is. It will not load the module until you run the function. Yeah, and that's cool. If you want to save some space for heavy applications, you can use lazy loading, not to load it, so you don't put some heavy weight on the process when it goes. Yeah, lazy loading. And also, for example, VIT, if the module is just imported using the await keyword, like if you only dynamically import a module, VIT will smartly enough create a different file for that module. Yeah, VIT. VIT is cool if you want to do lazy loading. I use Vita for all my projects, my simple projects about Svelte. I use Vita in Svelte, Kitten, Svelte. Also in other frameworks. What if I do this? If I do the CGS require, this is also lazy imported, isn't it? Or depends on your builder. Yeah I think it is still lazy Like it not loaded when the main module load but i think what uh i was saying is that uh obviously you this is synchronous uh so whenever you hit that require it will wait until the module is loaded yeah and that's a kind of a good practice if you want to Imagine you have a Firebase project that is really heavy, you want to load some stuff until you call that function, you can use lazy loading. Yeah, that all makes sense. Thank you for sharing those details. Yeah. Alrighty. I'd say if I want to do some clarification about something that you'd say in the stream or something like that. Sounds good. So moving on, just a couple of blogs to get by. Ross Rubino had shared about document components before my screen froze. And this is a really easy demonstration. You go to a component in your code base like my button house. And if you do add component in the HTML comment, you can write down the description of what the component does. Therefore, in your consumption of the component, hovering it will show you those comments. Here it says my button house. I can also say, hello, this week in Svelte. Go back. and the comment updates. So there you can document your own internal components using add component and HTML comments. Check it out. If I haven't shared the blog already, I'll just share it again. More with that. Obviously, as every js.comment, you can use a proper markdown inside the js.comment to document your component. Yep. And one more. Indeed. One more article, which is a really nice one, by our fellow ambassador, Stanislav Kromov. They wrote a guide on the missing guide to understanding adapter static in SvelteKit. And very detailed, almost exhaustive nuances are described in the article. Check it out. Things like if you're using adapter static, do note that the Vite dev server will not reflect what you'll get on production. little nuances like that are fully described here. Please check it out. And that's it for Quick Cracks.

 Okay, let's move on to Community Showcase. We have a special guest today. Please join us on stage. Hey, my name is Krishan Erbe. I'm a freelance full-stack developer, and I'm the creator of Throat, which is a framework and basically now like kind of an ecosystem that lets you write or lay out and drive scenes in 3.js with the help of Svelte. So in a syntax that is native to Svelte in a way. And you can use, for example, properties, just regular component properties, as you see in this small example. Or you can use Svelte's event handling to, for example, listen to clicks on certain things. And if you're kind of, I mean, 3.js is a very popular framework. I guess some of you know it, maybe tried a little bit with it. And for some reason, I think a lot of people just like this kind of working with 3.js a lot more because it's just closer to also, for example, apps that you would use to make 3D content like Blender, for example. And we just released Svelte 6 four days ago. And this is the version 6 now of Svelte. And I'm just going quickly over what changed, because a lot has changed, actually. And I just wrote it down in this Twitter thread, and I'm just going to glance over it really quickly. Now, as I said before, Svelte is a Svelte renderer for 3.js. What does that mean? It means that Threault itself doesn't really know about 3.js that much. It knows about certain concepts, and it can use these concepts to offer you everything that 3.js has to offer in a declarative syntax. So there's really no limitation to it. You can use really everything that 3.js has to offer. But you can use properties, like, for example, this position property, peers property. So in this case, it's only setting the C component of the position property to the value of 10. And you can use your component hierarchy to lay out 3GS scenes And why would you do that in the first place I mean, it's just way easier to comprehend, especially if you're building medium to large sized 3.js apps. It gets complicated really quickly in an imperative coding style. You just lose track of where you have to add and remove stuff. and so before Thread6 we were not completely a 3GS renderer but we also wrapped a lot of stuff and we ditched that completely so I would consider Thread6 to be the first real major version of Thread which is kind of exciting for us also we introduced plugins you see this that these component T is there all the time. It basically does all the heavy lifting. And a plugin allows you to run code inside of that T component basically for every instance. And you can use it for, I don't know, create entity component systems like in this example or assign properties to every T component or something like that. But you can also use properties inside of a plugin. You can use lifecycle mounts, everything basically. We also now have a little utility that lets you create Svelte apps, which are basically Svelte apps, but then with all the configuration already set up in a little interactive CLI that works basically just like the SvelteKit CLI. So you're probably already familiar with that. And there's an awesome project, which is called TheaterJS. and it's something that I think the JavaScript world has been long waiting for and it's a JavaScript animation tool set which allows you to make animations just as you would, for example, in After Effects keyframe base directly in your browser and we already have an integration for that and we basically, we've rewritten it from the ground kind of and the creator of, we're really proud that, for example, the creator of 3D Theater.js said that it provides the best API and developer experience currently available for Theater.js. On top of that we have stuff like that your assets are cached application So when you are using the same texture twice it only gets loaded once and then it shared across all your application And we have a completely new website with a beautiful landing page, of course. You cannot not have that as a 3D framework and lots of examples and five packages that we are currently offering. And as I said, we have this theater package. And what I'd like to show you now is how to set up a really basic float app and how to integrate TheaterJS into it and how to drive, possibly, if I still have the time, how to drive an animation that you have laid out in Blender with the help of TheaterJS. So let's jump right in. I'm using warp as my terminal. And this is the command, npm create Threault. Just going to call it this week in Svelte. I'm a TypeScript guy. I'm sorry, Rich. I don't like JS doc that much. And I'm going for these two. And now this is the first Threault specific question. I'd like to add extras, which is just helpers and other components on top of this T component. You probably want that in pretty much every project. And I'd like to show you theater and this model pipeline that automatically translates GLTF models, which is kind of a standard 3D content format for the web, to thread components. And no git repository and not with npm. No, this is wrong. And now I'm using pnpm to install the dependencies. And I'm going to... Wait, this is wrong. Sorry. Now I'm going to open it in VS Code. I hope I set up the screen dimensions so that you see something. I don't see that much in terms of screen real estate. It not a lot Still if I now just running the development server just as i would with any svelte kit application it goes through some steps of optimizing dependencies and i presented with this kind of default scene oh that's already something right so i can move around by dragging i have these three things set up there's a grid on the floor and um this is all in source loop The app is a wrapper because this component provides context. We are making heavy use of the Svelte context API. And this one provides all the contexts that we need. So if we just move all of our stuff into like a child component, we can always be sure that the context is available. And inside of here, we see that this is the scene that we see. And I'm just going to take out all of this stuff for this presentation. It's not necessary to auto-rotate. And you see that the grid that I'm seeing, I hope that you can see it. Maybe because of the compression, you cannot see it. Anyway, there's like a tiny grid on the floor, and it fades away as soon as we move away with the camera. I'm just going to disable that too. And contact shadows, we don't need that for this presentation. I'm just going with a camera, the orbit controls that allow me to rotate the camera with the help of my mouse, and two lights, and this grid. grid. You see that the grid, for example, is from the package thread extras, whereas everything else, no, not everything. This one is also extras. But everything else is made up from this T component and is using 3.js classes directly. These ones, they wrap existing 3.js classes and give us a little bit of extra comfort or for feature sets. And OK. So but this is shaping up to be a threat app. Now, I wanted to show you how to first. First, I'll show you how the model pipeline works that I just installed. A common workflow is that you have some form of model in Blender.

 And in this case, I have this cube and it makes, I just set up like a really quick animation. It jumps, turns around 90 degrees and lands. And these are all transform. There's nothing fancy, it's not rigged. It doesn't, there's no bones in here, nothing. One thing to notice that the mesh is called cube and the animation action is called jump. And if I now export that, to static models. That's where all the models go. There's already a Threault file in here. We're just going to delete that one. And check back into VS Code. Then we see that in static models, we have this cube now and the Threault file. We export it from Blender in this GLTF format. The standard settings are fine most of the times. Now there is an additional package script, which is called model-pipeline-run. And you can actually check out the script. It's part of your repository if you set it up with npm-create-threlt. You have a couple of options how that now works. And did that work? Oh, sorry. Yep, it worked. And this script, for example, yeah, what does this script do? It uses this GLB file and creates a Threat component from it. Why would you want that in the first place? In regular or like in vanilla 3.js applications, when you load a GLTF file, it's kind of opaque. It's its own little package that you import and you don't really see what is in there. You don't really see what kind of animations are in there. And there's not a lot of ways to actually edit what is in the GLTF file. And this allows you to edit basically everything that comes with the GLTF file and also inspect it. So for example we see that one node is being imported which is called cube just as we called it in Blender And you also see that there an animation action which is called jump also just as we named it in Blender Now, using it is fairly simple. We just go into our scene again, and we import the cube. OK, here it is. I mean, it's not a lot, but it's there. how would we just play the animation first that is in there? Because that's what I wanted to show you in the first place. You see here that we're using this hook useGLTF animation. And this GLTF variable is a store that gets populated as soon as the model is loaded. And because we pass it onto this hook, the animation actions are being populated as soon as this GLTF store is populated. So we can actually check out what's in this action store. And you see that it's a map. And it has got this animation action, which is called jump. And it's also TypeScript enabled, so we can just get this kind of autocomplete. Now you can already see that we have the animation back in here. So this little operator checks if jump is available. And we are using that to only play the animation as soon as the action store is actually populated. And this one is only populated when the gltf file is loaded. So this is kind of the, it's very small in terms of line size, but a lot of stuff is going on here. And, okay, now the idea is to show you also how we can drive this animation with the help of TheaterJS. So this is what we're starting out at. And the theater.js package comes with a component, oh, nice, which is called theater. And it's kind of a shortcut. It gives us everything that we need to work with theater just with one component You see that there all of a sudden a little bit of extra UI on our website This is the so-called Theater Studio. And unfortunately, it's not named, but this is a default project that has been set up for us by this theater component. There is a default sheet. A sheet is kind of an organizational layer. of TheaterJS that has been set up for us. It's also called default. And we can actually just start using TheaterJS now inside of our application. That's as easy as it is. Now what I want to do is, the idea is to tie TheaterJS into the rest of our animation system, into the rest of the Theater, of the 3.js animation. And the way we do this is by using the component sheet object of the ThreadTheatre package. Now it's complaining that it's missing a key, so we're giving it that. Just call it cube. And you see that now we have this sheet object. This is a sheet object. It's an object on the sheet default called cube, but it doesn't have any properties. So we can, for our example, we just give it props directly on here. And we'll want to have the property, what do we call it? Animation progress. And this is now something a little bit more involved, but TheaterJS comes with a little utility to create these properties. And I'll just show you in a second why we want that. This is a little bit of boilerplate. I'm sorry. So we are creating the property animation progress as a number with the initial value of zero. And it is always in the range of zero to one. now there is already, okay, okay, I have to rename that, sorry because local storage Qbex so there is now a little bit of UI on here Oh I getting a I sorry So there is now a little bit of UI on here, which is called animation progress. And you see that it's kind of a range slider that goes from zero to one, just as we wanted. And now we have to hook this slider up to the animation progress of our cube. How would we do that? First of all, we go into the cube, and we are getting rid of this kind of stuff, because this is actually not how we do it now. I'm sorry, I should have modified the pipeline first. Anyway, we are setting up just a regular property, and we just call it animation progress for the sake of clarity. And we are using a regular reactive, if Svelte Reactive Statement to first check if the animation action jump is defined. So actions jump. We put that in an if statement. Then this is something that just, It's necessary for 3.js. If it's not running, if the animation is not running, we play it. But also, we immediately want to pause it. Because we want it to adhere to the value that we are passing it in. And then we are setting up the time to be the animation progress times the length of the clip. And by that, let's say the clip is two seconds long, and we are multiplying that by a number between zero and one. We always are in between the beginning and the end of the animation. And just like that, we are ready to

 to pass in our animation progress value into the cube component. Now, how do we get that value out here? We use the slot syntax to get a property called values, a slot property called values. And that one is reactive. So we can pass the animation progress property and use this values slot prop and you also see that it's automatically typed so values is is also correct type correctly typed by by this object um now that doesn't work of course it doesn't work can you spot the error i can't animation progress That works. Jump. Oh, sorry. Okay. Now, this is a method. So now, you can see from 0 to 1, we hooked up this animation to a property in theater. Now, how can you animate that? Because this is kind of the whole point of TheaterJS. You can animate that by right-clicking on here and setting up a sequence. And a sequence is a sequence just as you have sequences in After Effects, in Blender and everything. So you have like a dope sheet down here. That's what you would normally call that. and you set up a keyframe at the very beginning of the sequence and let's say, I don't know, two seconds, I think, it was in Blender. And just like that, when you press space, it plays the animation that we initially laid out in Blender. You can think of several use cases for that. Normally for example in large projects you get these kind of animations and models by someone who professionally does 3D modeling and animation So maybe they would like to see animations that they did in Blender in there on a website, and then it's just easier for you to kind of sync up maybe other animations that you want to do in TheaterJS this way. Also, it just shows how you can mix and match these kind of tools together to get the best workflow you can imagine. Now, how would I now use this to kind of tie it into another animation? If I go back to that scene, this is where I placed the cube. And now I'd like to have an effect underneath the cube that when the cube on the way down hits the ground, there's like a little bit of a ring that kind of expands. I can use the T component and create a new mesh. I can use the ring geometry from 3.js. And a mesh is always made up from a geometry and a material. And in this way, you declare these. And you see it down here. But you already see that it's rotated incorrectly. And this is because we have to rotate it on 90 degrees on the x-axis. And yeah, now it's there. We just cannot see it because it's underneath the cube. Now it's something really fancy. We can add additional properties to this sheet object cube x by using components that the sheet object is giving us as slot props. So there's this component called transform, and it adds transform properties. Oh, yeah, okay. Now, it adds transform properties, so position, rotation, and scale, to our sheet object. And now you can use, for example, this thing to move the ring around. And you see that the values are reflected here. Actually I think it would be better to call it ring transform So the key needs to be alphanumeric So it ring transform with a label of ring transform And now it's grouped underneath ring transform. And now something even more magic maybe. There is another component that we get, which is called sync and the sync component can use properties from its parents to sync it up with the theaterjs component so in 3js if you want to make something transparent or even half transparent you have to provide the flag transparent and we want to sync the the opacity property of the the material with theater.js. And you see that now I can control the opacity of this object right in theater.js. So when it hits the ground, we want to have an opacity of 0, scale of 1, And over time, more opacity and a little bit larger. Then again, it should also, again, be less visible. Now, of course, this is not like a very ring. Is that ring? Ring geometry? Isn't that the one? Anyway. Now, of course, the animation can be way better, but you already see that the benefits of having these kind of systems overlapping and also controlling each other are really beneficial. Yeah, so this is kind of the end of the presentation. I hope, I mean, it was probably a little bit too much for some people because not everyone is accustomed to 3JS. But I hope that you gained a little bit of insight why we do that project and why it's kind of a big deal also for my professional practice. It just so much easier to bring stuff to life And as I said 15 people contributed over 900 commits over the span of eight months So we are really excited about that release And if you want to contribute go to ThreaultXYC We also have a very lively Discord community. Really happy about that. And that's it. Thank you. Thank you so much for presenting. Everyone give a hand to our speaker. I will be sure to share Threlt and the Threlt Discord in the YouTube description below and that was really nice I like how easy Threlt makes it to import geometry from Blender and to have a compile step to build it into Svelte components like that to me was pretty magical I agree wonderful is there like a Q&A now? unfortunately we're out of time but you can check out the discord chat and I think Sorella had a question further up you can always reply to them asynchronously and if anyone has any Threault specific support questions there is a Threault discord check out the links and we'll catch you next time thank you so much yep thanks for having me bye and maybe there's time for a question and answers period so let me pass it off to Paolo Yeah, I was preparing a small demo in SvelteLab, which I kind of, I want to show something that I worked on, which I think is pretty cool. And basically, I will share my screen and we can live code it. So, basically there might be some times where you want to show a component and maybe it's a fancy input, like for example, a range slider or something that actually does not exist in regular HTML. So you need JavaScript to make it works. But at the same time, this is kind of a bad experience for accessibility, because if the only way you have to set a value, for example, is through JavaScript, well, that will not work. But at the same time, you don't want to forego the fanciness of that when you will have JavaScript enabled. And so...

 What I come up with is, in my opinion, quite cool component, which is called noSSR.svelte. And this is a very, very simple component that basically allows you to show a fallback, a completely different fallback, whenever JavaScript is not enabled. And we can kind of do that with no script, but that will not exactly work. So basically, it's an abstraction that allows you to do so. And the way it works is it makes use of await, which is a block in Svelte. And the way it works is that you await a promise that just instantly return. So you can just create a basic async function that does nothing. And you can insert your fallback here. So you have slot name equal fallback. And then you can have normal slot here and you have to separate these with Dan So what it does is that if if there is JavaScript enabled it will immediately go to the Dan. And if there's no JavaScript enabled, it will be stuck to today's to this lot. And this way, for example, if I import these from no SSR, you can quickly do no SSR and I have to restart that server. And this means that I can normally pass my fancy JavaScript input, for example, but I can also provide, for example, a normal button that will be used when JavaScript is not enabled. So normal button. And as you can see this button gets not rendered but it will be rendered if we disable JavaScript So if we open these in the split view and we I mean it The dev server stopped. Well, I see the normal button, so it works. Yeah, I mean. But what I was trying to show is that if you disable JavaScript here... Come on. and try to refresh the page again. I mean, it's crashed again, but this is a normal button. So, uh, you can basically show a fancy that only works with JavaScript, uh, form element, uh, when JavaScript is enabled. And if JavaScript is not enabled, you get a boring plain old HTML, boring plain old HTML form control. And while I was also writing this, it got to me that you can also just use on mount for doing this and you don't need to do this complicated stuff. But I tested it and actually this runs before the on mount So it a bit better because you get when JavaScript is enabled you get the actual content before the amount So it a bit better because you get when JavaScript is enabled you get the actual content before the amount Very cool. Can you please zoom in a bit to the no SSR component? So it's cool to just zoom in a bit. Yeah. I see that you're returning an immediately returned async function that satisfies the awaits. And it looks like during SSR, they respect that. like okay i'll show you the fallback first you can even do promise.resolve yeah or return exactly you can pass in a results promise very cool yeah i mean it's useful there are some form elements that require javascript for them to be fancy like a range slider because We don't have a range slider yet in HTML, but rely only on them without having a fallback. It's a bad practice because then without JavaScript, your user cannot submit your form. Awesome. I will share my screen now and wrap things up. And that was questions and answers. How do I render something when JavaScript is not enabled? Paolo showed you how. And that is it for this week in Svelte. Thank you very much. Bye bye. Bye everyone. See you next Friday.