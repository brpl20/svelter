 Hello, everybody. Welcome to This Week in Svelte. My name is Enrico, and I am your co-host today. Joined with me is Kareem, Svelte contributor, community member, and overall, really great person. Welcome, Kareem. Thanks for having me. Yeah, and Kareem and I will be going over the changelog, Quick Facts, a community showcase featuring Kareem. and this week in discussions finally leaving off with this week in Q&A. But maybe your questions will have answers before we even get to the last point. So let's do it. The change log. Today's change log, or this week's change log, features SvelteKit changes, versions 1.15.10. We'll start at the bottom, and we'll work our way up to a new feature. The patch changes include a logging and an entire error object in the default handle error. So the fix here is handle error would usually throw errors, but sometimes it would strip out the nice terminal formatting. With this fix, you now have that nice terminal formatting forwarded. Thank you for that. And in version 1.15.11, we have some more patches. We have compact representation of invalid search params. This was a fun one because it reminded me of a Node.js feature or a JavaScript feature about the way numbers can be represented. So for example, let's zoom into our node terminal. 100 equals 100. 110 equals 110. 1 underscore 1 underscore 0 also equals 110. I rarely use this feature, but you can. 1 underscore underscore underscore 1 underscore underscore 0. Oops, that's too many underscores. Don't do that. But at least the underlying notation of numbers is more compact thanks to this patch. You may not see this in your day-to-day. 0, 1, 1, 0? Sure, let's try it. 0, 1, 1, 0. Oh. Accidental binary. Oopsie. Is that binary? Let's see. I can do math It octal Okay Well there goes my high school architecture course Next changelog is there an import path fix for Windows So kind of running on the heels of Windows fixes last week, we've got some more very useful import path fixes to the app script. I think this had to do with just general fixes. I didn't want to confuse this with the next fix, which is app navigation. more resilient to bundler reordering. In Vite, you have the option to override the manual chunk splitting with rollup. And there were some issues with the app navigation exports, such as before navigate, after navigate. Sometimes these would not get called correctly in their chunks, but with this fix, they should be. Thank you for that. Next, we've got page load fetch. Am I zoomed in enough? I've never zoomed in enough. All right. Whoa. Page load fetch now accepts the same input types for body as a fetch function. There was some interesting code in the Svelkit flavored fetch, which is a wrapper of Undigi fetch. It was stripping out some body stuff, but that has since been removed because a user pointed out that there are some features of the response body that needs to be included. And in this fix, you can now have, I'd say, 99.9 or 100% close to native fetch functionality in terms of what the body accepts. So that's a patch two. And then leaving it off with handle preload and filter serialized response headers and sequence function. This refers to the handle hook. So in the handle hook in SvelteKit, you can pass in multiple functions into a serializer using the sequence helper function. And this is underutilized for me personally, but some folks like to split up their handle logic into multiple functions. You might have a really large handler, and then here you can do a middleware style approach. And with that, you can also do something like module preload. So preload, there was an issue with preload not working when you use the sequence helper. I'm not zoomed in enough, never am. So if you have multiple functions put into the sequence handler, I don't think preload was being called but with this patch it now does Preload helps you specify resource hints for things like JavaScript and other assets By default SvelteKit provides a preload handler that I wasn't too familiar with, and that is module preload. Let's take a look at that. So resource hints, as you may know, tells the browser what you should preload or DNS prefetch, things like that. And if you do rel equals module preload, This will help resolve module scripts and JavaScript before they're actually loaded. It's very handy. SvelteKit does this for you by default. And now you have a little bit more control over that you've always did with preload. You can pass that in to your handle. And that is version 1.15.11. And then last but not least, 1.16.0. We have a new feature, route level entry generators, export const and stries. I should share some stuff in the chat. So here's some chat stuff. And there's the server handle hook. And now for this new feature. Take a look at this. So this is the documentation for SvelteKit page options. Page options includes export const pre-render. Some of you may be familiar with these. There's a new one way down here called entries. And it looks like this. Export function entries. Now at the route level in a page.server.js or page.js or TS, you can export entries. Rather than put them in your Svelkit config under config kit pre-render entries, you can have them right here in the route. This works especially or primarily or exclusively for dynamic routes. Svelkit knows to pre-render defined routes. It does not crawl dynamic routes automatically. It only crawls them if there's a hyperlink rendered on another non-dynamic route. But with this feature, you can inform Svelkit, hey, this dynamic route here, bracket slug bracket, I want you to crawl it with these entries. Now you can do that at the route level. Nice object-oriented content design happening here. And that's now version 1.16.0. Take a look Here your link And that is it for the changelog Let move on to Hold on to your Sveltebelts. We're in for some quick facts. We don't have much in terms of Q&A this week, but the QuickFacts hopes to address some of those things. Starting off with secret variables. In Svelka, did you know, this is like a public service announcement, are you familiar with dynamic and static variable handling, environment variable handling? Oh, Cirilla has a sneak peek for us. Are you referring to 1.16.1 change set? I didn't talk about this. Oh, issue 1998.11. I can try. I can do some unprepared analysis of pull request 98.11 as soon as my computer blasts off into outer space. is it an issue or a pull request this one okay remove entry points for a smaller bundle size opened yesterday merged already What happened here? What glorious fix has been released under my nose? We can just get rid of these? Okay. Remove entry points for a smaller bundle. Cool. one fewer request is now made for every layout and page yeah i think everyone likes shipping fewer bytes of javascript and we did it we have much fewer bytes now thanks to this so i'm not sure if this is released yet according to

 the change set or the CI pipelines here. It looks like it's merged. I don't know if it's released in 1.16.1. Maybe it'll come out of the next patch. Cool sneak peek. Okay, so back to some public service announcements. If you want to handle environment variables in Svelkit, Svelkit provides some helpers for that. You have dynamic private, you have dynamic public, and then you have static private, static public. You want to utilize these depending on the context of your app. If you're using adapter node, for example, on Docker, dynamic private is often a go-to. You can also use static private, and there's various pros and cons, which I won't get into now. I did cover this in a prior week, but I just wanted everyone to be aware that if you have secrets such as database credentials, you want to make them private. Dynamic or static is really up to the context of your app, but private has to be a variable like this. Deployment specific variable. Any variable becomes private, but a variable prefixed by public will be public. Public meaning the client can see it, your end users can possibly see this. So be extremely careful of what the difference is between public and private, and this should hopefully help some folks in the Q&A this past week. In Vite, Vite also handles public variables with the Vite underscore prefix, and since FeltKit is a consumer of Vite, both of those apply here. So public prefix and the Vite underscore prefix will both be treated as public variables. Watch out for that. The next quick fact is, oh yeah, I'll show the links down here. So yeah, double check your understanding of environment variables. Reactive statements become functions that are called after script. So let's take a look at this minor detail that I missed. I personally missed this, but I wonder if it'll be interesting to some of you. In the Svelte documentation when covering one of the most fundamental aspects of Svelte which is reactive statements did you know that reactive statements are actually executed after script So this is a special svelte behavior For example you have this reactive statement here Whenever the dependency changes, then the preceding statement gets updated. If you have a block like this, console.log will execute anytime title changes. but all of these are declared in the root scope of script. So here's your script, and in the root you have these reactive statements. You can only define these in the root, but they don't actually execute until the end of script. So this gets parsed after it gets compiled. This will run top to bottom, and at the end of script, only then and right before components mount will these reactive statements run. So there's a sentence for that. I'll read it to you. Reactive statements run after other script code and before the component markup is rendered. Unlike plain JavaScript, or some may call it the French vanilla JavaScript, in plain JavaScript, label statements get called linearly, but in Svelte, they have special behavior and special meaning. So do note that reactive statements won't get called linearly. That means if you expect this to instantiate from top to bottom, you cannot expect document.title to equal title directly below this line. It won't work that way. Let's read the chat. Jinx writes, how exactly does it know which is the dependency? Good question. So this is the magic of this file compiler. The compiler will analyze these reactive statements and look at anything on the right-hand side of the equal sign. The right-hand side of the assignment, that becomes a dependency. Anytime these variables update, this entire reactive statement will run. So let's highlight another one. In this reactive statement, anytime title changes, then all of these console logs will run. It's not necessarily on the right-hand side of the assignment. It can also be whenever it's declared or even utilized within the reactive statement. parameters to a function as well. There's some excellent tidbits about this on the Svelte Society website. Let's go there. Svelte if I can just spell Svelte Society Okay I share this in the chat If you go to Svelte Society I think it under recipes There's a cheat sheet here for reactivity. Very helpful guide. It shows you how to use advanced Svelte reactivity with functions and other cool stuff. Check it out. And I'll share the documentation. And we can all move on. So that was a quick fact. Let's share some more. All right, next is, did you know about the media query range syntax? This is something I saw in a Kevin Powell video yesterday. So according to CanIUse, there's a thing called CSS media queries range syntax. It looks like this. Let's zoom in more. Let's say you have a media query. You can do 100 pixels as less than or equal to width. This less than or equal operator in the context of media queries is known as the range syntax. It is now commonly supported in browsers. I'd be mindful of Safari users. Maybe they're not fully migrated to 6.4, but it's more or less widely supported for general audiences. Do take a look for exceptions. But yeah, you can now use media query range syntax, which is a nicety that brings you features like specifying one value without having to plus one pixel or minus one pixel. We typically, like personally, I like to use my media queries with min width. I always try to use min width. I avoid max width. But let's say you do use max width. Instead of saying min width 100, max width 99, or some 100 minus one value, you can now use the range syntax to say if at media 100 pixels is less than equal to width, then you can do another one that says greater than 100. Less than or equal to 100, greater than 100. It just looks a little nicer. So try out the range syntax today. I'll share that here. And that is it for quick facts. Moving on to Community Showcase Let see I think we have a special guest today Come on down So hello. Can you hear me? Yeah. Give yourself a light introduction. Okay. So, yeah, I think most people know me. And we had the idea of covering a few practical sweat and sweat get examples in videos or in streams. and thought it would be a good idea to maybe just combine this with the Friday streams. So hopefully in the future, I'll be here more often to cover a few things, a few examples. And today will be mostly about Swart Stores because we had a lot of questions here on Discord that come up relate to Swart Stores. And we try to get a little bit more in-depth and try to answer questions such as what stores actually are with the lifetime of the store. Can I set a store's value on the server? This came up yesterday. And how can I actually use a custom store? How can I boot one? And how can my app benefit from one? So, yeah. Yeah, I've tried to answer some of these or most of these questions, hopefully, by just trying to boot a store from scratch. and I think it hasn't been too long since here in the SOA documentation there was a section edit cause store contract should be able to see this I think on screen and there are three points mentioning what is store needs to fulfill basically to be a valid store and yeah also means that if you build a store you don't necessarily have to use a readable or writeable from the select runtime everything or literally anything that fulfills the store contract it has a subscribe function mentioned here that returns an unsubscribe function is a store so that includes any object any JavaScript class and even functions theoretically because I think functions in JavaScript can have functions or it's just read but it works and yeah so let's just take a look the The idea is to just create a function, call that createStore. And this function, it could be a class if you prefer to use classes, but I like to use functions. And that function is just going to return an object, which is going to be

 sorry, our store. Please bear with me. This is the first time I do anything live. We're just going to create a store by calling function, sorry, create store, and try to render that with Swell's dollar syntax, which right now, of course, doesn't work, doesn't do anything. I'll give you an error saying here that the store variable doesn't have a subscribe function, which is the first point mentioned here in the documentation. Every store must contain a subscribe method, and it must accept as its argument a subscribe function, a subscription function, which is just a function that gets passed in the current store's value. It does something with it. It doesn't return anything. And to do that, we just create a subscribe function here. It accepts a function, we just call it callback or function maybe, or just call it callback. Right, yeah, callback. And it has to save the subscriber some of the callback. And there are two things to do this. You could either use an array, which I would generally not recommend because it doesn't have a function to remove elements. It only has functions to add elements. So what you use instead is a set. So we just create a new set. By the way, if you have any questions, you're free to ask them, and Enrico will probably put them up. We have set for the subscribers and we just add the subscriber to the list. We call the callback of the store's current values. Currently, you don't even have a value. The value could theoretically come from anywhere. We just create a variable for it right here. And maybe also pass in a parameter to create still function to give it an initial value. Makes probably more sense yeah initial value And yeah we call the callback with the value As mentioned here this subscription function must be immediately in synchronously called with the store's current value upon calling subscribe, which is what we do here. And last but not least, we have to return an unsubscribe function, which at a minimum should just, in our case at least, remove the subscriber, the callback function from our list of subscribers. And this is why a set is more useful here because now we can just call delete on the set and pass in the callback again. And you see what I do. Oh, my subscribers call. I probably missed something. subscribe function. Why does it say undefined? Oh, of course, yeah. Our initial value is undefined. We're just going to parse in one. And you can see this is already a valid Swell store. It renders one. It doesn't do anything useful yet, but we try to recreate the writable store from the Swell runtime. And yeah, first let me show you. Okay, so we have a store that doesn't really do anything much other than just showing our initial value, but it works. You can see we use the dollar sign syntax here, and it just renders as any other store does. And I'll try to do something more interesting by just creating interval. Set interval. out, call it maybe every thousand seconds, thousand milliseconds, and just increment the value by one. So you can see nothing actually happens. It's because every time we change the value, we have to, of course, notify our subscribers. And the set has a forEach function that we can call to loop loop over our subscribers. Get the callbacks. Yeah, and then we just call our callback, each callback again with a new value. That should work yes You see here there are a few or is this mostly because it a bit dirty here I create intervals but it never cleared them So I have to reload the page just to be safe Yeah, so now it works. There are no other timers in the background. Yeah, and that's pretty much it. We have a store without any dependencies on the spread runtime. And you could probably use this in production. But we're going to go a little bit further and try to also here create a set function. It's really simple. So we have a function that we just call set. Because let me show you. Right now, if you were to go down here and try to assign a value to the store, let's say 100, it doesn't work. I would give you an error saying that you don't have a set function on the store here. So let's create a function. And it just accepts a new value. It sets the store's internal value to the new value. And then, of course, it has to notify all of our subscribers that the value changed. So we can think it's a little bit too quick. Hope this works. Like this. of a set function, it accepts a new value, sets a new sub-value, and then just loops over over our subscribers and calls them with the new, newly set value. So we can just simplify this by removing this and wrapping the set function around this. That should work. And here we have to return our set function, of course. So it starts at 100 because we set the value to 100 using the dollar sign syntax, and it just keeps going. The last thing, a very interesting thing is, I think, if you go to the documentation here, to, yeah, writable, readable stores, you can see it's a little bit difficult to understand here. but the writable store and the readable store too, they have a second argument which is optional that allows you, it's basically a function called start and it gets passed in the set function and it called whenever the subscriber count goes from 0 to 1 So because there's an article, I think. What is it called? The Quest for Java for Reactive Script, I think. For Reactive Script. It's written by the creator of Solid.js. And he basically explains what reactivity is, how it works, and how most JavaScript frameworks implemented it. And down here somewhere, he says that basically in Swellt, this is what it looks like in most JavaScript frameworks. So if you have a value that you want to be reactive, if you have to define a signal. But SWAT treats every variable inside a SWAT component already as a signal, which has the advantage that you just don't know, just don't have to explicitly define signals. But the disadvantage, of course, is that you can't use signals outside of SWAT components. This is why we need SWAT. And one interesting thing about stores is that we just have actually, because we've managed everything ourselves, we always know how many lines of code or if the store is currently used because we know we can check the size of our subscriber set. And if it isn't zero, then it's currently being used somewhere. So what we can do here is in the subscribe function, before we turn the add subscribe function is we can check the subscriber count. Subscribers upon size. Yeah, if you would be using an array, it would be subscribers to length, but for a set, it's subscribers to size. And sorry, we check if it is equal to one. and if it is, and we have a start function passed in here at the top, we're going to call our start function and we passed in the set function. I think there's a little bit of a

 here because the update function that we haven't defined yet is not part of the SWED contract. You can see it's not mentioned here but it has a benefit of giving you the current value of the store and allowing you to modify the value of the store based on the current value. But the start function only gets passed in as you can see the set function. But anyway if there is a subscriber if the subscriber size or count is 1 after we add the callback, we know that the subscriber is the first callback right now, the first subscriber, and we can call the start function. We have to, as you can see here, the start function returns optionally another function. I think that is a little bit difficult to see. Yeah, there's a stop function. So we need to find a variable somewhere here that we just call let's stop. And then we say stop equals start. And if the stop function returns a stop function, inside our unsubscribe function, we check again. But this time, only check, we have to, we check, sorry, we check if the subscriber count is zero instead because that would mean that the subscriber that currently unsubscribes was the last subscriber. So we say subscriber equals, subscribers.size equals zero and there is a stop function, then we call that stop function with the set function. Yeah. And we had a question just a few days ago. I think it was, can I close it? Yeah, I think I'll close it. Let's check. Let's see in the ecosystem somewhere. Here it is. Let's say you want to create a store that somehow does some polling. it's connected to an API and you're fetching, you refreshing the data every 15 minutes 20 seconds whatever you can pass in a star function here to the writable store Just a little bit Okay You start the interval inside your start function, and you return a stop function that clears the interval again. That's what it's very useful for when you have something that you want to set up. It could be anything. It could be a socket connection, for example. server set events connection sse is something we're going to take a look at later or for example if you have something like this uh it's very common use case and notifications uh toast component um oh actually not um this is something else but um uh any time you want to set up something it's very useful to only set it up when the store is actually used and because we always have we always know um we always have the subscribe account we exactly know when it's being used and when not and that is i think we covered almost yeah the update function is missing can do this by simply reusing our set function it's just the update function simply accepts a function that gets called with the current stores value and it returns um a new value so we just wrap a set function around it. So now we can theoretically do something and store it to update, say, value, and we return, I don't know, value plus 200, 100. Oh, no, yeah. But that's pretty much it. So this was just to show you that you can very easily build a store from scratch. you don't necessarily have to use a readable or writable store. There is one thing, I don't have the link to the GitHub issue, but the default writable store for the SWAT runtime, it does something somewhere that's related to the derived stores because if you create a derived store, it has to check somehow, it's really complicated. It's not required if you never intend to create a derived store using your own custom stores But if you plan to do that then you probably have to use the writable store because as a lot as soon as you drive a store from several stores not just one but several stores um there is going on something um i try to look it up again uh i think someone mentioned it even on disco somewhere let me try to find it here um I think it was later this. Yeah, I don't remember where it was, but if you look at the source code, you'll find it, and you will see that there is a mention somewhere on Discord that if you intend to create derived stores, or you create a custom writable store, you likely also have to create a custom derived topics, although it won't work. So yeah, I think that was mostly it for today. In the future, this is just the basis for other things that we want to take a look at, like this store for creating notifications. If you go to swelch.js slash examples. You see that there's a new example repository for future examples. We only have two upload examples, file up examples that also make use of custom stores. Here, this is a store that basically gets a signed URL, signed upload URL, and then it pushes a file from the client to AWS or any S3-compatible storage and shows you the progress. This is something that we might cover in the future, but I just wanted to lay the groundwork basically for what's to come in the future. So, Yes, sir. Sir? Yes, sir. I think Enrico can continue. Okay. Thank you Karim for showing us all about the store contract custom stores And if you like Karim you can share some of your repls in the chat and if you do eventually find that github issue related to derive stores must be custom if deriving from a custom store if you can find more details and share that in the chat then i'm sure folks here would appreciate it it doesn't have to be urgent we can we can follow up on that i will find it it's somewhere here cool does anyone if anyone has questions for kareem or any questions about stores or custom stores, now is a good time to ask. Otherwise, we can always cover this in a future video as well. Great stuff. And I especially like the S3 example because that sort of opens a window of opportunity to folks who want to encapsulate a lot of complicated network and feedback logic into a single store. Yeah, I think S3 is very useful, especially in Swag, because I'm compared to WebSockets. For WebSockets, you need a separate web server. But if you use SwagKit together with Adapter Node, you can implement SSE all inside or in one app without needing to create a separate server for the WebSocket connection. Yeah, that's right. Most serverless hosts do not support server-sent events, but Adapter Node self-hosting or traditional hosting does. So yeah, if you're using Adapter Node, you can have a store set up all of your SSE events. and do some background polling, or obviously not polling in the case of SSE, but it can do those updates into your store so that your HTML looks very clean. You have very clean template code that only calls the values you need, and those values can update thanks to server-set events. It all sounds great. Thanks again, Karim. So now I'm going to share my screen. Thanks for having me. Thanks for giving me the opportunity to show your stuff. Yeah, I'll share my screen. All right, let's move on to this week in discussions. Not much happened in discussions. There was a brief mention of some new features shipped by Vercel. And other companies, other host providers have released similar things related to sort of encapsulating a developer experience. because sometimes if you know what you're doing, you can pick and choose a la carte your various host database services and other remote cloud service providers. And what some companies like to do is calculate,

 this into an all-in-one, very developer-friendly experience. And it's up to us, like, what do we want? Do we want a nice developer experience that is easy to onboard team members and easy to spin up new projects? Or is our team small and lean enough where we can just do what we want and cost is something we can cover more carefully based on the expertise of our teams? So it's always like an it depends answer. But if anyone in the chat has some interesting questions or comments about that, we can discuss that here. Otherwise, move on again to this week in Q&A. I don't have anything because the questions and answers, kind of like last week, are so unique and varied that it's difficult to highlight one particular thing. Kareem, of course, covered a lot with regards to custom stores, and I did a brief mention of that in Quick Facts with regards to environment variables and other interesting things And I want to follow up with Cirilla in the chat It turns out that media queries with the syntax here the range syntax don quite yet work in Svelte And that because Svelte uses a compiler and the compiler has to parse and read CSS as well as JavaScript. And I suppose the Acorn script or whatever parser we use for CSS isn't up to date yet on the range syntax. But once this is available, you can probably learned about it in this week in Svelte. It was released eight minutes ago. Oh. Good for, thank you for checking on that. I guess I might share that next Friday. My intranet is eight minutes behind your intranet. And thank you, Karim, for sharing in the chat the writable and derived stores GitHub issue. But other than that, no need to stay longer than we need to so I'm going to wrap up thank you everyone for attending I will leave a feedback form in the chat and I might stay around for some cooler other than that see you next week bye bye