 Hello, it is June 2nd, 2023, and you've made it to This Week in Svelte. What's this? I used the new grounded rectangle two times in a row? Well, I'll tell you why. We have a changelog to go over, quick facts and announcements, that way we can put other short things together, community showcase and microtalks, which is new from last week, so if you want to present a microtalk about anything front-end or ecosystem-related, come on down. We don't actually have one today. But we do have this week in discussions where the topic will be all about headless UIs. And then finally, this week in Q&A, time permitting, of course. Why wait? We have a changelog to look at. So in the changelog, get the chat on screen, we've got some really small patches for SvelteKit. Version 1.20.0, we have a support for Svelte 4. Is it out already? I'll tell you more, and so will Karim. And we also have version 1.20.1, a patch for not copying the public folder to a service worker build. That's good if you're working with service workers. I will probably learn more about these on my personal time sometime soon, but that's SvelteKit. So hot on the heels of that, we've got svelte changelog stuff. Svelte.js 4.0.0 pre-release next to zero. Pre-release. The pill said so. So in Svelte 4, we're all anticipating the new major release of Svelte. I think Svelte 3 released in 2019, so it's been a while. And should breaking changes release often? Sometimes necessarily. For example, dropping support for outdated versions of Node.js. That's the common reason any Node module gets a breaking change. But this is a front-end framework we're talking about. There's a lot more to it. So let's go over some of these major changes. And Kareem is also going to talk a bit deeper about things like the store contract. So let's see if I can get what's at a glance. Kareem, what are the highlights? Local. is now the default for transitions. So sometimes when folks use Svelte transitions most of the time they want a transition to be isolated to a single component So in Svelte 4 the local pipe is now the default behavior So with this pre-release out, now's a good chance to take a moment, check out a branch of your project, install Svelte.js 4, and see if your animations behave a little differently. That way you're prepared in advance. I think this was proposed three years ago the first time, but it's still breaking change, so it took some time to be released. Yeah. And I think the overall... It's replaced with, I think, a global modifier instead. Yeah. It makes sense that they waited for a break and change. So, by default, they're local and there's... Yeah, I think global. It's called global modifier. Okay. There's also a migration script. So, Svelte Migrate is the... it's the one-stop shop for migration scripts. If you're using SvelteKit or Svelte, this will handle some migrations for you. So it's recently set up for Svelte 4. It can handle some refactors, some code comments to help you upgrade to Svelte 4. And Cirilla writes in the chat, if you use PNPM up, Svelte at next, then that should get you the latest because the at next signifier tells you all about that. Let's actually look at the NPM page for that. NPMJS.com. Svelte. So this is like a common pattern we see in Node Module Maintainer's way of working. So we have the versions here. Latest is targeting 359.1. Latest often means latest stable. And then next often means experimental. So next points to 400. So if you enter what Cirilla has in the chat, you will get this tag, which is 400 next zero. And that is currently targeted at next. So if you have a package on JSON and any of your modules are targeting next, you're likely installing experimental builds of something. And different module maintainers may utilize next. This is not an automatic thing. This is a deliberate thing that the maintainers utilize, whether it's Felt or any other node module. So we have a list of breaking changes. Overall, I'd say if I were to wrap this up in a few sentences, the reason Svelte 4 exists is to prepare the code base for better maintainer velocity A lot of you already know that they refactor from TypeScript to JS doc which really helps with rapid development and testing internally. That's one of the major reasons Svelte 4 came to be. So while the breaking change is happening, they took care of some minimal breaking changes, such as changing the lowest supported node version to 16 instead of 14 or 12, Webpack minimum support version as well. There's also a new peer dependency for Vite plugins Svelte and Rollup plugins Svelte. If you're using some of these, you may want to consider migrating to Vite. But that's like the overarching, most highly considered changes. So if you want to upgrade to Svelte 4, it's usually not a high effort, unless you're talking about, oh, Cyrilla writes, Note 8 was the last minimum supported version. That's like 2017. That's a long time ago. Wow. So, Karim, I think you have some examples to share with some of the changes around stores. Is that right? Yeah, nothing too exciting, actually. So, the default implementation would change. We talked about this, I think, three weeks ago. yeah so this change doesn't actually allow you to do anything new there's just an example of how you would do it until now so if you go back to the link you just opened yeah I was just going to preface it by saying custom stores need to pass an update in addition to set yeah it's handy because currently what you have to do in order to use the update function inside the callback that you can pass to readable and writeable functions. The callback until now only gets a set function. So if you want to modify the store based on its current value, you can't do it unless you get the update function from the return value of the writeable. And for some people, it was a little bit confusing. Some people don't even know that it's possible, but it is possible because the callback is only called after the function has already returned. And with this new update the update function is passed to the callback directly and that leads to a little bit cleaner code So I think the next link has an example of what this looks like in SWOT 4. If you scroll down, I think that's probably the most common example. If you have something like a store that subscribes to something, so it's really just a readable store but you need access to the update function so that you can update this value internally. That's now possible, and you can just call the readable function and return it directly, use the update function inside. If you actually look at the source code of the new implementation, you can see that the readable function really just calls the writable function and returns the subside function. So it's really just a wrapper function that strips away the set and update function. um yeah nothing like that wasn't possible before but it makes it a bit cleaner i see so in summary writable stores or custom stores require you to include an update function and this example shows that is this like a svelte 4 compatible store right here uh no this is uh this is what it looks like today in SWAT 3. And if you were to implement a replacement for a writable function or readable function, you now have to pass in the update function. I think most people don't do this, actually. So, I was a little bit confusing, but small discussion about this, but by custom store implementers, what this means really is just if you have some kind of library that implements a replacement, I think Astro has stores that can be used as a replacement. Not sure if they have to be changed, but yeah, just in that case, you have to pass in the update function so it works with standards with right word implementations. I see. So right now this returns subscribe, but it's spelled for it must also return update. Yeah. But in the callback function above. The callback to the one up here? At the top. Yeah, yeah. You call writable and I don't see it. It's at the end. You can pass a second argument to the store, which is like the start stop notify, I think it's called.

 function here by default only gets a set function i don't use it because i can't i don't need the set function i need the update function but that only uh currently you only get the update function from the store itself after it has returned and in swerd 4 you get set and update pass to the callback function i see so that's definitely confusing but yeah definitely worth looking at So I think what the maintainers would like everyone to do, if you have time, of course, especially if you're a library maintainer, try out Svelte 4 today. Give some feedback. Open some tickets as needed. And next week on June 7th, I believe, Rich Harris and Kev will be on YouTube to talk more deeply about Svelte 4's changes. I'll leave a link in the chat and the YouTube description below. Here you go. And here's the Svelte 4 release notes. And there you go. Five days later, five plus two is seven. Yep, June seven. Alrighty, so that was Svelte 4. Try it today. And other benefits are there's a migration script, there's a smaller bundle size or package size. This is mostly laying the groundwork for Svelte 5, So don't expect to wait four more years for Svelte 5. That should happen theoretically much sooner. That way, if you want some really big, exciting new features, then Svelte 5 is the number to look out for. And Svelte 4 should absolutely help the maintainers reach that point. And now let's move on. As always, soon. Registered trademark. We've got some quick facts and announcements. I just prematurely announced the talk with Kevin Rich Harris. That was one announcement. Let's look at some others. So interestingly, I was doing a bunch of accessibility research this past week, and I find that I never quite know enough. I'm constantly learning. I'm constantly finding out new and surprising things. And one of those things is this, the ARIA Authoring Practices Guide, APG for short. And what I noticed is a lot of people myself included often reference the practices here or the patterns such as how to create an accordion how to create a button alert breadcrumb etc and seemingly this looks like a very good resource it's designed very well it's got the authoritative w3c heading at the top and i think in the past three to four years there were some problematic representations of these patterns, which is why up here there's a new read this first guide. I'm not sure if this read this first guide showed up this year or last year, but I just want to point it out to everyone as a quick fact. There is a disclaimer to the APG, such as no aria is better than bad aria, and a role is a promise role, meaning if you define a role to something, then all interactivity associated with that role must be implemented. So really, this is a long way of saying that it's a reference guide, but it does not definitively mean that if you build a component based on these guides or based on these patterns, it does not guarantee that your components themselves are accessible, nor does it guarantee that your end user experiences or your websites are accessible. And this may be frustrating for some users because you want to develop things that are accessible. You have good intentions and you follow these guides. But the true guide really is the Web Content Accessibilities Guideline. That's this page here. So WCAG is the reference guide. And it seems like a large read, but there are some broad strokes concepts that are worth mentioning as a quick fact. And that is, if you look at these higher level headings, number one is perceivable. This is about visual representation of digital accessibility. Two is operable. This means all interactions are accessible via keyboard, screen magnifier, braille reader, etc. Things are understandable, and this is often overlooked. Understandable refers to content, how you simply convey information on the internet. Content plays a major role in accessibility, and even though it's point number three here, it may be considered one of the first considerations you make. How do you convey information before you even design components to get to this information? And then you have robustness and conformance. So in broad strokes, these are some concepts to look out for. And over here, there's also a guide on the rules of ARIA. Like the first rule of ARIA is don talk about ARIA I joking The first rule is try to use built behavior as much as possible The second rule is do not change native semantics unless you really need to. The third rule is all interactive ARIA controls must be usable with a keyboard. And that particularly refers to like arrow keys, enter key, space key. Do keep these in mind. The fourth rule of ARIA is do not use role presentation or ARIA hidden true on a focusable element because then that removes screen reader enhancements. The fifth rule is all interactive elements must have an accessible name, such as ARIA label or proper label. And the rules are nice, but above all else, above anything, this is not like caniuse.com. You cannot just get a yes-no check mark to approve your site or your components as accessible. The most important rule, if I were to announce a most important rule, it's testing. You can only really stamp approval something when you say you've tested it. You got to say, this was tested on Firefox and NVDA. This was tested on Safari and VoiceOver. This was tested on a Switch machine. This was tested. When you say something is tested, then that brings you closer not only to compliance, but it brings you closer to knowing the human needs behind digital accessibility. And those are some quick facts. So I'll share some of these links in the chat. And I'll move on to the next quick fact. And most importantly, the readmefirst guideline. Alrighty. All right, next is CSS nesting. Want me to show some examples of that, Karim? All right, yeah, CSS nesting. I just wanted to clarify two things, because we talked about it, I think, two weeks ago, and that it's now support in both Chrome-based browsers and Safari. And the first thing is that we saw last time it didn't seem to work with the optional ampersand symbol because, yeah I just verified that I looked at the you know as you know all the CSS that you define inside a SWAT component needs to be parsed by a parser called CSS3 And somewhere in a GitHub issue they mentioned that they actually only partially support CSS nesting and it hasn changed since then So, yeah, if you want to use CSS nesting, you need the ampersand symbol. And another interesting thing I noticed last week is that if you use CSS nesting, if you look at the output here at the right side, you can see that there is no scoping class. So if you use CSS nesting, all the nested rules are global. This is just a quick example to show you. Maybe that's, I don't know, that's a deep breaker for some people. I don't even think that we will use CSS nesting just yet because support is still rolling out. But there's nothing that SWORD is doing in particular to support CSS nesting. and that's probably something they may want to fix or will fix. I don't know. But yeah, just in case you are using it, you need to know that everything is global and you have no way of scoping it with the scoping class, the hash that's what it uses usually. Okay, good to know. Yeah, I left a comment in the issue. Yeah. Yeah. So do keep an eye on issue 8587. I'll link that in the chat. If you're interested in CSS nesting and you want to know deeper about its current support capabilities, this is the issue to follow. I mean, you can, of course, write just plain CSS and CSS nesting in a CSS file, an import that is only processed by VeeD, but not by SWIRT. That will work correctly. you can use it without all the features that you expect to work but inside a component there are some limitations yeah or unexpected behaviors because anything in a style block by default is scoped and Svelte treats top level classes as scoped but at the moment it treats nested selectors as global yeah so take a look at that let's catch up with the chat what have people been saying?

 SpongeBed writes, I don't think we're talking about space. Okay, there was some side chat about bundle size, and it looks like they learned a bit about that. Theo writes, we have a workshop where we go through WCAG one chapter a month at my company, and I must say, doing it byte-by-byte really helps. That's good advice, Theo. Having a regular exercise, especially hiring people that help with accessibility testing is vital, but just going over it as a team is an excellent idea to learn all about the web content accessibility guidelines. Avi12 writes, aspirationally, could we use chat GPT or AI to write compliant code? So the answer to that is you can't write compliant code for accessibility. You can only test the experience. And AI, at least today and for the foreseeable future, cannot do that. Testing how somebody experiences the web requires you to manually test. So accessibility is truly about manual testing. But automation testing gets you somewhat far. And I'll show you what I mean by that. If I go to, for example, this site and I open DevTools, and it looks like Brave Browser does have Lighthouse. So the Lighthouse tester does have an accessibility checkbox. And this is still imperfect because what I'm trying to implore everybody is to manually test. That's truly the stamp of approval you need. But if you run this, it'll run Lighthouse on your page if you're using a Chromium-based browser. And the accessibility tester provided by Chrome will test some basic things like color contrast, do links have roles, do headings occur in a sensible fashion. And I think I just broke the internet. Hang on a second. Yeah, I broke the internet. Let's try that again. There are other testing tools I recommend. There's the Wave browser extension as well as the Axe dev tools extension. And if you're using Playwright for manual testing, I did go over a talk a few weeks ago about Playwright and testing. And you can use Playwright to run Axe Tester on your web page. There we go. So the Web Content Accessibility Guidelines on ARIA has an accessibility score of 95. And some of the warnings it provides you is background and foreground colors don't have sufficient contrast. So if I go to that notification let see if I can scroll to element here One moment Usually you just click on the element and scrolls to it but I having a hard time Okay, it just goes here, and then you right-click that, and you go scroll into view. There we go. So the violation slash warning is background and foreground colors don't have sufficient contrast, and that's between this and this. so perhaps this warning text is red on a pink background maybe the warning text should be bolder maybe it should be darker red and that's the um this is how this is how far a machine can get you in testing accessibility and i think if you're making a website your accessibility lighthouse score should be 100 like that's your minimum target in my opinion you have to have accessibility score of 100 but also you need to manually test because this tool cannot test end-to-end experience It cannot test if a screen magnifier focuses on an element. It cannot test if text is read out in a sensible fashion. It doesn't test content. It doesn't test simple, plain language usage. It only tests really basic things. So this score should be 100. That should be your targets. Good question. Happy to help. There's the topic for the next This Week in Svelte. Please elaborate, Cyril. I want to know more. Oh, yeah. Captain writes, are nested styles still purged if unused, so can't be for HTML content? Yeah, we didn't test that. Yep. So I have a link in the description below if you're on YouTube where I do talk about playwright and some basic testing. But I guess what Cyril is recommending is I go a bit deeper. Maybe I can talk even more about manual accessibility testing. Long story short, you need a checklist. You need a really good checklist. if you're at a company, you need to hire someone to specialize in this, and you need to really go over things deeply. Sure, I can help prepare a microtalk maybe someday. But this needs to be a quick fact. The facts aren't quick enough. Actually, this is... Let's move on. So that was quick facts and announcement. We talked about CSS nesting, talked about accessibility, and now we're going to talk about community showcase and microtalks. I don't have any today, but that's okay. If you want to do a microtalk such as accessibility such as CSS nesting if any of you are passionate about certain concepts in Svelte or related to Svelte and front things come talk to us and we have you on the show But this week in discussions is actually going to be the big part of the day We going to talk all about headless UI libraries. And I think we have a few folks in the chat who are eager to share what they learned about headless UI libraries. So everyone is welcome to join the conversation. You can enter the stage, talk to us, or you can just talk in the chat and I'll read out your messages. I see Thomas is in the chat. They are the maintainer of Radix Felt. Welcome. And let's go over the topic. So we got some notes to share about headless UI libraries. Step one, what is a headless UI? And I'll bring a bunch of them on screen. what is a headless UI? So a headless UI refers to a component or a component library that does not contain state. Sorry, it contains state. It contains logic for interactivity, and it contains attribute helpers, but they do not provide styling. Not really. They don't provide HTML, and they don't provide component APIs or props. So I'll open up Radix Felt as an example. I have a bunch more to share as well. Thomas, you're more than welcome to raise your hand and join us on stage. Hey, Thomas is here. Welcome. I'll try inviting you harder. one sec hey can you hear me hey thomas yeah hello okay perfect hey thanks for inviting me yeah and everyone else is also welcome to join the stage so how are you doing thomas i think you're doing great what about you pretty okay all right so i wanted to already uh correct something like radix felt uh the way we have today is not truly headless uh unfortunately just because the original Redix, they have something called the as-child prop, which how Redix works is it's normal component syntax, which provides markup for you. So that's not headless, but with an as-child prop, you can actually just use your own markup right I had some trouble implementing that on Redix Felt but I already figured out a possible workaround for after v1 So then maybe we can call it headless But at the moment it's kind of like in between. It's almost headless. You can still, it's still unstyled, but it provides markup. So it's kind of in between. Yeah. And that's perfectly fine. Because we're going to talk deeper into the trade-offs because sometimes you want a truly headless library, sometimes you want something in between as well, because it does take effort to style a truly headless library. And I did this yesterday with Grail UI. Also worth sharing with everybody, Grail UI is a Svelte headless library. Truly headless because the components are not actually Svelte components, they're mostly factory functions that, or as we like to coin the term builder APIs, which I like a lot because here in Grail you can have an accordion for example. Let me zoom in more. There we go. So here you provide us the developers. If you're consuming Grail for example you provide the HTML markup and then Grail provides these functions that can spread attributes to build your accessible interactions. And let's go over some of these trade-offs and differences because the differences do impact the developer experience, and sometimes one is more favorable than the other. There is no one perfect UI, and according to my notes, they include some common goals. So headless or partially headless UIs, what they try to do is handle most of the accessibility considerations, and they try to save you time. Building an accessible interactive accordion, for example, requires things like ARIA hidden and state. And building these things perfectly and well takes time and understanding. And what Grail and Radix try to help you do is get you really close to an accessible result, but it's up to us, the consumers, to go the rest of the way. Does that sound accurate, Thomas? Right. I think one of the challenges that normally we face also when trying to build these components from scratch is just like browser support too, which is what you mentioned, like building this stuff out well in a way that works across all browsers, across different device widths, across mobile and desktop, and still being accessible is pretty, pretty hard. Yeah. So it's not to say that adopting Radix or adopting Grail,

 Opting these will not necessarily indicate that your components are 100% accessible. I kind of mentioned this a few minutes ago. That's really up to us because when we build the final result that's styled, then we have to do our own accessibility testing in addition to what these libraries provide. And with Grail, I tried to make an accordion last night, and I did pretty good. I'll show you how I did that. So pnpm dev. I'm going to show you an example. So if you're a consumer of a headless library, this is the sort of experience you can anticipate. On localhost 5173, come on down. So this is my This Week in Svelte test repository. I have a component playground. And here I've removed global CSS. And I've applied the accordion. And it's not done. This is not a perfect accordion because I have to do other things. But what I do have is keyboard tabbing. and you can see the border highlighting the focused element. And then I press spacebar to open the accordion. The accordion has a code snippet, some information. It's not selectable, and I think it's all my fault. This is not the fault of the library. But it does get me a lot of the way there. So for example, if I inspect the rendered markup, you'll see some things. For example, over here... Actually, I'll zoom in more. It's better. there we go so this button that i'm highlighting has aria controls accordion so this refers to an id to the corresponding content so this div that i'm highlighting has an id of accordion to content one and i broke this this is my fault because i was trying to turn this headless library into a component interface But the things it did take care of is are expanded. So if I collapse it, it says are expanded false. And if I open it, it says are expanded true. That's one of the several considerations that need to be done. And in my source code, here's how far I got with that. I created a Grail accordion, dots felt, and I also created a Grail accordion item. I tried to make my own component interface based on the headless UI, but I've made some mistakes, and I'll go over that. So for the Grail accordion this is the wrapper component and this is the elements provided So I wrapped this on line 34 in a slot so that the Grail accordion item can be slotted into this This is just the default markup that is provided if you use the data prop that I wrote here And on line 36, we spread the item attributes. Item attributes are defined on line 7 from Grail. And then the trigger attributes on the button are defined on line 8, also provided by Grail. So Grail takes care of the interactivity providers. and that it's up to me to correctly spread these into the right corresponding HTML elements. And down here in the div, this is the content. So I'm spreading content attributes, also provided by Grail. And this gives you a sense of what Grail and what headless libraries help you achieve, especially if they're truly headless like this. In my Grail accordion item on line eight, I'm using context to fetch the trigger attributes. And this is the mistake I made. I'm only getting the triggers. I need to get other attributes too. because in order to properly spread item attributes and in order to properly have the IDs matching between the button and the content, I need to make sure these things line up. So this is the effort that's on me, the developer. And Grail and the headless libraries really help a lot in documenting what needs to be done. And then I take it the rest of the way. So this goes to the next part of the conversation. Why use a headless library? Thomas brought up things like it's for helping with accessibility. It's like a Kickstarter in getting you up there. But it's also good because you can build your component library based on this. You can style it yourself. You can brand it yourself. And if multiple libraries consume the same headless library, and there's things like a patch required or an accessibility fix, then we can all patch the upstream code or the upstream library, and all consumers of the headless library benefit from that. By the way, feel free to interrupt me. This is also like a learning in progress thing for me as well. I'm just trying to highlight the benefits. No worries. I would also say that normally when we use headless component libraries on our projects, it is normally to create our own stuff like that because one downside maybe of a headless component library is that you need to write a lot just to make a component, right? There is a lot of things you need to import or call, as we can see on the according example. So you would have a lot of entries. That's a lot of item attributes, trigger attributes, content attributes that you're calling so creating a component and abstracting that it is great and it something that the i think the headless compost libraries help you create your own components it really kind of I wouldn say made for that but it where it shines in my opinion Indeed. Here's a good example of that extra lift you have to do. So on line 28, I had a comment here saying, I need to add this. So here on line 29, because I don't use utility libraries, I don't use Tailwind, I don't use utility CSS, I wanted to find a way to build my own components with plain CSS. So that's why I'm using Grail as an example. And here on line 29, I do button re expanded false plus div display none. This was necessary for me to provide because if I comment this out, you will see that the accordion is always expanded. So because Hezl's libraries don't provide styles, I need to draw the rest of the owl, hence the comment down here, draw the rest of the owl. and depending on your needs like if you if you need more customization this is actually a good thing but if you want to build a website fast and you want good accessibility groundwork then this might come across as a bit of extra work that you did not foresee some people want this perfect best of all worlds scenario where you adopt a library like radix and out of the box it comes with some styling. It comes with some markups to save you time. And then you can customize on top of that, but there are definitely trade-offs. And I wanted to segue to what are the trade-offs between these different approaches for the end user? And Tasos, please come on down. Happy to have you. Can I chat? Oh yeah, go ahead, sorry. First of all, thanks for showcasing, Grail. One thing I want to say is Yeah, specific for the example that you described here. We really provide stores that expose the state of the various components. So, yeah, besides getting the user coordinate and the attributes, you can take, if you go to the example, you see that we expose stores also that have the expanded state if you go down to the API. All right, good. I'm going there. Oh yes the expanded store Is it this one Yeah there is an expand Yeah, this one. So this is a store. No? Sorry. Yeah, the expanded one. Yeah, this is a readable store. That gives you, if you pass the ID of the accordion, whether this is open or false, or you can use it in other places, or hide the content of the item that you want. But yeah, this is, yeah, in general, the discussion is headless, headless libraries helps us on that. And yeah, I think we should also make a better effort between the headless libraries. So a lot of things that we do on Grail are repeated on Oswald Radix and other headless libraries. So I think there is a place, a common ground between us about sharing events, attributes, how all this accessibility works. So we try to take away some work from the component authors that actually build the component libraries, but we do the same between the headless libraries. We also build actions. And this is the thing that Grail initially intended to solve. So we want to provide just the actions and the attributes and be totally headless so you can combine them as you prefer. Yeah, thank you for correcting me. And apologies for the false advertising. Yes, indeed, Grail does come with even more stateful attributes that I took for granted. And to properly leverage them, as you pointed out to me, there is an API. And here you can do things like Asheron wrote in the chat, which is you can have conditional classes in Svelte, especially if you're using a global utility library or your own scoped styles. That should be possible. I guess I had tunnel vision because I'm used to styling things this way by using the attribute selector. That way I know that the attribute determines the visual representation. And my own bias clouded my judgment because it looks like Grail makes life a little bit easier than I took for granted. So yes, the proper way really is to utilize all these stateful managers, especially for things like accordions, because accordions cannot work without JavaScript. Just as an example or a side note, since accordions only work with JavaScript really, unless of course you make them expanded by default or something, then this is the way to apply

 classes or conditional classes. And let's catch up with the chat a bit. Captain writes, use actions help simplify that. And that's also showcased here. So in the markup, I have on line 33, use accordion. And the actions provided to the developers like me, like I'm the consumer of this, use accordion helps a lot in setting up the utilities. I have a question, actually. Let's say you want to have one of the accordion items expanded by default. How would you do that with Grail? There is an initial configuration that you can pass what is the expanded. Yeah, I saw that here. Oh, okay. And the creator added, okay. And does this work with SSR too? Yeah, and this was our initial problem that we had. So we took the approach that KattenCodeman did with using just actions, but yeah, we had this problem that if you don't have the attributes already from the SSR, you see this flashing of your UI. Yeah, this works with SSR. Yep. Yeah, it's very good because when you create the accordion, I'll show the consumer version of this. So here on line 10, I'm creating the accordion and you can pass in initial values like Tassel just mentioned. And during SSR, you can have those initial attributes spread and render the way you expect because the disadvantage to actions is they only happen after mounting. But with this, you have the benefits of SSR where these things can have a default representation from the server rendered HTML. And that's very good. Yeah, that's great. One point in general that I want to make is that when we use as consumers a headless library, the point is that we don't want to build another headless library above that. So in practice, the permutation of the components that we actually use in the application, the scenarios that we we want to solve are actually limited. So we don't have to be so flexible on what we support. And this is okay I think on applications level So creating a few variations of the components and using Grail or another Heads library directly on these components for me, is good enough. Yeah, and just to show everyone what I ended up doing personally, is on line 15, I have a Grail accordion, and then on 16, a Grail accordion item. So if I'm working on an internal design system, for example, and I want my end users to consume my accordion, this is the sort of interface I could write. and of course it's completely flexible. When you consume the headless library for your component library, you can make whatever component interface you like. I happen to go with a nested component here and I have some props for titles, but I also really wanted to leverage slots. So I have a slot for content. I pass in any HTML I like and for my Grail according item, the slot gets inserted in the markup on line 23. So we have the content slot here and then Grail handles the attributes for me on line 22. And one thing... So just to clarify, Grail or all these headless UIs are mostly or great to be used to just put your own UI library as a base. Is that a good use case or the perfect use case for them? Yeah, I think that's ideal. So Tassos and Thomas can clarify, but absolutely. KoreanMask is the point of headless libraries to be a baseline for your library? And I think the answer is yes, totally. That's a major reason why they exist. Yeah, exactly. Or let's say also, I mean, all the times you don't want to make a fully flash UI library, but let's say you're creating a portfolio or you have a client and you have really specific design. It's much easier using a headless library just because you are totally free to customize it, much more free to customize it than you would with a normal library. Like other component libraries are also stagnable, but normally they are much more rigid in that sense. It's a different use case. Yeah. One of the subtle differences is with Grail, you can use scope styles, you can use global styles. And with Radix, it's a little different. The example Radix uses is utility classes, which are global. if you wanted to pass in your own classes, you should mark them as global as well because they get passed into the components to be styled. Is that right Yeah you have an example If you scroll down you can see our carden item has a class of class a cardenitem which is not a new utility class And the way I styled this example was creating parents which basically applies display contents to the whole wrapper And then I pass in the global selector to the children So it's kind of scoped, not totally, but display contents does have some accessibility concerns. So it's not super recommended. If it could be changed to just a normal div, that would be fine. But to be honest, this is one of the biggest shortcomings right now with Red XSVALT, because it's missing that S-champ drop, as I mentioned. if Svelte had a way to scope children components classes, this would be fixed. Or if Reddick Svelte had an S-child prop, which I do intend to add in the future, then this would be fixed as well. Yeah, so subtle trade-offs to make when you're evaluating a headless library for your needs. And yeah, some even go, I'm not sure if any have the best of all worlds where you have a headless library. It comes with styles, obviously has no longer headless, but it's sort of a baseline white labeled, or what's a better term? A library that is completely stylable. I'll just call it that for now. Something that comes with styles that are also high contrast, also with accessibility considerations. And then once you start theming things, once you start breaking the warranty, I guess, so to speak, or customizing things, then of course it's the developer's responsibility to test those things and make sure they're accessible via testing. Yeah, there's also a small rise in component libraries that are installable or copyable that originate from headless libraries. Hunter Byte recently did a port of ChatCN UI, which the one he did is called chatcn-svelte.com, which you go, you can like, I'm going to put it in the chat. So basically, what he did is he got RedixFell. And ShadCN UI basically gets Redix and styles these components. The Redix come with predefined styles, but it's not NPM installable. You just copy and paste Tailwind configuration, and you copy and paste the actual component structure, or you can even just use a CLI as it shown below So it kind of the same thing as Redix felt but styled It comes with some styles And not all of the components shown here are coming from Redix felt. For example, Redix felt does not export a badge or a button components as they don't need any extra JavaScript or accessibility concerns normally. So this is just like a component library has some Redix Svelte components to build their own component, which is kind of cool. This is where I think it excels to. I see. So it's not a package. It's a CLI. It says npx, shadzian, Svelte, add accordion. Yeah, kind of like Svelte add, if you think about it. Indeed. Yeah, because then doing add accordion, I presume, will add the Svelte files in your code base. Exactly. Indeed. yeah because this is um and i think one of the questions people add is is there a tight coupling with utility libraries uh i'd say there's a favoritism or bias but maybe not a coupling because as i showed you can use scope styles for grail you can use scope styles for radix using the very fun svelte technique here with the scoped parent and the global child yeah so no there's no tight coupling but as but the documentation tends to lean into utility libraries more because that's it's kind of like the typescript of today people expect it or people are more familiar with it for sure i do want to include later on some examples like only tailwind and then only scope styles and then maybe global styles if that makes sense or css and js but yeah I do want to detail this better but I still think that first we need the as child prop because that would make the developer's life easier. It's something I really wish to add the as child prop Nice. I'm going to catch up with the chat and then maybe we'll wrap up in a moment Let's see here Asheron asks if you pass the accordion context to a child item, how would you handle disabled or expanded by default? that looks like I'm guessing that's just a matter of attribute spreading where because disabled and expanded that's already expanded but the styles of course have to be implemented by the developer but the attributes it looks like it's already handled by Grail

 But if that doesn't answer the question, feel free to weigh in. And then Captain writes, you hit a wall at some point with non-headless and what styling is exposed, what markup can be used, like many native browser components to select box. And that reaches into a sentiment I think a lot of us share is we wish that browsers and the web and HTML had a lot more interactive primitives. Because writing some of these interactive elements by hand via JavaScript is a bit of work, such as models, such as accordions. And it'd be really great to have primitives like button and like dialog to do a lot of this work for us. But time will tell. I H Y M writes, you could pass the utility function stores into the context. And then Ashron corrects if the child handles its expanded or disabled state on mount. Instead of passing in the accordion constructor. Yeah, that's a different workflow, I suppose. whether you're using a complete non-SSR scenario with just actions or just on mount, then you got to handle those considerations in JavaScript land. Let's see if I can wrap it up with one more note. And that is, so we see how these headless libraries differ a bit. We see what they have in common, and we see the benefits that they have to the users who are building their own components. And it's definitely a great idea to try these out because they handle a lot of accessibility considerations. But as mentioned repeatedly, you need to test your final result yourself as a developer. And how do we work towards the best of all worlds? Well, you can go on GitHub, you can talk with some of the Svelte maintainers to see what things you may need. But by and large, it looks like we have a lot of good interfaces today with Svelte. We have constructors, we have functions that spread with that are SSR friendly, we have scope styles, we have global styles. and if we want to get one step closer to like an even more user-friendly way that is like styled by default but easily overwriteable one thing that i've thought about was selectively removing scope styles from a svelte component and what i mean by that is you npm install something like radix and maybe radix comes with its own styles and maybe you can tell a svelte compiler to unload those styles that way you don't ship extra bytes to the browser and then you can customize it yourself I not totally engaged with this idea I don think it perfect but it just something worth pondering about One thing I also think would be interesting for Svelte to have possibly in the future, is the ability to pass event listeners through spread props as well. I think Unreal UI does an excellent job with using a single action as it's using on a card. and then I assume it uses that single action to actually pass in the event listeners to its children. But I've seen examples of like all your headless libraries that try and do this and stuff, and it gets a little bit harder. And then sometimes they have to add both spread drops and an action, and they both have like a parameter. Let's say, do you see on the li, there's item.key, right? So let's say also wanted to have an action like use a card and item, then you would also have to pass in that item key. So it would be pretty interesting to see Svelte have the ability to pass down event listeners as spread props. Indeed. I'm going to share one last thing in the chat. This is a talk by Stefan. they went over a renderless library. So what's cool about bringing this up and learning about is the underutilized, so I'm speaking for myself really, the underutilized slot variables here. When you have an HTML element like this button and you give it a slot, you're allowed to access the slot props within that HTML element. So you can do things like have state passed down to the children. And this is something Svelte provides that's really awesome. So check out this talk. It's in French and has subtitles in English that are translatable. So you can check out the YouTube video and learn about context and slot props and how this helps you write cleaner code, really, because you don't have to worry about making components that pass down context and then you have tons of sub-components wrapping each other just to pass context around. Svelte makes that easy with the context API. So check that out for flavor. and to wrap up that is all. Thank you Thomas. Thank you Tassos for joining. Thank you for having me. It was great. Alrighty. So let move on to the final topic This week in questions and answers there was one common question about object programming and stores and stateful variables. And let's see if I can help out with that a bit. Just a bit, because we're short on time. But we'll talk about this in more detail probably next week or two weeks later. so what I'm referring to is the question is how do I use stores in an object oriented fashion and I suppose in JavaScript that's using classes that's the question and I could do a shout out there is a Svelte library that makes this easier it's called Sveligant and with Sveligant you can if you like write stores in a class based manner So you can add a new store like this, and then it sets up the store, and then you can extend it with methods like increment, decrement, and it's all good, right? So I'll share that in the chat. But alternatively, I think what Svelte tries to advertise is ease of use. And since website and website interfaces are often event-based and functional, you probably don't need a class. if you're willing to adopt a different methodology, you can have each store represent a single value because oftentimes that's good enough. And I'll go over some of that. Kareem, feel free to interrupt, by the way. I think that one disadvantage with using or making your classes a store is, as you can see at the bottom, it's a little bit like, kind of like a foot gun. you can't pass in the function of a store directly to an event handler. You have to wrap it in a wizard error function because this would otherwise point to the target element but it has to point inside your store to a class. I see. Yeah, so counter.increment cannot be passed directly to onClick, you need to wrap it in a function. It's just a small thing to be aware. If you don't do that, then there will be, yeah you will see some errors in your concept Yeah when using classes that is an important gotcha because counter I think is not a function definition That why you have to execute it in this manner by the sounds of it. I'm not super familiar with JavaScript classes. I rarely, if at all, ever use them. I use them sometimes for DAOs, which is like a design pattern for data management. I use it for that, if ever. But when I use felt stores, I like to have one value per store. And it's very performant. It helps a lot with reactivity. And if you try to swim upstream or against the stream with classes, then yeah, you might run into some nuances and gotchas like this. So the recommendation is don't. But if you really like to, then there are ways. You just got to work around the nuances. And in the chat we have... Yeah, counter.decrement.bind counter. That would work. Okay. Then this would point to the counter. Tyler writes, might be able to define those member functions as arrow functions and circumvent the need to make new functions in the event handler. I see. So right now these are class functions. Oh, yeah, true. Yeah, that's possible too. Interesting. But how do you get access to the update function inside the increment and decrement? Because you need this, I think. Like, you can make it an error function, but you still need access to the update function. And for that, you use this.update, which doesn't work inside an error function. Wow. Yeah, I see the nuances are piling up now. So that is the risk you take, but you don't have to go that road if you don't want to. We have in the Svelte docs just typical writables nice and easy right here. So you do you have your variable, you make it equal to a writable, and you can call update methods manually, or you can use the dollar sign notation, which I regrettably don't have in front of me, but I'll pull it up as a last minute thing. And then we'll wrap up. Stores. I skipped it. There it is, writable stores. And then auto subscriptions. Right here.

 So you can have in your markup the dollar sign notation to auto-subscribe and auto-unsubscribe on Unmount. A lot of these considerations are handled for you in very brief syntax. So if you adopt it this way, it can help you speed up your development, reduce cognitive load on the developer experience. And that's what I highly recommend. And maybe more on this next week. We'll see. Thank you so much for attending. and I'll see you next time. Bye-bye.