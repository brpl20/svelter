 Hey, everybody. Welcome to This Week in Svelte. My name is Enrico. I am your host today, and the date is April 28, 2023. Let's talk about the things in Svelte. The agenda, as usual, is we'll go over the SvelteKit and Svelte changelogs, if anything applies, share some quick facts, and we have a special community showcase. I'll introduce them in a few minutes, followed by This Week in Discussions, and lastly, This Week in Q&A. So let's get to it, starting with the changelog. So now in SvelteKit version 1.15.7, we've got some patches. That was announced before. Today I'm going to talk about 1.15.8 and 1.15.9. In .8, we've pinned the Undici version has been pinned to a particular version. And this is to help solve a memory leak, but it seems to be persisting across other adapters. So there's still a somewhat ongoing memory leak issue with Undigee that should be resolved in an upcoming patch. Other than that, we have a Vite plugins felt patch. It releases to normalize path resolutions on Windows. So if somebody was developing on Windows using WSL or Windows proper, There were some issues with backslashes not being translated properly to forward slashes, but with the latest to be plugins felt, it should all be good on Windows. So if you're a Windows developer, this should excite you. 1.15.9 also came out, which correctly replaced the state when using hash links. So thank you, SvelteKit, for replacing the state. And that is it. So also Windows-related issues. and we'll see next week if we can talk more about that Indigipin. But that's it for changelog stuff. Let's go to quick facts. Let's see how quick this one's going to be. So your quick fact of the day is another accessibility tip. This is about color contrast. I've talked about accessible buttons in prior weeks, but here I want to dive a little bit deeper into contrast standards. So in front of me, I'll get the WebAIM color contrast tool, and I'll share this in the chat. When it comes to color contrast it good to keep in mind what are the standard contrast ratios prescribed by the Web Content Accessibility Guidelines So in WCAG or WCAG 2 it calls for a 4 to 1 contrast ratio So that's why in this example, in this tool, you'll see a contrast ratio between this blue color and this background white color. It shows you how normal text at normal width or boldness will pass AA as well as AAA. AAA calls for a contrast ratio of 7 to 1. And because this color combination is 8.59 to 1, that is a sufficiently high contrast ratio for both AAA and AA. Now, if I were to change the blue color a bit to something lighter, for example, notice how this light blue color fails the AA and AAA spec because WCAG AA calls for 4.5. So if I increase this just slightly, there we go. It's 4.5. Therefore, it passes AA. But to pass AAA, we need to go higher. We need a ratio of 7 to 1. And there you have it. Notice how bold text helps you a bit. So if you only have a particular color on your page and it's not perfectly high contrast, it can still sufficiently pass the AAA spec so long as it's sufficiently bold. and that's why there's the distinction made here. And for graphical objects and user interface components, there's things like borders, and I'll share an example very soon with Svelte so we can learn more about the differences in contrast for static content versus contrast for interactivity. And I have some more useful guides to share. Here's one for the chat. You can read that later. And now for a demonstration. And of course, I don't claim to be an expert. I'd love to learn just as much as everyone else does. So here's my demo. All righty. So let's pay more attention to the preview than the source code. Here, I want to showcase how contrast plays a role in static elements as well as interactive ones. So in this first example, we have paragraph text. Some of you may have seen things like notifications or block quotes. I happen to be using a block quote here, but this could just as easily be a notification. And this block quote does not have adequate contrast. The ratio is 2.43 to 1. This green text blends in a bit too well with the green background But below that we have a much better example because it has a contrast ratio of 7 to 1 And this is important It has a border. This kind of relates to how when you set your operating system to high contrast mode, suddenly things have borders or rather thicker, darker, more contrasty borders. That is because in this above example, the green background versus the white background does not have sufficient contrast. So on a really bad monitor, or if I'm outdoors, or if my eyesight has cataracts, if there are some circumstances and other vectors that make this less readable, then that will most definitely happen. That is all to say that this above example has a green background that is not sufficiently contrasting with the white background. However, this below example, has a very dark border. And the dark green border does have sufficient contrast with the white background. So this makes for a very good success notification, if you will. You can read the text clearly, and the background is sufficiently different from the background behind it. So it's not just about text on the background, it's also about backgrounds against other backgrounds. Moving on to interactive elements. this is not going to be an exhaustive demo there's so much to account for when making tab lists and radio buttons but here i'll just focus on text inputs text inputs has a standard attribute called placeholder and i'm here to tell everyone that maybe you shouldn't be using them and i'll tell you why the placeholder attribute shows what could go inside of an input and by default like it here on Brave, at least in the Chromium browser, the browser default has a low contrast against the white background. So in this regular input, you see a placeholder here. And if I enter text, the placeholder goes away. The issue is that the placeholder itself has such a low contrast, I can barely read this. And with someone with the wrong vectors in place, back to that example of bad monitor contrast ratio, you're outside in the sun, or you have some deficiencies, then this would be very difficult to read, which is why placeholders should not be used for essential content. And in my opinion, it should not be used at all. Even if you make the placeholder color darker, you cannot tell if it's filled. So in this below example, pop quiz, can anyone tell me if this here is a value that actually filled or if it a placeholder Even if you guess correctly who to say that all your users will know It is in fact a placeholder So even if you make the contrast higher, it's hard for the user to tell if this is filled, if this is actually a prefilled value. So when it suddenly disappears, you might confuse the user. Oh no, am I submitting this content or is it trying to tell me something? So below that I have what's what I consider a more proper example to improve the contrast and the labeling. So in this text input we still have a border, we still have the background. I think the gray background is not totally necessary, but the label is clear and when I focus on it, it has an adequate outline to show that it's focused and you can enter stuff. And instead of a placeholder, I have hint text below here. You can find your pin on the back of your card. So the main label's here, the hint text is below, and the input is in the center. And this is not really Svelte, it's HTML. So I can show you how I did this. So in the example, lines 48 to 54, I wrap everything in a label. I enter the main label up here. The input element is directly below, and the hint text is directly below that. Because the label and the hint text are both children of label, then the screen reader will read both of these. The screen reader should say, enter card pin, you can find your pin on the back of your card. Since both of these copy are nested in the label, they both count as a label. But the contrast is what matters for this discussion. If anyone would like to raise your hand or type in the chat anything they'd like to share, please be my guest. And with that, I will move on. So here's a demo for your posterity. You can take a look. And I'll just give everyone a moment. I see a few people typing. Yes, TyphoonJS, we're going to see you soon. All right, let's move on to... Yes, thank you, go ahead. More tools is more better. And now we're going to move on to our community showcase. So I would like to introduce to the stage...

 our special guest typhoon.js and you can of course give your name out and they will showcase container queries in depth so come on down raise your hand and i'll invite you to the stage sure so my name is michael uh leahy i have uh been working with svelte uh since uh 2021 uh full time though so um one of the really cool things uh that i'm doing is i'm i've created a gui framework um it only runs on a particular platform uh right now so i'm kind of a little bit in stealth but the really nice thing about this platform is that it uses es 2022 and requires users to have like a modern browser and uh you know during the pandemic i got back into like uh you know tabletop role-playing games something to do online with virtual tabletops and so that's what this GUI framework is involved with but container queries is a new feature a browser feature that is widely available now since chrome april you know last year around april and firefox uh february march this year but there was a barrier in having it work with uh spelt and i uh helped implement that fix and spelt 3.58 so you know this is new new uh new tech that you can apply to do advanced uh component design so we'll just kind of like take a very quick look at uh what container queries are a simple repl example and i'll show off kind of like an advanced color or picker component with the framework that I'm working on. The idea with container queries is that it's very similar to a media query where you can selectively adjust CSS based on the width of the browser. But with container queries, you can target particular elements, and that allows you to, when you're doing a component that needs to resize, and this is a very, very basic example in the REPL, you can kind of see like the quick brown fox text the font size is changing based on the container width and kind of fudging like you know the left and right like if you i didn want the repl example to be too too complex or too many different files but you know when things get down below 250 pixels the left and right like the the bottom component disappears and we're just left with the left side so i'm not too sure how much we should probably necessarily step through the code i will i will kind of point out one thing if you're new to container queries is that in the main components felt file here when you apply a container to an element you can't actually you only can style what's inside or the children of that element so that's something that uh you know you just have to be aware of when you start uh using uh container queries i suppose um we can kind of move on to like the more uh advanced demo you know certainly check out this repl i guess the The key takeaway here is that certainly with some components, like I'll show with a color picker where you have like a popover component, it's very nice to be able to have a single constraint or a single option, the width that you want to display the component by and be able to change it up. So when it's very small, you have a different layout than when it's larger. So we'll just kind of jump over to... And so this is running inside the Foundry VTT platform. And all this is like this window is fully svelte driven. And I just have some basic controls here that control the options of this component. but you can see when we when we make it smaller when it gets too small and i have my screen also very zoomed in so this is like when it goes below uh 235 pixels we get rid of the spinners because they don't fit anymore um when we get really small we get rid of the whole bottom section here so this is not in the pop mode but in the pop mode you have the full flexibility to as the developer to kind of choose how you want it to actually display and I should mention sometimes you know I do like there is a color picker component out there that's available and I actually did end up hard forking it, so it'll look very similar, but I changed pretty much the full internal implementation of what I've come up with. But yeah, as far as container queries go, I think it's going to definitely be something to look out for as long as you can kind of support browsers of this very modern generation and uh i you know i definitely going to be diving head headfirst into it and applying it um broadly across like the framework that i'm working on and i hope by year actually to kind of have everything um architected in a way that'll run on top of svelte kit and the larger svelte um world as well but it's been very awesome to kind of uh work on this and so this this platform it you know this is like an overhead map but you know if you had players you know this is kind of like the view they would see but you know this is not about uh this particular uh really cool platform for doing online uh you know virtual tabletop stuff but you know enrico thanks for uh letting me stop by and kind of uh talk a little bit about this i'll drop like a link to my discord too um so if if the idea of uh applying svelte and uh you happen to be passionate about you know tabletop rpgs uh definitely swing by i'd glad to chat with you um but yeah thanks again uh for letting me to stop by and talk about uh container queries Awesome, Michael. Thank you for your contributions and showcasing how container queries could be used for powerful popouts like this color picker. Yeah. Alrighty. So with that, the community showcase is coming to a close and I'm going to bring back my screen. Thanks again. Moving on to this week in discussions So this week in discussions not much has happened per se But I have a couple of things. There's Svelte check that if you don't know about already, you should. Take a look at this. It's more of a quick fact. so in svelte.js language tools repository there is a package called svelte check which is included if you're already using svelte or svelte kit it's a script you can run either in your package.json scripts such as this or you can run it directly using npx svelte check or pnpm svelte check what this does is it checks it runs the svelte compiler to check for potential bugs and errors such as unused CSS, accessibility hints, and TypeScript compiler errors. So it also runs the TypeScript compiler, or if you're using JSDoc like me, it checks your types. And I realize I'm underutilizing this. So it's a good idea to try out SvelteKit. If you have a high-quality repository and you're running continuous integration in your pipelines every time you make a merge request or pull request, this is great for that because you can check to see if there are type issues with the way you're consuming functions across your application. This would have saved me from a regression I had recently. I changed a function's return type, and I only refactored one file, whereas there were other consumers of that file also using that function. So obviously, if you're using TypeScript, you get that for free. But if you also use SvelteCheck, this will include that life-saving checker that you could all take advantage of. and just curious this could be like a segue to a discussion in itself like how do you like to maintain high quality code bases and let me just make sure everything's on screen here feel free to raise your hand talk in the chat otherwise this can just we can just keep it light no pressure So Captain wrote, SvelteCheck has saved me a few times. Great for checking things in templates that TypeScript may not find. Yes, interesting. So I sort of expected it to be as powerful as TypeScript in that regard, but it turns out, as per their lived experience, it could be even more useful than TypeScript. Because it wraps TypeScript and it's also the Svelte compiler itself, it could possibly save you from other regressions.

 So that's really cool to have. I fully intend to integrate this with my continuous integration. So every time I make a pull request, I want to see SvelteCheck run and provide zero errors in response. Of course, I currently have a few dozen errors I have to resolve first. But once that's all said and done, this could be very handy. And I'm sure everyone else is doing cool stuff like unit testing and end-to-end testing. I think this is a quick win because you get it for free. It's a single command. You don't have to write any tests. SvelteCheck just does a lot of heavy lifting for you in a single command. So for me, this is a quick win. And I'm going to prioritize this for my code bases personally. Second to this is I personally like to use unit testing. But end-to-end testing, because they're expensive to run but cheap to make, they're also very, very good, not to be underutilized either. But I think, for me at least, this is a higher priority. So I'm going to take the time for that. And that's it for this week in discussions. Moving on to this week in questions and answers. Interestingly, for the past few months, I noticed that the Svelte Discord has had a very wide variety of questions and answers. This is, I guess, a good thing and a bad thing. But the good thing about that is folks are not as hung up on repetitive concepts like in the past. Everyone is exploring Svelte and SvelteKit. Everyone is learning new things, but also reaching the limits of Svelte and SvelteKit. So we're getting a lot more unique questions every single week. So it's hard for me to pin down the most common questions and answers, really. So this makes my job a little difficult. That's the bad news. But I still have something to share. So this week in Q&A, we've got... How do I define global types in SvelteKit? And I'm not just going to talk about that one concept, but a little bit more to it. So let's go to our text editor. How do I define global types in SvelteKit? Global types can mean a few different things. The first and foremost is reusable types. So a common pattern that I use and I see a lot of other people use is in their lib folder, we have a types.declarations.ts. I believe d refers to declarations file And here you can make your reusable types In my case I have an interface called pet I written it in TypeScript and I exported it for reusability And here you can make your reusable types in my case i have an interface called pet i written it in typescript and i exported it for reusability so here if you have common types used across your application you can import them from this file very conveniently like i do here so here on line five i've defined a pets array and on line four i've imported my reusable pet type to tell everyone, to tell the code editor, this is what I want. And it'll have full type safety, so you can do things like food, ice cream, and there's an error. There's an error because, let's see the pretty error, here we go. Object literal may only specify known properties, and food does not exist on pet, of course. and the cool thing about importing the reusable type is IntelliSense works in your favor. So if I delete this type and let's pretend I'm adding it for the first time, I can do add type. I can type in pet and there's the autocomplete that I like to see. So right here it says change pet to import lib types and on the right side you can see dollar sign lib types. That's the path alias for the lib folder. I press enter and boom. It writes the import statement for me. It knows to check dollar sign lib slash types because types.d.ts gets shorthanded to just types. At least that's how my JS config has it. And if I hover pets, it says it's missing species age. I think it's just my computer is really slow. So I think the TypeScript server is eventually going to get there. I can always force it with restarting the Svelte server. needs array. Oh yes, very good. So the type is wrong. Because pet is just an interface object, I also need to mark it as an array. That's why there was an error there. So if I delete the array, there's an error. If I add the array, then I let the code know it's an array of pets. Thank you for that save. Live debugging. Don't we all love it? The next factoid is globals. So this is about reusable types, but what about globals? So for example, if you're using traditional web programming, where you have an object called window.myObject or something, and you not doing server rendering let just say hypothetically you have access to the window element So this is an unknown type And the window is optional Like, you can always do myobj, and myobj implies window.myobj. But here in the Svelte file, it doesn't know that myobj exists. It cannot find it. It doesn't know the definition of it. So one thing you can do is up here, you can do global myobj. And this will tell your linter, at least, that this is global. But I still get a JavaScript issue because this is not working out for me. Another thing you can do is in your app.d.ts in the root. So I'll open it here. Under source, app.declarations.ts, you can define global variables like this. var myobj string. So I'm telling the global namespace that my OBJ exists. And if I go back to that page and delete this global helper, there's no longer an error because I've defined this as global. Yeah, bear in mind, this will totally break with service-ed rendering. But let's say you're running this on the client and you know OBJ exists in the window object. Either you specified it in your app.html, for example. Then this is one strategy you can use to make the language server very happy. But for me, I don't need this. Maybe for you, you might. At least now you know. And now for a bonus. Some people have asked, where do I place components? You can place them wherever you want. However, there are certain strategies with pros and cons. Most commonly, if you have a component only used in a route, like let's say my loading images route, page.svelte has some helper components, you can put your Svelte components here in the route directory. That's useful if you're not reusing those components anywhere else. But let's say you are reusing it. What I have up here in the components folder, under source, components, pet.svelte, I have this reusable component I would like to use. So I can put it there, and I can probably replace this code with this code. So I have this component as a drop-in replacement. component. And I want to also set up a path alias because if I import the pets in a custom directory like components SvelteKit is not aware of any custom path aliases So let add one If I go to SvelteConfig I believe it's paths or alias. No suggestions. It's probably under kit. Alias. There we go. And you can say string or dollar sign components, source components. So I've set up a path alias called $components, and theoretically this should auto-import my pet component right here. Let's run the server, just to see this all come together. Okay, so here's my application. we've got two pet samples we have a cat age 10 and a dog age 7. I'm going to replace this loop with the pet component so if I type in pet now suddenly I get suggestions here's the cool part so it does find my pet component under dollar sign components slash pet.svelte if I press enter on line two it does the auto import and it correctly finds the path alias components that I made for myself. So what are the props for pet? Data. So it has the autocompletion for props. I can pass in pet. And I can refresh the page. And it still looks good. And to prove it looks good, I can say hello. And you can see hello twice in the loop. Hello, pet. Hello, pet. Everything's coming together. It's all working a little bit too well. Surely a demo I present today will break, but not today. So that is it for path aliasing. And just to recap, under your SvelteConfig.js, setting up the alias, this is also available in the documentation. SvelteKit will pass this into Vite and into your generated TS config. So your code editor will be aware of the alias, which is why Autocomplete worked. Svelte and Vite will be aware of it. So when you build your application, it will work because under the .svelteKit folder where everything's being generated, the tsconfig.json is auto-generating the alias that I had made in svelte.config.js.

 That explains how it works for those interested. Moving on. So you have the three strategies. It's really up to you. Strategy one, you can co-locate your components. So here in the loading images directory, I can make a new file called pet.svelte. That's co-location. You can totally do this if you're not reusing it. If you are reusing it, you can put your component in lib. Lib is fine. Some people do lib slash components. That's totally fine too. You can put your component in lib slash components and you can reuse the $lib alias. Or if you really like, you can do what I just did and make a separate source components directory and then you can import your components using $components like I did here. It's all customizable. Nothing is truly opinionated really. You do get lib for free. So that's why the lib components strategy is very common, because you don't have to deal with aliasing. If anyone has questions or comments, feel free to join me on stage or type in the chat. Otherwise, I'll wrap up soon. Let see if this is still working on production or development Yes And to prove it works when you build I can do pnpm build Yep Brittany wrote you can use the at sign instead of dollar sign too, if you don't like dollar sign everywhere. That's exactly right. It's all personal preference. If you and your team like a certain convention, you're more than able to do that. I can change this to at components. And I'll have to make this a string because of JavaScript. And if I change this to at components and I run my server again, that should work. Refreshing. It works. See? At components is also an option. You can call it at ice cream if you like and totally name it differently from the directory, but I don't recommend that. So that's it for this week in Q&A. Thank you all for listening, and it's time to wrap up. That has been your This Week in Svelte. We're here for a good time, not a long time. I'll leave a feedback form in the chat. I do look forward to your ideas if you want to see other things in these events. And that's it for now. Talk to you later. Bye-bye.