 Hello again. Welcome to This Week in Svelte. My name is Enrico and I am your host for today. The agenda is the changelog, quick facts and announcements. We have a few announcements, and a community showcase, and some discussions, and Q&A. It's all here. But the changelog is first in line. Let's go. Let's start with Svelte, and then SvelteKit. Okay, so the notes here for Svelte 4.1.0. I know we skipped a week, but it feels like we're about to catch up again. So the first feature is addability to extend custom element class. One of the highlight features of Svelte 4.0.0 in general is better ergonomics for writing custom elements, also known as web components. And Svelte 4.1 allows you to extend the custom element class, the classes in the JavaScript class, not the CSS class. So over here in the documentation, under custom elements API, which is like everything you need to know about building custom elements or compiling as them, there are options. And the newest option is extend. Extend allows you to pass in a function so that before the class is totally built, You can extend it with some constructor overrides, some bespoke methods if you need them. So for special circumstances, this may be useful to you. But for most people, you may not need to worry about using this. It's now available as a feature. Next is Svelte Component evaluates props once. There was a match cases where Svelte Component would evaluate, I think it was rest props, multiple times. but now it's more efficient and it's evaluating props only once. Next is let variable slot bindings from select binding dependencies. This was a doozy, but I actually think I can explain and understand it now. So the issue is best explained with a REPL. Take a look at this. The issue at hand is there's a parent component and it's using a slot prop. The slot prop is let data. I should zoom in more. You can never zoom in enough. This parent component has a variable called data, which is an array of three numbers, and it's passed in as a slot prop. So the default slot contains the data prop Then here the parent component is used Let data is defined And this should allow the select child component to set the value of selected which is a variable in line three. This should initialize as the first option. So lines 11 to 13 is in each loop. Data is being iterated. And inside the select, you have one, two, and three. but what's broken is in Svelte 3.4.4 and above before this release, it was not initializing selected. So the workaround that some folks have come up with over here is to initialize a local prop or a local variable called data. And I don't know if many people run into this, but the workaround is you have let data defined here, Data is iterating, and for some reason, defining it in the component scope resolves it. So now you have your three select options. The selected variable on line four gets instantiated as the first option. So now you correctly see one here in the rendered screen. But as of Svelte 4.1.0, you no longer need to do this. So I can comment out line five. It still works. and that's it. So the fix here is the slot prop is part of the scope now of the components being used in. And in this select example, the options get iterated and selected properly gets two-way binding. So the first option being number one passes to the value attribute in select. So that's resolved now. 4.1.0. Next. Handle destructured primitive literals. When you define props, I believe, like export let using component props, there was an issue with them not working predictably. I think there was a REPL for that or stack overflow question. I'll try to...actually, the Stack Overflow example works. There was an issue with this not working predictably but now it should I did not personally confirm if there a preferred way to instantiate so many props Personally I like to do this one at a time That just me But it should now be possible to do this destructured instantiation Maybe. There's a performance optimization. Imports that are not mutated or reassigned or optimized. And don't add accessor twice. Accessor, trying to... I think it's in my notes here. Yeah, this is for custom elements. So if you're making a web component, there was an issue with accessors being added twice. No longer the case. Especially in dev mode. I think it was fine in production mode, but in dev mode, custom elements had multiple accessors. So that's patched. And then finally, Svelte 4.1.1, the Svelte component special syntax has spread props changed, not being picked up, but now they are. So I think if you use spread props in Svelte component, some changes were not being recognized, but now they are. So go on and upgrade to 4.1.1 if this impacted you. Next is Svelte kit. 1.22.1 and 1.22.2. And I think within the last 12 hours, this came out. So let's go over them. So in 1.22.1, Vite, generating relative paths, is now quicker. 1.22.2. way to tick before announcing new page title. This was an interesting one, and I think there's a video explanation here. So this was about using page.data as your title in SvelteKit. So if you define SvelteHead and then you apply page.data to have a title, there was a race condition where the title would update. And I'll try to bring this on full screen. Let's do that so you can see it in action. So when the user clicks on home, now the title of this heading is home. So down here in the H1, it says home. But up here in the title, it says home. Wait for it. Okay. But the div says about and the title says home. So the screen reader would announce the previous page's title, but not the current page's title in the right order. So that race condition has been patched thanks to a tick. It all about the tick Next is a feature More helpful error for preview if build output doesn exist yes so if you run npm run preview for vt preview then it warn you if there no output 1 this is new it's my first time reading this gracefully handle server endpoints that return responses with immutable headers okay so this is like a compiler warning if it notices that server errors sorry server endpoints have immutable headers i think immutable headers is a http feature that i haven't used personally but now it should be handled by svelte kit and that's it for the change log let's continue to quick facts and announcements first quick fact there was a recent svelte siren stream featuring eric leo the former full-time maintainer of carbon components felt check that out on youtube the link is in the chat here in summary it was a retrospective of carbon components felt and things that went well and things decisions that could have been made to possibly improve the developer experience of Carbon, as well as the maintenance perspective of that. So if you're into design systems, or you're a user of Carbon, or you're just curious, like how to maintain good component library practices, this is a good stream to watch if you're into that. If anyone actually saw this already and has questions about design systems in general, or Carbon specifically, feel free to drop your questions in the chat and maybe we can discuss them together. I'd like to hear your thoughts. maybe next week we'll cover it too depending on you watching the video the next announcement is a public service announcement and that is for me to say please say no to low color contrast i do see more often than i should websites personal blogs that utilize gray text in the dark background some gray text is contrasty enough like in this example i'm using the official WebAIM contrast checker. Link is in the chat. And with this tool, you can very quickly see if the contrast ratio is adequate. This has a ratio of 10 to 1, which is good. I believe 7 to 1 is the minimum. Yeah, for Web Content Accessibility Guidelines AAA. You should strive for 7.

 In most cases, 4.5 and above is adequate. But what I do see a little bit too often is sometimes folks will have a gray text color, and then they'll set the opacity to 0.5 or something, causing the contrast to be like this. And as you can see, it's very illegible. Even if you have an amazing screen and you have really amazing eyesight, yeah, you might be able to read this. But I guarantee you, like, hardly a sizable population percentage has both of those things. A very good monitor and very good eyesight in very good well-lit conditions. So try your best to meet these standards and use the contrast checker. That's it. Quick public service announcement. Now let's move on to this week in discussions. So I'll just stick on the WebAIM website. This week in discussions, we had a topic on when is progressive enhancement needed? I know we've talked about this in the past, but it's always good to talk about it again and again. Usually concepts change, philosophies change, and newcomers show come and go. So this is for you. What is progressive enhancement? The quick definition is it's a minimal baseline of functionality. And there's a good definition of it on the Mozilla Developer Network, so I guess I'll keep this screen open as I go through the topic, and I'll share it in the chat. so what's topical about progressive enhancement is the fact that when svelte kit was introduced to the world there it was pushing for the the most common use case of full stack development which is remotely hosted web applications usually cruds e-commerce blogs informational websites and a lot of websites today have dynamic content and there are lots of popular usages of serverless technology and database connections. So progressive enhancement is, I'd say, a popular topic in the Svelte community, especially on Discord. So what are the benefits of progressive enhancement? In summary, it provides access to information to a wide variety of users under a spectrum of device connectivity and capability So even if JavaScript is enabled sometimes a user will load a website there will be errors there be network issues and sometimes JavaScript itself fails even when it enabled such as there are factors such as low connectivity, factors such as mobile devices that are underpowered, or you're on a corporate VPN. There's a wide variety of vectors that can make things go wrong. And progressive enhancement allows you to ship a server-rendered application that still works. You can still get the content you need. You can still submit forms, and you can still engage with the interactivity. So when does it matter? The examples I gave about diverse networking, and it helps with web archiving. So sometimes you're familiar with the web archive, this website. so the wayback machine can more easily archive websites that are progressively enhanced because they take a snapshot of the web page all the html as well as the hyperlinks and spelt kit it really excels in this manner because if you if you follow the documentation closely you'll be able to ship something that can be saved and downloaded and used offline as well as in an archive. So that's one benefit too. It helps with CRUDs, which is create, write, update, delete, light interactive e-commerce websites. You know, the number one rule of business is don't make it hard to give people your money, right? If it's hard for someone to give you their money, they're not going to shop on your website. It doesn't matter if they have accessibility needs or network issues. You want to make it as easy as possible for as many people as possible to browse your services. So now the question is, when is progressive enhancement not necessarily needed? There are absolutely use cases for this. So I'm not one to say, hey, you must use server side rendering for 100% of software use cases. That is not true. It's simply not true. For example, if you're using Capacitor or Svelte native to ship a Android or iOS application, progressive enhancement is unnecessary. Because in those applications, the user has downloaded and installed all of the scripts already. Everything is locally hosted on your mobile phone, in most cases So therefore you much less likely or almost impossible to run into JavaScript issues because all the scripts are served locally Service rendering not only is impossible but it unnecessary in those circumstances Another example is you using a single application on a embedded device which is a small computer or microchip that serves a specific appliance need. If you just want to engage with a locally hosted application, an SPA is perfectly reasonable. So where does that tie into progressive enhancement? It's about making sure that in your determined use case, that you're serving the right users in the right ways. Another example of progressive enhancement isn't necessarily, hey, it has to work without JavaScript. You can have a website use JavaScript and CSS, but you can also progressively enhance that by detecting features such as bleeding edge CSS. A good example of that is has. So if I go to can I use and look up has, you will see that the has selector is available practically everywhere except Firefox. I use this CSS selector in my code bases as a progressive enhancement. So if the has selector works, it shows a certain styling. And that's okay. You can still have fallback CSS that can show the users some kind of styling to indicate some kind of information. And for everybody else who does have the has selector, they can get some interesting new styles. So these are the considerations. You got to have a fallback that progressively enhances to something that's better. This is a CSS example. There also are polyfills. That's right. You can have JavaScript polyfills for CSS selectors and other things too. Oh no, there's too much screen share. I got to turn it off. so if anyone has perspectives or points to make about progressive announcement feel free to raise your hand join me on stage or type in the chat and i'll read some of your comments and i'll do some of that now because this is a discussion also for more reading check out this really awesome article because one thing that comes up a lot is people saying why should i support people who turn off javascript and I'm not even talking about that. Neither is this article. So it's not about users who disable JavaScript. They exist. They're real people. But it's more important to consider that a higher amount of people have JavaScript turned on but it fails And the article in the chat will exemplify that You have users the same users who visit your website but not 100% of site visits are stable. So these emojis, I'm not sure how well they're animating on your end, but sometimes the same users will visit your site and have a 10 out of 10 experience, but then a day later have a 0 out of 10 experience. This is what we need to account for. We want to make sure that every visit allows them to get things done and every visit is possible. This is especially true for remotely hosted web applications. That context is valuable. Of course, if you have local needs or you have some other servers written in other languages or other use cases, or especially if you have an edge case or you know your audience, if you 100% know your audience, like you're building a Svelte application for two people and they're your best friends and you know what their physical abilities are, then yeah, do whatever you want. You know your audience, you've done your research. But if you're developing something and you don't know your audience because you haven't met them yet, this is why progressive enhancement is so important to be at the front of our minds. so let's read the chat so in the chat we have so we talked about polyfills yep those are one way to keep everyone at the baseline Jiro asks how does this tie in with progressive web applications that's a good question progressive web applications are things that utilize service workers for enhanced functionality. And one of the most common use cases is offline support. So if your application is like a developer documentation, then it might be a good idea to support offline mode and give users the option to download the documentation in case they want to code in the middle of a starry field without a 3G connection. that people like that exist so pwas help because they give people more opportunities to read your content even when connectivity is non-existent is it 100 necessary that's for you to decide because there is a balance between like time putting into these versus the the output you need to gain and not everybody has time or budget

 so you need to balance all three. And Baffy writes, I have a global error catch for any JavaScript crash. It redirects to a personal apology letter. Okay. Hey, that's not bad. In fact, a related example to that is you have a e-commerce site that wants to do a home installation of something, like an internet service. if for some reason the user cannot use your website because you've designed it in a bad way, a sad but okay fallback is to show them a phone number. Say, sorry, we can't do that for you right now. Please call this number for our somewhat accessible fallback. Better than nothing. It's good for compliance, but it's not the best. What else we got in chat? I've seen how Rich develops his app nowadays. Always two cases, with and without JavaScript. Yep. Does CSS have a native way for fallbacks? Kind of. Not really fallbacks, but it's just a matter of looking at compatibility and targeting your browsers. Back before Evergreen browsers were the norm, there were prefixers you could use, but that's less necessary nowadays. So I wouldn't say there are fallbacks as much as there are like bleeding edge features. I think the more common use case now is you want to use a new feature, but not every browser has it yet. Literally has it. Let's see what else is in the chat. Aggressive enhancement? Maybe. Yep. So that's it for the topic. All right, then. Let's move on to this week in questions and answers. And we're back. So for questions and answers, the first question is, what are the differences between script and on mount and I might even answer this in a way that more than what you bargained for Take a look at this So the question was what the difference between script and on Script refers to every spell component has a script tag and the top level of that script is evaluated in order. If you're server rendering, everything at the top level gets evaluated during server-side rendering. So the Node.js environment or related JavaScript environment, not necessarily Node. It could be Dino, it could be Bun, it could be V8. Those runtime engines will evaluate the top level of script. But then onmount is not called server-side if you're in that kind of environment. It only gets called after the HTML markup has been mounted. So in this example, let div is an undefined variable. So console.logdiv will log undefined. Browser, which I'll show in real time as well, this is a SvelteKit feature. If you're in the browser environment, this will also log undefined as it gets evaluated. And then on mount will log htable element because we're using bind this down below in the template. So on mount will get called, this will get bound, and then this will be an actual htable element. So here it is in action. Alrighty, so I got my console open. And this time on line two, let me shrink this. There we go. On line two, I've actually imported odd mount. And on line three, I've imported browser, which is a SvelteKit feature, not a Svelte feature. So on line five, letdiv is there. It logs undefined. So you can see my console here, undefined. There's the first one. And then the second one is down here, undefined. Because this is the browser environment and not the Node.js environment, you do see it in the console here in the browser. So that all makes sense so far. And then finally, you see div being logged to the console thanks to the on mount. So that's the answer to the question. But let's take this a step further. What else do you need to know about lifecycle? There's also reactive statements. So let's see if I can live code this. So if you enter a reactive statement like thing equals div. All right, so I'll do console.log. Console.log div. There we go So now we see two div elements But the thing to note is that all reactive statements do not get evaluated linearly Even though in plain JavaScript, this would get evaluated in order, because felt is a compiler, it treats this in a special manner. Line five will get evaluated. Then line seven. Line nine will be looked at, but it won't run. So this gets skipped until the end of script. Finally, line 13. That runs. And then line nine actually runs. So reactive statements run after script is evaluated. After this gets evaluated, then on mount executes. So let's write that in order. One, where's my notes? One is script. Two is reactive statements. Where's my shift key? There we go. three is on mount. Now let's add some more things to the mix. If you have actions such as this div, you can say use a div action, and I can make a function here called const div action. There we go. So actions get evaluated right before on mount. So I'll throw them in here as step three. And then on mount is number four. And that's the order of operations. Thank you, Captain Codeman. So the correction I made there was the action here is a function, and here I'm passing in the element example. This should really be node. That's the more common parameter name. And then the node gets logged to the console. So the order is top-level script, reactive statements, use actions, and then on mount. I wrote this in a really weird manner. I usually save my reactive statements for the end, but you can organize this however you like, just so long as you know the order of operations. Let's look at the chat. All right so Tanti Kun writes that seems very confusing Yeah it could be This is one of those learning curves that is good to know about especially if you utilize all of these features at once Hugos writes how would you bind a function to a div Anyways, oh yeah, you're just helping out someone. How do you bind a function to a div that itself needs the div? Yeah, that was a contrived example. So I should have been more realistic. Baffi writes, if your div in this example is another spell component, then you can bind to that component's exported functions just the same. That is true. Does the bind happen before on mount? Are you referring to lines 23 bind this? It does. Technically, it happens right before. So on mount means this is being rendered. And yeah, bind this should get called right before on mount. That's why this console log successfully outputs the element itself. You can say there's an implicit tick between on mount and the document object model. So all of this mounts, there's an implicit tick that you don't have to think about. The smell handles that for you, and then the function callback actually calls. Cool. And if anyone else needs clarifications, feel free to write in the chat. There might be one more question. If not, maybe next time. Oh, a great question. Baffy asks, what is the tick? The tick is a superhero. No, I'm kidding. The tick is a feature. So here in the Svelte docs, there is a runtime section. I think that's where it is. Yep. So here in the Svelte runtime docs, there is a section on tick. Tick is a utility function exported by Svelte. It allows you to ensure that the document object model has updated before executing more scripts. So in this code snippet, we're doing console.log. The component is about to update. You await tick. And then after the tick is awaited, a tick is like, it's called a tick because it's not necessarily a millisecond. It's not necessarily a frame. It's just however amount of time it takes for the document to update. So it's not a specific unit of measurement of time. It's just an indicator that the document has updated. A tick has been awaited. Captain writes,

 if you want to have the render happen before your code continues, similar to how you sometimes with DOM updates. Yes, it's very similar to requestAnimationFrame in behavior. So requestAnimationFrame is different in two ways. One, it allows you to run functions at the next frame. So requestAnimationFrame, I'll pull up the docs. It's still useful. You might want to make use of this function in Svelte because it's a standard browser API. RequestAnimationFrame, if you have a 60 frames per second application or video game, then this will ensure that you render things at the next available frame without overloading the frame with JavaScript. You want every frame to cleanly execute code in under 16 milliseconds. That keeps your animations under at a nice smooth 60 frames per second. So requestAnimationFrame will determine, it's like, hey, this frame is about to take 20 milliseconds. So I'm just going to run this code that you pass in at the next frame so that the next paint can be very smooth. You pass in a callback function, and it will perform its calculations. Calculations such as new XY coordinates for an object moving across the screen, for example. That's the use case for that. But it's different from a tick, because a tick is just what Svelte developers use to make sure DOM updates. And I think I have a REPL for this. Let's see if I can grab that. One moment, please. Okay. Focus after undisable. Here it is. So let take a look at this I showed this example in a prior week and I utilizing Tick so that I can focus on elements So on line 6 I have an open dialog button I click on the open modal button The modal opens, and the input is focused. The reason this works is because I set open to true, I await Tick, and then I write input.focus. Input on line four is the input down here. So I use bind colon this input. This allows me to use node APIs, HTML node APIs, such as .focus. And the important thing about Svelte, I don't have a closed modal action. I got to refresh. When you set open to true, then the dialog open attribute gets called and the page has to repaint. the page has to update the document object model. If I were to comment out the tick, then this happens. My input is not focused because I'm calling dot focus prematurely. This becomes a race condition. I'm calling focus before the input exists in the window. That's not good. Oh, the escape key works. So if I call a wait tick, I open the modal, it waits for the modal to be open because of a wait tick. And then it's able to call dot focus. and focus on the input. This is especially useful for focus management. So hopefully that answers the question on what is Tick and what's it best used for. This is a real-world example. I'll share it in the chat, just so you can have it. There we go. All right, let's look at comments. The tick of a clock, it has no concept of time. Maybe. Hugo's writes, couldn't you do the same via tick.then? I guess so, like there's, I'm using await tick, but there's what, there are now three competing standards for promise syntax, so you can do whatever you prefer. That makes more sense Can we say it resolves when the DOM is fully updated I believe you can assume that I think the tick so when you do an assignment in Svelte as we know Svelte reactivity is declared with assignments So open equals true, that's an assignment. I'm telling Svelte, hey, there needs to be reactivity here. Any DOM element depending on open, the variable, must update now because I made the assignment at this point in time. So that's why it's appropriate to call tick right after the assignment, because you know the documents can update and repaint. You wait for the tick. It's just one line of code. And then you can finally call other document-related code. And you can safely call it knowing that it's rendered again. Baffy writes, so if I have some conditionally mounted button component, I've bound to some local variable. And on click, I perform some code that makes the button remount. If I await the tick in the click handler, then will it wait for the remount and rebind the variable? I believe yes is the answer. After the tick, I can use a newly bound local variable. Yeah, definitely try it out, but that sounds correct. As long as you await tick, the document should repaint with the new JavaScript variables used in the DOM. In my case, I'm using open, but if using anything else, yeah, the tick will allow you to wait for that to be repainted so that you can call other functionality, in my case, dot focus. Try it out. Give it a shot. and I guess to close it off with a bonus the fact that why is focus management so important it's because of screen magnifiers so I think I'm sharing my chat if I zoom in you'll see, I'm not sure if this works well in Chrome so let's give it a shot, I'm zoomed in everyone on Discord is going, wow you're zoomed in, yeah I am I press tab to focus on something There we go. Just barely getting by here. I'm focused on the open modal button. And then I press enter. Because I have two monitors it really contrived But because I pressed enter the screen magnifier actually jumped to the input so that if I a screen magnifier user and I'm zoomed in this much, which is a very realistic example, believe it or not, this is what I'll see. I'll actually see the next focus element. If I did not call .focus, then the user will get disoriented. They'll be like, I called open modal. Now where do I go? Do I go left, up, right, down? Actually doing focus management is helpful for screen magnifiers. And that's something we should all be doing. Let's see the chat. If anyone runs into issues, you know where to go. We have a forum channel, and maybe I'll jump in and help you out. What if there is a transition? Does it await transition also? Transitions are very special because sometimes the effects of a transition appear right away as it's transitioning, and sometimes they don't appear until the transition's completely finished. So you might want to add transition handlers like onAnimationEnd, which I think is the name of the event handler. onAnimationEnd. Yeah. So you can set up custom event handlers using use actions and use standard browser APIs like animationEnd. So when the animation's over, you can have a callback. So yeah, transitions might be special in this regard. If it's CSS, I think this also works for CSS animations. And if it's a pure JavaScript animation, maybe you need to use requestAnimationFrame or some other callbacks. But yeah, tick may not apply here. It depends. Yep, so now you know about animation end. Check this out. Okay. I think it's time to wrap up. Thank you, everybody, for hanging out today, and have a good one.