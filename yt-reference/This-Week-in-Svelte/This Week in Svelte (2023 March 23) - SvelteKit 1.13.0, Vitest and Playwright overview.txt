 Hey, paisanos, welcome to This Week in Svelte. I am your host today, Enrico, and what we like to do in this show is to discuss very casually what happened this past week in Svelte, such as the changelog, but also more specifically what happened on Discord. So in the Svelte Discord, we cover a lot of topics such as community discussions and tons of questions and answers in Q&A, so I hope to wrap up some of those and give you a digest. So let's go! Today's agenda, as usual, is changelog, quick facts, community showcase, discussions, and Q&A. I don't have a community showcase today, but if you have a project or library you wish to show here on stage with me, reach out to me and come up to it next Friday. So let's begin with the changelog. What is new in the world of Svelte? SvelteKit has a new release, version 1.13.0. and that entails dark mode styles and the default error page. The default error page is this implied error.html that does not exist in the code base, but if you add your own custom source, I think it's source error.html. Let's confirm. Kit.svelte.dev error.html. I will zoom in. Here we go. Yeah, source slash error dot HTML. This is an implied error fallback page if you don't specify a plus error dot svelte page. And now it's in dark mode. And under patch changes, we have a fix to recover from errors during dev by reloading. This is always good to see. Sometimes Vite is, with hot module reloading, sometimes you get into strange edge cases where things don't properly reload or errors don't properly render. So fixes related to that are always welcome. And that's it for the SvelteKit changelog. That was easy. Moving on to quick facts. Today is not a quick fact, but it is a fact. Let's have a look at voiceover. So what I like to do with these sessions is to cover one interesting accessibility tidbit with the time I have. And today tidbit is about Safari and Mac OS voiceover So I just going to talk briefly about what is voiceover why it important to test with it and how it actually works I going to actually show you voiceover in action So because we on Discord unfortunately you won actually hear voiceover but on the recorded YouTube video you will hear the prompts it says It's okay because at least you can read the prompts. Let's take a look. VoiceOver on Safari. So there it is. This gray box up here is the prompt window for VoiceOver. VoiceOver is an assistive technology. It allows folks with a variety of disabilities. It's not necessarily folks who are blind who use this. Sometimes you have blurred vision. Sometimes you have reduced motor skills. And VoiceOver makes it a little bit easier to navigate a page. So it's not just about reading what's on the screen. Sometimes it's also about power tools and navigation. And I will show you a couple of those. To begin, I have a mouse, but usually you navigate VoiceOver with a keyboard, and it's very subtle, but around the Safari window is a black border. This shows what VoiceOver is currently targeting. So if I use my keyboard and I press Control-Option-Right Arrow, I can progress through this web page. And out loud it says, Felt Wikipedia Web Content, and I believe that's the title of the page, using the HTML title. And if I double-click on the heading here, it says felt selected. If I press Ctrl-Option-right arrow, it moves on. So now it's hovering this language to a bar. Because it's an interactive control, I can press Ctrl-Option-space to engage with it. And there we go. So now it says go to an article in another language. available in 13 languages, menu pop-up, button. It announces to me what the accessibility text is, and it tells me at the end what it is. It's a button. Sometimes if it's a slider, it'll say this is a slider. Depending on the type of interaction it is, it'll announce that. So it says available in 13 languages. What's interesting about this prompt is if you can see my screen, it only says 13 languages. Menu, six items. Let's inspect that. VoiceOver off. Inspect element. All right now let read the text here So you notice it says ARIA label Let me zoom in again You can never zoom in too much on these sessions Okay so here it says ARIA label go to another article Sorry go to an article in another language available in 13 languages. When I use voiceover, this ARIA label is picked up by voiceover and read out loud to me. So this way, if I am blind and I don't have contextual awareness of what this button is, this additional label will give me that context. So this is why you can display one thing to sighted users, but also provide accessible copy to non-sighted users. And that's the purpose of ARIA label. And since this is an input with a type checkbox, that role will also be announced to me. So let's continue with voiceover. all right when voiceover reads things out loud i can silence it by pressing the left control button once this is for the youtube audience because i don't think discord audience can hear anything moving on heading level a link and of a arabic letter link so something strange is happening. As I navigate with control option right arrow, it has to, each item on this list has like three interactions. If I go to the next one in Chinese and Japanese, it says Chinese group or Zhonglan, and then it says link Zhonglan, and then end of Zhonglan group. And now it's reading the Japanese entry. So there's a little bit of finessing here that I think Wikipedia can improve. Instead of interacting with each link three times, it would be ideal if I could interact with each link once. Let's see how I can notice this. So here we have a list item and an anchor. And that explains why it's interacting with this twice. First, voiceover interacts with the list item, and then it interacts with the anchor. Oops. I clicked the link. Okay. And what's cool about some of these is you can specify the language of each item. So here it says anchor class, whatever, and then language Japanese. So because the lang attribute is set, voiceover actually reads to me in the Japanese language So you can set lang not just for the HTML element for the entire document you can set lang for individual items And this is a very good use case for that Sometimes you have articles on a website Some articles are written in English, some are written in Spanish. You can have lang set to Spanish and VoiceOver will read it to you in Spanish instead of broken English or the default of your system. So lots of things are happening on here, and you can see how HTML and these attributes impact the experience of voiceover users. This is why you can't write a website all using div. This is why using the correct HTML element makes for a good default accessible experience. Now let's try the power menu. I'll show you what that looks like. Okay, I've reactivated VoiceOver, and if I enter the page, I can press Caps Lock U. There's probably other keyboard shortcuts, but the one I'm familiar with is Caps Lock U. And this opens the so-called Uber menu or the Super menu, and it allows VoiceOver users to become power users. They can navigate web pages probably faster than I can with a mouse. So for example, right in front of me is all the headings. If I scroll down with the arrow keys, Heading level one, Svelte. Heading level one, Svelte. Heading level two. Heading level two, History. Heading level two. Heading level two, Syntax. So what's cool about properly setting headings in your document H1, H2, H3, that directly translates to this Uber menu. When you're using VoiceOver or any screen reader, this headings menu will become succinct. It'll become useful to the user of that assistive technology. And especially important is the ordering of your links. The order of your headings. If you have an H1, it should directly follow with an H2. And if you have an H2, it should follow directly by an H3 or go back to H2 for the next heading order. So the hierarchy of your headings is vital. If I press right arrow, you'll see other landmarks. Form controls menu. So this is form controls. Top search button. Anything that's a form control, I can quickly navigate to it using this tool. Go button. Let's go to Links. Alright, so here's the Links menu. The Links menu is cool because anything that's a hyperlink will show up in here, and you start to notice that some of these labels don't make a lot of sense. For example, Login is fine, that's good. Now Hide, this is strange. This link here says Hide, and on the very top right you can barely notice it.

 There's a black rectangle around this X. So this hide link corresponds to this X icon that supposedly hides this banner graphic. What it should say is hide banner graphic. Like it needs a more descriptive label. Because when I'm navigating using the links over menu, it's not quite clear to me what will be hidden. So when you make a label for your icon buttons, try to be more descriptive like hide banner or hide language selector. link link link and yes this is all generally good advice and there is a way to label your links to screen reader users without adding extraneous text to sighted users some way to do that is accessibility excessively hidden text and there's some css trickery you can do there so that it displays as the label syntax like this one here but the screen reader can get some bonus text there as well. Something like a span with a width and height of one pixel. That way you can include some bonus text for screen readers, but they're visually hidden for sighted users. Now let's take a look at landmarks. This is landmarks. Landmarks corresponds to elements such as section and footer and header. So this one is called contents navigation. You are currently on a navigation inside of voiceover off. So here's contents. And if I inspect it, we can see how it was developed. I hope it's a section, but it might be a nav. Yes. So this is the nav element. And they gave the nav element an ARIA label of contents. That is why the landmark says contents, because that's the ARIA label of this landmark. Another common landmark HTML element is section. So whenever you put a section on your page, always be sure to include an ARIA label because the landmark screen reader menu will read that out loud. So for example, if you have a section for Svelte history or a section for code snippets, the headings handles that generally. But if you were to put these into sections, it's very important to label your sections. A very easy way to label your sections is... Oh, it's time to code. It's coding time. Yes we coding now I show you an example So while my computer screams as I open VS Code here comes the example So you have a section, and then you close the section, and you tell VS Code it's HTML. Oh, it knows. Thank you. And you give it an H2. Maybe it'll autocomplete it. and you can say code snippets. You can have section ARIA labeled by, and you can say code heading. And then under H2, you specify ID equals code heading. So this is also really robust because not only do you have a heading for your section, you can label the landmark using that heading text. So because ARIA labeled by, because this corresponds to an ID in a heading, then the screen reader will say landmark code snippets. Pretty cool. So that relationship is symbiotic. And this is bonus points because you have sighted users have a very clear heading and screen reader users have a very clear heading. It's a win-win. And the last demo for VoiceOver is, let's see, we covered navigation landmarks, form elements, and alt text images. So let's see if the Svelte Wikipedia page has any graphics. It does here. So let's see what VoiceOver does with it. Rich. Selected. Link. Row 1 of 12. Original author. S. Spans two columns. Link. Image. Svelte. So it says link image, svelte logo.svg. Let's see if that was potentially programmed. Inspect element. Okay, so it's image, and it says alt svelte logo.svg. That kind of looks like it generated alt text by Wikipedia. Somebody uploaded the image, and the file name was called svelte logo. So that's what gets read out loud. It's super important to always, always give your images alt text and not just nothing. So if you give it nothing, it won't tell you what the image is. You're not just describing images and icons to blind users, you're also describing images to blurred vision users. Sometimes people can make out the silhouette of the Svelte logo but they not 100 sure what that is So users like that use voiceover to browse and try to interpret the images in front of them I sure AI will be very helpful in that regard once they can process what an image looks like. But as developers, we can give them all text. We can describe what the image is so that someone with blurry vision can say, okay, I see this image of two people. I don't know who the two people are, but at least the descriptive text tells me the person on the left is this person, the person on the right is this person, and now my silhouette is clearer. So that's why alt text is super important. And that's it, your very brief demonstration of voiceover on Safari. The reason why voiceover must be used on Safari is because it's designed for that browser. So macOS and Apple, they've developed voiceover for their products. So Safari and voiceover work together. If you use voiceover on Chrome, it'll work, but not for every regard. VoiceOver is not particularly designed for Chromium browsers. It's designed for WebKit browsers. So it won't work on Firefox as easily either. Other combinations include we've got Firefox plus NVDA. We have Edge plus Dictation. Well, that's Dictation. I think Windows 11, Windows 10 have a voice tool. I forgot the name, but screen reader, I'll just go with for now. And then you've got Safari plus voiceover. And then on Android, you have TalkBack. And I think on iOS, you also have voiceover, if I'm not mistaken, because Apple products, I'd like to think they're the same. But if not, let me know in the chat. Maybe one of you can look that up and confirm. Try these out. Try it on your phone. Try it on your desktop and see how the screen reader reads your application. And if it doesn't make it clear, then that's something you can work towards. And that's the end of the demo. Let's move on to quick facts over. Now, this is where we would do community showcase if I had one. I don't today. So if you want to showcase your product, let me know, and I'll include you next Friday. And that brings us to discussions. This Week in Discussions. What do we got? So AI has been talked about quite a bit Let bring it on screen Let make sure the chat is recorded Yes it is So AI is we talking chat GPT we talking about Copilot and all the image generation tools that came out. I can't list them all. At this point, there's like 100 or 200 products by now. It seems like every other week, something goes from beta to level four suddenly. It hasn't even been a year and these things are evolving before our eyes. The number one question we're asking as software developers is, how will this impact my workflow? How will this impact my career prospects? And what dangers yet foretold could there be related to AI? And there are so many people who shared parts of the conversation. As I go through my observations, I welcome all of you to let me know your thoughts in the chat or to raise your hand and join on the stage with me and comment or provide critique. anything is welcome. So here's what I've observed. There are some extreme opinions. And the problem with extreme opinions on both sides of the conversation is that tends to yield a lot of confusion and fear. However, maybe the truth lies somewhere in the middle of the spectrum. I'd like to think that it's either directly in the middle or more towards the positive scale, but I would be delusional to think that there is zero negative impact or a 0% chance of things turning for the worse. So there might be a bit of both happening. And historically, let's go back to 1950, 1940. If you think about back in the 50s, 60s, there used to be a human job called calculator, where a person would sit at a desk and do arithmetic functions for STEM services, government, or private sector. And then when the portable calculator came out between the 60s, 70s, and 80s, the calculator evolved. It became pocket-sized, battery-powered, solar-powered, more accurate than a human, faster than a human. So eventually, the calculator did take away the job of the human calculator. So that is a very slow, gradual example of technology evolving and eventually taking jobs over. Computer is similar. So there was a dedicated job for a calculator as well as a dedicated job for a computer. I don't remember the history of the computer, but it's a very similar process where computers,

 became gigantic. They filled an entire room, but eventually they became smaller, more compact, more affordable, and can process complex tasks as well. So things like spreadsheets come to mind. And spreadsheets actually used to be paper books, I think even 200 years ago. It would be a multi-page book with cells and you would do math within them. but I'm not a historian, so I don't want to go too far before I start spewing the wrong facts and historic facts. The point about this discussion is AI, so let me shift focus to that. So that's an old example, AI and related tools. One thing that's different from the calculator and the computer is the acceleration aspect. As I mentioned, GPT-3 came out, and then like less than a few months later, GPT-4 came out. So the acceleration or accelerationism is a really major aspect in this. Things are evolving and changing in less than one year. Whereas calculators took decades, AI is taking months. So this is what's causing panic. Because of accelerationism, things are evolving so quickly that it's like, what do I do? Do I pivot now? Do I learn this tool is my job at risk. And there's some yeses and some no's regarding that. So for example, yes, if you're doing something dedicated, much like the calculator job example, if you're doing one thing really, really well, maybe it's a good time to diversify your skills. And I'm not just talking about technical skills, but also problem solving valuable skills. and I think there's a couple of good quotes in my show notes. I will point towards them. So for example, if you go to your director and you say, hey, I want to look at the challenges you're facing and see if I can help solve them at an integration level. If you're able to glue together multiple human problems at your organization or in your project, then that becomes a skill that will stay with you forever. If all I did was CSS, then maybe that job will gradually and surely go away. I'm not saying there's no such thing as a CSS only job and maybe I being flippant but it possible that only doing one thing is becoming less and less in demand It not going to go away 100 and definitely not overnight but that's something that I would say is like a not safe bet. If all I knew was front-end JavaScript, maybe it's a good idea to learn a little bit of DevOps. Maybe it's good to learn optimization. Some things that the AI cannot do very well today is optimization. yeah. So Ixy in the chat says, I would argue that accelerationism is an illusion. The work on AI spanned half a century. It's just the recent leaps that are particularly impressive. Yep. I don't have all the answers, so I'll definitely, I think that's a very good comment on the matter. Who knows for sure? Only time will tell. I'm just sharing observations. And here's another one. So some common advice that I've noticed shared in the Discord chat was grow your breadth of knowledge. And I'll paste some of these here so it's easier to talk about. Wow, that's a lot of text. Maybe I'll paste one at a time. Grow your breadth of knowledge. Learn some uncomfortable skills such as infrastructure, DevOps, API development. If there's something that you are interested in but are not particularly comfortable in, it's always a good idea to take a little bit of time like once a week or if you can on the job, do like a 10 to 20% of your time thing learning or self-learning. It's good to learn these things. And I can say with experience that that helped me a lot because I used to be only comfortable with front end making components in React. But once I learned Docker, DevOps, infrastructure, I was able to take on more challenging roles. And that's very career enriching. Will this make you more immune to the powers of AI? Possibly, but I don't have the answers. Another idea is improve your code review skills. Improve your code review skills. So I have this example, which is a bit contrived. I'm not going to prescribe this, but there's this thing called conventional comments that I find to be very robotic. But I like to share this because conventional comments make you a bit more self-aware. It not a guideline I don see this as a guideline For example if this is your code review today you can improve it with a suggestion or a nitpick The point of conventional comments is to explicitly call out what a suggestion is explicitly call out what a nitpick is. I don't particularly like this. But what this does is it gives me a mental model of what kind of review I want to give to my coworkers so I can think about how to word this in a more human-friendly manner. Here's some other examples. a question that's non-blocking. So here you have this title here in the conventional comment. You're explicitly telling your coworker, hey, here's an optional thing that you don't have to stop in your tracks. I'm just letting you know, don't panic. I have a small question. I don't particularly label my comments this way, but I do think about like, how does my comment impact my coworker? And when it comes to ChatGPT and Copilot, sometimes Copilot will give you some code and it's up to you to review that code. You become the code reviewer for the robot. This website is more about being the code reviewer for another human and it's very important to be empathetic to the human. But for the AI, it's also important not to trust what the AI tells you because it might help you clean up and organize some boilerplate and that's very valuable, but it doesn't always give you performant code or accessible code or something that solves the the business need because it only answers what you prompted. It does not yet have all of the context. It doesn't yet have all of the sensory input. So as I continue laying down some ideas, feel free to raise your hand and chat with me. Otherwise, I'll read the Discord chat out loud. Oh yeah, Ixi, come on down. hello while you get your microphone up I'll try to get the next point Try saying something. Hello? Maybe your speakers are too loud If there an issue with my microphone let me know in the chat I go and mute while you say a few words if you were. Still no? No? Sorry, ICSI, I moved you down to the audience. Maybe double-check your mic settings, and I'll bring you back up here. So while ICSI resolves mic issues, let's take a look at this. So learn AI tools is another observation. Understand the shortcomings such as hallucinations. And I think Captain Codeman just brought that up as well. If you're just starting, let's say you're a junior entry-level developer, you should definitely not rely on its answers and constantly dig into the concepts it utilizes to understand why a good solution is considered good. If you're more of a senior, then you're pretty much code reviewing all the time. If you're on the low intermediate spectrum, then it's good to see what AI is giving to you, but it's more important to learn why it's giving you that. So don't just adopt the solutions wholesale. Learn about the concepts it's providing. Why does it work the way it works? So Godeman wrote, the current set of IDE and plugin tools that we have are scary clever compared to what we had 30 years ago. AI has just improved tooling. Exactly. When a carpenter builds a house with a hammer and nails, did the carpenter lose their job because power tools came out? Not really. the carpenter became more efficient at their job. So another observation or comment is maybe AI is just a tool that makes us a little more quickly and more efficient at our jobs. It doesn't really take over all of our jobs. That's not an umbrella statement. It can take over some jobs. I don't quite have a comment that's robust enough to dive deeper into that. But by and large, it does improve the way we work. For example, ChatGPT taught me how to make very constrained SQL queries. Like I'm using a MySQL clone called Dolt, and it doesn't have every MySQL feature. I was able to tell it, hey, how do I do this?

 MySQL, but I cannot use a certain function. And it told me how to work under those constraints. That saved me hours of documentation research and experimenting. Things like that I think are very powerful. And I think we're near the end of the discussion. So the answer to AI is somewhere in the middle. I think that rather than fear and panic about the spectrum of answers, try to think about something in the middle, try to broaden your skill set and see if you can take on challenges, especially integration challenges, because what are we doing? If you're making a crud, you're making information easy to manipulate. If you're making a website, you're trying to make information easily accessible. When we put things out on the internet, we're trying to make information easy to consume. And that's really what we're up to. Humans have to review the code. So Ixy wrote, yes, humans have to review the code. It would be possible for people to ship an app largely written by AI, but since the companies that make the AI will not want to be liable for it, it would be important for some human reviewer to take accountability for that app. Yes. And I think we all have a similar idea in our heads. I can easily imagine this year and next year, some company is going to ship some product and they're going to proudly blog about it saying, hey, I made this 100% in AI, no human oversight. And then months later, oops, we leaked all of our customer data because the AI didn't make it secure. So humans are slow and careful because we're liable for our solutions. And the AI, like every computer, is doing exactly what you tell it to do. And that isn't always going to be the comprehensive solution you're looking for. So even if it gets more, let's say it's four times more advanced than it is today. even then. It's not always going to give you exactly what you're looking for without the full maximum context. So I'm fairly confident that it's not going to rush away every single job. But yeah, do be cautious about being stagnant in a single specialized role. But since you're in this call with me, chances are you are passionate about learning, so you're safe. All good. and I not an AI expert so I won go deeper than I just did A couple cool quotes were shared on discord Here one by John Carmack famous from id software and meta Paste it in the chat And another one I found and picked up was an article by Josh Kumo So you can also read a couple of third-party opinions on this matter. I know the last article is called The End of Front-End Development. That's just a sort of clickbaity. What Josh really covers is that they're optimistic that everything's going to be okay with job security. because of human oversight being absolutely necessary. And comically, if some company proves them right, then oops, there's going to be some collateral, which is sad, but don't let it happen to you. Don't let an AI expose your personally identifiable information or user databases because no security audits were taken. And that is the end of this week in discussions. moving on to this week in Q&A. This week in Q&A, for the past two weeks, I've sort of saw this ambient need for testing. Some folks have brought up, like, how do I test? What do I test? Is testing necessary? If I'm using TypeScript, do I need to test my apps? All of these ambient questions around testing and I have some things I can share today. Let's talk about it. So in my editor, the things I'm going to cover is what is testing, why you should test, why you may not necessarily have to test everything, but most importantly, how do you test? So that's the most interesting part. Like how do I use vTest? How do I use Playwright and Svelkit? And I have a demo, very high level, very casual, just like how to use these tools and what their capabilities are. That way you don't have to sit and worry that you don't know what you don't know. I'm going to show you some of the things that it can do. So I'll start there. I'll start like what is Playwright? What is vTest? And then we'll dive into the conversation around what can I do with it and what should I do with it. First off, Playwright. So in this Felcut application, I have a folder called tests. and the name of your tests can be individual. It can be whatever you want There no strict convention But what I did here is I mapped my SvelteKit routes folder to a test folder So test routes links test This test file corresponds to source routes links page.svelte. So I sort of have this directory based route based test file structure. You don't have to do it this way. And this is not particularly my favorite way of doing it. But I just wanted to showcase you could do it this way. You can have your tests files mapped to routes in a separate folder. You can also collate your tests. Sorry, co-locate your tests. You can have your test files in the same paths as your routes. And I believe Vite will not include them in your production build because they're not being imported by the actual pages. And feel free to ask a question or raise your hand. So let's move on to what this is. So this test.js file is containing a single Playwright test. On lines one and two, I've imported the Playwright test utilities. And on line two, I've imported Axe Builder. So Axe Core is a company product by Deque. Deque is a company that built Axe. And Axe lets you programmatically test your pages for accessibility. So that's what I'm doing in this test. On line four, you start by writing test.describe. and this will tell your test runner what test is being run. And then on line six, I write the actual test case. Should not have any automatically detectable accessibility issues. So what I'm trying to achieve with this test is to run a browser, headless mode, and test to see if the page is violating any accessibility issues that a computer can tell. But I got to say, huge disclaimer, only a human can properly test the accessibility of a page. Do not rely on Lighthouse or this tool to give you a pass. If this gives me a pass or if Lighthouse says that my accessibility score is 100, that is not necessarily indicating that the page is accessible. So with that disclaimer to the side, let's test this. I am using an interesting tool called the Playwright VS Code extension, and that gives me this very handy sidebar. So here you can see my playwright tests, and they're all organized and conveniently accessible on my VS Code tool. And from here I can run them So I going to run test by clicking on play and it running I not using the command line I using the VS Code tool because it a little easier And what it going to do is start up Playwright It's going to start building this Felcut application in production mode. And then it's going to run Chromium WebKit. Oh, there it goes. It's running my program. Look at the browsers open. Wow. Playwright is like magic. And it's done. So that's what Playwright does. It runs browsers. I happen to have the show browser toggle over here. And that's why the browser popped up and displayed on my screen. So this is Chromium. This is Chromium from the node modules folder, not from my computer. So when you install Playwright and you install Firefox Chromium, it actually just runs these 70 megabyte packages directly. And that is configured down here in the root. So under playwrightconfig.js, I told it, hey, I want you to test Chromium. I want you to test Firefox. I want you to test WebKit, and as well as mobile Chrome, mobile Safari. This is really awesome because not every end-to-end testing tool has this plethora of browsers to select from. It's awesome that you can test Chrome, Firefox, and Safari in a single tool automatically. And you can also do this in continuous integration. So if you implement Playwright in your CI, you can test these things headlessly. I'll show you. So I'll close the browser, go back to my tester, disable show browser, and then run them again. So now it's running the tests headlessly. It's not going to actually open the browser and check the page. It's just going to run them in the command line headlessly. So headless refers to not shown in the GUI. At least that's my short description. And the tests are all passing. which is good. One of the developer's favorite things is watching the red text turn green, and this is making me quite happy. So down here, let's go back to the test. What did it just do? First, it goes to the slash links route. Then it runs Axe Builder to analyze the page. And then finally, it runs an assertion. So the bread and butter of Playwright and vTest and all of these libraries is assertions. You don't need vTest to run an assertion. Node.js has built it once. And personally, I've used NodeTap in the past, but this expect expression

 right here. This is the assertion. We're expecting that the violations equals an empty array. So when this assertion passes, the test passes. And in VS Code, I have this very convenient green checkmark. Very nice. It's working. You can do all sorts of things with Playwright. Because it's a headless browser, and if you want, it's a headed browser, you can also navigate a page, submit a form, and test that as well. Another cool thing, let me get my notes back, is you can walk it through. You can actually open the browser with, let's see, pnpm playwrite code gen. So pnpm is an npm alternative. And if you write it like this, this is like the NPM equivalent is npx playwrite. So this will run playwrite directly from node modules in case you don't already know. I'm going to run the code gen command. It's going to open Chromium, which is my default browser. So there you go. It's not going to work because I forgot to run my server. So in a separate terminal, I'll run pnpndev. And I'll go back to my Chromium browser. Here it is. Go to localhost 5173. Okay. So this is the Playwright inspector. You can do things like run a test, debug a test, step through a test, and it'll show you in real time on the browser what it's testing. But what I'm going to do is record a test. So if I click record, and then I go to my Chromium browser, I click on, let's say, progressively enhanced form. Oh, it didn't work. Hang on. Let's go back, click on record. There we go. So now it's highlighting in pink all the interactive elements. When I click on this one, we'll zoom in, it's recording the interaction. If I scroll down and click add pet name, it records that. So I'll stop the recording. and let's take a closer look at what just happened. So here in the inspector it says go to localhost click on the link The name of the link is progressively enhanced form and then dot click So here it just recorded the steps I took to interact with this page. And I can copy paste this into my VS code and I can save this as a repeatable test. Obviously, I need to add some assertions just to make it an actual test. But the cool thing is you can interact with your web page like a normal human. and Playwright will help you build your test for you. That way you don't have to programmatically write page.getByRole, page.getByText. You can even do more specific selectors like select button by ID, select button by attribute. That way it's a bit more or it's a bit less brittle than selecting it just by the label because sometimes you have multilingual, sometimes you change the labels. And if you do those things in the future, these tests will break. I just wanted to showcase the fact that Playwright gives you the tool to record your tests. And that's pretty nice. So the next feature, the next feature is component tests. Yeah, there's also a VS Code extension. There's also a Chrome extension to record your tests. I showcased accessible tests. XE asks, can you apply a test to a group of routes in the spirit of a layout? Kind of, I'm not 100% sure, but historically, when I write end-to-end tests for multiple pages, you almost necessarily have repeating code. I don't know if there's a dry way to do that with Playwright. You probably need a separate test with all of the interactions copy-pasted just to repeat them on a page-by-page basis. So that may translate to multiple test.js files per route or per journey. So you don't necessarily have to organize your test files this way. if you want to test entire journeys, such as go to page one, navigate to page two, click on button three, and then navigate to checkout. Let's say you're doing e-commerce tests and you want to capture that entire journey. You can do that in one test in Playwright. And sometimes you want to do that because it's a very good test to make sure that it's easy for your customers to give you their money, right? So testing entire journeys is a very good use case. Now let's move on to VTest. So that was Playwright. And Playwright cool because you can test in every browser or every evergreen browser and you can do things like take screenshots and take videos I not going to showcase that now but just for your awareness if you want to test like a component library, you can use Playwright to open them in their browser, take a JPEG screenshot, and let's say you change your component and that changes the way the component renders, you can do screenshot testing and you can test the before and after of a snapshot. You can record a screenshot yesterday, and then if you render the component today and it's different, PlayRate will yell at you. It'll say the assertion fails, these JPEGs do not match, and something's wrong with your component, which is awesome. You want it to tell you things are going wrong when you don't want them to go wrong. But that brings us to vTest. vTest is for unit testing, also for spies, mocks. I won't go over those features exhaustively, but I will show you a Svelte component test, which is something as Svelte developers you're probably interested in. I have this card here, and it has a prop called kind. And all it does is it changes the card to render as purple or render as green. I want to build a unit test to make sure that the rendered HTML has the class name I want. That's not a perfect test. It's not as good as the Playwright example, where you could take a screenshot of the rendered card and make sure that a purple card is purple and a green card is green. But just for illustrative purposes, I will show you a very basic test with Svelte. So here I'm using a few tools. On line one, I'm importing tools by vTest. On line two, I'm using Testing Library. You don't absolutely need Testing Library, but Testing Library is worth actually bringing on screen. Testing Library. This is a very useful and handy library for testing component libraries. So framework supported, we have Marco, Vue, Preact, etc. and Svelte. So what's cool about this is it saves you a bunch of boilerplate. Without testing library, you need to call the low-level Svelte API. You need to mount and server render your components. But with testing library, it's much easier. Take a look at this. So on line three, I import my card. The card is the thing I'm testing. And just like Playwright, I start by describing what I'm testing. And then I run a cleanup function which I think in future versions won be necessary But here after rendering the component after this test is finished after each is a lifecycle hook that gets called to make sure that the rendering is cleaned up. So line eight is my first test. I want to make sure it actually mounts. So I render the card using the testing library render method, which, as you can imagine, is a wrapper force felt SSR utility. So this is one line of code, one function call, saves you a lot of boilerplate. Line 10, I run my assertion. I make sure that the rendered container is in fact truthy, so probably an object and not undefined. Line 11 is we make sure the inner HTML matches a snapshot. Snapshot is a vTest feature. So up in here, we have a snapshot. It looks like this. ta-da so this is a vtest snapshot you do check this into git you do keep this in your code base and it's a string containing the rendered html so if i run this test again or if i change my card.svelte in some way that changes the rendered html then this snapshot will fail because the snapshot i previously saved has one snapshot of html but if i change that rendered html in any way then my test will fail, which is what I want. I want my test to fail when things are different, when things are changed. So back to the test, back to the snapshot. So all this does is make sure that the snapshot matches. So that's a single test in VTest. And just like with Playwright, I have this handy testing tool. I can press the play button. I can test if it mounts. And this runs JSDOM and VT directly. This does not render your SvelteKit application. It's much quicker than PlayRid because it doesn't need to build SvelteKit. It just takes JSDOM and it renders in VTest. What is JSDOM? Let me tell you. So JSDOM is a runtime environment for rendering HTML virtually. So it sort of mimics browser behavior so that you can test HTML being rendered without actually running a browser or without actually rendering a page. And that's what VTest does. it very efficiently gives you snapshot information and it renders felt components for you. And that's what this configuration represents. And also, feel free to interrupt me in case you want me to go over or clarify things. So back to the test to wrap it up.

 I need to live code. I need to render this as purple. Figure it out. Okay, past me. I'll do the challenge accepted. const container equals render card. And you can pass in a second parameter, I believe. Kind. I don't think TypeScript works, but I'll say purple. And then I'll say expect container dot inner HTML. to match snapshot. Let's try this. So I'll save my file, run vtest, and let's see what happens. Yes, Rob, this will be recorded. All right, now take a look at the snapshot file. Line 5 is new. You can tell by the green git reference here. Let's see if it worked. It says, oh, there it is. So card and then svelte, some hash, and then purple. So it works perfectly. Because I passed in the prop I wanted, I said card kind equals purple, which is the vtest equivalent of card kind equals purple, like that. It renders my HTML, and now I have an excellent snapshot of the card rendering as purple. So if for any reason I change my prop interface for the card, and if for any reason things fail, vtest will capture that because I have a test saved, checked into Git. I have a snapshot saved, checked into Git. Snapshots aren't the absolute best way to test components or functions. vtest is awesome for testing utility functions. So let's say you have a helpers Like I wrote this function called unique ID vtest is perfect for this because you can import unique ID you can run some inputs into it test it against expected outputs and assert that this unique ID function works the way you want it to work Even if you fully type this with TypeScript, sometimes you can refactor code and change the desired output. So having a unit test is very helpful to making sure that things don't change unexpectedly. When it comes to Svelte and any component library, snapshot testing, I think, is a cheap and easy way to test components, although it's not the absolute best way. For example, what if you want to test interactivity or accessibility? You can also use the axe tools in vTest to test for accessibility automatically. Obviously, you need manual testing as well. But unit testing is also great for making sure that passing in props that do things in the output is also being tested. And snapshots don't always cover that. However, if you're short on time and you just want to make sure your components are tested in some regard, then yes, a snapshot test is the cheapest thing you can do. You can throw a snapshot test like I just did in less than one minute. I wrote a unit test in less than a minute and it's just a snapshot. It's better than nothing. Another, I guess I alluded to this earlier. A big question people have is, should I test everything? Do I need 100% code coverage? And the answer is always, it depends. Here's my take. If you're making a component library or a utility library of some kind, then yeah, aspirationally, 100% code coverage or at least a very wide cast of unit tests is essential because when someone consumes your library, they need to trust it. They need to make sure that you're testing your library so that they don't have to. However, if you're building a full stack application and it's really comprehensive and you have a small team or a large team then the answer isn so straightforward If you go for 100 code coverage in a full stack application and you go for that day one you going to be slow You going to be spending more than half your time writing tests and not so much shipping features. So maybe you have to find that pivotal moment when you're developing a program and you decide what is stable and what deserves testing. For example, if you find that you and your team, but let's say you have a team of two or five developers and you're touching this file here. Let's go to links page.svelte. And you can tell with the Git history, if you go to GitHub or Git log, and you notice that, hey, this file has been touched 10 times in the past week, and they're all bug fixes. If you notice that a particular file is constantly being touched and constantly getting patched, that is a very good candidate for Playwright or VTest testing. Well, if it's a web page, Playwright is probably appropriate. Because you want to make sure that, hey, we're constantly patching this file. It's mission critical. we want it to be stable, then maybe throw in a test, spend a couple hours, write a good test. That way, when it changes in the future, you know you can rely on the test to yell at you and say, hey, this is not working. Don't merge that pull request. Things need attention. So that's one holistic or qualitative way to determine what needs testing first or what needs testing less. If you have any advice about testing, there's five minutes left, so feel free to raise your hand, have a nice informal chat, write something in the chat. What's your experience with testing? Do you find that one practice is better than another in your experience? And try to provide context, like what are you making and where did testing go wrong or where did testing go well for you. In the future I might have to cover this topic a bit more deeply But this is just scratching the surface So now you all aware of detest you all aware of Playwright and that's lovely. So back to my show notes. Yeah, maybe in a future episode we'll cover different kinds of debugging. All right. Captain writes, the level of testing is a business decision. Part of the requirements and depending on the risk or nature of the module is concerned. That's right. Like if you're building a banking application, then yeah, testing is almost pivotal because once something is stable and working, you want to test that 100%. A space shuttle launch system versus a cat meme sharing site. Yeah. sometimes when you build a blog for example a very good use case for playwright for something as small as a blog is writing a test to make sure your links work sometimes you write a blog and then a year later you have dead links maybe in your ci you can do a very simple test of making sure your links still work that's another interesting example of playwright testing but yeah it's very much business driven because tests can slow you down and you got to determine the the return on investment that tests give you. If you test absolutely everything, if you test a file that gets touched once a year and it's super stable, then spending a day or a week testing it may not be worth it. So these are the kinds of determinations you need to make when it comes to testing. And thank you very much for listening. Please leave feedback and submit topic ideas. So if you had fun, like this on YouTube and I'll see you next time. Bye-bye.