 Welcome everyone to This Week in Svelte. This is spooky season because it's Friday 13th October. So, ooh, spooky. Yeah, I didn't even notice that. I am Paolo. I will be your host for today. And joining me today, there's not Enrico, because Enrico will join us from next week. But we have a special guest and co-host, which is Thomas. Hello. And Thomas is a very proficient developer, very active in the Svelte community. And like he's the main maintainer of Melt UI, which you might have not have heard about, but you will for sure heard about it after today. So this is our usual agenda. We will have a changelog. So we actually have a small changelog. We will have some quick facts and announcements. We will have no community showcase today, but we will have a small discussion and a small Q&A. Actually, a big discussion, probably. But let's go ahead and start with the changelog. And I will actually check the changelog for SvelteKit. So we have a changelog just for SvelteKit. There are some fixes. Mainly, this is a patch change. So fix correctly update $page URL.hash when navigating history. So this is a bug fix about, like, if you know there's this page store that SvelteKit provides you. And before, like the hash part of that was not updating when navigating history. And now it's fixed. It's a fix to strip the virtual module prefix from error messages. So if you are not aware, basically the virtual module is a way that VIT plugins, which is what SvelteKit is, can pass information to the actual code. and Svelte is actually using some of them and basically it well like in the error messages there was this virtual module There is the convention of using virtual colon to get the prefix as a prefix for virtual modules And this was showing up in the error messages. And now it's not. There's also cancel ongoing navigation when the browser back button is hit to prevent an incorrect page from being rendered. This is another super weird edge case because basically if you are very fast in clicking back and forth between navigation, Svelte was basically lagging behind and so now it's not. Only remove VIT manifest when copying file. This is, I guess, it's a small fix about the VIT plugin. So this is the changelog. We don't have a changelog for Svelte because, again, not because the maintainers are not active, but because they are actively working on Svelte 5, which is very, very juicy. So let's move on to quick fact and announcement. And we have a single quick fact. That's also like it's also a quick fact from the old days. like from the last time, which is that like the call for proposals of Svelte Summit is closing in a couple of days. So please rush to propose your conferences, your talks, because we want to hear you talk. Let's go ahead. As I've said, we don't have a community showcase. But we kind of have, because we have this week in discussion, and we kind of have also a community showcase. Because as I've said, my co-host here, our proud Thomas, let's go back to here. It's the maintainer of a very popular library. It's actually the maintainer of a lot of library, probably. It's one of the maintainer of Radix's belt, but he also created this melt UI Oh I just noticed that this is a brand new change on the documentation website Yeah what happened there too Yours is dark The components are dark where normally they're white. I think you're using some extension that makes the page dark. It might be. It's actually like I'm using Arc browsers, so I don't know if maybe... Oh, you're using the team maybe. Yeah. Yeah, it's... What's it called? Arc browsers. Yeah, yeah, but I think you're using, like, what does Arc call it when you have custom themes? Arc brushes or something like that? Yeah, no, actually, I don't have one. So, I don't know. Maybe it's by default. By, like, Arc, it's using this by default. But, I mean, this is actually pretty nice. I actually like it. Yeah, I mean, and this shows one of the strengths of MultiUI, which is very, very composable, very, very adaptable, very easy about adaptable. Like you will get dark mode for free. That's true. It's also probably like, because I am actually like my system is in dark mode. So maybe that's something that like, this is actually something that like, it's controllable with CSS. So I don't know, maybe you did not do this and you're surprised. I have VARC too. I also have Dart mode. I'll have two. I'll need your notebook borrowed for a while so I can debug it, please. It's an order. Yeah, I mean, it's cool. It's still cool. So, I mean, what I was saying is that Thomas is one of the maintainers of Melt UI, which is a very popular component library for Svelte. And the very fun thing about this is that it's actually using a pattern, which is the builder pattern, which is a bit different from the builder pattern from TypeScript. But basically, you will write code like this. Maybe the easiest component is the toggle, I guess. So you will write code like this. you will create a toggle and basically they will provide you with all the state and behavior inside stores and actions so that you can basically bring your own styles So this is pretty cool because Svelte needed libraries with unstyled libraries and this is actually a solution for that. You can also use the preprocessor. They actually have a custom preprocessor that allows you to write slightly more, less verbose syntax. But I mean, this might seem confusing, but it's actually pretty straightforward. Like, these are all Tailwind classes. And if you remove these and just style your button, I guess you can actually... No, not for this one. I think Arcadium has an example of CSS that you can show. Yes. So, for example, if we go to the accordion and we view the code, we can actually see the CSS. Like this is actually like you can actually just use normal divs, H2, and then style everything inside your normal style. So this is a pretty cool library. But like one of the we are using this at work. And one of the pitfalls probably that we have is that obviously, like, you have to kind of understand how this library works under the hood to properly, like, to use it very, very effectively. Like, you can use it very easily by copying the code that they provide and just style it how you want. But it's very helpful to actually know the insides of MeltUI. So what I did is I prepared for all of you a mini Malt UI mini workshop. So I'm actually using your modified REPL, Thomas. So we will go through all the things that you need to know to understand how Malt UI works. So let's jump into this. Let's jump into this travel together. And if everyone wants to, like if everyone, I hope everyone, like I'm zooming in enough. If you can't see the code, feel free to tell me and I will zoom in. So this is basically all the steps that we are gonna travel through.

 So the first step is to understand how Melt UI works, is understand how action works in Svelte. We already talked about this the last episode, but it's a good refresh. Basically, an action in Svelte is just a function that takes in a node and eventually, like optionally, a props. In this case, we are just passing the text as a prop. and usually what you do inside actions is vanilla javascript so you can actually access the node and you can register listener on it and you can like remove listener from them you can dispatch custom event and you can do things basically so in this case this very function is abstracting away a very simple behavior, which is whenever you click on the node that you register this action to, you actually get, like, you log a value, which is the value that you are passing in to the action, and then you dispatch a new event. So very, very simple listener. From this action, from this function, you can also return an update function and a destroy function. The update function will be called by Svelte whenever the props changes. So with the new text in this case, and the destroy function will be called like it's a cleanup, basically. So how are we using this? Like very, very simple. We are using on this button and we are registering the event on my event to catch the detail, basically. And so what will happen is that when we click on the button, we get the value of log, which is an empty string, and the detail is this random number. And if we change something here and we click again, we get the value of log, which is the same gibberish that I've wrote here, and the new details. So this is the gist of how action works in Svelte. I don't know, Thomas, if you want to say something about it. I mean, this is a pretty basic thing. So yeah one thing I like to say about actions I feel like they pretty underrated One thing I love about them is that you could actually use it in vanilla JavaScript if you want As Paulo said it just a function We not calling we not importing anything from Svelte or anything like that The only thing Svelte-specific is the syntax, how we put it into an element with the use directive there. But in theory, you could use it with vanilla JavaScript. Let's say you had an HTML reference into a variable or something like that. you could call the action with the node. You would just have to deal with the update and destroy too, but it would 100% be possible to use it in vanilla JavaScript. I love how Svelte stays true to a lot of JavaScript fundamentals. It doesn't stray too far. Yeah, absolutely. Like we can literally import on mount, for example, and on inside on mount, just like call. we could literally do document.querySelector and select the button and, for example, pass these, like call these to myAction and pass in this thing. And this will absolutely work just, like after all, it's basically what Svelte is doing under the hood or something very, very similar to this. So, yeah, this is absolutely something very true about Svelte and very wonderful about Actions. And I agree that they are underrated because, like, I use them all the times. So, yeah. One thing I'd say that this is pretty unique in Svelte because normally to do this in Banner JavaScript or the frameworks, you would have to, let's say if you were using Vue or React, you would have to first create a reference, call it in the script tag, pass the reference down, and only then would it work. With Svelte, you just have the action, you just use it directly on the element. You don't need to do anything else for most action. Absolutely. And also, like, Taimur Shan is asking to speak. So, please. Yes. Thank you for giving me a chance to speak. I don't know if my question is relevant or not, But I'm having problem in managing server side state. You know, I have a plus page where I am using my login component and at the server side, I authenticating user and logging it in The problem is the duration while user clicks on the button it takes few moments to log him in I want to show some kind of state on the button navigation, and I want to catch that time period. Can I do it using actions or anything stores? Yeah, I mean, actually, like this is a bit more complex because actions can definitely help you with catching something like, again, you can define custom events, et cetera. They have in Next.js, they have what they call skeleton UI. They render it. We look at everywhere. There's something is loading on the page. They show the skeleton animation. Have you seen that? Yeah, I mean, you can actually... Loading UI, they call it. Yes. I mean, you have a way of knowing if you are navigating away from Svelte, and it's a custom store from SvelteKit, which is called Navigating, and you can get that from $up slash navigation. So you could... I think I need to use that within on mount because whenever I refresh the page, it just blinks, just shows and goes away whenever the page loads. I mean, I would love to help you, but obviously I cannot see your code. So, but feel free to like, either you can open a question. We have a lot of channels here in the Svelte Discord, so you can definitely post a question here. Both me or any other ambassador or even just some other user will try to read through your question and will definitely help you. Okay, thank you very much. I appreciate it. Yeah, thank you too. Okay, so back to what we were saying. So this is actions. Let's see now how a store works. A store in Svelte, it's something that it's used to... It actually like what allows Svelte to have reactivity reactivity outside of Svelte component And why is that Because the store, it's actually like a very simple implementation of the observable pattern. So Svelte provides you with this writable, which is a way to create a store and also provide you with a very nice syntax inside Svelte component. Because if you have a store and you prefix it with $, you can access the value of that store inside Svelte component. So as you can see, normally, like I will do a change to re-trigger this console log. Normally, like this SvelteStore is of type object, but the value of this SvelteStore is of type string. And the value at the actual value inside is SvelteStore. But you can also like create a custom store very, very easily. with initial, like you get a function that create the initial value, like you get the initial value. Then you basically have a set of all the runners. What are the runners? Because basically in Svelte, the Astor is just an object that contains a subscribe function that return an unsubscribe function. And optionally, it can take a set value and an update value. So this is basically a writable store in Svelte. If you remove the set and update, it will be a readable store. But like subscribe, a field with subscribe is literally the only thing that Svelte needs for treat these as a store. So with this function, create custom store, we are getting a value in and we are storing these inside this value. then we are creating a set. And what we will do is that we will store inside this set all the functions,

 passDin to the subscribe method. So basically, whenever you want to subscribe to a store, you will need to pass a function that will be called whenever the value of that store changes. And this is what basically Svelte is doing automatically when you do $SvelteStore. It's calling the subscribe function and storing the unsubscribe function to then call that function when the component is destroyed. And so, as we can see, when we are logging subscribing here, so here's the subscribing, and we are logging unsubscribing when we are unsubscribing from this store, we create this custom store with a value of 10. And despite this being an object with a custom function named subscribe, Svelte is able to actually handle this very easily. Now, how can we update this? With the set function. So the set function takes in the new value and then just basically call every subscriber, so every runner, with the new value. And so this very easily, we built the writable store from scratch very easily. And again, the things that I want to emphasize is the fact that Svelte is able to handle this syntax despite this being something that we actually made up. So this is very important. I also want to introduce you with the concept of derived store, which is a store from Svelte that allows you to pass a store and a function that will be called whenever this store is updated. And the value that you return from this function is actually the value of this store. So this uppercase is actually a store. So let's see how everything works. So this is the Svelte store and we are getting Svelte store. This is our custom store and we are getting our 10. And this is the uppercase. So as you can see, this is always in sync. Like this uppercase is always in sync with this belt store. And I can tap into this and getting the custom store that again we made updating the UI just by using So this is another really important part of MeltUI. Again, Thomas, I don't know if you have comments about this. Not too much here, I would say. I would say that one thing to notice also is the difference between using the $ and using something like get, SvelteStore does export a get function, which you can call, but it's not reactive. Get only does it one time. What the dollar sign is doing, as we're saying here, is it's automatically subscribing to the store. Whenever the component gets destroyed and stuff like that, it unsubscribes automatically. The get function, however, it immediately subscribes, gets the value from the subscription return and immediately unsubscribes. is a little bit not performance uh affected because of the subscription and subscription that's going on adding a new subscriber to the set and stuff like that uh but it works but it's not something you want to abuse and normally you wouldn't use it it's a very specific thing but it's something cool to know the difference about yeah absolutely so basically what uh svelte is doing undo is that I get a variable, for example, count, and I can say custom store dot subscribe. And what it's doing is that it's getting the value every time and assign it to count. So I can do count equal value. And basically this is what Svelte is desugaring your dollar sign store to. So this count will always be in sync with the store. And this function will be called every time the store changes, basically. So, for example, if we go on and actually print the count, we can see that, like, count is 10. Let me do a better job of showing you this. Okay. So, count is 10. and when I update count, like my store, it will also update count. Because again this function will run every time custom store update So this is another important thing to know about Svelte to understand Melt UI Let go on and see actions as store which is another very important part of Melt UI because they strive to make you write less code possible. And so instead of making you, extracting the action for the behavior and the store for the attributes and et cetera, they actually do something very clever. I'm going to write in the chat how it would look if we didn't do it while Paolo explains this. Yeah, exactly. So what we are doing here is abusing, kind of abusing the fact that in JavaScript, everything is an object, even functions. And given that in JavaScript, everything is an object, even functions, and that everything with a subscribe is actually a store for Svelte, what we can do is we can create an action, which, again, add a listener on the click, for example, but we can also assign, subscribe, and set to an action. So if we do this, basically this function will have subscribe and set as properties. And so this function can be treated as a store by Svelte. And so when we create action and store an action, this action can be a store. So we can see that this is a store and we can actually update this store very easily. and this reflects here, but we can also use it as an action on the button. So whenever I click on the action listener, it will log this was added via an action. And the very interesting thing is that once we have the set function, we can actually use the set function inside the action. So this action is registering a listener to set a value on the store, which is the action itself. So this is pretty complex, but it's a wonderful thing that Thomas has come up with to allow us to actually just write use an action and actually have some values associated with that function So this is very very cool And I just shared an example of what it would look like if we didn't do that. Of course, we could change the name a little bit so it wasn't that big, but still in the script, you would have to use two different variables. One thing that you could also do is have trigger via store, but also add a action key to it. So then it would look like use trigger.action, but still it's more verbals. Why not just do it like we're doing it here. So yeah. So this is how you could use, for example, the tab from Melt UI. So this is how you use them today. So you just retrieve the trigger, for example, from create tabs and then you can use this trigger as an action and also spread this trigger as a store. So it's much less verbose than these. And also like another interesting thing is that it's also like avoiding cluttering your component because then you have to remember trigger action, trigger attributes, then maybe you have another create tabs and you have to create another trigger two attributes, trigger two actions. So it's very, very interesting. And again, thanks, Thomas, to find this out because it's very cool. I cannot close this for the love of me. Let me see. OK, we will keep there. OK. Okay, so what we were saying, yeah, spread stores into element. So this is also something very important because we've seen that we have to spread this store into this element. So what does this does? So let's see how these work basically. So we have this writable, which is basically an object that has a style property and background color red. And we also have this other writable, which is actually a function that returns style with background color bg, which basically,

 It's one of the parameters that we are passing into the function. So how do we use it? We can just spread these into an element. And by spreading these, as you may be aware, basically what we are doing is that we are assigning this style attribute to this div. And when we are doing these, what we are saying is that we are accessing the function that is inside this store, getAttributes, passing the green color, and we are spreading these inside the div. So this is, again, very, very important. And the reason because it's very, very important is because now I can basically, like, MeltUI, which is our library, can pass back some attributes that we can use on our divs from their library. So this is very important also because another very big benefit of MeltUI is that it's fully accessible. So they want to have a way to control the accessibility of your components. And this is a pretty clever way to do it. Another thing that Thomas added to this demo is this derived, because obviously, like, you can also use this with derived store. So, for example, if you have this input value, which is writable with a string, you can have a derived based on this input value. And the derived actually just return an object with the input value. And what this allows you to do is that when you change something here, for example, green, the derivative will change accordingly. So if you spread these, exactly, like you are actually changing the background of this very input. So if I do tomato, if I can spell tomato, I will get tomato. If I do Rebecca purple, which is my favorite HTML name. You know your default colors. Sorry? You know your default HTML colors. Yes. Okay. And one thing that cool about this too is that this is basically how we do it now We going to show a more advanced example but this is kind of a builder if you think about it Yes, absolutely. And the reason because it's kind of a builder is because one thing that we are going to do now is actually build a builder. So to really understand how Melt UI works, the best way to do is actually creating a builder. So this is the end result. So we want to create this builder. I will open it in split view, which is the tabs. And basically, this is a basic tab. And obviously, we want something much, much simpler and much, much uglier, as you can see here. But the important fact is that you can tab, like you can have these different tabs and you can have the result showing here. And like when I click on tab one, it's just tab one is shown. When I click on tab two, just tab two is shown. So we want some code that kind of resembles this. And we have a list of trigger. And then, I mean, let's not look at the HTML because this is pretty. This is actually pretty. This is for this. And we want just ugly HTML. So let's go ahead and try to create a builder. So I just brought this just to make this work. So we are actually in this part of the document. And here, as you can see, it doesn't work. Like we don't have the tab here. We don't have the, like, all the three content are shown. So this is the basic HTML. And actually, a thing that I would like to do is remove this. I forgot to do this because what we want is instead of having a selected class, we want data selected here to make the background red. So what I want basically is that I have this list of buttons and I want the functionality that when I click on a button, I will actually get only these. Like for example this is the trigger for the tab one I want just this content to be shown This is the trigger for the tab two I want just this content to be shown So we have our list of triggers Actually, this is another typo that I always forget. So I've created these basic createTabs function and what we have is the exact same thing that the create tabs builder from L2I built. And it's an object with a state and a value. And this value, it's a writable store. And the elements, and this is like the trigger to spread and use inside the button and the content to spread and use inside the content. So let's make this work. I've created this function that basically just create the value. And we can actually, let's do this, we can actually take the first tab as default value. So default value. And so this can be, oh, this can be our first value. So the value starts with this default value. Then we have to create the trigger action. So the trigger action will take a node as input, and this node will actually be like one of those buttons. And so what you will do is we can create a listener. So function listener. And what do we want to do? Okay. This will be the click listener. So what we want to do is whenever I click here, I want to change this value. So let's say for a moment that I will just do this as a writable, so I can do value.set. Let's say that I will change this to a value of tab 2, always. I can register this node.addEventListener. listener, click, and I will register this listener. And obviously I want to clean up things. So return, destroy, and whenever these get destroyed, I want to node click for listener so now whenever I click here like if I try to show the value so I do dollar sign value I will get a value and the value that I get is tab one. Okay, perfect. Let's drop it into a div so that we can go on the next line. So the value is tab one. Now, since we are spreading, like we are using this trigger function on every button, we are actually registering this event. So whenever I click on tab two, I get the new updated value. Okay, this is fine. Now, how do we get to actually get the value, the correct value for like what I can change this to? I could do it in two ways. I could pass a parameter saying that I want this button to trigger tab one or tab two, but this is a bit more verbose and there is another way to do it. So this trigger store, as we can see, it's actually a function that takes the trigger item.id. So instead of having it to be a writable, I want it to be a derived. And the reason because I want it to be a derived is because I want this to be derived from the actual value. so then I get this function which is like we take the value of value and from here I can return a function and this is the function that will be called here when we trigger like when we spread this trigger so this will take the id as input and what we need to return is the list of attributes that we want to spread into this object, into this element. So what kind of values we want to spread into this button? One thing that we want for sure, because then we can use it, is the data.id. And the data.id,

 will be ID. Now, what this does is that basically, if we go and inspect the element here, this will actually add a data-id tab1, data-id tab2, and data-id tab3 to the buttons. So now we can use these to actually set the value here. Instead of defaulting to tab3, We can do node, which is the button, dataset, and inside this node.dataset will be every element. Like when you do data-something on an HTML element, that something is inside this node.dataset. So we can actually add .dataset.id. And so just by doing this, we can see that when we click on a tab, we actually get the correct value inside the store. And so this is something, but we also want this. We want to see the tab being highlighted. And we said that to have this, we want data selected to be present on this button. And how can we do it? Well, with our derived store. So instead of just returning the data ID, we can return data selected. And we need to return this only when the value, so the current value, is equal to the ID. And we can't just do this because if you say true or false, data selected is still there. So we need to check if value is equal to ID. And if it is, we can even just use an empty string. Otherwise, we need to return explicitly undefined. So by doing this, what is happening is that whenever we change value, this derived function will rerun. So this will be a new function. And this new function will be called again by Svelte. And this new set of property will be updated on this button. So if we go there, we can see that tab one is already selected. And if we move to tab two, it's selected and to tab three is selected. So now this is working Now let make this part work too So we get this function content which is the action that we are calling to on this div, but spoiler alert, this actually does nothing because this div does not want a behavior. Like it does not need a behavior. So this is just here. like they added these to make the preprocessor work better, but also for consistency. And likely Thomas will enlighten us after. But the important part here is this one. So we want a function that takes the tab, which is currently, like it's currently, like this is the content for the tab one. And so we want another derivate here. So we want the derivate. We want the derivate to be dependent on value. So we can get the value value. And then we can return, again, a function to be called that will take the ID as input and will return an object to spread into these. and what can we do to actually hide the parts that are not visible? Well, there is actually a super useful HTML attribute, which is hidden, and we want these to be present when value is equal. I mean, it's different from ID. And in this case, it's still the same thing. like we want these present only if it's different from id, otherwise we need to specify undefined, otherwise HTML will still see the hidden value and will hide everything basically. So now we should have everything and if we go here we can see that we don't see the other tabs, So it's probably working and we have everything. And the very nice part is that given that those are derived from value, I can also, and this is also a behavior that MultiWide provides you, we can also do this. Like if we create a button and we say change your value to tab two we can literally do onclick and we can just update the store So I can do dollar sign value equal to tab 2. And now if I go here, change the value to tab 2 and it actually works. And everything works because like these properties are derived from the value. so this is how you can build a builder and i mean there is thomas which actually has built a lot of builders so i i want to hear your opinion on this uh not specifically in general like do you think i i did a good job Yeah, of course. It did explain it pretty well. One thing I'd say that's cool too, not only as you said that you can do like override the state directly in value there, in Melt, do you have some more advanced stuff like you can bring in your own store, for example, meaning that let's say you define your store elsewhere and you want it to pass in that to the builder, you can, meaning that the builder, whenever you, let's say you have a value store in a JavaScript file or something like that. You can import it, you pass it down to the builder and it will be modified whenever you click in the tab triggers, that's cool. The reason why we have that, now just changing subjects a little bit. The reason why we have that content thing over there that use content, even though content doesn't have any behavior at all, is actually just because of Melt's preprocessor. We can talk briefly about it later on, But basically the preprocessor is just something that transforms syntax into another syntax. So yeah, if you look at the screen and turn on the preprocessor, we can see that work. Yeah, use melt equals root. Use melt equals item, use melt equals trigger, all that thing. That gets converted to, can you show how it looks without the preprocessor? I mean, I think like we can use the toggle as an example so that all the code is inside the page. So this is without the preprocessor. So you have to spread root and use root or with the preprocessor on you can use melt and just pass dollar sign root And this will be the sugar to this Exactly But since we don want the preprocessor to have to actually delve inside the code and check if something has an action or not. So we kind of have a builder method inside melt, which is an easy way to create these actions at stores and builders and stuff like that. And even if you don't pass in an action, it creates an empty action, just so it's easier for the preprocessor to destructure. But you wouldn't require to pass in used contents. But at the same time, it's valid. What if we want to, what if not later on an action had some functionality? Yeah, exactly. This is also something that I was thinking of. like it's always better to instruct your users to still use an action because if in the future you want to add behavior, you realize that you need to add behavior of something, you don't need to then instruct them or go and change your component. You can just say, okay, update, melt. Exactly, exactly. So that's pretty cool. This is pretty cool. Also like... And one... Oh, sorry. Just one thing I wanted to say. is that one, a lot of people I think at the beginning questioned like, why would I use builders instead of a library that just ships components for me? And initially before Ml2i there was Redix felt, some of you may have heard about it and it was using components, but there are some benefits. For example, you can see in the REPL over there that you're using scoped styles with our elements. if we were using Redix felt, since it's actually a Svelte component, like if we would go to tabs in Redix felt. Here we go. Yep, exactly. And go to the code, if that's visible, that doesn't seem visible. Oh, okay. I got scared. You can see that I do have a class that's being passed, but I think I use global on this code styles below. Yeah, I use global. I wouldn't require it to just, that's just how Svelte works. Meaning it's a bit harder to style, right? Yes. Meaning it would be easy if I just use Tailwind, but some people don't use Tailwind, some people don't like it, or sometimes

 Even when I use Tailwind, I do like using classes here. So this is a benefit of Melt. It's easier to just do whatever you want with it, to add also transition directives, animation directives, other actions, event listeners, lifestyle, anything like that. Like you said it sometimes, but I think it's completely true. Like Melt UI is more to build component libraries than to build components. Like you can build components, but you can actually like, it's mostly useful if you want to build your own component library, even just internal component library. So if you want to have the flexibility of building your component and style your component however you like it. Because after all, for most jobs, you will probably need to build your component library. Yeah. And one thing about Melt, if anyone starts using Melt or is already into it but doesn't know about it, you can also completely override any behavior in Mouth, like any behavior, really. All events are cancelable and stuff like that, meaning that, yeah, it's really, really flexible in that sense. You can just disable things you don't like and make things work more akin to what you think should be. Of course, it's going to be more verbose if you do that, but still, it's a possibility. And also worth saying that, like, this is Melt UI and you are working very close with Hantabyte, which is another Velt ambassador, and it's another content creator. And he is also working on Bits, right? Bits UI which is a set of component that uses Melt UI and it a bit more like a component library per se which is also under construction. And the reason because it's working on Bits UI is because Bits UI is what is used in Svelte. I can never remember the name. ShadCN. ShadCN. Yeah. CDN. And this is a part of the popular ShadCN library. So if you didn't know about this, now you know it. One fact, the original ShadCN UI is used over at the OpenAI dashboard, if I'm not mistaken. Yeah, yes, yes, absolutely. Yeah, I mean, it's literally exploding in popularity. I mean, I think it's a good idea because after all, basically what you're doing is that you're copying code over. It also has a lot of like, it has a CLI. Also, like, I have some slight opinion on this. I feel like sooner or later, someone is going to come up and say, okay, now you can build your ShadCN component and install it with a CLI. And actually, ShadCN... You can install it with a CLI. Yes, yeah. But we will define a folder where your component will leave so that your CI can automatically install it and we will probably rebuild NPM just by doing so. Yeah, it kind of works like that. Yeah, I mean, the only real difference is that you are committing your node models basically with ShadCM. So you are building like you are downloading the component with a CLI and the component actually are committed into your code instead of living in your node folders So that's just this slight difference. But it's really subtle. So I feel like someday someone might come up with something like, oh, I just had an idea. What if we install every component in a folder called shadcnmodules and so you don't have to commit it. That's hilarious. One thing I'd say too is currently in Melt, we don't have too much documentation on how to componentize builders, even though they are component builders. Yes. That's why they are called builders. But if anyone has any doubts, a lot of times they do refer people to Bits UI source code because they use Melt UI builders to create a component and pretty generic components. What I mean by generic is not as an insult. No, I mean generic is in that they can be used for a variety of use cases, which is, yeah, they're a bit more complex in that sense. Your components probably, like if you're working on a website, they don't need to be as generic. They can probably already pre-styled and stuff like that. Yeah, also, we already talked about this, like me and you, and I think you are right because obviously, like from the code that you get here, this is also is always a component that is scoped in itself like all the stake it's inside this component so if you really want to build an accordion that it's usable and reusable through your code base obviously you will need props and you will need a way to connect these props to the actual component created by the builder exactly one thing i want to do is recently in vitconv Storybook shared some updates, especially some official Svelte related updates that I want to try out so that we can have Storybook docs as well which will serve both as a testing playground but also as a way to show how componentization works, like with props and stuff like that, and updating mouse options when props update, stuff like that. I think it'll be pretty cool. Yeah, absolutely. Yes. Okay. So this was pretty long. Sorry, guys. Yeah. but we got to the end and so now we just need this week in Q&A that we don't have because we already are at, we are running pretty late. So, and also like I had a small Q&A thing that I wanted to show, but it's not ready yet. So I will store this for the next week. So feel free to join. And also, I see someone that is asking to speak, but then it kind of retracts itself. So if someone wants to say something, the show is open to everyone. So if you want to talk, feel free to raise your hand and we will invite you on stage. So in the meantime, thank you for watching. please I will show you so that please leave feedback submit topic ideas if you have some library some project that you have worked on and you want to showcase it please feel free to reach out both to me, Enrico, Thomas everyone like write us in the discord we will find you and we will kill you and we will invite you to speak here so thank you everyone and we will see you next week. Yeah, thank you, everyone. It was great. Thank you for having me too, Paul. Also, people are seeing the comments about fees.