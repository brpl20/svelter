 Hey everybody, welcome to This Week in Svelte. I am your host today, Enrico, and let's go! This looks different than usual. The agenda today is the changelog, some quick facts, and what's this? Community showcase and microtalks? Wow! If you have a microtalk or community showcase, reach out to me and I'll include you. And today our special guest is me! so we'll get to that soon followed by this week in discussions and this week in Q&A. A micro talk is just a really really short less than 10 minutes sometimes less than three minutes talk because the quick facts were not getting quick enough so now we've moved quicker facts to quick facts and longer facts to micro talks. Isn't that great? Let's start with the change log. so the change log caught at the last moment 12 hours ago i noticed svelte kit version 1.19.0 and it's got some goodies let's zoom in i could never zoom in enough some minor features allow link options to be set to true and false link options as you may know are these data attributes provided by svelte kit so you can set the behavior of certain links whether to preload or explicitly not preload things. For example, data SvelteKit preload data. The word data is used twice. That's because to be a standard HTML attribute, we should make use of data because it's an extensible attribute, data hyphen whatever you want. That's why it's prepended with data. And preload data just sets the behavior that you want this link to preload. What's new at the very bottom of this page is disabling options. So now you can set these attributes to false or true programmatically. You can unset or set using Svelte variables, and that's nice and great. The second feature is a new module called Resolve Path. This is exported by the Svelte Kit module, let's get a demonstration. It allows you to build relative paths, but show me, don't tell me, right? Let me show you. You guessed it, Svelte Lab. So in my Svelte Lab example here, I have on line four the new resolve path module It a named export from atsvelte kit And on line 6 and on line 12 I have two kinds of path I want to build The first one is just a regular path. What you do is you enter a string, and you do this in the SvelteKit style, so the brackets indicate a dynamic path. You can also do rest paths with the three dots. But what you do is you pass in the string template as the first parameter, and the second parameter is a key matcher for those params. So here in brackets, I have branch. I want this to insert the string main, and in ID, I want to insert the string abc123. And on the rendered example to the right, you can see that resolves as slash main slash product slash abc123. So if you need a convenient way to programmatically create links, such as for anchor links or go-to links, resolve path could help you get there. I actually rolled my own version of this a month ago for my personal project because I needed to encode URI components. So hence the second example, other path. On line 14, I'm passing an encode URI component to a branch name that has a forward slash. I wanted to do this because, see, the rendered path is feature percent 2f, which is a URL encoded forward slash. This way, users can navigate to this path without erroneously entering a forward slash and going to a non-existing path. So this is helpful for me and my needs. And Cirilla writes, probably more useful combined with the page store route.id. And I think that was its originally intended purpose. So if you use the page store route.id, you can also use the route.id for the path. And that's just a quick example from the changelog. Back to the changelog. We have some self-explanatory patches. Let me just get my show notes because sometimes there's more to it. All right. So the first fix is prevent history change when clicking on the same hash link. So a hash link is an anchor link with the number sign pending a part of the document, linking to a heading or a part of the page. For some reason, history changes were occurring when they shouldn't be, and now they do not. Next is gracefully handle server endpoints that return responses with immutable headers when pre-rendering. That's good to see. Fixes are good. Immutable headers when pre Yeah I think there was an issue with this changing what it shouldn have but now the headers do not Do not add content security policy meta element if content is empty. Yeah, that makes sense. If something isn't filled, you probably don't want the HTML element rendered. But content security policy, yeah, it's a meta element. There was a documentation fix. Good to see. and then avoid creating update check timer on the server. This relates to the pull interval. So let's go back to the kit docs, go to version under, I guess here, we'll start here. So here under modules, we have version. SvelteKit provides a versioning system with a version string. This allows you to have a version of your entire application shipped to the client so that if you deploy to production a new version of your SvelteKit app, then SvelteKit will know to download a brand new set of chunks. So the JavaScript chunks may have changed. Some assets may have changed. And what you want to avoid is client-side routing that lead to an old cached version of the website. So version helps mitigate that issue. And if you go to the config, there is a snippet here about version and pull interval. Pull interval means when the client has hydrated and the Svelkin app is running on production, your users can have a pull interval check in the background with JavaScript to see if the version is updated. And if the version has updated, you can do a hard refresh, such as this one using a before navigate hook. and the error that has been fixed is avoid creating an update check timer on the server since this is entirely handled in the client meaning instead of like using javascript navigation like the progressively enhanced version you want to do a full page refresh or pull a full page navigation only on the client so setting a set interval timer on the server is kind of redundant and i think that was taken away and that is why it's a fix so if you ever run into issues where where your users are not getting the latest version of your SvelteKit app, do look into this version config and do set up a poll interval, and that should help you out. And that's it for the change log. OK the chat was not open That OK We have quick facts I promised they would be quick The first quick fact is here on Discord There are some new announcement roles So if you're on Discord at the very top of the channel list, take a look at channels and roles, and you can assign yourself to the new pingable roles, such as being pinged for events like this one. The second quick fact is here on Discord. Yes, hello, welcome. Here on Discord, we have two support forums. We have Svelte and Kit and Ecosystem. In the Ecosystem forum, you're able to create new posts with a tag called Recommendations. So if you're ever asking questions like, hey, what do you recommend for databases? What do you recommend for hosting? There's a new tag for questions like that. So do try out Recommendations in the Ecosystems channel. We did it. Quick facts. Moving on to Community Showcase and Microtalks. So I have a microtalk for you today, and I think some of you know what it's going to be about. Yeah, how quick were those facts, right? Now it's time for slow facts, aka microtalks. Quick bits, sure. Microtalks for today is about how to choose a UI library. Hello again. My name is Enrico, and I'm here to present a microtalk on how to choose a UI library, Svelte edition. So let's get into it. There's only so much I can say in a short microtalk. Thank you, chat. But I'll try my best. So the disclaimers here is because I'm trying to keep this under five or 10 minutes. No matter what I say, no matter what you learn, it always depends. There is not a perfect recommendation for everyone. There is not. It's almost impossible to recommend one thing that's universally applicable. because so many of you have different constraints, whether it's your team, whether it's your time, whether it's your stack. There are some constraints you may have that make some things a non-starter. But hopefully I can introduce some things to you so that you can make good decisions, especially if you're a beginner. Point number two is beware of solutions that do not scale with you. So that's often an enterprise concern, but it's usually an everyone concern. That means when you see a solution and you adopt it day one, maybe a year later, that may not have the needs you have. So if your project scales up or has more needs or more views or more products, you may soon find that it doesn't suit everything you need.

 And you either need to enhance it greatly or you have to change it completely. Number three, some terms used here are oversimplifications and evolve in meaning semi-regularly. So the definitions and terms I introduced to you today may have a completely different meaning three months from now. So with that out of the way, today is May 26, 2023. Let's see how these terms pass on three months from now. What are some of the kinds of UI libraries? First off, we have CSS utility frameworks. we have component libraries, and then we have headless UI libraries. I did mention a disclaimer that these are oversimplifications, but I'll do my best to introduce these to you all. So the utility framework, it's helpful for organizing your themes and design tokens. Design tokens are CSS variables for us, the developers, but it's actually just a, it's also a nomenclature for making sure your design team and their primitives and their atoms align well with the development and what's actually presented to your end users. Two, it provides utility CSS classes. Some of you like that. It's very handy and reusable. And three, it's not technically a UI library, but it can be composed into one. There are exceptions. There are some versatile options, and I'll get into those examples too. Two, a component library. So a component library is a set of JS framework components. In our case, Svelte. Svelte components, and they account for markup, style, and interactivity. The somewhat complement to that is the headless UI library. And the headless UI library is a set of JS primitives to set up logic state and interactivity. They're not components. They're often especially not Svelte components. They do not provide styles. They do not provide HTML markup. A headless UI library are usually hooks or actions in Svelte to help you set up complex interactions like modals, like accordions, and multi-step forms. Let's talk more about these. So how do I choose a UI library? Number one, you have to ask yourself what sort of branding needs to be applied. Because if you take something like Material, that's fully branded by Google. Or you take something else like Shopify Polaris, and that's fully designed for Shopify and their clients. And if you need something much more flexible than that, then that's when utility frameworks come in handy. The second question to ask yourself is, how many interactive patterns do you require Is it a document Is it a blog Are the interactions really minimal Then you find yourself on the opposite end of the spectrum and I show you that spectrum So down here I attempted to make a two-dimensional grid. Honestly, there should be four dimensions, but let's start with two, okay? Two dimensions. So on the y-axis, top to bottom, we have more brand control, and on the bottom, less brand control. On the left and right, we have fewer interactive components and on the right, more interactive components. So the left and right side is more about quantity. How many interactive components can a UI library give you? And then brand control is how headless or how unstyled is it? How much customization does it provide for you? On the top left, I've decided to put utility CSS frameworks there. It's got a lot of brand control. It's mostly utilities, but there's fewer interactive components. You will often not see utility framework give you Svelte components or any components. You got to build them all yourself, but at least they give you a framework for building things in a manner that's sensible or opinionated. Somewhere around the middle, we have headless UIs. Headless UIs do come often with hooks such as Svelte hooks or the use action. Some of them also come with Svelte components too, and they're highly customizable. So you have a lot of brand control. You have a bunch more interactive components, but they do not primarily help you with tokens or things like scaling up or organizing your assets and primitives across a large team, like with designers and developers. So you need to fill in those gaps, usually, not always. And then finally, component libraries, which I have sort of put alongside to the right. Component libraries often have a lot of interactive components. An example of that is Carbon Components Felt. They have more than 30 or 20 components, many, many, but you have a lot less brand control. They come with their own styles. Sometimes they have class selectors. Sometimes those class selectors aren't so selectable, so you have much less brand control in exchange for more components. Let's go into a flowchart. Wow, I wonder how legible this flowchart is. Apologies in advance, I tried to render these rectangles correctly. Some of them are truncated, but don't worry. Let's just go over this in broad strokes. This is probably what most of you are looking for, and I will share these in the chat later. How do you decide which URL library is right for you? And this flowchart is mostly to educate you on what questions to ask yourself The endpoints that I highlighted in orange are not necessarily the right choices for you but they do get you thinking about what kind of choices may be appropriate for you So for example, the first question is, do you need to apply your own brand or your own branding? On the far left, you say yes, extensively. Do you require multi-brand? Do you require theming? If yes, maybe you need a utility CSS framework, such as Tachyon's Uno CSS Tailwind. If your needs are more complex than that and the utility framework is not enough or you have scaling issues, maybe you need to integrate with your teams more. If they're so complicated that these tools cannot handle it, then usually you start with the utility library or roll your own. So the far left of the spectrum is like the very high scale, high enterprise stuff. And sometimes you may need that. Now let's go all the way to the far right. Do you need to apply your own brand? No, or not really. Are your needs simple? Do you just need buttons, links, some form elements, practically no interactivity? If the answer is yes, you may consider a classless CSS library, such as mvp.css or pico.css. So a classless CSS library lets you write HTML elements, apply no classes to them, and the library picks up the tags for you. If you do require additional interactivity, you may consider using Svelte features, such as scope styles or use action. So in some cases, if your needs are very tiny, such as an MVP or light-light blog, then Svelte has a lot of features out of the box for you, which are the scope styles and the action hooks, so you can write your own. I won't exhaustively go over this flowchart, but let's do a couple more examples, just to hit the point home. If your needs are simple, not really, then you have to ask yourself this. How many interaction patterns do you require? Short answer, you may not find something that covers everything, but there are a few options. For example, if you have few interaction requirements like informative websites or marketing websites, then you can consider themable component libraries such as Skeleton or Daisy. And if you do not require SSR or pre-rendering, you could also try web component libraries like Shoelace. If you need some interactivity like e-commerce or documentation, then you can use a component library such as Flowbyte. And on the far right if you have many interactivity like CRUDs or applications and you doing a lot of data manipulation then you can use an interactive component library such as Carbon or Flowbyte So you notice that some of these options show up multiple times. And there's also the headless endpoint way up here. So if you don't need a lot of branding, you can try a headless UI library like Grail or Radix. And if your needs are more complex, then also consider contributing back. So for example, if you adopt Grail, you can add some extra primitives that are special to you, but you can make a pull request to the repository and contribute back to the community so everybody can benefit from your additions. Do not start from scratch if you don't really have to, especially in the headless path. If you feel like, oh, this library is missing one component, I need to write everything from scratch, I need everything to be bespoke, I would strongly recommend not doing that and instead adopt something, but also contribute back. Because if the delta between contributing back is much smaller than rolling your own everything, then you got to make that trade-off decision. Alrighty. So that's the flowchart. I will share this in the chat so you can all give me some feedback. But I want to ask you all, how do you decide what to choose? What are your interesting contexts? I wouldn't mind a little discussion here, so feel free to raise your hand and join voice chat, or you can save your questions for the very end. Maybe we'll have a water cooler. And that's the final slide. Let's read some chat messages. So CEC TV Deppucan wrote, is Skeleton there? Yeah, I mentioned Skeleton here. Skeleton and Flowbite are very versatile, so I should give them more credit. In fact, a lot of these endpoints on this flowchart can qualify Skeleton. It can also qualify Flowbite in multiple places. And I did have a disclaimer that this is an oversimplification, so different solutions may call for different outcomes. Let's look at the chat some more. Let's see, what did folks write? Let me just open the chat up, and then we'll cover some chat questions. Okay, someone mentioned material. Yeah, material is interesting in the state of Svelte. There are lots of material libraries, but the maintenance is a bit questionable. So hopefully someone will step up to the plate and ship us a material 3 library. Pablo would like to speak.

 you're more than welcome to come on down okay you hear me i hear you okay sorry i'm in the car so i i hope you can uh all hear me good uh my question is uh what what do you think about the fact that um i i often resort to using tailwind and that's just because i think it solves a problem that uh spells have in my opinion which is the the ability to to really have a headless a headless uh because very often when you are using a component library you need to style your children and that's not very very easy to do in my opinion in belt and so do you have any solution for the for those kind of things when you are building a a headless component library without tailwind when building a headless component library I mean, if you are building a headless component more than a headless component library Yeah So I guess when it comes to headless stuff we can look at Radix as an example Usually they're 100% composable meaning you don't have to worry about styling children because the children are provided by you as CaptainCodeman wrote in the chat So I'll show you an example here. So this accordion, Radix, great work, Radix. And you'll see in the example, the developer, that's us, we have to provide all of the components. In this example, accordion app is to be a Svelte component. Maybe I can do a better example. So tabs, actually, it looks like this is a component library. So I'll try Captain. I think you got a website. Yes, you do. So here, spelled headless UI. You notice that everything or mostly everything here is HTML and the classes doesn have to be Tailwind It could be your own provided classes So the answer to your question Pablo is how do you style children In the case of a headless UI library, you should rely more on hooks. You should rely more on JavaScript primitives. And if you provide your own HTML markup, like in this example, you can style it however you like because it's 100% composable. So another example is this modal or this dialog. The dialog is instantiated here, and then you pass on the dialog functionality to this button, which calls dialog open, and then the state is also passed over here. So there's a div way down here, and it's calling useDialog.Modal. So as mentioned in my slides, A headless UI library is a provider of logic, state, and interactivity. It does not provide styles or markup. So a true headless library would be more like the example I shared. It can be other things too, though. It's a spectrum. Does that answer your question? it was a bit too i mean to start the conversation about this fact so yeah for sure this answered my question yeah i i apologize i'm not super equipped to talk too deeply about the state of Svelte and styling children. I understand that the official solution today is style props. So on Svelte.dev, go to documentation. If you provide a component library, let's say, this is more appropriate for component libraries than headless ones. You can document yourself CSS variables. So these have to be documented. These have to be user-facing. That way the user can use your components like this slider and then pass in CSS variable overrides like dash dash real color black. This is the current way to do things, but I think there are lively conversations on GitHub to evolve this and push the envelope more, maybe some compiler controls, other things like that. I'm not saying this is the end, but this is the current state. All right let read the chat a bit With the current state of Svelte ecosystem I not looking for something finished or polished I like the code to be readable and approachable and easy to contribute. Yes. Making repositories, especially component libraries, open to contributions is something that takes a lot of work, takes a lot of synergy, so to speak. And this is something I'm also interested in pursuing as a maintainer myself. It's good to train contributors, especially your regular contributors. It's good to train them, teach them the ways, show them what considerations to make when approving pull requests. It's also good to write tests for your components and welcome more maintainers as well. So that way, with more people steering the ship, you can have a higher velocity and move things along quicker and accept even more contributions. CC writes, TZUI needs a lot to implement. I believe UI needs JS, otherwise incomplete. Tyler wrote, I'm a big fan of combination of the two, utility framework and headless UI. Yep. So Tyler, that's a good example of a highly flexible solution. And if you have the bandwidth to implement your own branding that is close to ideal. So it makes a lot of sense, and I'm sure it's a very agreeable take. If you're like me and you don't have a designer, so I guess I'll apply myself to this chart, shall I? And then we'll end the micro talk. So let me just minimize the chat. So personally, I don't really have to apply a brand. I'm building a CRUD. My needs are not simple. I have a lot of interactivity requirements. and so that led me down here in the right side of the flowchart. I'm building a CRUD. I need a lot of interactive components and I'm okay to adopt some styling and branding wholesale. So I went for Carbon in my case because I'm building a CRUD that's internal facing, not external nor public facing. It's just internal to the company and that works appropriately for me but that doesn't mean it's the only solution for me. And that's the end of MicroTalks. Thank you, Pablo, for joining the stage. Feel free to jump up again if you like. All right, moving on. Hang on we have some more questions in the chat so let me bring up the chat Habite asks do you have experience building libraries perhaps in larger companies the more complex scenario in the chart Yeah, I was actually a technical lead on a design system team at a telecom company in Canada. So I do have three years of experience building UI libraries. And it gets really complicated in a large company context because you're not just building for developers. You're also building for designers and end users. So at the very beginning of all of your takes and all of your planning and all of your tickets, you start with design and accessibility. Then you collaborate with designers and build the UI libraries. And we also faced several impasses, such as how much of the styles can be overridden. And that's an interesting story that I can save for another day. So enter, throw in some chat messages if you'd like to hear that in a future event. Moving on to this week in discussions. So in discussions, we have a few topics. We got, oh yeah, let's bring up the chat again. Prettier single quotes, double quotes, and international keyboard layouts. So this one was fun and interesting to me. As a bilingual person, sort of, it's actually a bull's claim to make. I like looking at international keyboard layouts just to see what that means. not just for people, but also for programmers. And I recently learned on Discord, folks were talking about prettier and how it automatically changes apostrophes versus double quotes, some of which is configurable, some of which is annoying to some people, and I can see why. So as for myself, I use the US QWERTY layout. I know in Canada, where I live in Canada, we have English and French keyboards, but I prefer the US keyboard layout because sometimes the Canadian French layout is not conducive to programming, and I also don't use French on a daily basis, so it's not needed for me personally. But what's fascinating is the other QWERTY and QWERTS layouts, such as this one in Germany, also used in Czechia, I believe. Take a look at this. So this is the German keyboard layout, and the apostrophe is, I think, way over on the right side near the enter key, and the double quote is on the number two, whereas in the US keyboard layout, I'm used to the double quotes being on the right.

 So it's interesting how entering double quotes can be finicky or a chore in some keyboard layouts, whereas it's easier in others. And so in the chat we see UK has the same double quote. Yes, let's get some more layouts in here. This is just interesting points of discussion. I'm not here to say what the ultimate layout is. I think QWERTY was invented almost 100 years ago to slow down typists because they were typing too quickly on mechanical keyboards. So QWERTY slows them down to not break the mechanical keyboards. But nowadays, QWERTY is just commonplace because it's a relic of history. And it's doing a really good job slowing me down because I think slower than I type. I don't know. I'm slow in other ways. I can't find the US layout here. Maybe it's this one. Since software is, by and large, a Latin-based language sphere, it does show bias towards the ANSI keyboard layout that I have on my screen. So I'm trying to zoom in. I don't know if zooming in works on Discord, but there's the apostrophe. There's the double quote next to the Enter button. Yeah, thank you, Hugos. So that's that. I know someone who I think grew up using the German layout, but they switched to the US layout just for programming reasons. And of course, there are also some really cool coders out there who use Vim, Emacs, and the Dvorak keyboard layout, and they type in 180 characters per minute. I can't even think at 20 characters per minute, but that's just me. Some people ask me, do you type fast? No, I just think hard. I put my elbows in the desk and I think half of the day. The other discussion, yeah, typing speed is not extremely essential. Typing a little fast is helpful, like 60, 80 words per minute. That's decent. That's good enough. You don't need to be a speed star at 200 words per minute. Not totally necessary. And I think the conversation about Prettier I don know if prettier has a playground If it does I can show one If not then that okay Oh, it does. So this is prettier. And I think prettier has some opinions on correcting or changing the way quotes are displayed. Let's see if I can do a string. So const name equals person. And I see it corrects single quotes to double quotes, but that's configurable. So where is it? Quote props, no semi, not semicolons. Single quote, there we go. So if I enable single quote, see ya Brady, then my apostrophes remain as apostrophes. And if you use a keyboard layout where the double quote is on the number two, then this This one may or not irritate you, but I want to hear from you personally. Like, does this cause problems? Do you prefer strings to always use apostrophes? It is what it is. Tyler writes, reducing hand motion is helpful. Yeah, repetitive stress injuries are real. Everyone, look into ergonomics. It's good for you. The biggest improvement I've gotten was that remapping caps lock to additional programmable super keys, very accessible. By all means, do what's comfortable for you. I am on board. Captain writes, I prefer single quotes in JavaScript, double in HTML attributes. That is close to standard. I think, I'm not sure if this is a W3C spec, but I do believe HTML attributes should use double quotes. So it might be closer to spec rather than an opinion. So I'm in agreement. And yeah, prettier. It has configs. You all have keyboard layouts. That was the discussion. Hugo says, same single quotes. feel good until I have to write legacy. And of course, there's backticks. So if you're using string templates, you know you have no choice but to use backticks to do things like that, where you need a JavaScript expression to be interpreted within $brace. A better example is const a person equals Rico. And then you can put the variable here. And in In order for this to work, it has to be in backticks. At least for me the backtick is one four reach away from the caps lock key So that good Alrighty I think the point has been made Also in discussions we have this interesting website that I think existed for a few years now, but it recently resurfaced, roadmap.shell. Yeah, the double-svelte templates. I don't know if .sh literally means shell, but the TLD is roadmap.sh. So this is an interesting developer resource. If you're looking into learning about a role, becoming a developer, or switching between two roles. Here, for example, is a roadmap for DevOps. And what I like about this website is it exposes you and informs you to the different things you should learn or at least be aware of. It does have some opinionated aspects, but I want to highlight the positive parts. The positive parts being know some programming. If you're learning developer operations, no the terminal, no operating systems, no orchestration of containers. Docker is a really, really big deal in the industry. And I like how everything is here listed. So at the very least, you'll be aware of the things you need to be DevOps. And the way this website presents some of these things is the purple checkbox. It's not super accessible, but the purple checkbox says it's a personal recommendation. which means if you're short on time, the way I interpret it is if you're short on time and you need a fast track to some DevOps, then you can just take the purple track and you can just trust the opinions of this website. If you have a little bit more time to think and you can do the green track or if you want to expose yourself to other things, just to be aware of them, try the grade track. And that's cool to have. It's very opinionated in some ways. We're all a Svelte community, so frontend is probably the most relevant to us. and in frontend, there's a lot of boxes. I wish the accessibility box was 20 times larger, but it is what it is. At least it's mentioned, and when you click on it, it shows you some resources, and I think that's very helpful. So at least it exposes you and makes you aware of these things so that you can go and learn them. It has a bit of a bias to React. So React, Remix, Next, and Style Components. You don't need to know CSS and JS if you're learning Svelte. Just FYI, you can skip these altogether because Svelte has scope styles and does a lot for you. But other than that yeah these are great concepts to learn if you getting new into frontend I forgot to share some links in the chat Let do that So here a link And here a link And Svelte Lab Here's a link. All these links. I'm flooding the chat with link previews. So many link previews. And I did promise you a flowchart. Here it is. This is the Choose Your UI Library flowchart. And here are my slides. That's right, I am giving you my slides. enjoy. All right, let's move on to this week in Q&A. So I'll minimize the chat. This week in questions and answers, I forgot to load Visual Studio Code because this one is going to be a fun one. It's about debugging with breakpoints. As promised yesterday, I think I've cracked the code, so to speak. For the past several months, I've been searching for ways to do breakpoint debugging in Visual Studio Code. And I'm not 100% there yet. I don't think this, what I'm about to share with you is not complete. The developer experience is not done, but it gets you very, very close. So I'll show you what I mean right now. Okie dokie. Thank you for waiting. So breakpoint debugging, as you know, is a way to pause your code editor so that you can see and inspect JavaScript symbols. And for this demonstration, a lot of people have been asking on Discord in and out for the past few months, hey how do i debug with typescript and i do have a typescript example ready for you the doce asks mmd is for flowcharts it's actually mermaid so dot mmd is a mermaid file format that gets interpreted by github

 So for the longest time, I've been trying to use breakpoint debugging in Svelkit, and I couldn't figure out how to do it. Even though I know where to do it, it's here in the .vscode folder. There's a launch.json. Shoutouts to JoinKey on Discord for sharing their launch.json. I have borrowed it for this demonstration. And the most important config is right up here, line 7 to 15. Here we're using pnpm. You can also use npm or yarn. It doesn't matter. I am launching the server, and it is going to integrate the debug server and latch onto Node.js. I don't 100% understand how this works, but I'm glad it does. So this launches the server and attaches to the process. So if I go to the debug tab in Visual Studio Code, you can see I have a few breakpoints set up. And if I click on launch server, there it goes. It runs a new terminal instance. It runs pnpm dev. It attaches the debugger. And it starts the server, localhost 5173. Let's go. Localhost 5173. Okie doke. So down here in Progressively Enhanced Form, I click on this page, and this is my dynamic form example from a few weeks back. What I'm going to do is I have a breakpoint right here in page.server.typescript, and when I click on the Add Pet Form action, it should break here on line 5. So let's do that. I'll click on Add Pet Name. Visual Studio Code seizes focus. It's on top of other windows. breakpoint has activated you can see by the yellow pentagon and now I can do some inspections I can see what request is by hovering it there it is I can also use the variable pane on the left side I can add some watchers and I have a full debugging experience here in Visual Studio Code this works for for now for the sake of this demo I can only show you back code So plus page or JS you can fully inspect back-end code using the Step2 debugger. I couldn't quite get it to work with client-side Svelte code, but I did get it to work in the dev tools. Oh, I've seen the TS video format. So let's try front-end code. I'm going to continue the debugger, turn off this breakpoint, and on the page, I want to debug, let's say, a handler or even this reactive statement. If I put a breakpoint on line 9, it doesn't quite trigger. There it is. So I pressed refresh on my page, and here the breakpoint does happen, but I think the only reason this happens is due to surface-side rendering. So the reason this breakpoint has hit and only once, like I press play, it steps through, it's done, and the breakpoints are no longer stopped. I click on add or move pet. Nothing happens to the debugger. It no longer breaks because it only debugs server-side rendering. So anything that happens in the Node.js server will break here in Visual Studio Code. Now the question becomes, how do I do a breakpoint debugging in Svelte? I want to do it. You can. Here's how you do it. You open the dev tools. I happen to be using Chromium, but I'm sure this works in other browsers. Thanks to Vite and Source Maps, you go to Sources. And for this demonstration, we're going to go to a different page with a callback handler to this button. Go to Source, go to Routes, go to Loading Images, and then I'll zoom in a lot more. Hopefully it's legible. The way DevTools represents Source Maps is in italics. I know it's not a really clear indicator, but this pluspage.svelte, this here looks to me like compiled Svelte code but this italics file pluspage is a source map And I think to ensure the source map works is right here So at the very bottom of the compiled file you can see this forward slash forward slash source mapping URL that relates to this italics file. So that way, when I put a breakpoint in the handler right here on line 17, and if I click on the example button, boom, the breakpoint has happened. We did it. We can debug Svelte code in our browsers client side using DevTools, using source maps, using TypeScript, I should add. So I think if you use lang equals TS, it will also work because the source maps doesn't really care too much about what language you're using. But there you have it. This is the endpoint. Now this question becomes, how did I get here? How do I adopt this in my project? Well, you need two things. One, you need the .vscode launch.json with this. My repository is open source. I will share the link in the chat. And the second thing you need is source maps to be enabled only for TypeScript. So under Svelte config, on line 14, if you're using TypeScript in your Svelte files, then you definitely need this enabled. I think for JavaScript, it's not necessary, but for TypeScript, it is. So on line 15, I wrote, if process ENV, Node ENV is development, turn on source maps, otherwise false. This is just a habit of mine. You can probably enable it all by default. I don't think SvelteKit ships server-side source maps to production. Either way, you should not be shipping any source maps to production. It's just a bit wasteful. So that's what this config represents. But the most important thing for you to remember is source map is true. And this will allow you to do client-side breakpoint debugging with Svelte files using the TypeScript language. And those are the two things you need, and happy debugging. If anyone has questions in the chat, let me know. I'll share a link to the repository. So, send my notes. And there you go. Let go over some nuances The first nuance is you may have inconsistent results using TypeScript but it should work in Chrome DevTools as I showcased using the italics file selection here in the sources panel. The second nuance is don't enable production source map builds. Server files can be stepped through in VS Code, so you can stay in VS Code for VS Code debugging for server-side logic only. And finally, using JavaScript and Svelte files can be stepped through as well. Patrick writes, vtplugin true. Shouldn't this be vtplugin inspector true? I think that's different. So Patrick is highlighting an interesting new feature from vtplugin Svelte called the inspector. I did not prepare a demonstration of the inspector today. I need to practice with it first. But for your awareness, Vite plugin Svelte, which I'm sure most of us are using, if you're using Svelte with Vite, you're definitely using this. There is a new inspector config, which will allow you to click on elements on a page and inspect the Svelte files. I'm not sure if it's all UI-based inspection or if it's also JavaScript inspection. So once I educate myself more, I may follow up in the coming week. but this is the inspector config that Patrick had mentioned. I'll link that in the chat. And there you have it. So yeah, this was not a showcase of the vPlug and Svelte inspector. This was just a showcase of source maps and breakpoint debugging, which is compatible with most Node.js applications. So this is just something that Node and the browser dev tools can just do. And it's been around for a few years, but it took me a while to get it working. And that is it for this week in Q&A. And that is it for this week in Svelte. Thank you so much for attending. I hope you all learned something cool and groovy, and I'll hang back for some water cooler chat. If you're watching this on YouTube, check out the links below, and join us on Discord. See you next time.