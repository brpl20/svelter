 Hey everybody, welcome to This Week in Svelte. I am here today. Co-hosted is myself, Enrico, and joined with me is Karim. Welcome. Hello everyone. Hello, and let's go. The agenda. We have a changelog to go over, some quick facts. No community showcase, but you'll definitely see an orange slide when that appears, and followed with discussions and Q&A. So let's go. The changelog. No time to lose. So in the changelog, we have some cool things, cool patches brought to you by cool maintainers and very cool contributors. The first one being SvelteKit 16, 1.16.1. And I did go over the pull requests and I tried to learn some of the nuance behind these patches. The first one is realign state.branch on the client on first load. This is some source code jargon related to the kit source, but the issue this resolves is actually about form actions not displaying errors correctly when there's no layout. So let's say you have a route with a page that's felt, and it's missing a layout. Then for some reason, form action errors were not being displayed, but now they are, thanks to this patch. Welcome, Blixem. The next one is update page data correctly after invalidate. This was a follow-up to some previous code changes. So now when using form actions with use enhance, for some reason, page data will not correctly invalidate or correctly update, but now it does. So these two are related to form actions. Finally, file not found in manifest, a bit of a murky patch note, but what this really refers to is a rollup config fix. So there was an issue related to loading files asynchronously. So up here, you know how you have dynamic imports in JavaScript? Await, import, some path, like that. That's a dynamic import in JavaScript. If you're importing JavaScript files, that tends to work, but you can also import non-JavaScript files like config.config. just some random extension and a typical Node.js file import. For some reason, this was causing issues with rollup. But in SvelteKit 1 importing non files now works a bit more consistently And that 1 Moving on to 1 there is support for Node 20 And given that it's a patch, I assume that's a backwards compatible support for Node 20. I still think it targets version 16 and 18. So if you're using Node 16, 18, or 20, they should all be supported now. And fix focus synchronously on navigation. there was an issue with focus rings. You know how when you press tab on your keyboard, you see a bluish halo around a selected item? For some reason on, I think it was Firefox or Safari, I forget which, there was a browser issue where focusing on the main page showed a focus ring erroneously, but that's now patched. So resetting focus synchronously on navigation is there. Moving on to 1.16.3. entry generation with mixed segments this translates to export const entries works in multiple files so there's a new feature in spell kit called export const entries and this is a route level export you know how at a page.js you can have export const pre-render equals true this is a page option and now a few versions ago there was a new page option called entries and this was to complement the config. So in SvelteKit's config file, you can have kit. prerender, I think, prerender.entries. And you can configure what to crawl when prerendering your site. But with the entries page option, you can set that up at a route level. And there was an issue with allowing this to work in a plus server.js file. Because you can actually prerender server.js endpoints in SvelteKit and that'll produce typically static JSON. So in plus server.js files, it should now be possible to consistently export constant entries and expect them to be crawled for real. The second note is focus visible false to prevent unwanted focus ring on navigation. This sounds very similar to the 16.2 patch below. And according to my notes, it's removing focus ring after navigation. So yeah, there's Safari shenanigans that had happened, but our fellow contributor managed to solve it out. So all good now. And that's it for SvelteKit's changelog. If anyone comments in the chat I be sure to round back to it Let move on to Svelte 3 Handle dynamic values in accessibility autocomplete valid This was a fix in the way this compiler error would show up. I don't have rich details, but it's good to see that sometimes erroneous accessibility warnings don't get overzealous. There was a similar patch to this a few versions ago. so now things should be things should warn you when they're meant to warn you and that's the patch what do you think Karim? cool stuff right? yeah it's the first time I've seen it now but you know some accessibility accessibility issues they also run over sometimes especially when it comes to HTML attributes great to see it fixed yes in the chat Cirilla writes the difference in the size of those releases yeah yeah you must be referring to the bulleted list here whoa and then the patch they got a wasn't this i think this was last week yeah i think it was a week and a half ago maybe for 59.0 but we're going to talk about this changelog in a few moments. For now, it is time to move on to quick facts. If I talk really, really fast, does the facts become quicker? Let's find out. So today in quick facts, I'm going to demonstrate an accessibility tip called ARIA current. And I regret not loading the example sooner because my laptop is crying and it's going to have to load Node.js in the browser now, but Svelte Lab makes it easy. Thank you, Svelte Lab. Looks like the changelog is missing the CSS media query syntax thing, though. I think... I'm not sure if that's in the next release or in the current release, but actually it was in the last release, so Cirilla may be referring to in the chat the media query range syntax. I believe that's now available in Svelte. Can I use .com? I tested this recently. I'm pretty sure it works now. But just to let everyone know, range syntax, I think that's what they call it here. Yes pdQuery range syntax This now works in Svelte You can now specify greater than less than equal to width and a pixel value rather than min width which you would do traditionally So try range syntax today. And that was a good stall because I'm waiting for Vite to start. I agree with you, Blixen, 100%. Let's just get a golden shovel, dig a golden tree and then I can get an M1 Mac. So I can show you source code in the meantime because that's really what this is all about. Today's demonstration is about navigation and trying to indicate to the user of all user types what the current page is going to be. So I'll close this dialog and go to my layout. Okie dokie. So this layout file has a set of links. I'll just scroll down to the important bits first. And what I want to talk about is this sort of decision-making tree I have when it comes to making accessible navigation. I don't claim to be an expert, but I do want to start this conversation because the more developers talk about accessibility, the better the internet it becomes. So I'm just going to show you different features and how I apply them, but also what considerations to make when you apply them. When it comes to accessible navigation, here's what I do. Here are the basics. On line 80, we have a nav element, and a nav element is a landmark. When you navigate a page using a screen reader, such as macOS VoiceOver, you can navigate by landmarks. And on line 80, I have nav with an ARIA label of main navigation. That way, when I show the landmarks menu, it'll show the navigation and it will label it and read out loud to me this label, main navigation. The second feature is an unordered list. The reason why we have anchors or hyperlinks inside list items is so that folks at the screen reader can tell how many items there are. It's a way of measuring number of legs, but it's also a way of indicating hierarchy. If you have a sub navigation or a sub menu, then unordered lists can represent hierarchy. For example, I have an unordered list and inside there I have a list item. On line 92, I have another unordered list. So because there's a sub navigation in this demonstration, the screen reader should indicate that there's like a sub level. So now I know how many links there are and how many levels there are. And then finally, the hyperlink itself. If I'm not zoomed in enough,

 please let me know. I might as well zoom in one more. On line 86, this is the star of the show, ARIA current. There are a number of values you can pass into ARIA current. And what this value does is indicate to screen readers whether or not this link represents the current link in a page, or the current link in a tabs list, or the current link in a set of some kind. And what I'm doing here is I'm using Svelte to conditionally set ARIA current to the string page. You can also set aria current to the Boolean value true or false or nothing, or you can unset it as well. And I'll show you some of the other options for that using our favorite resource, Mozilla Developer Network. Come on down. So aria current has a set of acceptable values. I mentioned page, but there's also things like location, which is a sort of navigational context as well. You can say the current date when you're representing a date picker, or you can do very simply true and false. And true and false is particularly useful if you're using a tabbed menu. So if you have like some hidden content on a page and you use tabs to reveal that content, setting aria current true on the currently open tab is very helpful. Back to the demo. Step is probably useful for multi-step forms, I guess. Step? Yeah. Yes, multi-step forms. Here it says checkout flow. That's also a multi-step form. So yeah, that's also a good shout out. Step is a good way to indicate a current step in a multi-step process. And Vite is taking a while. It's not Vite's fault. It's my fault. My computer is not powerful enough. But don't worry. I'll refresh the page. But before I do that, there's more code to look at. I'm also using an action on line 89. I made this action called use toggle, and this progressively enhances the link to become a toggleable submenu. When JavaScript doesn't load, it's going to fall back to providing an href and becoming a hyperlink. And I will demonstrate all of this now. Let's try refreshing. Hopefully, because it's, oh, it's incognito. I remember running into issues using a private browser. Hang on. Let me try this in my other browser. So let see what I went over Number one provide a nav Number two give the nav a landmark label Number three indicate the current page with aria current page And we go over sub pages as well maybe later in Q The current pages link can link to hash main which would apply to the main element So down below if I collapse the nav on line 108 I have a main HTML element with an ID of main This is so that the current link can navigate to the main content. Over here on line 87, the href changes from the href from my loop or hash main to become a hash link. Now I can finally demonstrate this. With our powers combined, we have a demo. So here's the navigation demo. I've indicated the current page with a black background. This is not visually designed fully nor properly, but it is for illustrative purposes. I press tab on my keyboard. I get the standard blue halo to show focus. I can focus on blog. I hit enter, and it navigates to blog. The current page is shown here because of the black background. So there's a visual indicator of current page, but there's also an accessible indicator. So this hyperlink has aria current equals page. It's server rendered. You can also pre-render this usually. like 99% of the times. And it also has a hash link to main. So if I navigate again and I press enter on the blog button, on the URL address bar, it says hash main. So I've actually navigated to blog. Let's try this with voiceover. Here comes voiceover. Voiceover off. Voiceover off. Voiceover on. Voiceover on Chrome. All righty. Brave OBS. Okay, so I've got it open, and let's try navigating with voiceover. All right, so in the screen reader window, it says current page visited link blog 204. There's a lot of information in here. It says 204 because it's an unordered list. The unordered list indicates how many links there are. It says the label of the link blog. It says it's a link because it is an anchor. It says it's visited and it says current page. If I navigate backwards, it says visited link home. It does not say current But if I go back to blog it says current page Because I said ARIA current to page the screen reader then says page All of this stuff is very language driven Because we not making, like ARIA current doesn't exist to tell a machine what to do, although it kind of does. It tells a screen reader what to do. But really what matters is what we're telling a human. So if you have a multilingual site, for example, trying to give as much succinct context as possible will help them navigate much more nicely. Blixen asks, does unordered list and ordered list give the same result? I'd say yes. They both indicate number of items, but for a screen reader, it always indicates the number, even if it's unordered. Ordered list is just the visual representation of numbers, but in the context of a screen reader, they always indicate how many there are, like two of four, three of four. All right. Now for the fun example, I'm hovering tools. Tools has a submenu. And the screen reader says collapsed visited link tools 404. Cyrilla asks, the value of ARIA current also needs to be localized or it is not done by the browser. If you do ARIA current page, it does localize automatically. So it does give you translations for free if you just use the core features. When I'm thinking about translations, I guess what I was referring to was visually hidden text that's provided by the developer. If, for example, in this anchor link, I have a span with some visually hidden text read by the screen reader, it is up to me to make sure that's translated. But the standard attributes do have translations provided. Not to worry about that. So hovering the tools link, my submenu pops open. So this is a good mouse experience. If I hover something, I can see the sub navigation. I don't have good hover styles here, but the interactions are what matter. But what's more important and often neglected is keyboard navigation. So how do I interact with tools menu with the keyboard? So what I've set up here is if I take action on tools, Expanded Visited Link. It says Expanded Visited Link Tools. And now, kind of like a toggle tip, this pop-out shows up permanently, and I can navigate inside using Control-Option-Right Arrow. List two items, Level 2. List two items, Level 2. Visited Link. Visited Link Hammer 1 of 2. and I can activate it with control option space collapsed visited link and now I've navigated so I now on the hammer page and the navigation menu is collapsed and the list and of may not end of me and and and and I just going to navigate again Expanded List two items Visited link Hammer One of two So back to the hammer Let's see what it looks like. Hammer. Select. Menu. 15 items. Get image description. All right. So I did not set up the main navigation for these set menu items. But that's OK. If I go to the About page. About current page. Let me show you what happens when I go to a current page. End of list. End of. End of. So right now it says current page visit link. If I press control option and space, it now says heading level one on about page. That's what happens when I click on a hyperlink that has a hash link to the main content. The screen reader will jump to the first readable copy. And that's a good experience too. So rather than keep the Ahrefs going to this page when I'm already on the page, I can just have it jump to the main content. Blixen asks, what if OL has a reversed attribute? That's a good detour, I guess. I'm curious as well. So let's see. MDNOL. I'm not familiar with the reversed attribute, so let me see it here. The Boolean attribute specifies the list items are in reverse order. Items will be numbered from high to low. I'm not actually sure what will happen, but that'll be fun to play around with. I do know that if you're using Flexbox, if you sort a Flexbox in reverse, the screen reader will still navigate the page in the order the DOM appears. So let's say you have a column of items and you use Flexbox reverse. It'll actually read bottom up because that's the order the DOM elements are written and rendered onto the page and not necessarily the order they appear visually. Screen readers navigate the DOM. Okay, let's finish the demo up. I'm almost done. So the last point here is sub nav links are a link that get enhanced. So let's try this with JavaScript disabled. I'm going to go to my dev tools, disable JavaScript, refresh the page. Let's see what happens. I'm using my keyboard this time, not the screen reader. And if I press enter on tools, it navigates the tools page. Because JavaScript is disabled, my pop-out feature will no longer work. And I've achieved this with Svelte using the use action. I got use toggle, which only activates when JavaScript is present. By default, it'll fall back to a regular anchor link with an href.

 And what happens next is I'm on this tools page, and the good thing about it is it has links to the hammer and the wrench. So as a fallback, it's good that these parent navigation links go to a sort of page or sitemap that allows the user to then navigate to these subpages without JavaScript. So that's my idea of a fallback page. And that's it for ARIA Current. I think Karim will go over this a little bit more during Q&A. So with that said, thank you for your questions. any uh great okay great let's go that was quick facts next is oh yeah i have to share my demo hang on i gotta share my source code with everybody here is the demo and here is some extra reading if anyone would like to learn a little bit more and let's move on to community showcase. I don't have one. Next, this week in discussions. This week in discussions, we have some interesting sneak peeks. And the sneak peek is Svelte 4. So on the Svelte Discord, it was shared that there is a Svelte 4 changelog you can preview. I say preview because although I'm 90% sure all of these features will make it. Actually, This is not the droids I'm looking for. One sec. Let's go here. There we go. Yeah, there's a really high possibility that all of these Svelte 4 features will make it into the final release. But because it's an unreleased changelog, any of these items here are subject to not make it or change or anything. So I will not exhaustively spend a lot of time covering each bullet point here. But I will highlight some of the features of Svelte 4 that we can all look forward to in the near future. As some of you may be aware, Svelte 4's code base is being rewritten into JavaScript and JS doc. This will really help the contributors and maintainers to rapidly test stuff. That means you can test something in Svelte, throw it into SvelteKit without a build step, and you can link it up nicely. So that in addition to NPM link for testing modules you also can avoid a build step and rapidly test This has zero impact on the end user experience So don worry Svelte will fully support lang equals TS You can write TypeScript in your Svelte components for years to come As for the Svelte 4 release their minimum supporting node version is 16. I think 16 might be out of LTS soon, but that's also important. Typically, when a breaking change happens to any node-based library, you're almost inevitably going to see a breaking change in the minimum supported Node.js version. That's not a big deal. We all live with that. Minimum Webpack version is now five, and Vite Plugins Felt has a minimum version as well, which makes a lot of sense because Vite Plugins Felt interprets and pre-processes all of the stuff we do with the Svelte components when using Vite. the minimum TypeScript version is 5 but it may work with lower versions though not guaranteed and there's a lot of stuff here I won't go over this exhaustively another highlight is a really major one is about custom elements so if you're using Svelte as an interface for developing custom HTML web components there has been an overhaul in how that looks and what the user experience is like and I think there's a link to a pull request with lots of goodies. Here we go. Overhaul and drastically improve creating custom elements. If you see the linked pull request, you too can have a look at what that is. Let me just press Y on my keyboard to activate hash links. So this GitHub hash link is permanent. I can share this in the chat. and if you come back here a week or a month later, it should still go to this changelog page. So have a look and look forward to Svelte 4. This is going to be a nice transitionary release to Svelte 5. So if anyone's looking forward to some really cutting-edge, cool new features, you may have to wait for Svelte 5 or perhaps a feature release in Svelte 4. But hey, we can all be surprised. And that's it for the discussions. Moving on to this week in questions and answers. So Kareem, I heard you got something exciting to share. Yeah let me try to share my screen Oh I can Okay there are two questions for today Not many, but interesting ones. The first question is how to detect if JavaScript is available. Yeah, basically to just run some very special, specific JavaScript code or to style your JavaScript swell up, depending on whether JavaScript is available or not. And there are several ways to do this. Let's take a look at the JavaScript patch first. The first very easy way in Spark, at least, is to use browse environment variable. It works, but it only runs before the HTML elements have actually been mounted, or this page has been, yeah, the HTML elements have been mounted, and your components and the template. So if you're trying to interact with these elements, this won't work. Instead, you would be using onMount, which runs, it's basically the same here in this example, basically, but it runs after everything has already been mounted. So you can, yeah, interact with your DOM elements and do stuff. Another common or very simple way is to use event handlers. And the thing is, if it's just about JavaScript, you don't need to really detect if JavaScript is available because if the code runs, you know it works. So there's a small question of how you want to structure your code and making your app accessible for users with and without JavaScript. There is an example for this in the Swagkit docs, I think, as an alternative to the use enhance function. So this is something you can do. The event handles run after SWAT has hydrated your page. So if it doesn't, if it fails for whatever reason, nothing happens. And this also only runs in the browser. then I think probably the most used way of dealing with this is to use what actions? They're essentially lifecycle functions for HTML elements. And it can also be used to attach event listeners and do other things not just to the element itself We could also use the document element I going to show you an example of this shortly Let me check. Yeah, and for the CSS part, there is a pattern that I think is very commonly used, and it doesn't matter in which framework you do this, But essentially, you can just create a container, a div container. I'm not sure if you can see my mouse. Yeah, you should be able to see it. You create a container somewhere in your... Can you see it? Yes. Okay. So let's say you have an app and a swap could happen. You probably have a layout somewhere where you create one at the top level of your app. You create a container. And so a div basically. and add a Node.js class. You can call it whatever you want, but Node.js is very commonly used. And then you have a SwagCit action here that simply replaces the Node.js class with a JS class. And because the action also only runs when JavaScript is available and when everything on the whole page has been hydrated, you know that JavaScript actually works. And then you can hear down here, you can use the JS class and nest your selectors and show or do stuff only with CSS when JavaScript actually works. There is a very new media query that I just couldn't find much details about. I lost it somehow, the link. There's a new media query that currently only works in Firefox and that allows you to detect if JavaScript works. The thing is, I think this basically just checks whether JavaScript is actually enabled in the browser. So if you, like there could be the scenario that JavaScript is enabled in the browser or the user, but the user maybe is sitting somewhere, is using his phone, the connection is interrupted, and the bundle, your JavaScript bundle, just fails to be fetched completely. And in that case, I guess, I assume that the media query would probably still say that JavaScript is enabled

 in the browser, but your JavaScript app, your Svult app, actually failed. So I think this is probably the best way to handle this, because again, the Svult action only runs when your whole app has actually been hydrated. So when this JavaScript is applied, you know that JavaScript works in the browser and that your whole app, or the minimum required for your app to work with JavaScript, was actually fetched. Yeah, and that's it for the first question. Next question that came up, and it comes up very frequently, actually, is can we use stores on the server? The question, yeah, the answer is yes, but it really depends on where you create your store. And there is an issue about this, actually, on GitHub. And it kind of gives the impression, I think that this is related somehow to stores itself. But this applies to any kind of variable that you deal with on the server. So a common way to create stores looks like this. You have a file, some kind of store.js file. You create a store, a writable, and you export it. This works on the client, or if all users use your app and use your website, get the same data. But an example here would be a WebSocket store that only works on the client because you only connect to the server in the browser, or an SSE store, something like that. But the problem is that if you do this, once this StoreJS module is actually imported on the server, you only have one instance of the store. And if you then use the store for every request for every user, then whatever you put into that object here and send out is shared for all users. So what's currently recommended is, I think it's probably the easiest way to deal with this, is to just, first of all, make sure that you always create a store inside a component. So in Swerkit, that means inside a page. And that alone is probably not as useful because you want to use a store to share data. So what you do is you create the store in a page file or a layout file It doesn matter but somewhere in a component because components are created for every server request You can initialize the store with data that could be coming from a load function, for example, or whatever you want. But make sure that it happens inside the page. And then you can use the setContext and getContext API to set the store so that other components actually have access to the store, because otherwise you wouldn't be able to share the store. And, yeah, this is... It might be a little bit difficult to understand, but it's just related to how JavaScript works on the server. And the page store in Swerd, there's a page store that you can import. But as far as I know, it does essentially the same. So if you import the store and it happens, I think outside of the swipe component, it will show you an error saying that something about a context API because the page store also is created somewhere higher up in your swipe kit app and then shared through the context API. So there are some people who basically completely avoid to use stores on the server just to avoid leaking any data to other users, which is fine. But as long as you think about where you actually create your stores, you can definitely use stores on the server. And you can use a store that, for example, is initialized with data on the server, but then further used on the client. Yeah, with some other stuff. And I think, yeah, that's it. Hey, Karim, can I have an ask a follow-up question? yeah of course i think to add flavor to this uh i do see some frequent questions around like can i use store in plus page.server.js or in a load function you've clearly explained how stores are most recommended to be used in svelte files because once they receive data from the back end then they're safe to use and be trusted as like a per user store so if the question becomes can use stores in my backend like within a load do you recommend that you mean just generally using stores or stuff on the backend Yeah on the backend Well, I mean, you could because the pattern that stores implement is very simple. You just have an object that has a subscribe function and you subscribe to the store whenever something happens. So what you could do is, or what I think you actually often do is in a NodeJazz app, you have some kind of event emitter. I did this in a very small SSE example where, let's say, you have an app where users open a connection to the server to get notified about any events, like notifications, real-time updates. So you could use some kind of store pattern where a user connects to the server, and the server is an object where you subscribe to it. But you don't need a writable for this. You don't need Svelte for this. So this is very rare that you do this. You could do it, but yeah, it's more questionable about the pattern itself. I agree with that. Yeah, I don't use stores in my backends. So for folks watching the stream, you can also maybe consider passing data in one direction. Load them from your load function, pass them to the page, and then your stores get initialized for the sake of making Svelte updates easier. The purpose built for Svelte reactivity, right? To share the examples for the navigation example. All right, well, back to you. Thanks for that segue. Yeah, so I have an example here for a navigation that works with and without JavaScript. This is from something I'm working on currently for a dashboard example. And can you see it? I think you should be able to see it. Yeah, and this is a page navigation currently using JavaScript. Let me check. Yes. And when you resize it, you see the navigation is folded down. You can click the menu button to get the navigation from the site. This uses the new inert attribute so that when you step through the navigation what behind the navigation can be focused And when you click outside, the navigation goes back again. Let's take a look at what happens when we disable JavaScript. Initially, you don't see a change, but what happens is that the menu button is actually replaced with a link. And when you click down, instead you scroll down where the navigation is placed instead. So yeah, there's a very easy way to deal with this. There's another example I have from this website that by default has here a menu button that you can click. It's a toggle button. So real button only works with JavaScript. When you click it, the navigation is shown. But when you go and when you go to the settings and you disable JavaScript, they just show you the navigation. And the way this happens is, let me check here. Again, I have the action that replaces the Node.js class with the JS class. And then this is what Enrico mentioned actually before. I just, yeah, this is actually a Flexbox. And I reverse the direction so that the navigation is shown at the bottom when JavaScript is not available. Check here. If JavaScript is not available, then flex direction is set to column reverse. And navigation link is shown instead of the navigation button. And some changes to the height are made. And yeah, that's how you can make a navigation accessible for users with and without JavaScript. You could put this at the top if you want, like here. Sorry, here. Yeah, that's it. I will show the repository.

 Let's see if it's, I think this was my last slide. Yeah, I added a link to the discussion here from a year or two ago where they mentioned the store and context pattern for you to check out. Okay. Wonderful. Thank you for your time. Yeah, navigations are a pretty big deal. We all use them. And I guess I have some personal opinions to share that I'm quite confident in. One of them is if you have a small number of links in your navigation, try to avoid hamburger menus. Try to avoid sub-menus. For example, if your website is just one, two, or three links, I recommend having them always visible. have the three links always show up If the screen is really small like an iPhone 5 from 2013 I guess then allow them to break down into multi links because the user is not going to scroll too far and they have a very easy chance of clicking the links without having to finesse with toggles A second recommendation from me is try to keep your toggle menus as close as possible to where they're toggled from. I've seen some websites where you have a hamburger menu on the right, and then the menu will appear from the left. Try to not do that, because if you're using a screen magnifier, then you're going to force somebody to zoom in on the menu button and then travel really quickly to the opposite end of the frame just to see the navigation. And that can cause some nauseating experiences. Try to keep the action from your links as close as possible to where they're triggered from. And that's it for Q&A. Some little tips. And that's the end of this week in Svelte. Yes, thank you for attending. And have a nice adventure. See ya.