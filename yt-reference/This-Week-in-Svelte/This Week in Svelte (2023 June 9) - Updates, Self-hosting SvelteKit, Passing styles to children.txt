 Hello, welcome to This Week in Svelte. Today is June 9, 2023, and your co-hosts today are myself, Enrico, and Karim joining me. Hello, everyone. Hello. It's agenda time, and these two features are perpetually new until I remember to delete them. Starting with the changelog, followed with quick facts and announcements, we have a microtalk by Karim today, who will go over self-hosting SvelteKit. Following that time permitting, we have this week in discussions and this week in Q&A, going over all the things that happen here on the Svelte Discord. Let's go, starting with the changelog. This is going to be a really fast changelog. SvelteKit 1.20.2 released patches. We've got remove scroll bars from default error page. The default error page is a vertically centered error code message, and there were some issues with scroll bars and viewport height, and I think I have some references to viewport height later in this meetup. So now the scroll bars should not erroneously appear. Second, disallow actions export from layout.serverfile. A nice compiler warning because form actions cannot happen on layouts because they're route specific, whereas layouts can cascade. So yeah, it's good that there's a little warning there for actions being misplaced inside layout.server. Third, ensure optional routes with matchers and catch-all match correctly. So there may have been an issue with matchers such as spread rest params in SvelteKit, but now it'll match more correctly. Good to see it. And that's the change log. Were there any Svelte releases? Well, last week there was the Svelte for beta iteration zero. I don't believe a iteration one was released yet. So a friendly reminder to everybody, if you haven't tried Svelte 4 pre-release yet, give it a go in your code base or component library or other library, and give as much feedback as you can before the official release of Svelte 4. Thank you. And that's the changelog. Easy, right? Moving on to Quick facts and announcements. Welcome. So over here in quick facts we got breakpoint debugging and Visual Studio Code Oh yeah Peru has an announcement In the chat he writes would love feedback on the new Svelte website Okay, there's a link in the chat. I'll share a link below in the YouTube description. And here is the new website. Wait for it. It's thinking. Okay. Okay. Svelte Dev 2. Check it out. The new official Svelte website. Try it out on your phone, on your computer. Read the documentation. It's got a very good SvelteKit information architecture with a side navigation, per page goodies, search, get context. I can indeed get the context. The REPL has been upgraded. You can learn more about some of these things in the recent video hosted by Kev and Rich Harris on the Svelte dev vlog. Dev vlog. Try it out today. The next announcement is Visual Studio Code breakpoint debugging. So in a prior week, I showcased as much as I could at the time how to do breakpoint debugging in Svelte. So to save you 10 or 20 minutes, I'm going to go over very quickly a thing that I've neglected, and that is in my launch.json. This is in my open source This Week in Svelte RoboStory, link in the description below. I have a configuration here for launching the server, running pnpm dev. You can also configure this for other node module managers, and launching the Chromium browser. So by combining these two, Chromium Browser will actually latch onto the node debugger context, as well as the Vite dev server, as well as source maps. This means you can have breakpoint debugging with client-side Svelte code. Here's how it's done. So I'll press start. And I'm launching both the server as well as the browser. So the browser window shows up. Little nuance here, I need to do localhost. This is probably a me problem. with the way I have things configured, localist 5173. And there's my site. Now for the breakpoint demonstration I have a breakpoint here under images So in my images route I have this button handler and in my website I go to loading images It'll do a breakpoint here on the function definition for handler. That's server-side rendering happening. I press play, and the page renders nicely. If I click on the example, boom. the breakpoint toggles in visual studio code for me and i don't have to debug using chrome dev tools like i showed you last week so this is cool as long as you run the browser with your debug server this should all connect correctly i will leave a link in the description below to my repository and i can grab it for the chat as well that was a quick fact are the facts quick enough who knows get up I think so get up e-train slash this dash week dash in dash svelte here's the repository check that out go to .vscode.launch.json to learn more also if you use NeoVim and you want to do this as well our fellow resident Theo wrote a blog over here. So if you'd like to get breakpoint debugging set up in NeoVim, check this out. There's some descriptions here, some Lua code, and all those NeoVim goodness just for you. Enjoy. Another announcement. So if you haven't seen it already, there was a dev vlog with Kev and Rich Harris this past Wednesday. Check it out on YouTube and you can learn a lot more about Svelte 4 upcoming features, breaking changes, testing expectations, potential Svelte 5 anticipations, and any other word ending in I-N-O-S, check out that YouTube video as well. And that's it for quick facts and announcements. Let's move on. To Community Showcase and Microtalks. Kareem, welcome. How do you feel? I'm a little bit nervous because it's all I even hope I don't screw this up, the demo, but it should work. So it's okay. Give it a shot. So yeah do you know what we going to talk about How to deploy a SWATKit app to pretty much any kind of server actually But we had a previous discussion server discussions about this actually Yeah, I just wanted to list a few options that we have and the option that I choose to do. But there are several options. and first talk about why you may want to self-host your application. So there are several reasons and some reasons may be more relevant to you than others. Cost is definitely a factor because a VPS is generally very cheap or like the performance per dollar that you get out of a VPS is relatively high compared to a serverless platform. Then maybe your tech stack, depending on what you use, might require it. So for example, I like to use SQLite for my database, and there's no way to really run it serverless, but there are a few services now, but the best way to run it is really just to host everything on a VPS. You don't look into a vendor like a serverless platform, if that matters to you, and it's also very flexible. Another reason might be compliance. And so I had a few clients that really wanted to host everything on their own VPS because they just couldn't use another platform and they need to make sure that everything is actually hosted inside the country. So I figured there are three main reasons, three main ways of how you can host something. The most, I think, naive way, I would say, is probably to just log into your VPS and clone the app and then use something like PM2, Forever, or Systemd to run it in the background. I used to use it for a long time, but it has some disadvantages, especially if you want to run multiple apps on one server and at one point you want to update Node.js, then you might run into issues because some, like a few apps may not be compatible with a new version of Node.js. Or if you use SQLite, for example, So you often have to download or you have to rebuild your app every time you update to a new Node.js version. And the second option, the most obvious option, is probably to just deploy a Docker container. There are a few...

 So, discussions about this already on the SWOT Discord, so I don't want to go into that. Instead, I want to cover how you can actually use Systemd and Systemd Portable Services, because this is, I think, something that is often overlooked. So, Systemd essentially is a process manager, and it is like the process manager used by most Linux distributions, both on desktop and on server. And yeah, it's essentially responsible for running your applications, for starting the system, and for monitoring everything that runs on the system. And usually what you would do is you just clone your app on the server, and then you can create a file in a specific directory and put in at least one line, which is going to be the command that you need in order to run your app. And you run a command and that will instruct system B to start your app. But the problem is again, that all of this is not really self-contained and that you may have issues upgrading everything. So something like container is usually preferred, and System B has a container mechanism since, I think, a couple years now. So what you can do is really put all the dependencies you need into an image, including the System B configuration, and System B can natively just start it, and that's what we're going to take a look at today. What do we need? We need a VPS, obviously. KD server or Nginx. I prefer KD server because it's a little bit easier to configure and a little bit more advanced in terms of features. And we need the systemd container package installed. If it isn't already on some Linux distributions, it's installed on desktop especially, but on minimal server distributions, it might not be installed. And we need a GitHub Actions workflow because ideally what you want to do is just push our changes to GitHub, and it will just trigger the deployment process. Here's a quick overview of what this would look like. So we have I hope you can see my mouse Yeah We push changes to our main branch of our Sparkit repository This will trigger a GitHub workflow that I going to show you in a minute That GitHub workflow has a build job and a deploy job. The build job is essentially, if you're familiar with Docker, something like a Docker file. It just builds an image. and that image will then be uploaded to the VPS using SSH and started. And Keddy is used to just direct all requests to your app. So if you have multiple apps, you can instruct Keddy to direct requests from domain.com to your app running on this port. Or if you have another app, you tell Katie to write all requests from this domain to this app. It has a lot more features. You can create apps where every user that signs up to your app automatically gets a subdomain or something like that. But that's not really important today. So yeah, before I go into any more details, I wanted to show you what this actually looks like when you do it. And this is the part where I hope I don't score it up. So I actually have a repository here with a guide written. And this repository just contains a SwellKit project. The only things that really changes is I install Adopt-A-Node, which is necessary to deploy to a VPS. And here above, I have a GitHub Workflows directory that contains our workflow. You don't really have to change anything about this, but this is what we're going to use. Yeah, here's the build job. And what do you see here is the systemd unit, the systemd configuration file. We're going to take a look at that later. later, but this is essentially the file inside the container, inside the image, tells systemd how to run your app. And further down below, I think, yeah, here is the, no. Oh sorry yeah here the deploy job which depends on the build job So uh before we use this actually um we need a vps so if you have never set up a vps then this might be a little bit difficult for you at first but i have a section here about this about options that you can use i like to use heads now um and generally there are a few things you want to do when you set up a new vps so um you often want to like set up a few users in StarCaddy, obviously, enable firewall, all these kind of things. And you can do this through a so-called cloud config file, which is like just either a YAML configuration file or a bash script. And most providers accept this configuration and you can just give it when you create the file. and this file runs the first time your server starts, the first time your server boots. And yeah, this is a configuration that I use, so I don't want to go into too much detail, but that's very important is I have two users. Usually I always have two users. One is a admin user, which is like the user used to just log into the server and view all running apps and everything. and there's an interesting option that you can specify, which is the SSH import ID, GH for GitHub, and then you can put in your GitHub username in here, and that will import your public SSH key from GitHub, if you have set one up, but I think most people today actually have. And yeah, so if you put that in here, you can just log in with your GitHub SSH key by default. And another user here, which I'm just going to call deploy. And what's very important is that it's a restricted user, and that user only has access to the portable CTL command, which is the command that we need in order to attach the image. There are a few other things like enabling the firewall. It's very straightforward if you've worked with Linux before, so nothing too complicated. I'm installing Keddie and generating an SSH key for the deploy user. So let's actually go to Huts now. Sorry let go in here Yeah create a new server and copy all of this first into a text editor because we need to replace this with our GitHub username And the host name is important too. So it can be just anything you want to give it, like a name to identify your server. This time I'm going to, I don't know, I'm just going to call it server1. And server1.domain.com. Let's copy this. And when we create a new server, this works on both DigitalOcean as well as Hetson and all the big providers. some of the smaller ones don't support Cloud Config, but most do so. I'm going to choose Germany as a region and make sure that Ubuntu is selected for the operating system. It usually is because it's the most used operating system for servers. Then the cheapest for dollar VPS is fine. And further down here, we can just copy our script into this input and click Create. And while this is running, this is not going to take maybe a minute. Let's actually create a repository for our app. So you can either just copy this, this workflow directory into an existing app or you can use this as a template. Let's name it SystemG. Let's just give it demo. Twist demo. So yeah, create a repository and this will actually create a commit already. So what that means is it already will trigger GitHub actions. The thing I don't really understand is if you create a,

 a repository for the first time, and you make a single commit, it will trigger your workflow twice. I haven't figured out why. Yeah, but this only happens the first time, so I'm just going to cancel one of them. And here you can see the boot drop is running, which will, or should succeed, and the deploy drop should fail because we still need to give it our server credentials. So let's just check. Has that, it's still running. Still installing everything. We can already open a terminal. And in order to log into the server, we just have to do SSH, says admin, ads, and then the IP address. Okay, it takes a little bit longer to know it's word, but we can already just try to actually clone our repository. So inside VS Code, let's clone our demo. Instructory open trust. Yes, so, let's just whack it up and back. Yeah, now it's finished. So we should be able to log in. You can see if we do ls dash lal home, we should have two users, deploy and sys admin, sudo system ctl status kd. Yes, should also show that KD is already installed and running. And what's left is we just need to go to our repository back and go to settings. And under where is it Secrets and variables actions we need to give it um three secrets first ssh host which is our ip address save it Another one, which is the user that we want to use. In that case, it's called deploy. And the SSH key of the deploy user. And you can generate one yourself. The Cloud Inuit script always did that for us. So let's just look into the home directory of the deploy user. Again, if you've never worked with Linux, then this might look a bit too complicated at first, but it's very straightforward once you've done it. SSH, so there should be, yes, a private and a public key. We need the private key. So it's just run sudo cat. And then, path to our private key. And you copy this. And create a mother secret. This is H private key. Yes, so now if everything went well, I hope this works. So let's go back to our failed workflow run and click Rewind Jobs, only the failed ones. And that should now give access to the VPS. I see. Almost the container that was built, it writes SSH key to the file system, uploads the container, yeah, it seems to work. And it starts the container. Yeah, and we're done. So container was just deployed So if we go to summary we can actually see the container here as a size of 34 megabytes It's really small. Now, if we go to our VPS back again, we can just make a request to our app just to see if it's running. But internally, yeah, we get the HTML response from SwellCut back. But we still need to expose our app. And for that, we need a domain. I'm just going to use a domain I still have left. The records, this is Cloudflare, but use whatever you use for your domains. Oh, and I need my IP address. And that looks good. Okay. Save it. And actually just go back here. If you remember, we just deployed our app to the VPS. It's running on part 5100. What's left is we need to point our domain to our server, which we just did, and we need to configure Kedi's server to redirect all requests from our domain to our app. So in order to do this, we need to edit the Keddie configuration. If you don't know this, on the Linux, most global configuration files are under the etc directory. So what we do is we open sudo nano, which is the default editor, etc. Keddie has a directory there. And the Keddie configuration file is called Keddie file. Let's open that. it has some default configuration here. We don't need that. We can just delete everything. And the only thing we need is the name of our domain, which in my case is here's the name. Open it and do reverse proxy to our port, which is 5100. Close this, save it, exit, and And reload caddy, which we should be able to a pseudo system. JL reload caddy Right, and everybody watching this should now be able to view the app. I hope. No, not yet. It might take some time. Let's just view the logs. So maybe let's actually go back to the presentation. There are a few slides I want to show you. So system is made up of a few tools and the most important tools you need to know are portable CTL which the command used to attach, detach and reattach a container, system CTL to just view the status of an app at the configuration file start stop or restart it and journal ct is used to view um logs there's really everything you need to know so let's view the logs of caddy and see um it's happening to the journal ctd dash u for unit and caddy queen oh, okay. Scroll down. That looks like a problem with... Oh, okay, there we go. It just took a few seconds. Yeah, so it works, as you can see. The thing with Cloudflare is if you use Cloudflare for your domains, and KD actually provisions an SSL certificate for you, you need to go to SSL and make sure to tell Cloudflare that the certificate is coming from your server and Cloudflare doesn't interfere with this. So where did we stop? Let's actually go back to the slides here and just go over and admit what happened. So this is the systemd service file for our SWACET app.

 As you can see, there are a few important options. A dynamic user is set to yes, which starts systemd to automatically create a user when the app runs and assign it to the app and restrict access to other parts of the file system. We have a state directory. I'm going to show you this in a minute, but it's essentially just a directory where you can save and write data to. and it's persisted between deploys, between new versions of the image. Environment variables, we set that, it's all in the GitHub workflow. We set port to 5100. It's just an arbitrary value, but we can overwrite this data. Again, the command used to run our app, a very minimal service file would just contain the slide. But we don't want that because then the app would run as a super user to have all rights. And this is also very important. It restarts our app every time it fails, it crashes for whatever reason, up to three times within 60 seconds. This is important because, let's say, your app consumes if you're environment variables and you just forgot to set them, and then your app will just crash and restart and crash and restart until you actually notice it. So we want to restrict that to a maximum of three times per 60 seconds. And this looks a bit complicated, but it just says that the app should be started whenever the system is booted. So in case your server provider, I don't know, has an outage or they do some maintenance work, and your server is online for, I don't know, a minute or something, and restarts, this will tell systemd to also start your app. And yeah, I don't want to go into too much detail, but this is just what you need to know, including these commands. And let's just demonstrate that we can actually push, so yeah, that we can actually push updates, Google page. I don't know how much to make this. And yeah let make this right And one thing I want to show you is how you can use a SQLite database So we're going to pnpm at data.sqlite. Create a hooks.server.js file. import this from data there we go and now we need access to environment variables I always forget what this is in SWEGit I think they see privates, private dot something. Let's just check modules. Here we go. This is a model that we need in order to access environment variables. and systemd will pass a state directory environment variable to use. And this contains the past to the directory that is persisted. So in production, we can just use it. In development, we want to use something else. something else. So, state directory. If it isn't defined, we're just going to use the current folder. So, database. Let's see if you like. And then we just open database. ConsDB equals database. or equals new. That should work, I hope. Yeah, looks about right. Push that to Git. And that will trigger our workflow again. You can actually install the GitHub Options extension and then you can see everything inside VS Code Here a workflow to run or build a job The only disadvantage, it seems, is that you have to press the refresh button a few times. This doesn't really update life. These are the steps. uh j only fine and then we could help workflow file but yeah this is pretty much it actually so if you have questions or anything you want to say um how's the time cool while we watch the build yeah we can do some discussion thank you for teaching us about container d so i guess to start this off my question is when you when this pipeline finishes and it pushes the update, does it do a graceful swap of the production application? Yeah, so this is actually interesting. So if we go to files and go into the workflow, what it does, the first time the image is deployed, it just calls the attach command. It charges the container, enables it on root, and starts it. But if there is a previous version running, there is actually a reattach command, which stops the previous container, but keeps most of the resources allocated. So there's pretty much no downtime in between if you do this. Very cool. I'll share your repository in the chat so we can use this as a starter kit of sorts. So let's run it there. The color changed, and we can see that we actually get a database now on our system, we do sudo ls. The details are only in the repository, but the path to the directory is, I think, ls, var.lib.services. and there we have a directory named after our repository and insights that we have a database and this database is persisted between deploys i see and that the environment variable provided by is it your server or systemd Systemd yeah it sets Okay forgive the beginner questions That's fine. So here we have a state directory option and say site services, and this is going to resolve to our repository name. We want to use that as our persistent directory, and it has to be a relative path. Because this will all be inside the, yeah, inside var lib. SQLite is a service, so it's in a separate directory. Yes, exactly. So if you can create as many directories in between as you want, or no directory at all if you want, but I always have one so that in case you have multiple apps deployed, all you have to do is to back up everything and just copy the services directory. Yeah. Cool. By the way, if anybody else has questions, leave them in the chat or join us on stage. And voice is good. Tyler writes, tiny correction. I think SQLite's not a server. It's a file. That's right. It is a file. And that's why, I guess, Karim, part of your benefits showcase here is by running SQLite directly next to the web server, you get most of the benefits of a local hosted database. Yeah, exactly. So you could also use Postgres or MySQL or the other databases that exist. You would still kind of communicate, I think, through a WebSocket. It's still slower. There's some benchmarks you can see, but it's still slower than just using SQLite. Yeah, so it's really, what I like to use to deploy an app. If you, however, you already use MySQL or Postgres or all the other databases you need, then Docker might actually be easier. It depends because Docker has these predefined images for all these databases. Yeah, but if you don't, if you just want a Svaki project and actually you can put into the container, you could put multiple apps. So if you have a SwireKit app and maybe a WebSocket server, you could put them all into one container, whereas I think in Docker,

 would usually use Docker Compose to create two separate containers. Yeah, Docker Compose, you typically have your database in one container and your application in another, and then they all communicate via an internal network. So SystemD, is this one image containing SQLite and SvelteKit? And if you use Postgres, would that also still be one SystemD image? It depends on how you would like to do it. So you could, but you could put all your apps into one container, assuming that your container all has the dependencies that all the apps need. But you could also create separate containers, and then here in the unit section have a requires option where you specify which other apps it depends on. And these apps would then always run together, essentially like Docker Compose. So it's very flexible. Cool. I'll wrap up soon since someone has questions. I guess one more from me. You gave the use case of the low-scale situation, which is great. This is great for people wanting to get into self-hosting with a reliable service that has a graceful update lifecycle. It restarts on its own. Your built image was 35 megabytes, which is below average for Docker by comparison. Docker is typically 50 to 70 megabytes for a compressed image. So your question is why it's so small? Yeah, why is it so small? Okay, yeah, I didn't have time to go into this, but let's actually go into here. Let's download the container. And if we go back to the workflow, flow. You can build a system container with like whatever tools you want. There's no like standard tool to do this. So what I do is you could use Alpine Linux or you could use a small Ubuntu base Linux just like with Docker. But there is also something new, correct me I don't know how this is pronounced. Is this called Chisel? Yeah, Chisel. There is a package manager built by Ubuntu called Ubuntu Chisel It very new and inspired by um uh docu with distroless images and what they allow you to do is essentially just install the dependencies only the packages that you need for your container without all the base os image files and everything so um yeah, this is the article. You can use it for any kind of image. You can use it for Docker images, for SystemG images. And I use this in the workflow here. That's it. Call it and just install the C++ standard library, which is required by Node.js. It's the only dependency it really has. But if we go into the container, This is a container, it has 36 megabytes and unpack it using the unsquash command. Can see here, so these three pieces are all empty. They're required. This is empty, this is empty, this is empty as well. It's required because systemd will mount these directories from the host system into the container. So they have to exist inside the container itself. The only files that here really exist inside the container are the C++, like the libc library. It's all libc. I see. So it's built basically from nothing and you opt into your dependencies on like an image such as Alpine. Yeah, I mean, I'm not too sure if you could get a Docker image this small, but you can use this OpenTool just also with Docker. And Microsoft uses this for all its images now. Yeah, we had a thread about image size. I still haven't seen a Docker image, which is this small, but really only contains like this, which is, I think, like 10 megabytes. And the largest file is really the node executable, which is 90 megabytes. but if you compress that to a container, it's only 36 megabytes in size. Very cool. And with that, we'll wrap up the Microtalk. Thank you so much for preparing and demonstrating this for us Also for everyone in the chat check out the community talk provided by ChromeV on a similar topic over here, which is how to self-host SvelteKit using CapRover, GitHub Actions, and a VPS. So if you'd like to try a self-hosted managed platform as a service, check out this YouTube video. And let's go back to this week in discussions. Pardon me for a moment. It's time for This Week in Discussions. We had a couple of discussions. A couple as in two. The first one being viewport units are a thing that you can use now. Take a look at this article. I won't read it, but I will show you that there is now SVH, CSS viewport units, and LVH. There's also a DVH for getting the height of a mobile viewport. Because the conundrum we ran in with viewport height units is they did not account for the dynamic toolbars that mobile browsers had, such as the bottom toolbar or the address bar at the top. These would hide or go away, and your websites would stretch unfavorably. But with these new viewport units available, I'd say widely available, you can use different measurements. There's LVH, SVH, and further down there's this one, DVH. Welcome back, JB. DVH is dynamic. So if the mobile toolbars do show up, then the max height of your window or pane or container will match it. If those toolbars disappear, the height adjusts dynamically, hence the D in dynamic. So check out this article to learn more, and you can use this in your mobile-friendly applications today. I guess adding on to that fact is it's a cool thing. The second discussion was, wouldn't it be great if we could pass classes to components? So this is back to Svelte. So the question is, how do you style children in Svelte? And why can't you easily pass classes to components? And I have an answer for you. And this is very similar in other front-end frameworks. This is not unique to Svelte. Other frameworks have this challenge that isn easily solvable due to the deterministic nature of props So here a demonstration which I link in the chat as well What you want to do is you want to style you want to pass classes to children components In this demonstration we have a card on the right. Let's zoom in more. You can never zoom in enough. We have a card. We have a card with a class passed in, and we have a card with a CSS variable passed in through style attributes. The way I achieved this is the first component is just a card on line 28. It does what it does, and it renders this card component, which is on line 1 to 3. It's just a div. And what I've done is I've applied Svelte's rest props to pass in classes. So there's no explicit prop for class. There's no explicit prop for style. But I use rest props to spread them into the target div. And a minute ago I said, there's no deterministic way to figure this out. We have to instruct our components where class ends up, or where style ends up, or where any rest props end up. Because Svelte cannot make that choice for us. What if there's down here an input for some reason, or an h1 for some reason? How does Svelte know where the classes go? So when you pass in a class to the component over here in the parent, line 30, card class equals big card. Okay, how does Svelte know where big card needs to go? It doesn't. That's why you have to tell it. You have to give it rest props dot class and pass it into the appropriate element. And that's limited in some ways because you only have one opportunity to use rest props. So alternatively, you can use something else. You can use pass through props. and I'll show a demo of that in a moment. But another disadvantage to, or I guess nuance, is classes must be global. So this big card class, I defined it down here on line 43, but I have to put the global modifier in front or I can import a CSS file because CSS files are global. As long as this is global, it'll work. But unfortunately, line 44 and 45, I have to say important because that would probably not necessary, but in my case, I cannot easily determine by reading this code where the cascade occurs. I don't know if this big card class will be written after the scope CSS or before. So will this line 44 padding definitely override this line 10 padding in the scope CSS? I'm

 I'm not too sure. So that's another disadvantage to passing down classes because you don't know where the cascade will occur. Another, so these are like so-called flaws, which I've listed out in the comments here. Third, you can only pass in class to a single element and the same issue occurs with style. When it comes to style in line 36, I pass in a style attribute. I know Svelte has style props and I'll show you the difference between the two. Here, I give it a BG CSS variable of pink And down here in the component, line nine, the background color is set using variable background or gray by default. And CSS variables work very well. So you can do this. You can document your components in such a way where your end users can pass in variable overrides. This works too. And Svelte has a built-in provider called StyleProps. But StyleProps has a nuance as well, which is documented to their credit. If I do style props and, well, not style prop, if I do dash dash BG, I just enter directly what I want to modify. I can do BG equals pink. But something happens. Notice the margin disappeared. That's because the line 27 have a box class, and the box on line 47 has a selector of the scopes class box and the global asterisk selector. and it sets a margin top to all child elements. The reason it breaks here is because style props provides a boxless wrapper. Let me zoom in and explain what that means. So this is like a combination of discussion and Q&A. Like why doesn't Svelte pass in classes and how do I pass in classes? It's two discussions in one. Here I'm highlighting a div provided by Svelte that sets display contents as well as passes in my CSS variables for me. So this is a convenience wrapper, but the effects of display contents destroys or deletes the CSS box model around that div. And that makes my margin top asterisk selector sort of not work. That's why as a workaround, I opted for style. So I just pass in style myself. The div element appears predictably and it becomes a direct descendant the way I want it to be or the way I expect it to be This is just what I did for my use case I not saying everyone has to do this but Zendo wants to keep in mind So what are your alternatives Well you can use pass-through props. Here's a link to another REPL, a REPL within a REPL. Pass-through props, I've went over this weeks ago, but long story short, you can have a component on line 20 like I do here, where the label text is whatever you want, and then you have what's called label props. This is a custom prop that I had made called label props, and it will spread into the label. I have another prop called input props on line three, and that spreads into the input on line 11. So this pattern is called pass-through props. It allows you to spread attributes, anything you want, into a target predictable element. And you can use this in your component libraries or SvelteKit applications if you need that control, because the component interface is a single element. It's a single component. But the pass-through props give you the flexibility to target multiple siblings, multiple children inside of that component. And that includes passing in class. That includes passing in style, so long as your class is global. So caveats aside, enjoy the REPL. It's shared in the chat below. If you have questions, post in the chat, do what you like, but we got to move on to this week in Q&A. In questions and answers, we had a bunch of questions in fact. Let's see if we can provide answers. The first one is, what is SAS and post-CSS, and how do I use these with Svelte? Should I? The question goes here. What is SAS? So SaaS is, I think, super CSS, and then post CSS is a similar yet different tool for writing advanced CSS or providing future versions of CSS into today's browsers. It also has a lot of other advanced features. It's evolved quite a bit over the years. In fact, post CSS has an extension to allow you to write as CSS inside of your post CSS. And I'm running out of time to actually demonstrate how to install PostCSS, but I will share that there is a convenience function or a convenience command called Svelte Add SAS. So if you want to add SAS or PostCSS to your application check out Svelte Add And this will provide the boilerplate you need to configure Svelte or SvelteKit and to provide a global SAS variables file It does some really convenient stuff for you which is explained here in the documentation The question ends. Is SAS a post-CSS plugin? SAS is its own separate CSS preprocessor. However, post-CSS does have an add-on for it. So there's post CSS SAS plugin. These are two different things. So post CSS is one thing, and then SAS is another thing. But post CSS, since post CSS is so comprehensive, it happens to have a SAS plugin or a SAS parser. Oh, okay, I see. Yeah, good question. I think then you can probably use this, because Vite, I think, supports post CSS by default. but not inside Svelte files. So if you were to use it inside Svelte files, you still need, I think, Svelte preprocess or whatever it's called. Correct. That is correct. So because Svelte is a compiler, you do need to have the right preprocessor set up as documented here on the SvelteKit website because the preprocessor parses your Svelte style code. So for example, in this component, I have, actually let's try this other one. So in this card, I have a style tag. And if I were to do style lang equals post CSS, I need to install the appropriate preprocessor for my Svelte config. But you're right, Vite also happens to have a separate post CSS feature in case you want to write post CSS outside of Svelte components. That is a built-in feature too. And Tyler writes, I think the biggest reason to use Sass itself rather than post CSS is for performance. If you have a huge amount of style sheets written in SAS and the Dart SAS processor will run faster than any of the JS based stuff like post CSS. Yeah, give or take. If you have a large application with dozens of components and they each use SAS, you may notice some slowdown due to two things. One, you have the Svelte preprocessor running against SAS as well as the SAS library precompiling CSS. So that's like two extra build steps necessary to integrate SAS or post CSS Also I think DartSass was renamed to just Sass recently I believe it written in Dart That probably why I got the name Interesting fact Next in Q is how do I update SvelteKit Well, maybe I'll save that for another time. But long story short, npm... Whoa, where's my notepad? npm update at SvelteJS slash kit. And if you're using npm, better if I show you instead of tell you. So in my terminal, in my project, I can run some commands to upgrade Svelkin. NPM outdated. We'll check if my dependencies are outdated. And this should show a table of outdated dependencies, probably Svelkin being one of them. And so long as the package has a caray version, it will be highlighted in red like it is here. It says I have 1.18.0 installed, but the latest is 1.20.2. And the wanted version is 1.20.2. The reason why it says wanted is because in my package.json, I have a Coray version for SvelteKit, which means the major version number one is locked, but the minor version 18 is upgradable. So if I run npm upgrade at SvelteJS slash kit, it will update to the latest SvelteKit because the Coray version allows it in my package.json. I should probably have to use pnpm because I'm using the new stuff, aren't I? I am. So if you're using a different package manager, keep in mind your different commands. But that worked out. So SvelteKit upgraded to 1.20.2, and it looks like pnpm goes the extra mile and updates my package.json. If your package.json doesn't update, don't worry. The lock file is all that matters. And you can also do pnpm or npm ls svelte.js slash git. And this will tell you the true installed version based on the lock file, based on node modules in your project. So here I can definitely tell which version I have. So if you're ever reaching out for help on Discord and you want to double check which version you have installed, you got to run ls. That tells you the true version you have installed. Packer.json only tells you the allowed version to be installed. And that's all the time we have for Q&A. I'll save the rest for next time. thank you so much for joining today and thank you again Karim for that wonderful presentation I'll see you all next time bye bye