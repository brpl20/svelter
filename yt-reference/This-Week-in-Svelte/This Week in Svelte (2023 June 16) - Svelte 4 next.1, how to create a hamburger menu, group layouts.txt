 It is Friday, June 16, 2023, and you have arrived at this week in Svelte. Our usual agenda involves a changelog, quick facts and announcements, community showcase and microtalks, and we have one microtalk today by somebody, followed by this week's discussions and then questions and answers. Let's go. Changelog time. There's just one small changelog update that I missed a week ago, and that's Svelte's version 4, pre-release next.1. There are a few minor fixes. Expose export component type from the Svelte entry point. So that helps with typings. Derive store types. Yes. And generate type declarations with DTSBuddy. Declaration.TypeScriptBuddy or whatever else you imagine that stands for. DTSBuddy is a cool tool because it takes pretty much all of the types you would need in Svelte and lends them into a single file so that our developer experience using Svelte is a little easier. This helps with things like auto imports, things like types in general. It just keeps it all organized. So try out Svelte for pre-release if you have time and give some feedback. That's the change log. And now for quick facts and announcements. What do we got? today, there are a few quick facts. One is there's a new blog for What's New in Svelte, the June 2023 edition. If you want a comprehensive update of the past month, check out this blog post written by Dani. And see how the world's most popular homepages are faring for accessibility. I think I shared this a few times, but I don't feel like I can overshare this. So on webaim.org, there's a WebAIM Million Project where they report on the top 1 million homepages. I just want to go straight to the graphs because everyone here likes big numbers. There's homepage complexity. It looks like it's increasing over time since 2019. And then there's Web Content Accessibility Guidelines Conformance. 96 of homepages had detected WCAG 2 failures And I like the enthusiasm It says this improved very slightly from 96 in 2022 So that's like a 0.5% gain. We're doing it. Thank you, millions of websites. So since 2019, the violations have dropped tiny smidgens over the past four-ish years. if you'd like to learn more about that, check out this site. But the thing I want to highlight about this quick fact is this. The homepage is the most common WCAQ failures. The most common failure is low contrast text, then missing alternative text, such as alt tags on images, empty links what missing form labels what empty buttons so yeah it's a tick and i agree accessibility may be hard to get right because you need testing but i feel like these top violations are inexcusable these are the easiest things to get right all you got to do is run lighthouse on your website make sure your accessibility scores 100 and that should cover all of these like these are quick wins. You can easily fix these. This doesn't require comprehensive testing or knowledge. Low contrast text? Yeah, don't put gray text in a gray background. Missing alt text? It's just a single attribute in the image tag. These are quick wins. Very easy. So don't wind up on the don't wind up on this website if you can avoid it. Next quick fact is Oh, Karim is here. Welcome. You can have a large touch target without needing it to be visibly large. I have a Svelte REPL example. So over here, we're talking about touch targets, which is a good segue from the million topic. So on my screen I have three buttons. And what's interesting about these buttons are their touch target sizes. So this first large button, the dimensions are 166 pixels by 48. Then we have a small button. My dev tools are way too small Let put them on the side Ooh that hard to read Okay The small button has a height of 33 pixels In the Web Content Accessibility Guidelines WCAG version 2, the touch target of something should be ideally 44 pixels height and width minimum. And this button here is 33 pixels tall. So that's a little bit difficult to hit if you have tremors, for example, and your hand's a bit shaky. And down here we have a solution. So sometimes you have a small button next to text. Usually it's an icon button. And you don't want to make the icon button too large. This is like an edge case. No, I use rem units. So Cirilla writes, how do I define the height and width of stuff? I typically let the line height and the font size dictate the height of my buttons. But here in my button icon example, I use rem units, which defaults to 16 pixels, but is, of course, adaptive to the browser font size. And what I'd like to share with you is a little hack you can use. So this button down here, the guidelines in WCAG 2 specify 44 by 44. In WCAG 2.1 AAA, it's 48 by 48. So down here in the button, the button has a touch target of 60 by 48, but the visible button, the one you see with your eyes, is 47 by 35. So this achieves the goal of having a large touch target. When I move my mouse into that 48 by 48 box, the outline effect shows. So you can still have a button that looks small, but still has a large enough touch target. And you can achieve this using a wrapping div like I have here. And I'll show you some of the CSS involved. I think I have Cole's notes down there. Yeah, so here we have a div, and then a button, and then a span. The span is like what looks like a button. and then the button wrapping it has padding. Here I set a minimum height of 3rem and 3rem. And if I have a calculator, I can show you what that means. So as long as you have your body, your HTML font size to 100%, 1rem is always 16 pixels So 16 times 3 is 48 So that why with a min height and min width of 3 rem we achieved our goal So instead of the text BTN this could be an icon this could be anything really And that is how you can achieve a larger touch target. I'll share that in the chat. I don't have a convenient link to the guidelines, but you can check that out too. Unless I do have a convenient link. No, not today. That's okay. Next quick fact is how to install SvelteKit from GitHub. So can you hear me? Yeah, I hear you. Great, Rex. Okay, so yeah, we can actually install SvelteKit from GitHub directly with one single command. So a little bit of context. I've been playing around with some of the unreleased features in SwellKit, the OnNavigate hook and shallow routing. And I used to just clone the repository with git clone and add it to my package.json. But there's actually this website called git pkj that can generate a link and allows you to install a dependency from a subdirector, which is very important because SwellKit is inside the Mono repository. And you can also specify a git commit and a branch. And yeah, once you have your link, you can just run npm i followed by the URL. It doesn't seem to work with pnpm. Like the commands run successfully with pnpm, but if you run pnpm dev, it still seems to resolve the wrong slide kit version. It does work with NPM. Yeah, you just run the command and get access to whichever branch you want to play around with. I entered the repository. What else do I need to do? The subpath. Can't see it on my tiny screen. Yeah, it's git-packages-kit, because SwellKit is inside the packages kids directory. And then you just append the branch with a... I need the branch. I think my example was gh-

 5, 6, 8, 9, which is a branch that contains the onNavigate hook. And then you can use onNavigate already to do page transitions using the view transition API. So, yeah, just something to know if you want to play around with a pre-release version of KID. I can't wait. I think the onNavigate hook will probably be merged after sprite 4 has been released and after the maintainers are back from vacation. but yeah. Okay, I see how this works. So I entered the package directory on GitHub and down here it creates a install script using git package.shell and then you can have a branch name. So if you want to install from a branch, this will supposedly run npm pack and just build a installable package for you. Exactly, yeah. And you can also deploy this. I deployed this. You, of course, have to be careful which branch exactly you use, and some branches might be behind the main branch a little bit, but if you know what you're doing, you can use this. Cool. I'll share the links. So this is interesting. If you want to try experimental or yet-released features of SvelteKit, git package is one way to do that, just by specifying a branch. or tag, you can try things that are not yet released. Pretty cool. So does this work because Spelkid's written in JavaScript? Or if there was a build step? Yeah, I think so. I think it's still, like if you run this command, I think it also runs npm install inside the directory because I think without that, it wouldn't work. but yeah there is essentially no build step so if the project had a build step would this tool work still or probably not? I'm not sure I think if you run npm install in general you can have an npm build script and that build script will run automatically when you install a package so I think it might still work but I not sure well it cool Quick fact Try it out Try it out with other packages that don really have a build set but you should get some reliable usage out of it. And that is it for quick facts. Cyril asks, what happens with PNPM? Can you repeat that issue? What happens with PNPM? Yeah, does GitPackage work with PNPM, or was there an issue with it? The command runs successfully in my testing, but when you run npm dev, it resolves, like it uses the actual version, it uses a version from npm from the website. Like, the version has been published. I don't know why, so it kind of resolves the wrong SWAT kit version, at least in my testing. But npm always worked. Cool. and Patrick shares a demo, another version of TouchTargetMinsize for buttons without an extra wrapper. Nice. Let's check it out. TouchTargetMinsize. So here we have a button with the letter T, and it's just a button. It is 33 by 24 pixels. how did you get the touch target so large let's take a look is it the padding expand the node dun dun dun pseudo elements it was you all along very cool so we have a pseudo element with uh yeah translate 50 percent top left 50 percent and have been heightened with a 3rem. That is very elegant. Very, very nice. Thank you for sharing. I'll add that to the YouTube description as well. Moving on to Community Showcase and Micro Talks. We have a Micro Talk today brought to you by me, Enrico. How to make hamburger menus, Svelte edition. I'm trying to keep this a Micro Talk, So think of it as an introduction to hamburger menus. It won't be as comprehensive as you may expect, but I'm happy to take questions in the comments at the end. And if you have something to teach me I more than welcome to hear that So let talk about it What is a hamburger menu It a place to house your top site navigation much like this Pozilla example It does not need to exhaustively contain all links on your website. That's why you have a footer or a sitemap, because a top-level nav or a hamburger nav is supposed to get you to the important parts or the common parts first. That's highly dependent on the content of your site and the information architecture you've devised. So content plays a significant role in the creation of menus. It can be toggled with a keyboard, mouse, or assistive technology. And they help with small screens. So that's primarily why they exist in the first place. You have a small screen. The amount of stuff you can put on the screen is not easy. So we tend to obfuscate things under usually a single hamburger menu. And you probably only need at most one hamburger menu. What is not a hamburger menu? Something like a select or an autocomplete, a tooltip, or anything else that serves another purpose. The semantic elements you use highly plays into the eligibility of what you would qualify as a hamburger menu. And I found this pretty funny image picture. It happens to be on Dribbble. So do you want a strawberry menu? Do you want a cheeseburger menu? That's up to you. But I typically go with the hamburger. do you need a hamburger menu like do you actually need one so here's some small criteria you can go over in your head first organize your content to require as few links as possible if you don't have a lot of links you probably don't need a hamburger menu two some scrolling is okay excessive scrolling not so much if you have a page and you're scrolling just a few pages in length let's say four to ten pages, that's actually not so bad. Most users are okay with that, and you don't have to worry about making each individual page as tiny as possible, because doing so would cause you to have more links and more pages in your site, which can actually decrease the ease of use. Third, do you only have a handful of links? Try always displaying them. And then four, do you have a large mega navigation? You may need a hamburger, especially on small displays. And now for the fun part, the Svelte style way, how do you actually make a hamburger menu? So the parts that you need is a nav element, because a nav is a landmark, and I'll show you how that works. Two you provide a toggle button or anchor And I actually make use of both of these and I show you how Three use ARIA Expanded to indicate the button has opened and ARIA Controls for the corresponding navigator Four, use discretion by revealing all navigation until JS hydrates, or keeping it all hidden and fall back to an anchor. This is highly dependent. This is not a strict guideline. All of this is just a guideline. Sometimes it highly depends on your situation. Five, use list items and owner lists to contain links and nested links, because list items and unordered lists tell the screen reader how many links there are and what hierarchy they are in. So if you have sublinks, for example, the list items will for free tell the screen reader that they are sublinks. Number six, use ARIA current page for current page links and finally provide subnavigation links within top level pages. That means when your user goes to a page, that page may have sublinks or subcontent. On that page, you can provide actual static links. It's time for the interaction demo, and there's a little minigame for all of you. Try to spot the opportunities to improve because this is a microtalk. Let's go. Okay, bring it up to chat. And I have all of the code I'm about to show you is on my repository this week in Svelte, so you can review it later. For now, let's run this using pnpn-dev. Local host 5173. Patrick writes, does anybody know if our current page belongs to list item or anchor? I think it belongs in anchor, and we can check this together because it's always good to double check. So here is our hamburger menu. There it is. So I'm going to have to turn on responsive mode for this demo to work well. There we go. So it's responsive. Let's change this a bit to device type. I'll use desktop. There we go. There we go, good. So to answer Patrick's question, where does aria-current belong? Usually I check MDN for that, like aria-current, and it tends to provide a quick answer to that.

 So here, the example is on the anchor itself. Anchor href, aria-current equals page. And that makes the most sense to me because when a screen reader hovers a link, the link has the role semantics. It's like, hey, you're on a link, and this takes you to this page, and then it reads the label to you. Aria-current will then... Above, they also say, in a broadcast list, when a link within a set of pagination links is started to indicate the user is currently on that page. Area current should be set on that link. So I guess, yeah. Yeah, it makes sense to me. So let's work backwards. I'll show you what the hamburger menu does and how the interaction feels, and then we'll go backwards to how I coded that in Svelte. So here on a fairly large viewport, I have all of the links in line. I only have three links on this example. If I had like 10 links, then this whole hamburger would be a little bit more justified. So this is a contrived example. because once I get to mobile, there's a kind of useless hamburger here. When you click on it, it opens three links. I think having these three links always present is a much better idea. It saves the user a link. It doesn't take up much more space. And as I said earlier, it's perfectly okay for the user to scroll. And if I make this navigation menu not sticky, which is the default, then it's an okay experience. But this is how it looks so far. So what are the interactions? Well, if I click on it with my mouse, we're going to start with the mouse. It stays open even if I hover outside of it. So I turn this into a toggleable nav, and it's always good to have a toggle in case the user mouses out, backs it, and you want the menu to turn off too soon. When I click outside of the menu, it turns off. So I have a body handler set up to listen for that event. And for the keyboard, let's try keyboarding. I press tab, it hovers the entire button. I press space or enter, and the same toggle effect occurs. You can optionally add some code so that mouse hover does the same thing as toggling, but that's up to you. Pressing tab goes through each item, and then pressing enter actually executes the link. In my case, these are hash links, hence the URL change to hashtag food. I'm only linking to parts of the same page, but these could just as easily link to other pages. now another feature is progressive enhancement if I disable JavaScript there we go JavaScript is disabled I refresh the page It looks the same but when I click on it the navigation changes to hashtag footer which navigates to here, where I would put my footer if I had one. Let's see what that looks like element-wise. So if I open this, here I have a wrapping div for the hamburger wrapper, and then I have an anchor and the button. So using just CSS, I am showing the anchor when there's no JavaScript and I'm showing the button when there is JavaScript. So let's enable JavaScript again and see what that looks like. So when JavaScript is enabled, there's a special class I've inserted up here in the parent wrapper called hasJS. So that's this class right here, hasJS. The presence of this class dictates whether to show or hide the button or anchor. So these elements are always on the page. Yes, there's a bit of duplication in the SVG icon, but I opted for this behavior. So here it says, when has.js is present, display none on the anchor. And Karim shared another demo. Check that out as well. The button by default just shows up, but if the has.js class is not present, then it'll hide. So right now JavaScript is enabled. This is a button. Clicking on the hamburger text opens the menu. Clicking on the menu button should open it, but I broke it so that we can do some real-time debugging. For some reason, this SVG is nested in the button and it prevents the interaction to occur. I think setting pointer events to none helps, but I'm scared that setting pointer events to none will break keyboard navigation. So now I can click on the SVG and the entire button is clickable. If I keyboard navigate, it still works as well. And if I use my screen reader, let's go screen reader. VoiceOver on Brave. Hamburger menu. All right, there's the screen reader. I'll try navigating this. Fancy restaurant, collapsed button group. So it says fancy restaurant expanded. If I press spacebar again, it says fancy restaurant collapsed button group. And that word collapsed is there thanks to the aria-expanded attribute in the button. So aria is false when it closed Fancy restaurant Aria is true when it open And another attribute down here is aria controls so aria controls equals nav and nav is the i controls equals nav unselected voice over off so nav corresponds to the id of the navigation down here so this menu that's currently highlighted it's a nav it has an aria label main navigation that's a landmark and the id is set to nav this id is what corresponds to ARIA controls in the button. So as long as you have ARIA expanded, you must have an accompanying attribute ARIA controls. These two play together nicely. And let's talk about landmarks. So if I open the screen reader again... There it is. And I press the Uber menu, which in my case is CapsLogU. There's the landmarks. Landmarks. Let's see the Landmarks. Menu. Form Controls Menu. No, I am. Landmarks Menu. Main Toolbar. Dom Trix. Side Panel Toolbar. Navig. Windows. Links. Form Controls. Links. Okay. So I noticed that sometimes it doesn't show up. Fancy Restaurant. And that's actually my fault. Fancy Restaurant. Expanded button. VoiceOver off. Let me close that. Okay. So in order to properly test Landmarks, I should be using Safari and not a Chromium browser because macOS VoiceOver is designed for Safari. So for now, I'll just say that this landmark, this nav element is just a landmark. It serves only that purpose. It also helps a little bit with SEO, but I'm not sure how much bots care about it. This is mostly to communicate to screen readers. And then finally, we have the unordered list with list items and anchors. I'm not navigating to separate pages, so I'm not making use of aria current equals page. But if they do go to different pages and you're currently on a certain page, then I would make use of that. All right, now let's look at code. how did I achieve some of these things the Svelte way? So here's the wrapper for the hamburger menu. In this demonstration, I happen to have a route in SvelteKit. So here's a layout, nothing fancy related to menus here, except up here. So my layout, this is where it all begins. I have a header on lines 10 to 12, and then inside line 11 is the hamburger nav. And I made the hamburger a separate component. Inside of which, we're doing a few things. You can do most of this with the action, but I opted for using a mixture of actions and Svelte code and Svelte templates. So the wrapper on line 29 has a useJS action and that on line seven All this does is add a class hasJS because if the page has JavaScript enabled then this will run, because it runs as soon as the element mounts to the page. So this will apply the class hasJS to this wrapper, and then this will help with the CSS to display or hide the anchor on line 31 versus the button on line 36. Second to that is we're inlining the SVGs on line 33 and 42. So the icon I'm importing using the Vite parameter, question mark, raw. I just take a hamburger.svg, I imported raw, and then I use at HTML to inline the SVG HTML. This is safe because it's what I'm importing, it's what I trust, it's not a user-generated SVG, so I can use at HTML safely. On line 37, we're using bind this to the button to facilitate clicking outside of it. So if I click on this menu and open it and then click outside, it closes. It closes because I'm comparing the target of the page versus the target of the button. So line 37, I set the button instance to BTN to find a line 12. And BTN is used here on line 15. So in on mount, when the entire component mounts, we have this outclick function, and we add the event listener click to document, and it sets it to outclick. When this hamburger menu disappears for whatever reason, we have this unmount logic here being returned by on mount to remove the event listener. So I can reuse this function just to turn off that event listener. All it's doing is when you click outside, it'll make sure that the event target is not equal to the button and that it sets the open prop to false. And open on line 13 is used to set classes as well as RA expanded. So on line 39, RA expanded equals true or false, depending on the status of open. And on line 52, the open CSS class is applied to the nav based on that single state. Tante-kun says, I was thinking a few days ago how to dismiss a popover, and this is how I do it. Yeah, this is just one way. In fact, you can probably encapsulate majority of this logic into a single Svelte action. I did not opt for that for this demo, but it's a totally viable and actually pretty, I guess, comfortable way of doing things as well.

 I also recommend actions. But here I only have one action, and that's just detecting JavaScript. There's a little bit of a CSS conversation to be had as well. I decided to use all handwritten CSS for this demo just to show you what's involved in making a hamburger menu work. So let's start up here with the wrapper. I have, this is the black background that corresponds to this entire navigation thing at the top. Cirilla writes, Do you know how outclick would work with stop propagation? I'm not so sure. Since I only have one interactive element on the page, that's hopefully not a concern. But if you have multiple, yeah, I can see how propagation may hurt. But something to keep in mind when you make clicks like that. Then there's the hamburger wrapper with a display of flex. It's a flex because on wider viewports, wider viewports. Let me zoom out. There we go. This is a row, and it's a flex wrapper. So when I go back here, it's a column. And I'm using the new media queries available in Svelte, I think, 3.59. Width is greater than 540 pixels. Display none. So this hamburger wrapper is being applied to this div. So this is to show or hide the hamburger button itself. So the button can be a button or an anchor link. And this hamburger wrapper wraps both of those things. And it hides it on desktop right here. And it shows it on mobile. That's it. Single media query. Further down, we also have some mouse events like hover. I set the weights to be bolder. There's a title that appears on desktop. So by default, it's display none because the hamburger button itself is the title of the website in my case. and then we set the display to inline block when it's a larger width. Yeah, I did say that in a bit weird fashion. In the web, media queries with the, I forgot what this is called. It's like, it's a special new media query syntax that's widely available. Let's see if I remember it. Media syntax. It's a special name, range syntax. So the range syntax is relatively new And because Svelte is a compiler that has to keep up with these new changes what I trying to say is the Svelte compiler has updated to support the new range syntax And that's what I'm using in this demo. So the demo has the range syntax that now works in Svelte. Yep, thanks for asking. Clarification's good. So down here is the hamburger, the hamburger itself. I'm just setting the styles of the hamburger, so nothing too noteworthy. but down here's the nav. So we have a nav.open. Earlier I showed you that there's a conditional class set on the nav. So let's go back to that. Line 52, we conditionally set open based on the status of open. So when that open class is applied, I have a very specific thing here where if the page is small, set a display block, position absolute, and all that stuff. I don't want position absolute on larger displays. So that's why in line 109, I have some CSS here for the default look, which is display none, but on larger displays, display block. So this helps a lot with some edge cases. Sometimes a user can open this, and if you spread the viewport wider while it's open, you've got to be cautious of that behavior because sometimes your open JavaScript logic will interfere with CSS. I had an issue yesterday where it would pop all over the place, but I've resolved that by segregating what is mobile, what is desktop with just media queries. So this is mostly a CSS achievement. JavaScript is only used here for state. And that's it. So that's the demo. Let's go back to our slides. And if you see any bugs or saw any bugs, now's a good time to call me out on them. So keep in mind, here's some tips to keep in your head sort of as a personal guideline from me. One, test with your users, not your team. Sometimes you'll be making a website and your coworker or your boss tells you, hey, do it this way. Try to push back on that because your users are the most important. They're the ones navigating your site. They're the ones finding information. So try to go with what they're saying. Of course, if you have an interaction designer on your team, then they'll help you a lot with that. Two, a JS-free pop-out menu isn't necessarily the best experience. There are some examples out there where people have made a hamburger menu using a checkbox. And a checkbox is kind of difficult to make a good interaction with because they designed for forms and not for on interactions This is why earlier in the slides I said avoid a select avoid form controls because those are for forms not for menus and not for on interactions Third, always place the pop-out menu near the button. It seems like an obvious thing to say, but worth pointing out. So in the demo, the hamburger menu is here, and of course the navigation pops below it. Sometimes I've seen websites where the hamburger menu is on the right and the navigation menu pops out from the left. That's what I'm trying to say to avoid. You want your menus to pop out near the interaction, near the button. This is good in general because we want object-oriented information. We want information to come from a place from the interaction, but it's especially important for screen magnifiers because if you're on a magnifier and you're zooming around the page, you get disoriented and you lose your spot. So by keeping things in close proximity to the interaction, you're doing something right. Avoid hamburger menus on desktop. Yeah, because hamburger menus are a step back away from good information architecture. We want to avoid them at all costs, but sometimes you need one and that's fine too. On desktop, you have much more screen space. So if you have a large web page with a large hero graphic and you decide to put a hamburger menu there, all that does is make it harder to find information. So a desktop, make use of that space. Try to show all your links if possible. Next, keep touch target size in mind. It's a good thing we had those quick facts, and thanks again, Patrick, for the showcase. Touch targets matter a lot. So our hamburger menu should be 48 pixels tall, and it is. So yeah, keep those touch targets at a reasonable height. 48 is the recommendation. Consider not making the nav stick to the top of the page. So sticky navigation is somewhat problematic, but it can be done well if the use case calls for it. For example, if you're making developer documentation where the user navigates very, very often, then maybe an auto-show, auto-hide navigation is okay. But if it's something like a restaurant or an information page or Wikipedia, maybe you don't have to have that omnipresent sticky navigation. So for one, it takes up space, but more problematically, it's impacted by zoom. So if the user is zooming in, or if the user is increasing their font size, that menu that's sticky to the top of the page will remain sticky. In my case it scrolls up the page which is good You want that behavior by default But imagine if this was sticky In fact what if I can fake it How quickly can I do this Position, position, sticky. And I guess at a top zero, I think. No. I forget how that works. That's okay. Display block. Yeah, I can't do this on the fly. I could try fixed. And then I set a width. 100 pixels. That's right. Yeah. So this is what a sticky nav would look like. You have to take into account other issues. For example, when it's sticky and I click on food or about, you can't even see about. You got to scroll a little bit up to see about. So you have to also take into account the offsets that are issued with this. And without JavaScript around, that's even harder to do. So it's very problematic to have a sticky navigation. Try to avoid that if you can. And that's it. So more reading. We got some links in these slides. I will share these slides. There's inclusive components.design. That's a very comprehensive resource, as well as MDN and can I use. Speaking of can I use, there is the popover API that's looming ahead. Hopefully it'll change the way we write these. it's the popover HTML API. Unfortunately not widely available yet but I'm keeping my close eye on this because the popover API might make this a little easier. Maybe. We'll see. And that's it. Thank you for learning about hamburger menus. Was that a microtalk? How long was that? I guess I'll find out afterwards. And that was MicroTox. I'll share some links in the chat. Oh dear, I hope I didn't cover the slides. Here's a link. And here's the repository. And here's a live demo. Pointer events fixed notwithstanding. Oh yeah, I guess we can test things on Lighthouse. So let's try Lighthouse.

 Lighthouse is a good, naive way to test the accessibility of your site. It is, of course, not the end. It's only the beginning. You can start with Lighthouse, but if it gives you a score of 100, don't just call it a day. You have to actually physically test it as well with magnifiers, screen readers, other ATs, real users. Accessibility scores 100. That means the contrast is good. That means the semantic elements are correctly placed. There are no warnings here. and it's good to also test this on your site as well. Another good thing to try is the developer tools. I'm not sure if Brave has these, but I'll try it anyway. So in Chromium browsers, you have the accessibility tree. It's this button on the top right once enabled. So I've turned on the new full page accessibility tree. And here it is. So when I toggle with this button, you can see the elements and landmarks. Pretty cool. But what's really cool is the navigation. So when I expand the navigation, the navigation landmark appears. If I hide it, it disappears. If I show it, it reappears. And inside there's the list, list item. The fact that it says main navigation is thanks to ARIA label, and it sells you right here in the dev tools. So this is also a good way to check to make sure things are configured correctly. But that's it for Microtalks. Let's move on to this week in discussions. All right. We had a couple of topics this week. Maybe we can zoom on by. The first one is benchmarks. Benchmarks are important, but sometimes there are issues with benchmarks. I don't have an example in front of me, but I think we've all seen some framework benchmarks, like how does framework X compare to other frameworks? How do they loop through rows in a table? Things like that. How quickly do they mount and hydrate? Benchmarks are important. It's good to keep those numbers as low as possible, but they don't... In isolation, benchmarks alone should not inform a decision. If you decide to use a framework based on benchmarks alone, then you may not have considered other things, such as what about the developer experience? What about the user experience? It may benchmark really well in one way but what if that causes a lot of network requests What if people on slow devices and other network conditions can use your built framework experience very well So I guess the discussion there is try to keep in mind the other factors. Most importantly is the user. Start backwards from the user. At least that's how I like to make decisions. If it's good for the user, then I can ask myself, is it good for the developer? and then I can ask myself, is it good for the system or the architecture? Try to start with the user as much as possible, but that's just me. What do you think? What is your process for choosing technologies or anything really? I'll get back to you if you type something in the chat. You can also join me on stage if you like to speak with your voice. Discussions are open-ended. There is another fun topic slash question asked, which is, should there be an accessibility developer profession? That's an interesting question, and I think it comes from a good place of intent. The question surrounds, what if we need to hire developers who are experts in accessibility? Such people do exist, but mostly by persistence, because when a developer gets down the rabbit hole of accessibility, they tend to become more experienced with it and more knowledgeable. But does that mean you need dedicated roles for this? My personal answer to this is I hope not because I think accessibility is everyone's responsibility. I think, yeah, everyone should learn accessibility, especially developers, because we are the last line of defense before something is shipped to production. So the digital experience that people actually experience, the last person to touch those is either quality assurance, product management, user acceptance testing, but most importantly, the software developer who's writing the code and shipping it. So it makes sense for that to be there at the endpoint of a deployment, but more significantly, it should be there at the front end. So not development front end, but the front of the project planning phase. If you're planning a project, if you're ideating something, you start usually with content. You start usually with design. You start usually with user research and sometimes product or market research. At those phases, accessibility should be discussed, is what I'm positing. Theo writes it cool to have someone you can ping though G writes ideally yes everyone knows it but we tried that Security concerns UX design every single time without fail Yeah, I'm sure everyone here has really colorful anecdotes to share. And everyone's experience is a little bit different from others, I'm sure. Personally, I've worked at small startups. I've worked at large businesses. And I've seen where these things break down. Like at a large business, we've had, I guess I would call it a luxury of a so-called accessibility prime. And that's the role we typically give people with these professions. It doesn't fully encompass their responsibilities, but their title was accessibility prime. They are the go-to person. There's like one or two of them at the company. and designers early on in their exploration would consult these individuals on accessibility advice so that early on in the design, accessibility is considered before it reaches code. That's good, but it can be better because if you involve development early on in the planning phase, you can discuss feasible interactions. You can discuss feasible shipments to production. Interaction designers are great at this because interaction designers do know a lot about how the user experiences content. And they also know a little bit of code. Sometimes they know like enough JavaScript or CSS to get by and make things like a hamburger menu. And the accessibility prime will go a step further and provide checklists, reviews. Let's say you got to test in the screen reader. You got to test in the screen magnifier. You got to test high contrast. You got to test other situations. And they themselves know what the lived experiences of some users are to help you with that advice. So, going back to the chat, let me make sure the chat's open. Okay. Having at least one person on hand who's an expert is an improvement. C writes, like most things, trying to bolt it on at the end is way more difficult. Yes. And what the Accessibility Prime, in my experience, has done is education. They would host seminars regularly, weekly. They would host office hours, and they would be always open for consultation. And I think that's a great use of their time because having them put on specific projects, one project at a time, is a bottleneck. Not only does it make shipping to production slower it doesn help the other teams learn more and do better So education is great And C writes like adding it to the end of the process this is bad And we all know it bad because when you address something very late into a project lifecycle, it's almost too late to fix things. So addressing things earlier helps with compliance, it helps with good user experiences, it helps with risk mitigation. I worked at a telecom, and we were subject to some laws in this province that I live in. And if things were not accessible, you could be sued, for example. And that's risk mitigation as well. But you shouldn't make things accessible for that reason alone. It's just one of the reasons why we hired for this role because there was a lawful obligation. But even if you don't have that, it's important to educate yourself and educate your teammates. If you know something about accessibility, talk to your team about it as often as you can. And that's all I have to share for now, but I'll read back chat messages if you have some. Yeah. In summary, I think digital accessibility is everyone's responsibility. That even includes API developers. One time I had a scheduling API service, and it took 59 seconds for a request to resolve. And that's bad for accessibility, because that means the person looking for booking an appointment had to wait 59 seconds for something. It was bad for the user experience. So yeah, even backend developers are not, I guess, defensible from the obligations of good accessible design. Alrighty. Moving on to, let's close the chat. I think I kept chat open the entire time earlier. This week in questions and answers. I found one small question from last week that I didn't have time to get to, but I have time now. The question is, how do I use layout groups? Or how do I reset layouts? So in SvelteKit, there's this concept of layouts, and there's advanced layouts too. So in routing, you're all familiar with plus layout.svelte. And that is where you have your page layout,

 You can also have advanced layouts. So on this documentation, we have concepts of groups. Groups allow you to separate routes into logical visual routes. So for example, this app and this marketing route each have a separate layout. So there's a layout that's felt under app. There's a layout that's felt under marketing. And the parentheses indicates to the SvelteKit compiler that this is not going to resolve as an actual route. So if you have a file that's source route app and then dashboard, the actual website path will be site.com slash dashboard. That's it because the group layout route does not resolve as an actual path. It's just there to separate layouts. And I have an example of this in the repository I was working on minutes ago. So here in this week in Svelte, I had to separate my layouts into these two layout groups. I have common layout and I have no layout. The common layout is for pages such as here. Let's close this and go to 5173. so this is my common layout if i go to links on a page there's a top navigation here and the reason it looks like this is because layout.svelte has this return home link in the header that's this link up here on the actual web page but then in the no layout group i don't have a layout.svelte that's global to component playground or hamburger menu hamburger menu has its own layout Component Playground has no layout And if I go to there go to component playground take a look at the route it slash component dash playground there is no upper header with a home page link it just has its own zero layout so this is great if you want to separate your application into logical layouts usually it's app or static pages that's one way to do it But part of the question is, how do I reset layouts? Another advanced layout tool in the kit is setting the page or the layout to a target layout. You can use that with the at syntax. Dante asks, what layouts are not inherited? They are inherited, and it depends on your structure. So in my example, under routes, I don't have a plus layout.svelte in source routes. So there is no inheritance to be had because there is no layout. If I did have a layout here using plus layout.svelte here, so here's an example. So if you put a slot here, then yeah, this layout here under source routes plus layout.svote, this will get inherited by all subpages. That behavior is still a behavior. That does not change. Thanks for asking. That's why we're here, to clarify stuff. And then you can use the at syntax to specify a different layout. That's, I think, up the directory tree. So let's delete this. Don't need it. Oopsie. So hypothetically, if I did have a layout, actually I should add that back because that would have been a good example. Or would it be? Let's say I had an about page. So if I make a new file called page.svelte and I use I guess about There we go We have an about route hamburger menu slash about I call it about page And by default it should inherit the layout in the directory above it So let's prove that. I go back, go to my hamburger menu, and go to slash about. Here's the about page. The menu is at the top. That all makes sense because my about page inherits the layout above it. If I don't want that behavior, I can change the name of pluspage.svelte to pluspage.svelte. Let me double check the documentation. Yes, pluspage.at. What do you think will happen? You have five seconds. Time's up. The answer is pluspage.at.svelte will jump up the directory, not inherit the layout, but at will correspond to the source roots folder, which today is no layout. So let's see what happens. There you go. So it just says about page. Just like I wrote here. Because the at symbol is used in plus page, it corresponds to the root, which is currently no layout. So if I do add a layout there, plus layout.svelte, and I do something like, something cheeky like root layout, what will happen? Nothing, because there's no slot. That was a test. There's the slot. So now it says root layout about page. The reason that works is because of the at. You can also use the at to specify some other directory. So I can do at no layout like this. And now this page will inherit the layout in no layout, which is literally no layout. But if I add one here layout I going to call it coolLayoutLayout and a slot There it is So we have the root layout the cool layout layout and the about page So what this does is it a little funny but the way this works is plus page at no layout it'll jump and skip the hamburger menu layout. So this is no longer being cascaded or layered. It's just going from page to no layout to root layout. And that's what's shown on the page. we have the page the group layout and the root layout and we're bypassing the hamburger menu layout by using the at syntax and if i get rid of all of that it'll use the full cascade of every layout there's the page there's the hamburger layout there's the group layout and there's the root layout and that is how you do layouts those are the tools at your disposal i'll share the links here. How to break out of the root layout? You cannot. So that's why group layouts are a thing. If you have a root layout here, like under source routes plus layout.svelte, everything, almost no matter what, will inherit this. So what I did for my project is I don't have this. I start my source routes folder with my layout groups. So in my case, common layout, no layout. This way, I don't have a route layout. This way, I don't have to worry about breaking out of one. I just immediately specify a layout group, and then in that layout group, I can have the layouts I do want. So yeah, there is no easy way to break out of it other than to reorganize your routes like this. Hopefully, that answers the question. If you need more clarification, I'm around. And that's it. Okay, let's hide the chat and say good day. Thank you for joining me at This Week in Svelte. I'll hang back for a minute and have a good time. Bye-bye.