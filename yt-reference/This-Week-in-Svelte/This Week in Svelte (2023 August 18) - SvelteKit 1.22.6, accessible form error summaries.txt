 Hey everyone, welcome to This Week in Svelte. My name's Enrico and joining me is Paolo. Hi everyone. You made it, and the agenda today includes the changelog. Unfortunately, no quick facts, oh, but there could be a community showcase to make up for it, followed with discussions and Q&A. Let's go. Change log time. I believe there's only one changelog in the Svelte code system today, and that's SvelteKit 1.22.6. First up, correctly restore trailing slash and URL path name for data requests. I think there was an inconsistency. If you had trailing slashes enabled in SvelteKit, for some reason, what was shown in the client store was different than what was shown server side, but that has been patched in this edition. So for those of you customizing trailing slashes, this is for you. Similarly, loading trail slash option from server, even when there's no load function so a fellow contributor made a double patch and as you can see they're linked to the same pull request and that's it changelog over yeah trailing slashes now works correctly at least for just things oh it works it actually always worked the issue was referencing the trailing slash was a bit weird sometimes Sometimes you would call for a URL path name and in the client there was a trailing slash missing. So it was just an inconsistency. Oh, okay. Yeah, referencing it didn't work, but now it works. So quick facts and announcements. I might have to pull one out of my hat because I don't have one. Do you have any quick facts, Paolo? No quick, super quick facts. Here's a super slow fact. I don't have one. Well, just make sure you're all coding responsibly. Next up is Community Showcase. I think we have a special guest today. Please join us, Paolo. Whoa, incredible. I also shared my slides, if anyone wants. Oh, this is a talk that I already shown somewhere, and it's called Shareable State. So let begin by presenting myself I am Paul Graciutti I am mostly a proud Italian I am a full stack developer I work at main matter with Svelte luckily And we also get to teach Svelte And in general, I am a Svelte lover. You can find me on Twitter at Paul Gricciuti, on GitHub at Paul Gricciuti and on Mastodon. So let's talk about shareable state. So isn't what stores are for? Yes and no, because this is not just not the kind of share I'm talking about. I'm talking about URL and URLs are very, very complex. So you have a protocol, which is HTTPS. Most of us use HTTPS, at least I hope you have a domain, which is youtube.com. Actually, the dot com part is the global top level domain. There are a lot of them, like, for example, dot com dot net. There are national domain like dot it, for example, for Italy. Then there's the path. And this is basically what allows the server to respond with the correct resource. So these HTTPS YouTube.com gets resolved by our DNS to a specific machine connected to the Internet and behind on that machine, there is a server that is listening for requests. And when a new requests come in, it's see the part and says, OK, I need to serve this specific resource. Then there are the query parameters and query parameters are basically a way another way to tell the server which resource you want in this specific case for example on youtube you are saying okay i want to watch something and i want to watch this specific video the video with this id then there is the hash part and the hash part is not sent to the server so it's just a browser thing and it allows you for example to quickly scroll to a specific link a specific an element with a specific ID on the page So what do we care about all this thing Like we can really choose the protocol at least I hope like we are kind of stuck with HTTPS We can buy a domain plus global top level domain but then that it Like we as our front end developers don't does not have much to do with domain plus global top level domain. ZaltKit help us for with the path because it allows you with the suite file based routing. It allows you to have to define what are the parts that you are interested in. But the most interesting part for us from 10 developer are the query parameters. So how do we access the query parameters inside our code? So you can use window.location.search to get basically this. It's just the part after the question mark. And you can pass that to a new your search params object. And this search params basically allows you to quickly get, quickly parse the whole search. And it has commodities methods, like, for example, search program dot get V will just get you the V part of the of the URL. Everything is a string. So even if user ID is obviously a number to you, this is also returned as a string by the search programs dot get. If you try to search for a query program that is not present, you get a null. And if you try to search for a query parameter that is there but has no value, you will get an empty string. And you can also set a query parameter. So you can use set for set. You specify the query parameter you want to set and you specify the value, which is always a string. And then if you to string the search parameters, you get the updated search parameters. So this is a lot of code, but why you should lift the state up to the URL. So the reason is because you can keep state between refreshes. So given that you have the state inside the URL, you can keep state between refreshes. When you refresh the page, the state, your state is still there. You can get a shareable link that carries information So if you copy and paste your your URL your friend will see the same thing that you see It global state without a hassle So everybody knows how difficult it is to handle global state but the state being in the URL means that the state is available to every component, for example. When not to leave the state in the URL? Well, when the state is unique to the user. So for example, if you have a specific date for a single user, it's not useful to put that in the URL because obviously, if you then share that link, the other people will not see the same page. So it's not useful when there's too much state because URLs have a limit, unfortunately, like you cannot send more than if I can remember correctly, 248 characters. I learned the hard way these because I had to debug this pretty nasty bug in my old job. So if there's too much state, you have to be aware of the fact that URLs have a limit. And obviously, if you can easily get it on load, for example, there's no reason to load the whole blog post, if you can just have the ID of the blog post and load on load, basically. But I hear you say it's not reactive. We live in a world where every variable is reactive and this thing is not really usable. Or is it? Because SvartKit developers, like the maintainers, are no jokes. So we actually have a reactive version of the search programs. And it's inside the page store. So if you import page from dollar sign up slash stores, you get a reactive variable. So how to show the value of a source params? This is wrong because you're just declaring a username variable, but this is not reactive. So this is okay. You can literally just show inside your markup this thing, but this is kind of nasty. So this is reactive, but it's not very legible. So the proper way maybe is this one. So you can use a reactive statement and save the username inside a reactive variable. So how to update the state? So this will not work. It will just not do anything. This will work. So if you use...

 go to you can literally navigate to a new URL with the updated state but you have to be aware of the fact that this will delete the other state like if you have multiple states you have to repeat all of them basically this kind of work but there is a slight catch because all the query dot to string, remove the question mark at the beginning. So you have to add it again. And obviously, you cannot bind the value of the username to an input, for example, because this will update the variable here, but will not update the URL. So this is how you should probably do it. So you have to save the variable inside the username. you have to update. You have to use the value inside the input and on input update the query parameter. Remember to adding the question mark. And also you should keep focus and no scroll because otherwise you will lose focus. But even then, it's a lot of boilerplate for every new piece of state. Every value is a string. So it's also type as a string for us that use TypeScript And let's be clear who does not use TypeScript. So it does not have to be that way. So drum roll, because I'm showing you SvelteKit search params, which is my library that I wrote. What is SvelteKit search params? It's the easiest way, in my opinion, to read and write to the query parameters. It's customizable, so you can you can do basically what you want with the query parameters. it's reactive, it's very dev friendly, because it has a lot of commodities is built with TypeScript in mind, because you actually get proper typing of your search for arms. It's teeny tiny is less than one kilobyte. So you can install it with npm installs belt kit search for arms. And the marvelous dash d that it's very common in Svelte application. Now this is actually not needed anymore Like if you are running a very old version of SvelteKit you need to include the VIT plugin for SvelteKit search params because that gets search params uses dollar sign up from SvelteKit, and you need to externalize that dependency, but this is not needed anymore. And this is how you very quickly can recover the username query from from the URL. So you import query from from SvelteKit search params, you initialize these username, which is a store, and then you can bind the store to the input and to the username. And by doing that every time someone type on the on the input, you will get an updated URL with the new username and a new value inside the store. You can also write encode and decode functions that basically allows you to convert from string and to string. And basically, this is because now count is actually a number. So you can actually do $count++ and TypeScript won't complain. And also, this is why I say that is developer friendly, because we have encode and decode helpers. So if you import SSP from SvelteKit search params, we have sort of SSP.boolean. So in this case, is present is boolean. And you can see because you can bind to check it. And we have ssp.object, for example, where you can pass a generic. And by passing this generic, you will get that example shape. So you will get autocomplete, for example. And obviously, you can bind to user.name and user.lastname. You have to check if user is there, but it's just how it is so uh how those helpers work for example the object one that we have already seen you get dollar sign object dot is complex true for example so it basically encodes the url like this and you will get this work for nested value too you can map an array so something like r one two three four will be mapped to dollar sign r being one dollars and r one being being etc You can map to number you can map to Boolean. So for Boolean, if the query parameter is present, and it's different from false, it will be true. So even if it's bool equal something else, it will be still true. There is exported string, but it's mainly for readability since all query parameters are already string. And then if there is one interesting one because is lz. So you can do ssp.lz. And this is a common way to represent JSON serializable state inside the URL. For example, this is what the TypeScript playground uses. And also, for example, solidjs playground uses so you can get a shorter version of the string and also it's not very legible so it's maybe cooler to share a link that does not have the whole state in the url and this basically gets converted and converted back so in this case for example this URL will map to $state.value being my cool query parameter. So this is, in my opinion, really interesting. You can also have multiple query parameters. So, for example, if you import query parameters, this basically returns you a store. And inside the store, you have every query parameter. And you can also specify some required one. So, for example, if you know that you will have a username, you will have dollar sign params dot username here accessible. And you can either pass a boolean here or an encoder and decoder. So you get the correct typing basically. And then that's what I just said. So that's basically the gist of it. You can find the slides at those links and you can check out the repository for the library. It's paolo.rechuti.com. But that's the gist of it. Thank you. Everyone give Paolo a hand. Emojis with hands in them saluting clapping you name it And I think Paolo are you going to accept some questions Yeah Cool I think I start us off I noticed that you had Anyone that has questions feel free to join the stage and we can talk about it. That's right. At this weekend, Svelte, joining the stage, raising your hand is welcome and encouraged. So back to the setup, you mentioned there was a Vite plugin. Is that still needed today? Yeah. As I mentioned, it is not needed today because The only reason it was needed, it was because basically I had to externalize SvelteKit's search parameters of dependency because it makes use of $signup slash page and $signup slash navigation. So before SvelteKit, I think it's even less than 1.0. I had to externalize the dependency with Vite. But nowadays it's not needed anymore. Okay, so let's look at the comments. The Grish writes, the URL as the primary means to store app state is unfortunately an underrated concept with modern frameworks. The amount of websites you reload and land somewhere completely else is bonkers. Having a lip to stream like that is awesome. Thank you. Yeah, that's basically the reason why I created this library. I mean, as usual, I guess, because I think in open source, most of the time you scratch your own itches. Like I had to use the query parameters and it always felt wrong to me that you have to write so much code to have the query parameters. And I said, wait a moment, I have that store in my disposal. So I started to write this store and then I realized, well, maybe this is something that a lot of people need. Yeah, that's a great idea. And in fact, I can see myself using it soon. Right now I have a table search and like a debouncer. So every time the debounce executes, I use goto to change the URL and I use a backend load to refresh the page. So with client-side JavaScript, it just works without refreshing. But with your library, I can have the query params change in real time, which could make copying and pasting and sharing a bit easier. Yeah, that's also basically the same thing that you do. So I literally navigate your page to the new query parameters. So this is, I think it's very important because if you try to manage everything with effects and

 updating the URL at the same time of the state, it's all messed up. Instead, it's much more useful to have, it's much more useful to have the state be derived by the page. So actually, whenever you set a new value for that store, I literally navigate you with go to. And obviously I also add that this is a quite old presentation. But I also added the ability to debounce the entry on the history because maybe you are searching inside an input value and you don't want your user to have 20 entries on their history. So basically you can debounce the history entry and have the history entry just after 200 milliseconds that you stop writing. interesting point are you using the window history api or using goto under the hood i'm using goto okay that's why it's a svelte kit proprietary library i get it now yes exactly okay we have another comment in the chat how does the back button work with your library will i get the old state with every back push it sounds like yes what's your answer yes and actually obviously if you debounce it, like you will get just the before the debounce state. But yes, if you go back, you just get the old state inside your application. I see. So the debouncer is something you opt into because every keystroke is a new history state by default. Is that right? Let's say you bind your store to an input and you change the query param on keystroke, then each keystroke is a new history state. Exactly. Exactly. And to avoid that, you can specify the bounce timing, basically. And so it just... By default, it's zero, I guess. I don't remember, actually. But by default it's zero, and then you can up that time so that not on every keystroke you get a new entry. Very cool. Thank you again, Paolo, for presenting. I will come back soon because I have to connect my laptop. So, okay. And that was your community showcase. Moving on to this week in discussions We got no discussions today It going to be a fast one We going straight into this week in questions and answers related to Svelte And today I have something to present. Let's bring it on screen. The question for today is, what's the ideal pattern for handling form errors? And by pattern, I mean specifically user-facing pattern. Let's start up my code editor, and I'll show you what I mean. Welcome back. So when it comes to form errors, one of my beacons, so to speak, or my inspirations, is the gov.uk design system. And here they describe error summaries. When your form has an error, the user has faced an input error, it's a great idea to include an error summary at the top of the form. So for example, here it says there is a problem. And then in this error summary, there are hyperlinks that take you to the first error, the first respective error. Yeah, this is great stuff. I'll show this in the chat, of course, because it's a wonderful resource. There are also other very good resources. This is just one of them. So what I'm going to demonstrate today is how to build an error summary and what is involved in it. Because what this does is it accompanies your input-specific errors so that the user can jump to that. It's very screen reader friendly. It's very screen magnifier friendly. And you'll see why. All right. The text editor is on the way. Let's zoom into it. and let's start the server and zoom in. You can see the frames per second. I press zoom in and it takes five seconds to zoom in. Okay, we're good. So in the browser, we'll go to localhost 5173, and we'll go to the progressively enhanced form. Don't mind the debugger information here. This will not appear in production. So in this dynamic form example I shared in a prior week what I want to demonstrate here is the error summary So what I do is I submit the form and then immediately I see an error summary The error summary says there were errors in your submission. The content guideline here is to just write there's a problem. That is also very acceptable because you want to keep your heading very succinct. In the demonstration, if I press tab, it immediately jumps to please fill your name. And if I press the Enter key, it jumps to the input. So under your name, it's the label. And then there's this context-specific error in between the label and the input. Not below the input, in between. This is an important detail. Let's zoom in some more. So now I'm in the input. I can enter my name. I'm Paolo. And then I can submit it. We're good. but if there was an error, then there would be the error summary. So let's talk about focus management. Another detail is when I submit the error, focus management is given to this error summary, and when I press the tab key, it jumps to the first link. That is why that works, and when I press enter key, it focuses on the input, supposedly. Let's try that again. a little bit of nuances here it's probably the dev server but let's show you some code shall we so in the code we have the form i'm going to show you in a few different orders we'll start with the form. On line 97 to 109, this is the input that I want an error to be shown in. So the label is here, and I'm using an externalized label. So this HTML label is not wrapping the input, it's just a sibling of the input. And I'm using the for attribute to make it particularly linked to this input here. So on line 104, the ID is name field. On line 97, the for attribute is also name field, connecting these two. I actually tried wrapping the label over the input and that caused screen reader issues on Safari and VoiceOver. I'm not exactly sure why, but I think this goes to show that the for attribute is more reliable for screen readers. And then it says your name followed by a conditional error. So if I have an error in my form response it show the error name The actual coding doesn really matter You can do what you prefer You can use any schematic you prefer I just happen to use plain SvelteKit at my disposal. And when I submit the form, we got to find the error and log it to the page. So I'll show you the named action here for submit. It's very short. When I call the submit named action, I parse my form data and I generate a errors object. I could use an errors array. Really, it's up to you. It's personal preference. But here I do errors.name equals please fill your name. My name key is corresponding to the name input. And the please fill your name message corresponds to the error message. So that way on the page, I can say error.name here, and that outputs the error message. So finally, if the errors object contains at least one error, it'll return the fail function with a 400 response saying success, false. These are all the form items, and these are my errors. Now let's go back to the page and see how those errors are handled. At the very top, we have line 7, export let form. And I have a reactive variable in line 19 called errors. And it's just a wrapper of forms errors. And if errors is undefined, it'll return an empty object. This is just for some ergonomics I like to have. So I can always call in errors and not have to constantly use optional chaining to check if something's defined or not. I can just use the empty object as a default. That's the reason I did that. It's all personal preference, really. So don't worry about that too much. What really matters is the error summary. So in the error summary, I have this summary wrapper on line nine, and that corresponds to the error summary wrapper in HTML. Way down here on line 60. This is the div that wraps the error summary as well as the success dialog. On line 60, I use bind this, which is a Svelte feature for calling the HTML element. That way I can utilize focus management. So if the form values do update, then reactively, I can see if form.success is true or false, then focus will be called. If focus is an async function up here, that will await tick and then set focus to the summary wrapper. Enough code. Let's look at this in Safari.

 as I'm on Mac OS. And Safari works a little better for these things. Here we go. So now I'm going to submit the form again. There's the form summary. It should technically be focused. And then tabbing to the hyperlink and then pressing enter should move on to the next element. The hyperlink itself is part of the children here. So it should have a hash link to name field. And in the address bar, it's a little small to see, but it says hash name dash field. So you know the hash link is working. Now let's try this with the screen reader. Three, two, one. Maybe I have to toggle it explicitly up here. Voice over. Okay, we're on Safari. I'm going to refresh the page. Good, we're going to submit it again. Alright. So, actually I should do that slowly because I cut it off. Okay, so after pressing enter on submit form, it says there were errors in your submission and one more item group. So now the screen reader focuses on the first heading, and you can see the blue outline. It's very faint. There's a blue outline around the error summary, and there is a screen reader focus on the first heading. So, so far, so good. Let's go press the... I'm going to press Control-Option-Right Arrow to go to the next item. We're in a list. We're in a bullet. And now we're in Visited Link. Please enter your name. I'm going to press Control-Option-Space to activate this. your name. Now it says your name, please fill your name, invalid data, edit text. I'm focused on the input. I'm able to start typing things like Enrico. And the screen reader did announce the error. It said that the input was invalid. It read the label and it read the error message saying, please fill your name. And there's a question in the chat, which I will get to as well. VoiceOver off. The reason why it said the input is invalid is because I also toggling the attribute on line 108 ariaInvalid equals bangbangerrors That a lot of stuff So if the name field has an error or an error message, this is a truthy value, and then this would resolve as ariaInvalid equals true. If there is no error message, then it's a falsy value, which would resolve as ariaInvalid equals false. And the ariaInvalid tells the screen reader that this input is invalid. This goes hand-in-hand with the actual error message. So that's the end of the demo. And really the message here is try to have an error summary. And the question in the chat was, what happens if I wrap my input with the label instead of using for? I will show you. So I will move the label as a wrapper. I will delete the for attribute. And I'll show you the effects of that. quick question by captain is aria label or labeled by i'm not using either of those actually i'm just using aria invalid because the label is using is using the form attribute i don't really need to apply an aria label aria label is sort of an instead of and not in addition to okay so the code is saved let's go back to safari and i will show you what happens Oh, replace the anchor on your summary with a label. Interesting question. Can you elaborate? Like, what kind of code are we talking about? Instead of please fill your name being an anchor tag to the input, you just use a label there. So right now it says please fill your name. What should I replace that with? Instead of an anchor tag with a label. A label. focus on the input when you click on that oh so like label for equals name and then it'll focus on the input yeah exactly we can try it together i'd have to test that because i'm not sure what the effects of it would be but yeah when in doubt yeah thank you for clarifying paolo so yeah when in doubt just test because i'm not sure objectively that's a good idea you have to like try the screen reader experience to ensure it's an effective idea. It's an interesting one, so I will try it out with some live coding. Step one, let's answer the question of what happens if label wraps the input, and then we'll try out that label suggestion next. So I'll activate the screen reader. Three two one there it is And we back VoiceOver on Safari Leaving to visited link Okay, we're back to the link. Please fill your name, list one item. I'm going to press Control-Option-Space to focus on the input, and we're going to find out what happens. Your name and one more item. Invalid data, edit text. It says your name and one more item. Invalid data, edit text. So the and one more item is sort of implied as the error message, which is please fill your name. It doesn't actually read it to me. It just says, oh, there's more inside of this label that could be read because it's a separate DOM element. So that's the difference in the experience between wrapping a label versus applying the for attribute. VoiceOver off. This is something that is always true, like because it's very common, I think, to wrap your input inside a label. But I think if you are getting this kind of behavior, generally, I think it's far better how you did it, like move it as a sibling element. Yeah. I'm using this resource as a reference. This is not like a perfect resource, but what it shows here is there's different screen reader support for wrapping an input with a label versus using the forer attribute. And I'm trying to see if there's a clear message here for that. It says correctly compute the name, explicit label, implicit label. So the testing results here show that an explicit label, which means using the for attribute, I'll click on it for double checking. Explicit label down here is with the for attribute. So let's go back. voice control support for must correctly compute that accessible name it's supported mostly across the board except for android voice access this might be outdated see this is why it's not a perfect resource because android nowadays uses talkback by default and dragon naturally speaking does not work consistently with the implicit label which means wrapping your input voice control on mac os as i just demonstrated on safari on mac os implicit labels don't fully read the label. Let's go back to the show. What if you do both? Like you drop the input and then use the form. What if I do both? Well that the kind Yeah you drop the input That kind of the mad science experimentation we like to do here don we Let's try it. Yes. Okay. So I'm doing that. I'm doing both now. It's wrapping and it's explicit. What happens? This is what I mean by testing, because I don't have all the answers. I just know what to look for. VoiceOver on Safari. Dynamic form. Okay. Visited. Your name and one more item. It says your name and one more item. So it still applies as an implicit label. Visual Studio Code. VoiceOver off. Let's change it back. One question I have is I've seen that you are focusing with JavaScript. There's a way to do it with just HTML so that even if JavaScript is disabled, users still get the focus on the error message. Are you proposing autofocus? I don't know if autofocus is good because, I mean, it has accessibility, like, it's always a bit sketchy to use autofocus, but, like, will it work on non-input values or non-input elements? also? It'll work practically anywhere, but it's not recommended because when the page loads or gets refreshed, it'll always get called. And if you change something like client-side navigation or history, I cannot predict what will happen. But I appreciate the chatter in the chat because this is not a complete example. In fact, I'm missing something. At the very top of the page, there's the title. When there's an error, you should have an error at the title of the page, such as errors. Where is it? Errors. Object. Keys. Errors. Dot length is greater than zero. Then I can say error. Otherwise, nothing. Errors. Okay. So now the title of the page changes too. So right now it says, Error dynamic form, which is good because when the page refreshes after a non-JS form submission,

 The first thing the screen reader reads is the title of the page. So the title of the page will also say error. Let's go back to the chat. I think I missed a few comments. Discord is censoring your name. So if I didn't or if I did answer your question, please let me know. Captain writes, ARIA label labeled by to not require the prompt be above or in the label element coupled with ARIA invalid. I think that's viable, but you'd have to test it in NVDA and JAWS as well. I don't actually know if that's going to work consistently across the board. Nowadays, it should. I think since 2022, screen reader support has been very good. But testing yields the absolute truth. Let's try it out. One last test. So if I go to the input, the name input, and I do ARIA labeled by, and I give an ID to my label. Maybe. It seems a bit redundant, but it could be interesting. Is this in addition to the for attribute or instead of the for attribute? I'm not sure what the proposal is. But let's try this first, and you can clarify in the chat. See what happens Back to the link and pressing control option space Now it says your name please fill your name invalid data Of course it works because I already have the for attribute. So let's try the implicit label and delete the for attribute and see what happens. It might be recursive, for all I know. All right, we're back. Control-option-space. Your name. Please fill your name. All right, it works. So Captain Scientific Theory of ARIA Labeled By is showing to be working well on voiceover. You should also test this on JAWS and NVDA to prove that it works across the board because that's what testing is all about. It's manual testing. And that's the end of the demonstration. And by the part that HTML is the most difficult programming languages. HTML is the hardest programming language. That's why we all need Svelte. Yes. Okay, that is it for Q&A. That is it for a lot of things. Let me move the chat away and wrap it up. Thank you, audience, for helping me out with that demo, and we'll talk again soon. Bye-bye.