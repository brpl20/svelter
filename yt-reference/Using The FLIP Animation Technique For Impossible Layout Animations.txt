 Hey friends, what's up? Today I'm super excited because we're going to talk about one of my favorite things, which are flip animations. And not only that, but we're going to make a simple flip animation library using the web animations API. And if you aren't aware what are flip animations, there are these beautiful transitions that we can use to animate things such as CSS Flexbox, CSS Grid, and etc. We can animate anything that otherwise wouldn't be possible using regular CSS while still being performant. And in the past, you might remember that I already made a video about flip animations. So I made this video, Impossible Flip Playout Animations with Svelte and GSEP, which you can check out because GSEP already has a wonderful plugin for doing just that. But in my case, I actually have my own animations that I want to do and I just want a simple flip animation function. And I already made a video in the past about using view transitions. And it's really interesting how almost a year ago, I had people in the comments saying, why would you even use flip when there are view transitions? and a year after that Firefox and Safari haven't still expressed interest in implementing view transitions it only works in Chrome to be fair Chrome owns like 60 or more percent of the market share but there's a couple of problems with view transitions they don't even work with SVGs which is a really huge problem because I absolutely love SVGs let's just really show you that that is true so in this last video design for developers I made which you should also check out here I'm doing this wonderful animation using my library Animotion and this was really a pain to animate first I had to set all of these properties at first, right? And then I had to animate the X and Y position, which was really repetitive, and it really took me a while. And let me show you what I mean. Here in this last one, where I'm going to animate these circles, this is what I mean. So this was really tedious to animate. And instead of doing that, I can just spend two seconds using flip animations, which to be honest, I should have done here, but some cause fallacy. I was like, okay, I'm not going to use flip at this point. And if you're familiar with Animotion, you might be thinking, doesn't Animotion already do flip animations? And that is true. For example, if we go to the docs here, if we go to auto animate here you can see when we go through these slides thanks to the flip animation technique we can just get these wonderful magical transitions but the problem is that you have to put things on separate slides right i actually want to control the flip animation technique itself in this smaller animation so that's something wonderful and the flip animation is also used when i animate these call blocks here so it's really something wonderful and absolutely powerful but speaking about this example from the video let me actually show you how simpler this can be So here I have this grid example but I just going to go here to SVG And here I have these circles you don see but they stacked on top of each other and here i have this layout simple state and here it doesn matter how you update the dome which is the most magical part you can replace a class you can hide or show elements it really doesn't matter the only thing we care about is the before and after state in the first layout here we have these circles stacked on top of each other and now i'm going to show you if i switch to the second layout here we're going to have this grid of circles right so when i save this you're going to see this and now we can animate between them so here I'm going to use our simple flip animation library I passed a duration and even a stagger so it looks even more wonderful and now we're going to update the DOM so this can be anything removing or adding a class changing or showing hiding items right and then I can just go here I can say circles flip and let me just say delay 600 milliseconds and then I'm going to save it and let's go here and you're going to see like magic with this stagger this is going to animate and this is also a promise so we can await it so we can do procedural animations which i love doing using any motion so we can also just go here we can say layout one and let me just copy this over so i'm going to say flip circles and maybe in this case we actually don't want the stagger so we can just override the previous values and let me just do this so now we're going to see the circles are going to beautifully animate and then they're going to go back to the first layout position and this is the power of the flip animation technique all right but before we get started writing any code I think it's really important to understand how simple the flip animation technique is and the flip animation technique was coined by Paul Lewis in this post years ago eons ago at this point right so let me just close all these tabs and I'm going to show you in XCollege. So we can pretend that this is our viewport of the browser here right so here we have our first and second position and of course in this example this might look trivial because these are just two items we can just use CSS regularly to animate it but we can imagine that maybe this is some justify content start or end so we can animate impossible layouts right so the first thing you're going to do in the flip stands for first so we're going to use get bounding client track to measure this so we're going to get the x and y coordinates and we're going to get the width and height right so here we're going to have 400 and 400 in this example and then we're going to measure the second position like this so this is the last in flip right and then we're going to measure this so this is for For example, in the X axis, this is 800 and the Y axis stay the same, right? So now we just need to get the difference. So the difference between 400 and 800 when we subtract them is minus 400 So the trick with the flip animation technique is now that we invert it So now we can take this item we can put a transform with a translate on it that has negative 400 because that's the difference that we measured. And now we're going to pretend that it's the initial position. So we can just move it over here. And now the last part of the flip animation technique, which is play when it's time, we can just animate this going from minus 400 pixel to zero pixel using this move translate transform. and this is what a flip animation technique is. It's a really simple but powerful concept. Alright, so let's start simple. Once we solve the basic example, everything else is going to fall into place. So here you have this box that you're going to animate from the left to the right side. As you can see, the markup is very simple. In the first layout, I have flex start, box small and the second layout, I have flex end and box large. And this can be anything you want. You can change a CSS class, maybe using a variable like start and that is perfectly fine. You can do whatever you want, right? and in the CSS here you can do whatever. Let me just show you here. I can set background gray. So you can see this is just a container, so we're centering the items in the middle, and then when we change this layout from layout 1 to layout 2, for example, it's just going to go to the right, and nothing special. So you can start implementing the flip animation technique. So here I created this simple flip.ts file inside of the lib folder, so you can just scaffold our regular Svelte or SvelteKit project. It really doesn't matter. Here I'm just importing some types in advance for people who don't care about TypeScript. And the only thing I should explain probably is this linear easing function. So here this linear function is a new function in CSS for creating more natural animations in CSS. So before you were limited by a couple of easings in CSS, including cubic bezier, which only had two control points, I think. So that wasn't really expressive. But now you can mimic bouncy and spring-like effects in CSS, which makes your animations look so much better. And this looks complicated. Of course, I didn't do this by hand. there's this really awesome site, linear easing generator. So you can pass easing functions as functions or even as SVGs. And then on the other side, you're going to get the CSS that you can copy paste. So I'm also going to include that in a description if you want. But yeah, let's get to implementing the flip animation technique. All right, so let's go back to the code. So here inside of our flip file, I'm going to create and export a simple flip class. So I'm going to say export class flip. And that's basically it. If you're easily intimidated by classes, don't be. they're just fancy objects and nothing else. They get a bad reputation from people abusing inheritance but there no inheritance here they just a simple object that can encapsulate methods and whatever else you have so here i just going to create a simple constructor and that basically it this is just a way to initialize some things in your class so for example i'm going to have a selector which is going to be a string of course you can also pass a DOM reference if you want that's perfectly fine but in this case for right now i'm just going to pass in a string so we can query it and then i'm also going to have some defaults for the animations and then we can create properties on this class or object right so we can say here selector and then we can say defaults and right here if we go we can just say this so we're referencing the properties on the class or object itself we can say selector equals to the selector repath that's it nothing special then we can say this defaults equals defaults and that's basically it and now we're going to create the flip method so the flip method is going to accept options so the same as before so we can override the animations option if we want so let's get these options out of the way so we don't have to think about them so here i'm going to destructure them but first we're going to create this like mega object of options you're going to spread these defaults so what we passed initially in the class and then we're also going to spread the options which are going to override the defaults and that's basically it so now we're also going to define some defaults that we can just pass in so those are going to be duration which is going to be one second and then we're going to have a delay which is going to be zero let's say we also have a stagger right so we're going to say zero for the stagger and then also for the easing we're going to pass this linear easing from before and that's basically it now our options are done all right so there are two steps that we actually have to do and let me just make space here inside of our flip method so let's query the element and then we're going to measure it so we can just say const element document query selector so what is the query selector, this dot selector that we pass to the class, right? As I told you, it's really not that intimidating. Alright, so how do we measure elements? Well, we can use this lovely API get bounding client correct. So in this case, we can say const measure, we can say element get bounding client correct, and let's just console log it out, but you're going to see there's going to be nothing here because we actually have to use our class, right? So let's go back to our component. So here I can just say const box equals new flip. So this is going to get imported. and we're going to target the box class, right? And we don't need these defaults here because they're unnecessary. And we can just say here box flip so we can invoke the method. Nothing fancy.

 let me just save this, so now when I open the developer tools, we can actually see we measure this element, right? So now when we open this special DOM rect object, this is some weird class, right? It's not even iterable, so we're going to have to do something to spread the values. So you're going to see here we get bottom, height, left, right, top, width, and if you remember from before, in Ascalger, this is exactly how we're going to get these coordinates. We don't really need to do nothing fancy, right? It's simple as it gets. Alright, so I'm actually going to create two methods here to help us. So inside of our flip.ts file I'm just going to go here at the top and I'm going to create a rect method so this is going to be the same thing as before and let me just do it like this and then we're going to also have a measure method so we're going to say measure and that's going to be it so here we're going to query the element and then we're going to return it back with the measurements so actually we can just go here and then let's just EOing this line, so we can just go to the top, and now we can say const rect in this case. So, this is some really weird thing that we have to spread. We can really do it like this. We can say return x and then we can say rect x, and oh my god, this is already so tedious, but there's actually this really simple trick that you can do when you have something that's not iterable, so we can't spread this or whatever. We can just use this special function to JSON, and this is going to create this as a regular object, which we can spread and do whatever you want with it so that's really great and then besides returning this i also want to return the element so we can do more things with it so let me just return this object i'm going to return this and let me just spread all these values and now we saved a bunch of work all right and now here inside of measure again we can join this again so we can also instead of defining this let's just return let's invoke this track because we want to return the measurements by querying this element. So it's more clear. Let me just take this. And I can say const element or target whatever you want to call it. Let's just say that it exists. And now we can just pass this rect element. That is basically it. So now we can close this and now we created something reusable that we can use here. So let's for example say const from and now we can say this measure. So this is going to measure the from element, the starting element because that's the only thing right now that's on the screen actually, so if we go back here, even if we say for example, layout one, this is going to be this And now when we go back to flipDS let just also look out console So now we going to get this measurement So we can see here the first element it will have to return this element And here we have bottom, and we get all the measurements, height, left, right, top, width. And now we can use this for a flip animation. All right, but we're going to run into a problem which is specific to JavaScript frameworks and how they render things or how they batch updates. So for example, let's say that in our components, so we want to flip this thing okay so we say that layout is 2 now we have box flip let me just save that and here i'm just going to say cons from this measure and i also want 2 so i can say this measure so i want to measure it first when it's in layout 1 and then when it's in layout 2 but we're going to see there is going to be a slight problem so let me just log this from 2 going to do this and now actually if we zoom in you're going to see that it just captures this box small and why it is? Well, because we're trying to do everything on a single frame. And what am I talking about? Well, let me actually explain this to you. So let's talk about request animation frame, which probably no one knows how it works, right? So here in our example, let's first define what is a frame. So basically your browser is like a first person shooter, right? It runs at a certain frame. So things are painted ideally one second, right? So 60 frames per second. So one frame is 16.6 milliseconds. So the problem here is that we're trying to do everything in this single frame. We're saying const from equals measure and then we're saying to measure while this second box doesn't even exist. So the request animation frame, I actually had no idea how it completely worked until recently, but it made perfect sense and it's actually in the name. How beautiful is this frame? It says request animation frame. So here we're going to say const from equals measure. this is going to be on this frame and then when we say request animation frame we're going to measure it when we request this other frame so we're saying to the browser okay do all of your logic everything that you need to do on this frame and be ready on the second frame for something new and that is basically what request animation frame does alright so let's go back to our code and I'm going to yoink this line so now let's just use request animation frame here we can say request animation frame and we can also based inside of here and that's basically it and Svelte also even has a special function for this and it basically works the same as request animation frame you might have seen or used it in the past it's tick or something like that and you can say then or you can await tick and then you can do something else And basically this is the reason why these things exist in these frameworks It how they batch updates And using requestAnimationFrame is a good practice in general just so we know that all the work is done, and then we can do something else. All right, but now let's see if this actually works. So now we can say from to, and let's just save this, and now when we go back here, our page inside of our developers, we can see now we measure things exactly how it's supposed to be. So first we capture the small box and then we capture the large box. All right, so there's only one step to do. So now that we measured the from and to state, now we just need to invert it. So if we look here at the diagram again, so here we have this. So now we measured first, last, and now we just need to translate this to the first position and then we can animate it and that's basically it. So let's do that right now. And I'm going to create a method called invert. so I'm going to say invert and not CSS math invert just invert nothing special like that and let's see so we're going to pass it an element we're going to pass it from that's right we're going to pass it to which is erect and we're also going to pass it the animation options and that all looks correct to me how beautiful is this friends all right so we have to calculate the difference between the x and y coordinates and that's basically really simple so we can just say here const we can say dx and now we can just say from left minus to left and we're going to do the same thing for dy but we're going to say from top minus negative to top right all right so let's actually log this values just so we see that it works so we can say dy and then we can go back here and instead of this console log we're just going to invoke this invert right and then we can just pass it these things that you need. So of course you want to pass it the last element that's what you want to flip right? Flip animation right? So we're going to pass it to .l that's why we return the element from the rack so we can do more things to it. Then we're going to pass the from and to measurements and then we're going to pass it some animation options like duration, delay and easing and that's basically it. So let me just actually go here and I'm going to save this and now we're going to see that we get this difference. So now actually when you debug something like this of course we can go here and then let's just say if i say let's just use translate so you can say minus 600 px as you can see we actually translated to the right place all right so let me just go back here to the console refresh for good measure right all right so now at this point you can actually use any animation method you want You can use Motion1 you can use G you can use AnimeJS whatever But in this case I just going to use the good old Web Animations API because I feel like it. Alright, so the only thing we have to do here, we have to say Element, Animate, and then we can pass in the keyframes here, and then we can pass some options. So let's actually pass the options here so we don't have to think about it. So let's spread the options that we passed, and then so we don't have to do something like this for example element transform because you have to set the element immediately to this so we would have to set the translate here but actually since we're using the web animations api we can pass in the property here so we set the animation to the first initial value so there's this handy method we can say fill and then you have a couple of options and one we want is backwards so this is going to immediately apply the first keyframe all right cool and now we can just specify the keyframes here. Alright, so let's see. First we're going to say width in this case. So we're going to say from width px and in most flip animations you're going to see people animate scale for that buttery smooth performance but scale has a lot of problems and I'm actually working on a complete explainer video on flip animations where I'm going to explain those things more in detail but in this case it's actually just easier animating width and height for a small penalty in terms of performance. Because in general when you're using animations you want to use transform because it runs on the gpu so you can offload it these animations when you're animating with height it's a bit jerkier you don't really notice it when it goes fast right but it actually saves you from a lot of problem scale causes like distortions borders and etc that you have to fix yourself so we can just use width and height in this case all right so we're going to do that let's see if this is right and here is actually where we use flip so we can say transform and now we can just say translate so don't forget when you translate in when you input dx dy don't forget to put in the pixel value otherwise you're going to run into some surprises and then actually while we're here let's just copy over this block because those are keyframes so from two keyframes right and now we're going to change this from here to two so this is going to be really simple to animate the width and height and if you remember the flip animation technique so what we want to do we want to go back from here where we have translate minus 400px we want this to go to 0 and this would work really great if we just left it or set it to none but I actually want to be explicit so in this case I'm just going to say here

 0 pixels and I'm going to set this to 0 pixels. And believe it or not, that's it. This is our basic flip animation library. But you're going to see we're not done yet. But actually, let's see if it works. So let me just save this and then let's go here to our tab. As you can see, let me just... I'm going to even close the develop tools. As you can see, it works. Kind of, right? The problem is that this element is in the document flow, right? So what do we have to do here? Because we're animating width and height, we actually have to set this element to be position absolute while we're doing the flip animation technique. Alright, so going back to our code here where we have access to the element we can just say element set attribute and now let me just actually do it like this so we can see what's going on and then let me just autocomplete. So we're going to say position absolute so we're just setting some basic styles on the element itself, nothing special. We're going to say position absolute top we're going to use is from the last element so it measures properly and then we're going to do the same for the left width and height all right so let's save this and see if things work properly and again we have kind of the same problem so what i love to do to debug these sort of things let's go here to the component and i just love to set a long duration so let's just set something ridiculous like 20 seconds and then let's tab over oh and we can see our animation is working okay well i have a hunch actually so we can go here and let me just set the delay something small let's save oh and as we can see for the first time it's not a shitty code but the animation just happens to run so fast that once we tap to it it's already done all right cool that's good to know but let's just clean this up so we can take this and let's just create another method let's create absolute this is going to do it for us so we're going to pass in the element and the two and then let's pass set attribute and now we can return a cleanup function from here which we can invoke. So we can say element remove attribute style and this is a bit sketchy if the user already has some styles in this case I really don't care but maybe we should do this more carefully in the future. But okay so now we have this cleanup thing and now we don't have to do this here anymore. So we can say here const remove style so we can get the callback and we can say this absolute and we can pass in the element and then we can spread the measurements from two right So now we can just position it absolutely And let just save this and see if everything works the same as before beautiful let see it again awesome so how can we run this cleanup well the web animation api returns a bunch of things so we can say here const flip not flip open but flip and now here we can go here to the end and now we can just use an event listener so let me just make space so now we can say flip we can use add event listener i'm just going to say on finish that's going to be basically it. Let's just complete this. And now here we're going to run this cleanup. So we're going to say remove style. And let me just save this. I'm going to go back here and let me just see that everything is clear, right? So if we inspect the element, let's see, once it's animating, it's too fast, but right, we already saw a glimpse of it. And then it just removes the styles and basically everything works beautifully. All right, so we're done with the basic example. We can even remove the background here to appreciate it in all of its glory. So we can see it looks like magic. But actually, let's now figure out how we can animate multiple items. So let's go back to the grid example, and we can see here we have this grid, and as you can see, it doesn't really work as expected, because we actually have to query multiple elements. So here I'm going to close this file, and I'm going to open the grid one. Here I have this example, and I'm just going to query box, and really nothing special here. Here I have just grid. I'm using this data layout, so for every box here has a child so you can see there are no distortions when we have children element and etc so you can see this is just a simple grid that uses a grid template areas so when the data layout is one we have this layout and etc until layout six or seven right and that's basically it nothing special here as i said you can do anything and you can flip any animation right so for example if we go here here it's layout you can look at layout one for example then we have layout 2, 3, 4 and etc and we're just going to animate between those layers. But right now the problem we're facing is that we're querying only one element so we can actually fix that really easily. So let's go back here where we measure things and instead of L let's just say else and we can say query selector all. That's basically it and now we can pass back else. But in this case, what we also have to do, because this isn't just a regular array, but some weird HTML element, we can say array from, so we can turn whatever we get back from this into an array. And then in this case we can loop over every of those results and return the measurements So how can we easily do that Well we can just remove this We can say map and we can just say distract So we're going to just pass in this method here. And now we're going to get a measurement for each of the query elements. And now this is really simple. So we can just remove this code. We can say return array. And if we save this right now, it wouldn't work because we actually have to loop over the elements. so we can go here where we invert the values and we can just use a for loop here so let me just yoink this and let me just make space so it's not confusing so let's just say for and then we can say let i and then we can say as long as i is less than from length so we're going to loop over the x amount of elements and now we can just place invert here and of course we need to initialize i like this and that's basically it okay cool so now we just need to pass in the index that you're accessing and that's really simple we can say to i so the current element right and then we can say from current element to current element and now the beautiful thing about this is let me just this so now we can use our stagger right let me just print it up so you can see what's going on so the stagger is going to affect the delay right so now we can actually use the i from the loop so So we can say I times stagger plus delay. And that's actually going to be it. So now I actually expect this to work. Okay. Awesome. You can see how simple this was. So we solved the basic use case for the flip animation. And now all the other things work which are more complex like selecting multiple elements and etc. So we can see this works really beautifully. Alright. But the next problem we face is actually to promissify our flip animation. so we can for example just copy this over and we can say this and then we can just animate another layout right now it won't work because we are not awaiting them for the completion right so we're going to see these janky animations like this all right so how do we turn our flip animations into promises and it's actually not that bad so for example here where we're using inversion we have to turn this into a promise so we have to say const promise and we have to actually first return a promise from this so actually let's go back to our function here where we do everything so usually when you want to turn something into a promise you have to do this callback type thing so for example you want to say return new promise you have to use this constructor you get resolve pass this callback blah blah blah do whatever you have inside of here And I actually really hate this because it makes your code so much harder to read, you're indenting things forever, right? But there's actually a new API that I want to try out today and it works really great. It's called promise.withresolvers and it works in every major browser. So instead of having to provide a callback let's just go here let's just make space we can say cons we can destructure something for this we can say promise with resolvers and trust me this exists this is actually so new that the types don't even exist so we can say ts ignore but it works in every browser from what i research and you have promise resolve and reject so now you no longer need to pass things as a callback and make your code ugly right so in this case i actually don't care about reject we actually care about promise which we have to return and the resolve so when are we going to resolve it when the animation is done we can just say resolve and then we're going to return the promise boom bam thank you ma'am that's it but this is not all that we have to do we also have to return this flip method as a promise also so actually let me just go here so i don't have to type it i'm going to copy the same thing so here where we measure things i can actually just go here and let's say this and I should have copied also yes ignore but whatever so we can also do the same thing here but we actually have to keep track of promises since we have multiple animations I'm going to say cons promises and let's give it a type we can actually give it promise void it returns nothing so that's basically it alright so here where we return a promise we just need to add it to a queue in quotes right so we can say promises push promise alright so now we're going to have a queue of promises and we just need to wait for them to resolve so we know that our flip animation is done so how do we do that? well we can use another API called promise.all so here we can go and we can say promise all and we can just pass in the array and we can say then resolve when you're done so we're going to pass this resolve here and the last thing that is left to do is return this as a promise right so we can just go here let me make space we can say return promise and that wasn't that bad right so we can go back to our components so now I'm going to say and I'm going to also await this let's save

 And I'm going to refresh. So now we're going to see it does the first one. It animates to the second one. How beautiful is this, friends? And now we can do for all the seven layouts. So now we can go here. Three, four, five, six. Let me just see. Layout four, five, six, seven. Beautiful. So now we can save this. And now let's go back here. We can see now all of our layouts are going to animate. And this is the power of the flip animation technique. All right. But before I go, I want to talk about a couple of more things. So for example, how can we make this better? Let's say maybe you're not a fan of classes or you don't want your users to use this new keyword and etc. Well, you can just use a factory object. And what is that? Actually, I'm not even sure about the name, but I actually see this plenty in code like Motion 1 and etc. So you can just actually wrap this class. We can say function, create flip. And let's just pass it the same prop. So we're going to have selector, default, options. And that's basically it. So now we can just close this and we can export this function instead of the class, right? So we just wrap this class inside of this create flip function. Basically it. So now we can even remove the export here. Just go here. And now we're just going to update this. So we're going to say create flip. We can remove this. There we go. So now we can go here and all of our animations work the same as before Alright so more things that you can do For example let say that you want to animate more things. Maybe you want to animate border radios and etc. Well, maybe we can provide a third prop here with values. This is what GSEP does. So they give you here another option. So maybe you can pass in more things that you want to animate and then we can just simply use the web animations API to animate those things also. And another thing that are going to be cursed if you try it out so for example what happens if we're here let me just find the grid item i named it box i think okay here it is so something that's going to be cursed is going to be rotations and etc so for example if you apply transform rotate let's say 45 degrees the thing is that if you have something like this and you go back to your animations things are going to start to look weird because you actually have to first remove this transform and then you have to apply it inside of your animation again so it doesn't screw with all the other things. Because rotation is just a skew and translate. So it actually changes the space where you're animating things. So you have to be careful. You can use get computed value and you can solve it that way. But yeah, that's basically it. And you can also maybe pass it more props like repeat and etc. But yeah, basically, this is the beauty of the flip animation technique. Alright, so if you like what you've seen, don't forget to like and subscribe and you can also support me by becoming a patron. Thank you for watching and catch you in the next one. Peace.