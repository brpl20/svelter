 Hey friends, welcome to the Svelte 5 course. This course was made for new and existing Svelte developers. In this course, you're going to get hands-on experience starting from the basics to more advanced topics. You're not only going to learn how to use Svelte, but also how it works. I believe that knowing how things work gives you greater joy by being more competent at what you do. This course was a lot of work, so before we get started, I would appreciate it if you subscribed and engaged with the video by liking and leaving a comment for the algorithm. And listening to the message from our sponsor. This video is sponsored by Sentry. If you want to see all of the errors in your application and have more insight when things go wrong instead of guessing, you want to check out Sentry at Sentry.io. The worst case scenario is when something goes wrong in your app and you don't know about it, costing you a potential customer. Sentry gives you complete visibility in case something goes wrong, with error monitoring to get actionable insights to resolve the most important code-related issues, and other features like logs so you can see what happened and why. Session Replays to get to the root cause of an issue faster by watching actual replays of real user sessions. Tracing to find out why an API is slow or where a crash came from. And Sentry even has a new AI debugging agent Seer that can debug the root cause of an issue and open up pull requests with a fix for you. Sentry supports almost everything and makes it incredibly easy to get started with Svelte. If you're using SvelteKit, you can use their installation wizard to set everything up for you or you can do a manual setup. Thanks to Sentry, SvelteKit now has even first-class support for observability, with built-in open telemetry tracing and a dedicated instrumentation setup file that ensures your monitoring tools work seamlessly. If you're a solo developer, you can get started today for free with Sentry's generous free tier, so make sure your user experience remains great by using Sentry at Sentry.io. Thank you Sentry for sponsoring the video. Alright, before we get started, you're going to need Node.js to run and install npm packages. So you can go to the Node website and under Get Node.js, you can pick your target platform. For the code editor, I'm going to use Visual Studio Code, but any Vibe coding fork of VS Code And of course we going to need the Svelte for VS Code extension for syntax highlighting and other features If you using another editor like JetBrains or Vim you can find the Svelte language server for your editor Usually to set up Svelte you would use the VIT CLI by saying npm create VIT at latest. And then you would get a bunch of options for other frameworks, but you could pick Svelte, and you can pick if you want TypeScript or JavaScript. In this course, I want to focus on Svelte, and I think that types are just visual noise, so I'm not going to be using TypeScript. But if you care about types, I'm going to include a link to a post where all of the examples are going to be typed. And this course is also not going to be focused on SvelteKit, the meta framework for Svelte. If you want something with more opinions that has routing, server-side rendering, and so on, then once you're done with the course, I encourage you to look at SvelteKit. In this case, we're not going to use the VCLI, but a SvelteStarter that I prepared. The Svelte starter includes the assets, styles, and packages that you're going to need through the course. It also uses the minimal CSS framework Pico CSS, so everything looks great out of the box. This way, we can focus on what's really important. To get started with the Svelte template in your terminal, you can type npx degit the name of the repo which is going to be joys of code slash learn dash Svelte, and you can name the folder whatever you want, but I'm going to name it learn-swelt. This is just going to copy the repo without a commit history, and it should take a second. Alright, let's cd into learn-swelt. Alright, so now that we're inside learn.swelt, we have to install the dependencies, so we can say npm i, and this should take a second. Once it's done, you can run the development server by saying npm run dev. Alright, let's go to the browser. Now we can open a new tab and let's navigate to localhost 5173, which should open the default example. Now you should have Svelte running on your machine. Alright, so what is Svelte? If we go to the Svelte webpage, we can see that Svelte is a word that means attractively thin, graceful, and stylish. And here we have the definition. Svelte is a UI framework that uses a compiler to let you write breathtakingly concise components that do minimal work in the browser, using languages you already know, HTML, CSS, and JavaScript. So let's actually investigate this claim before we even start learning about Svelte. So here I am inside of VS Code, and I already opened the Learn Svelte project. And this is just a minimal VIT project, so we keep everything simple. And if you aren familiar with VIT here we have IndexHTML which is the entry point of our application Here we have the public folder so you can put your assets inside of here and the most important source folder where we going to keep our code So let's open the app.swealth file. Let me bump the font size up. As you can see, here we have something that looks like regular JavaScript and HTML, but unlike regular JavaScript, this count value here is reactive. So if we go to our example here, and we can just increment the count, and you're going to see it's going to be reactive. So the advantage of Svelte being a compiler is that you can take the syntax of JavaScript and change the semantics for a better developer experience. In this example where you have count++, here we're actually using reassignment to update the value reactively. So you can also say plus equals one and this is the same thing of course. And we can actually see the compiled output. If you have the Svelte extension, you can press Ctrl-Split-P and you can type show compiled code here. and it's going to show you the compiled code. As you can see, this is human readable JavaScript. Of course, I cleaned it up a bit so we can actually examine it more. So let me just open this empty tab and I'm going to copy paste some code here. So here we have this function app which accepts a target and then we're creating this reactive value which is actually a signal under the hood. And then here we're creating the DOM elements which is the button in this case. And then we're going to append it to the DOM. And here we're just retrieving the text node from the button and then this is the reactive part. so we can update the DOM when state changes using this template effect. And later we're going to learn more how this works. But as you can see, what we learned from this exercise is that Svelte doesn't have a virtual DOM. It doesn't re-render the entire component when your state updates like React. It does granular updates to the DOM when the state changes. This is what makes Svelte fast and performant, and what it means to do minimal work in the browser. Alright, let's start from the beginning. Every file that ends with a .svelte extension is considered a Svelte component. To be more precise, it's a single file component. As the name implies, a single file component means that all of your logic, markup, and styles are inside of a single component. So for example, here we can create this logic block. We have markup and styles. So let's create a script tag here. And then we create a variable named title that has the value of Svelte. And inside of the markup, you can put anything you want. You don't need a special template tag or anything like this. You can just create elements directly. So let create a heading and then we can use an expression inside of it So you can use the opening and closing curly boys Now we can press save and we can see Svelte in the output But of course we can add some styles So let me create a style block We're going to target the h1 element, let's say color orange-red, same as Svelte, and that's basically it. I'm going to save it, and now we're going to see we have this orange text Svelte. And of course, the order of the blocks isn't important. For example, even if I take this style block, and I put it at the top. I'm using Prettier, so when I'm going to save it, it's going to reorder it for me. So I'm pressing save, and as you can see, it reordered the blocks. So the order of the blocks isn't important at all. Of course, you can also use TypeScript. You can specify here lang, and then you can say TypeScript here. And of course, this is inferred, but we can use TypeScript. We can say string, and you can even use TypeScript because it's natively supported in the template, so we can say title as string. But of course, I'm not going to focus on TypeScript in this course, because I actually think it's very distracting when you're learning, it's just visual noise. But if you care about types, I'm going to link to an accompanying post in the description. Alright, so lowercase tags behave exactly like regular HTML elements, and so do attributes. So let's for example create an image here, we can pass it a source attribute, let's say imageGIF, and we're going to see something also very cool. So when we do this, we're going to get a warning from cell that says image element should have an alt attribute. So let's do that. Let's add a description. We're going to say alt. First some nodes. Let's save this and we're going to see the output. How wonderful is this, friends? Alright, so going back we also have the power of JavaScript. So we can create the tag. Let's create a variable source. We're going to say image.gif and let's also create another one. Name it alt and we can also give it a description. Awesome. So now we can use an expression here. we can say source and we can say alt another cool thing is if the attribute name and the value have the same name you can just use the shorthand so in this case instead of source equals the source expression we can just say source but let me actually show you something cool because I'm using Prettier it's automatically going to do that for me alright so I'm going to save right now and we're going to see it works the same as before but of course we can also use an object so I can say let object let's say source image.gif and then let's give it a description and we can say person nulls

 So now we no longer need this, and of course this would be really tedious if we had to do something like this. Source equals object source, alt equals object alt. Of course it works as expected if we look here, but there's a simple way to do this, and we can spread this object on this element. So we can just remove all of this, use the curly boys, and we can just use the spread syntax. So we can spread this object, and everything works as expected. there is one more thing regarding attributes that i want to show you and that is how to conditionally render them so often people make this mistake they define some piece of state like lazy let's say false and then maybe you want to conditionally render this attribute loading here so we can pass an expression and then you can say okay lazy in that case we can use short circuit evaluation and then we can say lazy all right anyway we're thinking since this is false this isn't going to be rendered but that is wrong and also typescript gives you a warning here because the types don't match. So here for example if I save and then I go here and inspect the element you're going to see we're going to get loading equals false which might be completely unexpected or you might do something like this you might use a ternary. So let's say lazy and then in that case we can actually show lazy otherwise you might be thinking to yourself okay let's just use an empty string here. And again we get this warning in our editor which is super useful in this case when I save this we're going to see we're going to get an orphan attribute loading. Alright so the solution to this is to never use short circuit evaluation like this or this ternary where you return an empty string. Always use null or undefined. So for example, if I say null here, you're going to see TypeScript is going to be happy. So now if I save this, you're going to see this behaves exactly as you would expect and the attribute isn't rendered. Alright, so let's talk about component styles. Let's create a script block with a color variable. So let's say orange red. Let's create a heading with some text inside. And I heard a bunch of you like some inline styles with this thing called Tailwind CSS, so of course you can just use the style attribute and you can include all of your styles inside of here, right? I'm just joking, but the style attribute is really cool in Svelte, and I'm going to show you why. So we can just use a regular CSS property, and here we can use an expression, so we can pass color, and you're going to see it works as expected, but there is also a shorthand you can use. So instead of saying style equals, you can just use the CSS property using colon color, then we can remove this and we can just leave the expression in like this Boom And since the variable name is the same name as the CSS property we can also omit this part So you can remove this and I going to save this and I'm going to see it works as expected. The only thing you can do with a style attribute, like in another framework, you can't really pass an object. So something like this isn't going to work. If you say style equals, and then you may want to pass a color. That being said, I don't think I actually ever needed this use case. And if you want something like this yourself, you can write a simple utility function. The style attribute is also great for using CSS variables. Let me show you how cool that is. So here we can create the style block. Let's just say h1. And then we're going to define the color. Let's use a CSS variable. By default, we're going to pass color. If that doesn't exist, we can specify a default value as white. And here we can just use a CSS variable. Dash, dash. Color. And we can just use our color as before. and of course we can also use the shorthand so here we can say dash dash color and then you can say equals and we can pass in the expression or a color alright so if I save this you're going to see everything is going to work the same as before and this is something that I absolutely love about Svelte thankfully you're not just limited to the style attribute so let me just remove all this code and we're going to say that color should be orange red And this leads us to another awesome thing about Svelte. By default, any styles that you define inside of a Svelte component are going to be scoped to that component. That means that the color we define here is only going to affect the heading inside of this component and not globally. So if we go here to our example and open the developer tools, we can go to the head and see what Svelte generated. So we can see that Svelte generated a unique class name. so these figure styles aren't going to clash with anything else you can also of course import css inside your components so for example if you have a script tag here you can say import and then you can say something like app.css and then you're going to import styles that apply to this component but of course you can also have global styles so if i remove this i'm going to go to the root of my which is main.js and here i can import app.css which i'm already using so let's actually look at So here I have just some basic imports and some CSS variables. So if you want to define something global here you can just go here and you can say for example H1 color red and now you have global styles That how easy peasy lemon squeezy that is But of course i not going to do that so now you know how to apply global styles if you have to so speaking of global styles you can also have global styles in your component so let say for example that you receive a post from a content management system and maybe you don't have control over it so here i have some piece of content and let's say i want to render it i can use h group and then we can use the special at html tag in swell to render raw html so you can say HTML content. Let's save it and you're going to see it works as expected. So let's add some styles. So we can say style. Let's target the H1. Let's say text transform and we can say capitalize. What you're going to see we immediately get a warning in the editor by Svelte. Unuse CSS selector H1 and that is because in quotes Svelte can't see that this style is being applied here so it's going to be removed. And for this reason we can use the global style modifier. So we can say colon, global, let's use parentheses, like this, save, and you're going to see everything works as expected. All right, but this would be really tedious if you had to do this for every element. So for example, if you had to do global P and et cetera, now it's really annoying, right? So let's say we have some styles here, whatever, and we can actually get around this by just using global. So here's what we can do. We can say global, then we can just use the curly boys, and then we can just move the styles inside of here. and of course we don't have to use global. Let's just do this, remove it, like here, and now we're going to see if we save this, everything is going to work as expected, and this is only complaining because we don't have any styles here. But we can, for example, say color orange-red, and now we're going to see it works as expected. Of course, one downside of this approach is that these styles can clash with your global styles, but we can also fix this. You can have global scope styles. So what do I mean by that? So here we have this HGroup element. Before global, we can actually just say HGroup and it's going to be scoped just to this element. So let's save this. All right, so we can open the developer tools to see what's well-generated. Let's go to the head. We can open the style block and we can actually see here Swell generated this unique class name but it's prefixed with HGroup. So this way you can have globally scoped styles. You can also have global keyframes So for example inside of here if you use a keyframe it won really work But you can do this You can say add keyframes And now you can just prefix this with global And you can just use the name of your animation. You can say animation, and then you can define your animation inside of here. If you want to make it global for whatever reason. And there is one more cool thing about the style block, and that is that you can use a different preprocessor. So similar to TypeScript, you can define a lang attribute here, and you can define SCSS for SAS or you can use both CSS and it's going to work out of the box. How cool is that? Alright, so let me show you another cool feature of Svelte which are dynamic classes. So for example, let's say we have an accordion here we can say open false and then we can create button with a class button and then we're going to have a span item A and then another span so we can say point let's see, let's use this emoji so this is going to be our trigger and then of course we can use an expression inside of here alright if open is true then we can say apply an open class otherwise do nothing and then we can create some styles so we can say trigger we have to say that this is display inline block so our animation works and let's just say transition we're going to use rotate we can say rotate 0.2 seconds ease and then we can say hey if this has an open class then we're going to animate it so let's say rotate minus 90 degrees all right but in this case this isn't reactive yet we're going to learn about reactivity in the next section but for right now we can just say state false and then here we can just say on click and then we can just set open to the opposite all right so let's save this and we should see let me just zoom in, we should see this works as expected. Awesome. All right, but applying classes like this can be really tedious, so there's actually a better way. We can use the class directive to conditionally apply classes. So we can remove all of this, and we can say class colon, and then we can say open. And of course, you can base this on some other expression. But in this case, we can just remove this, and now I can save this, and you're going to see it works the same as before. You can also pass an object or array to the class attribute. So let me show you how cool this is. So we can say class, and let's first start with an object. So we can say trigger, and if this is

 true, then this is going to apply this class. We can also just pass open. So now this is going to be trigger and open conditionally. All right, let's save this and it should work the same as before. Of course, you can also pass an array. So for example, if I pass an array here, we can first define our base styles. So it's going to be trigger and then we can apply open conditionally. So we can say if open is true, then this is going to be open. Let's save this and I'm going to see it works the same as before. Or instead of this, you can pass an object, which is a lot simpler in my opinion. So you can just say open and it works the same as before. And under the hood, this uses the CLSX library to merge all of these tiles together. And this is really useful if you're working with Tailwind and you need to apply a bunch of classes. So for example, here again, we have our base tiles. We can say transition, transform. And if you want to apply some Tailwind class, like for example, rotate 90, we can just make it conditionally like this. And it's going to work beautifully. All right, but there's something else that you should consider. So instead of applying a bunch of classes, if you have something more complicated, use data attributes instead. So for example, instead of this being a Boolean, you can say status, and this can be open or closed. So in this case, this onclick really doesn't matter. Let me just remove this. And then we can just go here. We can say class trigger. So we are separating our styles for styles and our logic for data attributes, which is really cool. So you can say data status, and then we can just say status. And now if you have something more complicated, now it's way easier to orchestrate your transitions. So instead of using a bunch of classes, we can just go here and we can say data, status and we can say open. And now if you have more of these styles, of course, now it's way easier. You can do whatever you want. It's way more explicit. it. Alright, let's talk about Swellt reactivity. In the context of JavaScript frameworks, application state refers to values that are essential to your application working, and causes the framework to update the UI when changed. Alright, so let's look at a counter example. I'm going to create a script tag, let's say count equals zero, then I'm going to create a button, we can use an expression inside, let's add an onClick event handler, and we can say count equals count plus one But of course this isn reactive and we even get a warning from Svelte count is updated but is not declared with state And we can see it ourselves that count is not going to reactively update. To create a reactive piece of state in Svelte, we use the $state rune. So we can see it looks like this. State, we can say 0. Now it no longer complains. If you look at our example, we can increment the count. And this might look like a function, but it's just part of the language. So Svelte is actually going to turn this rune into a signal under the hood. And because this looks like a regular function, if you're using something like TypeScript, you can just pass your type in here. And it's going to work. As we can see here, we reactively update this value by using assignments. So we can reassign count by saying count plus one. Of course, you can be much simpler about this. So you can say count plus equals one, or you can just say count plus plus. We can save this and we're going to see that it's going to be reactive. We can also have deeply reactive state. And what to remember that? Well, let's say for example that you're working on something like an editor. So we can say editor state. And now if you pass an array or object inside of editor, it's going to become a deeply reactive state proxy. So what does that mean? Well, that means if you for example change something like editor content, it's going to reactively update. Same is true if the editor is an array. So we can say editor push 1 and it's going to reactively update. And that is really cool. So here we can create a theme. We can say dark by default. Let's add some content. And now we can render the content. So we can use curly voice, HTML, editor, content. And this works as you might expect. alright but let's actually change the content by using a text area I'm going to remove this let's say class is going to be editor and now we can say value equals editor content and now we want to update it so we can use on input we get access to the event and now we can say editor content equals e target value and we can also disable spell check alright so let's save this and now we can see it works ok but something like an editor might become quickly complex and maybe you don want to reactively update the entire editor object when a property changes In that case you can use the state And now when you save it you going to see it not going to reactively update The only time it's going to reactively update is when you reassign the entire object, or array if you're using that. So for example, here we can take this, let's just like this, so this isn't going to work. it's only going to work if you reassign the object so you can say reassignment and then let's say editor equals we can spread all of the old values and we can say content e target value let's save this and we're going to see now it's going to work all right but i want to show you another useful state room so let's actually undo this and make it just state so we can log editor and we can see that this is a proxy so if we open the developer tools we can see the proxy object is here and this is a bit awkward because we have this target and we have to dig our way through this content but this might be even worse if you pass this to some api that doesn't expect a proxy so let's say for example that you want to save the state of the editor and now we can define const editor state and maybe we want to clone the object so we can use structure clone and we can pass the editor but now if we try to save the editor so we can say save editor state so now we get this error that it failed to execute the structure clone because it expects a regular object and we passed a proxy to fix this problem we can use the state.snapshot rule so we just have to go here we can just say state snapshot and then we can pass our editor and this is going to give us the actual value so we can even console.log editor state. Let's save it. Now if you refresh it, we're going to see that we just get a regular object. And what's also interesting is that Svelte does this under the hood. So let me just delete this. And previously we said console.log editor. Now we can see that actually Svelte detected that you're using console.log so it actually did state.snapshot for you. So you get the actual value. And that's really cool. and the last thing I want to show you is that you can actually destructure the value from this deeply reactive proxy so we can go here and we can use curly boys we can pluck theme and content now we can remove all the references with editor dot great We can remove this And of course we can delete this code And this works right now. Alright. So we can save. And we should see that this is reactive. Awesome. But it's not going to work if you try to destructure these values where they weren't defined. So for example, let's keep this. But we're going to name it editor. And if you, for example, go here and say let. and we destructure these values from editor, this isn't going to work. But if you want to do this, you can use the derived rune, which we're going to learn about next. You're going to see it's going to be reactive. All right, let's talk about derived state. So I'm going to create this count here. Let's initialize it as zero. We're going to have a multiplication factor. And then let's also create the result, which is going to be the outcome of count multiplied by the factor. And we can already see that Svelte gives us a warning. This reference only captures the initial value of count. Reference it inside a derived instead. And this is where the derived rune comes in. So this has different names depending on the framework you're using. Some frameworks call this computed values. Some frameworks call this derived values. In case of state, to derive the value, we can just use the derived rune. And that's it. Now each time count or factor changes, result is going to update. So let's actually do that. Let's create a container. Now inside of here, we can say count times factor is going to be equal to the result. And let's also create the buttons so we can change the values. So we can say count. Let's add an event handler. we can say count plus plus we can do the same for the factor say factor alright and now we can save this so now we can go to the example and we can see that everything works as expected and that's how simple it is to create derived values there's one important thing to know about derives and that they're lazy evaluated and what I mean by that well let's actually just first delete all this code so we can just keep count here and that's it so let's say you have some value max which is a derived so we can say derived

 And we can say count is greater than or equal to 4. And we can go here and add a disabled attribute, for example. What's really important to know is that the right values only run when they're red, like in this example where we pass max to disabled. And they only update when they change and not when their dependency change to avoid unnecessary work. So in this example here where we have this derived max value, even though it depends on count, max isn't going to update when count changes, it's going to update if it changes due to count changing. So we can actually see this by using the inspect rune, which is a really useful way to log when a reactive value changes. So you can say inspect max, and this is only going to log when max changes. So when we go 1, 2, 3, 4, we should not see max being logged. So let's save this, let's go to our example, open the developer tools, You're going to see first we get init false, and you're going to see 1, 2, 3, 4. Nothing happens until we reach the number 4. Only then is the derived value going to update. What's actually cool about signals is that they only have to be read to become a dependency. So let me show you what this means. I'm going to delete this, and let's simplify this expression. Under the hood, actually Swell turns this derived into a function. And count is actually something like this. Count get greater than 4. but the cool part is that we can just create a function with some state inside of it and it's going to be reactive so let me actually show you let's create a function limit and then let's say we're passing count and we can say return count greater than four but this actually doesn't work how you might expect so for example if we say here limit and we pass count count is going to be get count. So this function is going to be tracked inside of this derived. This is what's actually going to rerun when count updates and max updates. Count is not some magic reactive container. And I can prove this to you by showing you that passing count is completely optional. So we can actually remove count. And now inside of our function, I can just take this, remove count. And now this is going to be get count. As long as the signal is red, is going to become a dependency, so this limit function is going to rerun when max changes. If you just pass count to limit here, it doesn't mean anything because it just a regular value The only thing that matters is that count is red so if you want to be explicit you can pass it as an argument but you don have to Alright but what if you have something more complex So for example, let's create a card here. We're going to say state, and we're going to pass an array of items. So you can say item, and let's pick a juicy apple, and let's say the total is 10. now let's pick up banana now let's say that we want to derive the total sum we can use the derived rune so we can say total derived but how can we actually do this we can only pass an expression inside of here you could actually use an array method like reduce or map but let's say that you just want to loop over the items and return a sum in that case we can use derived by and we can just pass a function inside of here. And now we can say let sum equals 0 and now we can loop over the items and get the sum. And let's return the sum. That's it. So now in the template we can create a paragraph tag. We can say total. And as you can see, it works as expected. The only thing you shouldn't do is use derives for side effects. And Svelte isn't even going to let you change state inside of them to save you from yourself. So for example, if I want to push something to the cart here, so let me actually just copy over this apple, and let's see what happens. And now we should get an error in our console. It says updating state inside derived or a template expression is forbidden. And Svelte even tells you that if the value should not be reactive, you should declare it without state. But I think some use cases are fine. Like for example, let's say that you want to fetch some data inside of derived. You're actually not doing any side effects. So if you wanted, you could do something like that. Since everything is contained inside of that function. Alright, so to finish the Holy Trinity of reactivity in Svelte, let's talk about the effect rune. Eventually you're going to have to do some side effects like fetching data from an API or manipulating the DOM directly. In that case you want to use an effect. So let create a count here And then we can create a button We can say count plus plus Alright so to create an effect we just use the rune And really, effects are just functions that run when their dependencies change or when the component is removed from the DOM. Any state that is read inside of an effect is going to be tracked. So we can say console.log.count and now count is going to be tracked. As you can see there is no dependency array. Now we can open the developer tools and when we increment count we are going to see the value log to the console. One important thing to keep in mind is because how off-signals work, values are only tracked when they are read. What does this mean? Well let's say for example that we have a condition here. and let's say this is false. So we can copy over this button, and we can say toggle. So now we can say condition equals the opposite of condition. And let's also add a container here. So now inside of the effect, if we use a conditional block like an if, so if we say if condition, and then we log the value of count, in this case, since condition is false, only condition is going to be tracked since it's red and not the count. So going back to the example, if we increment the value of count, you're going to see it's not going to be logged as expected, but also your effect isn't going to rerun. But of course, if we change the condition from false to true, then it's going to log. In this example, if condition is false, then the only value that's going to be tracked is condition. And if condition is true, then both condition and count are going to be read and tracked inside of the effect. That being said, there's an exception to the rule what gets tracked. If a value is read asynchronously, like inside a promise or a timer inside of an effect, it's not going to be tracked. So let's look at an interval example. Let's say count the same as before. And let's copy this over. This is going to be our delay. or 1000 milliseconds. So now in the template, let's create a div. We can say count. And let create the buttons to control the interval speed So this is going to slow down the interval So let say on click So we can say delay times equals 2 Alright, so let's copy the button. So to make it faster, we can just divide it by 2. And let's add a container. Great, now let's create an effect. Let's create the interval. So now we can pass a callback to the interval, and we can say count++. So we want count to be incremented every second, so we can also pass a delay. So in this case, because we're reading this value in an asynchronous function, like setInterval, it's not going to be tracked. But what is going to be tracked is going to be the delay. So let's go to our example, and you can see it works as expected. Well, kind of. Let's try to make the interval faster. And that works, okay, so let's make it slower. But that just makes it go faster. And of course, that is because this effect runs each time delay updates, and it creates new intervals. Thankfully, we can return a cleanup function from the effect. So we can say return, and we can say clear interval, and we can pass our interval. And this function is going to run each time its dependencies change or when the component is removed from the DOM. So now we can go back to our example. We can see it works as expected, so let's speed it up. Alright, so let's see if we can slow it down. As you can see, it works as expected. If you don't want to track a value inside of an effect, then you can use the untrack function from Svelte. So let's look at an example. So let's create two pieces of state, A and B. Let's copy it over. Then let's create the button to increment them. And we can copy this over. Let's say B. Alright, so now we can create the effect. Let's say that we want to log the sum of A and B. Also, let me add a container here. Alright, so now if you look at the

 For example, if we increment the value of count, it's going to log the sum. And if we increment the value of b, it's also going to log the sum. But what if we don't want to track a, we only want to log the sum when b updates? In that case, we can use the untrack function from Svelte. Let's start typing untrack, and if you press enter it should auto import for you. The untrack function accepts a callback, so we can just pass it a callback, and then we can pass the piece of state that we don't want to track. And that's it. Now A isn't going to be tracked. So now if we go back to our example, if we increment the value of count, of course it's going to update in the background, but it's not going to log the sum. But if we increment B, then it's going to log the sum. Alright, let's talk more about dependency tracking inside of an FX. So let's say for example that you have an object and array. So we can create an object state. Let's pass current. And then let's say we have an array. And this is just going to be an empty array. So now we're going to have a button so we can update these values. So inside of here we're just going to say Object Current++ and Array Push 1 Alright, so let's create an effect Now if we say Console.log Object and let's also copy this effect So we can say Array You're probably expecting that this is now going to track the object and array, but that's really not the case. So we can see if we update these values, nothing is going to happen. And that is because the effect is only going to rerun when the object changes and not its properties. So we have to be more explicit. We have to say that we want to track object current. And in the case of arrays, this isn't going to be enough. We have to track array length. Now the effects should run. As you can see, it works as expected. But of course, we can get around this. Let's say for example that we want to store this object value inside of local storage And we say JSON stringify object Then we actually don have to track object for it to be tracked. The entire object is going to be tracked. And this is a pretty cool hack if you want to react to this object changing. So for example, you don't even have to use JSON stringify directly. You can just use it to track this dependency and then you can do something else when this object deeply changes. But of course, if you only want to track reactive values updating, then you should use the $inspect rune. So now we can just say object array, and it should work. And you can also customize what happens when you inspect a value, so you can say with, and then you get the values, but of course you can also do other things like run console trace and etc. You can do inside of here whatever you want. In general, effects are something that you're rarely going to use, but you should especially avoid using effects to synchronize state. So let's look at an example. So let's create count. And then let's create double. Next we're going to create a button. Let's say don't click. And then we can increment count. Alright, so let's create an effect. So let's update double when count changes. Unless you have to, you should absolutely avoid using effects to synchronize state like this. Because you might run into unexpected results like your state being out of sync. So let me actually show you this in practice. Here where we increment count, let's say that we depend on double updating. So we can console.log count and double. And now in our example, when we increment count, you're going to see the value of double is going to be out of sync. And that is because effects run last. To be more precise, Svelte queues your effects and runs them on the next micro task, before the DOM updates. So we can actually test this claim. So let's go here and we can say console.log. We're going to say script. Let's copy the console.log. Let's say effect. And then we can say onClick So now in the example when I increment the value you going to see that onClick runs before the effect That is why double is not updated. So we can see the first thing that ran was a script block, then the effect when the component was added to the DOM, then we pressed onClick to increment count, and then the effect ran after it to update double. The lesson here is that you should always derive state instead. So we can just remove this effect, we don't need this, and instead of state here, we can just use derived. And we can say count times 2, and now everything should work as expected. Another reason why you might not need effects is because of the onMountLifecycle function. So let's say that you want to run something once and then run a cleanup function when the component is removed from the DOM. In that case, you can use the onMount lifecycle function. So we can say onMount and then we can import it from self and we can just pass a callback to it. So now we can say console.log, component added. Let's use a wave emoji. And we can also return a cleanup function. So we can say return. And we can say component removed. And this is also great because you don't have to worry about tracking some state inside of an effect on accident. You can also use the onDestroy lifecycle function from Svelte to run a cleanup when the component is removed from the DOM. So we can import onDestroy from Svelte, and then inside of here you can run whatever cleanup you want. Also keep in mind that you can put these lifecycle functions in other functions so you can import them in your component. They don't have to be declared at the top level of the script block. Alright, so when should you use effects? Effects should only be used as a last resort when you need to synchronize with some external system that doesn't understand Svelte's reactivity. For example, fetching data from an API or working with a DOM directly. Alright, so to show this, we can create a simple Pokemon search. Alright, so let's create the search query which is going to be Pokemon. Let say it should be Charizard by default And then we going to get the Pokemon image and then let create the input So this is going to be of type search. Let's make this more readable. And let's say placeholder should be enter, Pokemon name, and then on input we're going to update the search query. so we get access to the event and then we can say pokemon equals e target value now we just need to add the image so the source is going to be image and the description is going to be pokemon let's also add a container and that's it. And now for convenience I'm going to copy paste this get Pokemon function. So this is just using fetch and the Pokemon API to get the Pokemon but now this makes sense to use an effect because this is a side effect. We want to rerun this function each time Pokemon updates. So we can create an effect and we can just pass a function inside of here. One common mistake I see people do is pass a promise here. So for example, if you say async, Svelte is also going to give you a warning because these types don't match. So for example, if inside of an effect you were to say cons data await get pokemon, this would actually work, but the problem is that since you're passing a promise, your cleanup function is never going to run. So instead of passing a promise here you can reassign state inside of this function get pokemon and then you can just say get pokemon and that's it or you can use an immediately invoked function expression so you just need two round boys here is our logic then we can invoke the function inside and you just need to pass a function inside and now you can make this async but of course this isn't readable in this example we're just going to do get pokemon pass the pokemon then we can say then and we get the data and now we can update the image so we can say image equals data sprites front default so let's be more responsible and not spam the pokemon api so one of the options that fetch accepts is an an abort signal that's going to cancel the request. So we can pass it as an option here. So we can say signal, and Swell provides a useful function getAboardSignal

 which is going to cancel the request as we type. So we can say get abort signal. It's going to be important from Svelte. We can just invoke it and that's it. So now in our example, we can see that we already fetched Charizard. So we can try fetching Pikachu. So you can see it works as expected. Alright friends, one last thing I want to talk about when it comes to effects is the effect.prerune. So for example, you might need to do something before the Dome updates, like measuring some elements or the scroll position. In that case, you can use the Effect Pre-Rune. For the sake of time, I'm going to copy and paste this example here. So here we're using the G-SAP animation library and the Flip plugin. So we just register the plugin, and then we're going to create 10 elements, and then we're just going to shuffle them. So in the markup, we're just looping over these elements. Nothing special. And then we're going to shuffle them. In this example, I want to use the GCEP flip plugin to animate the view changes when we update state. So instead of these numbers teleporting around, I want them to smoothly animate their change in position. For that to happen, we have to record the previous and after state. So let's create an effect. Alright, so whenever we shuffle the items, we want to run this effect. So let's add items as a dependency. For this, we can just say items. Alright, now we need to measure the elements before the DOM updates. So we can say const state equals flip getState, and then we can give it the class of the item. So this is going to be .item. Alright, so now we can transition the elements. So we can say flip rom. We can pass it the state with some animation options. we can say duration 1 second stagger 0.01 second and then we can specify an easing so you can say power 1 in out but as you can see this isn't going to work if we save this for example and go back here we can shuffle the item but nothing is working and that is because this effect runs too late we need to measure these elements before the dome updates and then we need to run flip after that fact. So we can measure the elements again and do the flip So to do this we can use the effect pre rune So we can just go here and say Effect Pre And now we can save this but you going to see this still isn going to work So if we shuffle nothing happens And that is because this all happens at once. We need to measure the DOM before it updates, and then we need to measure it again after it updates, so we need to somehow schedule this function. So there's a couple of ways that we can do this. We can use RequestAnimationFrame or QueueMicrotask. So for example, if I go here and say QueueMicrotask, And this is actually what Svelte uses under the hood to queue your effects. But in this case, we can use this to schedule this task to run. Now you can see when we go here, it should work. And Svelte actually provides a function that does this for you and uses queue microtask under the hood. So let me just remove this. And we can import tick from Svelte. So now tick is imported from Svelte, and tick returns a promise. So we can invoke it, and we can say then, and we can do the same thing. How cool is that? Alright, so keep this in mind if you ever need to do something before the DOM updates. So far we only use state at the top level of the component, but we can use state inside the functions and classes, including derives and effects. So let's look at an example. Let's create a function named createCounter, which accepts an initial value. So let's create some state inside of it. So we can say count equals state, and let's pass the initial value, and let's return count. So we can create a counter, and let's create the button. and also let's increment the count. But this isn't going to work. So if we go to the example and try incrementing count, nothing is going to happen. And that is because count here is just a regular value. So when we define a piece of state with the state rule, this isn't some magic reactive container. The value of count is going to be the same value as when it was evaluated. Swell doesn't change how JavaScript works, so we actually need some mechanism to always get the latest value of count So for example we can use functions So we can say count and then we can return the latest value of count To update count, we can say set count, we can get the value, and then we can say count equals value. But the downside of using functions is that it's very verbose. So for example, now we have to use functions everywhere. We have to invoke count. Here it's not simple anymore. we have to say counter setCount. Now we have to say counter count, have to invoke this, and then we can increment it. Alright, so let's save everything. Now we can try incrementing the count. As you can see, it works as expected. Alright, but there is actually a better way. Instead of using functions, we can use getters and setters to create property accessors. Instead of this count function, we can just say getCount, and instead of set count we can say set count and that's it. So now instead of doing all of this we can remove this, we can say counter count plus plus and we don't have to invoke this anymore. So let's save this and let's try incrementing the count. As you can see using accessors is a way cleaner syntax. Alright, but even this approach isn't perfect. And speaking of magic reactive containers, we can use deeply reactive state. So here instead of initial, we can pass in an object, so this becomes a deeply reactive proxy. So now we can say count, and we can pass initial. Now let's rename count to counter, and instead of returning this junk, we can just return counter. So let's try incrementing the count. As you can see, it works as expected. Alright, but if you want, you can create your own reactive container. And another reason you might want to do that is because of type safety. So let's say, for example, that you're using TypeScript. So let's create a reactive container. So you can say function, reactive, but you can name this whatever you want. Let's say value, and then let's create state. So we can say state equals state, and now we can pass the value. So this can be regular or deep state. Let's return the state. And that's it. So now you can actually type this function. So we can say T for the generic, and you can do whatever you want here. So now you can just replace with reactive and everything is going to work the same as before Alright, so this reactive utility looks really useful, so why doesn't Svelte ship something like this out of the box? Well, there are actually two reasons. The first reason is because it's only a couple of lines of code, as you can see, but another reason is that Svelte encourages you to use classes. because when you use state inside of classes, it unlocks some superpowers. So let me actually remove this. And let's yoink all of this. So we can create a class named Counter. We're going to create a constructor. Same as the function is going to accept an initial value. And the only thing that we have to do is create this count field. And we can say equals state and pass initial. So let's create the counter. New counter. Let's pass the initial value. Alright, so let's try incrementing the count. As you can see, it works as expected. So what kind of black magic is going on here? Well, let's actually look at the compiled code. As you can see, under the hood, Svelte is going to turn this into a private field and is going to create the getters and setters for you. Of course, at the end of the day, it doesn't matter if you use functions or classes as long as you understand how Svelte reactivity works. Alright, so let me show you another cool thing. Svelte has this concept of universal reactivity. That means that not only can we use state inside of functions and classes, we can also use it in a regular JavaScript module. So let's do that. I'm going to open the sidebar, and inside of the source folder, I'm going to say new file. Let's create a lib folder, and then we're going to create the counter. So you can say counter, and the only caveat is that the file name has to end with .swelt, .js, or ts for TypeScript. So this way the Svelte compiler knows that this is a special file, and it doesn't have to do unnecessary work. Alright, so let's create the file. So we're going to close the sidebar, and let's just copy the code, so we can take our beautiful counter. Let's go back to counter.swell.js. We can paste the code in, and we just need to export it. Now in app.swell, we can just start typing counter, and it should auto-import.

 port from lib. Alright, so now we have our beautiful counter. And everything works as expected. Alright, so let's talk about something very important, and that is passing state to functions and classes. So let's say for example that we have a Dobler class. So we can say Dobler. We can create a constructor. So we can say discount equals we're going to derive count times 2. So let's create count using regular state and then let's create the doubler. So we can say let doubled new doubler and then we can pass count. All right, trick question. Is this going to work? The answer is no. And why that is? Well, because as we learned before, count is just a regular value. And we can actually see this if we create a button. So let's say doubled count. Let's create onClick. So we can say count++. And we can look at our example. We can see that nothing works. So again, we have to use some mechanism to get the latest value of count. And usually that is a function. So instead of just passing the plain value of count, we can pass in a function. So because this is a function, we need to invoke this. Let's try incrementing the count. and you're going to see it works as expected. So we learned that we can use DeepState if we pass an object inside of here, for example, or we can use a reactive utility. But in our case, we already created a count class which is already reactive. So we can use it. So we can just say new counter, so we can import it from lib slash counter dot svelte. We can pass in the initial value and now we can just pass the count. And this is actually going to be counter, so we can rename this to counter let's say counter.count and here we just need to change count to counter and we can just say counter.count times 2 so we can derive the value alright, so let's try incrementing the count alright, so now when we increment the count the doubled value is also going to update You can also have reactive global state thanks to Swell universal reactivity So for example let say that you have a global config So you can create a new file inside of the lib folder We can name it config.svelte.js. Let's close the sidebar. And we can export const config equal state. And the only thing you have to do is pass in an object to create a deeply reactive state proxy. So for example, we can say theme, and of course it's going to be dark by default. And that's all you need to have reactive global state. Of course, you can just use a class. So let's create a config class. We don't even need a constructor. We can just say theme equals state, and let's say dark. I'm also going to add a method to toggle the theme. So let's say toggle theme. so we're going to say this theme equals let's check what the current theme is so we can say this theme if it's light then we're going to set it to dark otherwise it should be light all right so now we can create a singleton so we can say const config equals new config and of course we should export it now let's go back to app.svelte let's create a button so we can say config let's import it we can say config.theme and now we can also add an onclick event handler so we can say config toggle theme all right so now we can toggle the theme and there is only one gotcha with classes so we have to do something like this inside of an anonymous function because the context of this depends on where it was called for example if just pass config.toggleTheme this isn't going to work because in this case this refers to the button but you can also use a narrow function since it doesn't bind this so you can go back to the config so you can use a narrow function here all right so let's see if it works awesome Alright friends, so let me show you how you can avoid using effects. And I honestly don't want to scare you from using effects If you sometimes use an effect when you shouldn it not a big deal It not about performance or anything like that If effects were that bad they wouldn be part of the framework Effects are necessary The problem is that it easy to overcomplicate your code with effects because it seems like the right thing to do. So let's look at an example how you can make your life hell using effects when you don't even need to use them. Alright, so let's use the same counter class that we used before. so we can say let counter equals new counter and then let's set zero as the default all right let's create a button and then let's increment the count all right so let's say that you maybe want to read and write to local storage when you update count. That sounds like a side effect, right? So that's a perfect use case for an effect. So let's go to counter, and inside of this constructor, I'm going to copy and paste these effects for sake of time. So here we have two effects, one that is going to read the value from local storage, and if it exists, it's going to update count. The second effect is going to track when count updates, and it's going to update the value in local storage. So if we go to the example, and let's open the developer tools. We can go here to application and local storage. We're going to see that the count is zero. So let's try incrementing the count. As you can see, it works as expected, but let's see if the count value persists when we refresh the page. And it does. All right, so what is the problem? Well, let's go back to our example. So let's say that you have a favorite counter that you want to share with everyone. So we can say export const counter equals new counter. So we can go back to app.svel and we can import the counter. We can remove this counter that we created and everything should work the same as before, right? Well, if we go back to our example, we can see that we have a bunch of errors. So let's go to the console. And we get this mysterious effect orphan error. Effect can only be used inside of an effect, for example, during component initialization. What does this actually mean? Well, your entire Svelte app is actually a root effect, and your component is just a nested effect inside of it This way Svelte can keep track of the effects and run the cleanup automatically for you So what this error is saying is that you trying to create an effect outside of that root effect. So let's go back to counter.svelte. Alright, so this is how you enter the first circle of hell. We can actually create our own root effect. To do this, Svelte provides an advanced rune called effect.root. So we can go here at the top. Let's say effect.root and now we can pass a callback. So let's move the effects inside of the callback. The major downside of effect.root is that you have to do cleanups manually. So for example at the top we can declare a private field called cleanup and then we can assign it here. Alright, then at some point we're going to have a destroy method. and inside of it we can call the cleanup. As you can see, this is starting to become convoluted. So now let's enter the second circle of hell. Let's remove all of this. We no longer need a root effect. And let's remove this cleanup. Alright, so there is another advanced rune that we can use, and that is the effect.tracking rune. this rune is going to check if you're inside of a tracking context like the template. So maybe that's the solution. All right, let's try it. So we can go here. Let's say if effect tracking. And then let's also move the effects inside of it. And if we go to our example, we can see we have no errors. So let's go to application, local storage. we can see count is 10 that looks good that's the default value that we picked so let's go up to 20. we can see the count increments but the value is never updated even if we refresh the page and why that is well that is because our effects are never going to run because this counter was created outside of a tracking context all right so how can we start escaping this hell well it would make more sense that we only create this effect when you read the value and we can write to local storage when we write to count. So this effect is completely unnecessary. So let's start by creating a private field, count, and then we can rename count to use

 private field count and now we can create the getter and setter all right so let's go here and let's say get count and we can return this dot count all right so we can do the same thing for setting the count we get the value and then we can say this count equals value so now we can yoink this local storage line we can just place it here we don't even need this count we can just say the current value and then we can yoink this effect just delete it and we can copy this entire effect where we read the count value and as you can see things are a lot simpler all right so now when we go to our example let's increment the count and we should see that everything works as expected So let's see if the value persists, and it does. But there's actually one problem. If we read this count in multiple places, we're going to create an effect. But we can easily fix this. So we can create a new variable at the top. Let's say first, and this is going to be true. So now inside of the effect, we can actually check if this ran the first time. So we can say, hey, if you already ran, then return. otherwise we're going to retrieve the value from local storage once and then we're going to set first to false so now we can increment the value and everything works as expected all right we've been through many circles of hell but we're still not done as you might have noticed we don't even need an effect here so we can just remove this effect and let's say if this is the first time this ran, then we can run this. And we can set first to false. As you can see, this is much simpler. So you should always avoid using FX. So now if we go to our example, and if we increment the count, we're going to see that everything works as expected. Let's see if the count value persists. And it does. As you can see, this is why you should avoid using effects You can do side effects inside of event handlers like onClick So always avoid using effects if you can Alright friends so far I been constantly talking about signals how values are being read and etc But what does this actually mean? So in this section you can get the popcorn out because we're actually going to learn how signals work. So let's look at this example. So far we learned that we can declare reactive state using this rune. And to update state we can use reassignment. but this equal sign isn't anything special. If we look at the compiled code, we're going to see that this just gets turned into a function call. So this gets turned into set. So we pass the signal and we pass the new value. But how does this actually get updated? And this is a true Scooby-Doo moment because you're usually discouraged from using FX in Svelte, but actually, under the hood, Svelte compiles this template into FX. So you can see here is a template effect, and that is how Svelte updates the DOM. So in this section, I actually want to implement a simple version of signals so you understand how they work. And Svelte isn't the only framework that uses signals. You have Angular, Solid, Quick, and so on. You're going to see that signals aren't just hype, but they're the perfect primitive for building user interfaces. Alright friends, let's pretend that this is just regular JavaScript. So what is a signal? A signal is basically a container that holds a value and subscribers. So we can create a function called state. Let's pass in a value. And let's create a signal which is going to hold the value and subscribers. So we're going to use a set so the subscribers are unique. And then let's return the signal. As you can see, a signal doesn't do anything on its own. For signals to be actually useful, we need effects. so let's create an effect so effects accept callback functions so we can accept the function and now we need to track the active effect so we're going to say active effect equals this function and then we're going to invoke the effect so let's create this active effect by default it's going to be null Alright, so the actual magic happens when we invoke the effect and we read a signal. So let create a function called get So we just going to pass a signal So now inside of get we can check hey who called me Then we can say signal subscribers add the active effect And then we can return the value. So we can say signal.value. All right. So now when we update the signal, we notify its subscribers. So we can say function set. We're going to pass in the signal and the new value. So we're going to say signalValue equals the new value. And now we can notify the subscribers that the value has changed. So we can say signalSubscribers forEachEffect. We can invoke the effect. And that's pretty much it. And that's really how simple a basic signals implementation is. So let's actually use it. In this case, since we're not using Svelte in particular, we're just going to create a button but of course since we're still in Svelte I'm going to use on mount to query the element and then we can create the state so we can say let count equals state let's pass the initial value now let's query the button alright so let's update the count by saying button on click so we can use our set function which accepts a signal so we can pass count and we need to use get to get the latest value from the signal and we can increment it and that's cool but the actual magic happens is when you use an effect so again we're going to pass a callback to this effect so So we want to update the button text node. So we can say button text content, we can say equals, and we have to say get count. So when we read the signal, it's going to rerun this effect. Alright, so I hope you're starting to understand how cool this is. Because when this effect runs, this callback is going to run, this is going to become the active effect. Then we're going to read the signal. And when we read the signal, it's going to ask itself, hey, who called me? Is there an active effect? If so, let's add it to our subscribers. And then when we update the signal, we can notify the subscribers. Of course this is very oversimplified but this is a basic example of how signals work Alright but let actually see if this works at all So we can save this So let go to our example and let see if we can increment count How beautiful is this, friends? Alright, so not only did we learn how signals work, but we also learned that Svelte doesn't compile reactivity. This is what it's called runtime reactivity. Because this happens each time you update a value, It runs the signals and recreates the dependency graph. The only thing that Svelte compiles for is developer experience, because it hides this method set, get, and etc. And that is the reason why you can use signals like regular values in Svelte. As the React people love to say, it's just JavaScript. Alright friends, so I hope you understand now why signals are so powerful. Instead of having to do all the manual setup to update values, anyone that is interested about a value updating can just subscribe to the signal. Once you understand how signals work, you're going to understand them in other frameworks. And there's even a proposal to add signals to JavaScript. And now that you understand how dependency tracking works in Svelte, is going to give you more confidence in your own projects. And now you also understand that this isn't some magic under the hood where Svelte compiles reactivity, it's just JavaScript. And this is also important when you read in the docs. So for example, here they mention something that's called the tracking context, and they say that's the effect, so your user effects and things inside your template. But what they don't explain here is that your templates get compiled to effects. So that is the tracking context. And speaking of effects, derived values are also effects. A derived value has its own tracking context, and it returns a signal. Unlike user effects, when a derived updates, it gets immediately evaluated. Alright, so I hope this was helpful. Alright, so let's talk about using logic in your template. HTML doesn't have conditions and loops, but in Svelte, we can use control flow blocks and even blocks to deal with data loading and promises. So let's look at an example how we can conditionally render content in Svelte. I'm going to create a piece of state called status. and this is by default going to be loading. So this state can be loading, success or error. Now inside of our template, we can start by opening the curly boys. We can say pound if. And now here we can use an expression. So we can say status does it equal

 to loading. So we can use a paragraph tag and we can say loading. Alright, so let's close the if block. Again, we're going to use the curly boys slash if. Let's take care of other states such as success and error. So we can go here and we can add another block. So we can use curly boys again. We can say colon else if, and now we can use another expression. We can say if status is equal to success. let's also use a paragraph, then we can say success. Alright, so let's copy this block over. So we're going to say if status is error, then we're going to say error. We can also add another else block. So we can say curlyboys colon else, and we can say paragraph tag impossible state. Alright, so let's add some buttons. let's say loading and then we're going to add an on click event handler so we can say status equals loading all right so let's copy this over a bunch of times so we can say success here we can say error And then here we can say other. All right, let's also add a container. All right, so let's go to the example. So let's go from the loading state to the success state. And then we can go to the error state. And if we go to other, we should see impossible state. And that is how we can conditionally render content in Svelte. All right, so let's look at how we can loop over data in Svelte. So let's say that you have a list of items such as to-dos. We can say state. This is going to be an array of to-dos. So let's say ID 1. The text is going to be to-do. And we can say done false. So let's copy this over a bunch of times. So now we can say to-do 2, 3, 4. We can also bump the ID. And that's it. All right, so in the template, we're going to create a list. Alright so let use the curly boys then we can say pound each in this case So now we can say each to do as to do we can also close the each block by using curly boys slash each now inside the each block we going to create a list item inside of the list item we're going to have an input and a span so we can say input type checkbox and then we can set the checked value so we can say checked equals to to do done and then let's add a span for the text so we can say to do.text all right so we can add one more thing if the list is empty so we can go here we can open the curly boys we can say else so if the list is empty we're going to render this paragraph that's going to say no items as you can see we successfully iterated over the items we can also destructure the values from the item we're currently iterating over so instead of to do here we can use curly boys and we can the structure id text and done we can even get the index here and you can name this whatever you want like index but i'm just going to say i and then we can also pass a unique key like the id so this is so swell can keep track of changes so we can use the round boys and then we can just pass the id in this case it's unnecessary but in general it's a good practice to provide a unique key so swell can keep track of changes. Alright, so now we have to remove to do dot. And let's also do something more fun with the index, so we can color odd and even rows. So here we have our span, we can use the style attribute, and we can say colon color. So we can say I modulo 2, if there is no remainder, then we can say that the color is going to be orange red, otherwise we're going to use the default color. So now if we go to the example, you can see that every odd row is colored. Alright, so let's say that you want to loop over an arbitrary amount of items, like creating a grid for example. In that case, we can even omit the S part in the each block. So let me show you. In this example, we're going to create a 10 by 10 grid. So let's say cells, and then we can start with the curly boys, we can say each, And now we want to create an array of 10 items. So we can just say array, and then we can pass the amount of items that we want to create. So let's close the each. And here we don have to specify as anymore We only interested in the index So we can name this index row Alright so now that we created the rows we can create the columns So let's just copy this code here. And we can rename row to col. Now let's create a div. We're going to name this cell. And we can just output the row and column number. So let's use curly boys. We can say row. And then let's say column. As you can see, we created a 10 by 10 grid of rows and columns. Alright, so what's really cool about the each block is that you can iterate over any value that supports array from. So for example, we can create a map, let's say let items map, we can say new map, let's pass in some default values, we can use an array of arrays to do so. so we just need to pass a value let's say apple then let's copy this over we can say banana alright so now let's create a set new set let's pass in an array so again we're going to have an apple and a banana and let's also create a generator so we can just say function and we can use a star so this is a generator so we can say items generator and then we can just yield the apple and the banana so we can say yield so we can yield the apple and then let's yield the banana alright so let's loop over these items So now in the template, let's create a list. Alright, so this is how we can loop over the map. We can use curly boys, each, we can say items map, as, and then we can destructure the key and the value. Alright, so let's close the each block. And then let's just output the key and the value. So we can say key, colon, value. Alright, so next let's loop over the set, which should be the same as looping over a regular array So we can copy this list Instead of items map we can say items set And then we can just say item Alright so the last one is going to be the generator So we can copy over this block. And this is also really simple. The only thing we have to do is invoke the generator. So we can say items generator. And that's it. Alright, so let's go to the example. As you can see, we iterated successfully over a map, set, and even generators. Awesome. So keep that in mind, you can loop over basically anything, as long as it works with array.from. Svelte even has reactive versions of some built-in JavaScript objects that we're going to look at later. Alright, so let me show you a simpler way of dealing with promises using the await block. So previously, we fetched some Pokemon data using this getPokemon function. As you can see, the function is mostly the same, the only thing I changed is that I explicitly returned the name and sprites from the response. But in that example, where we used an effect, we didn't even account for any loading success or error state, which becomes quickly tedious. So to make that simpler, we can use the await block in Svelte to deal with promises, like asynchronous data loading. So let's go to the template, and we can use the curly boys, we can use the pound side, and then we can say await. If you want, you can store a promise in a variable, or you can invoke a function like this directly. So we can say getPokemon, and then let's say Charizard. And then let's close the await block by using curlyboys slash await. Alright, so let's show the loading state. So we can just say loading, but then when the promise is resolved, we can use the then block. Let's use the curlyboys. We can say colon then, and we can name the return result. So this is going to be Pokemon. Alright, so inside of here, let's create a container named Pokemon Details. And now we can create an image. So the source is going to be Pokemon Image, and the description is going to be the Pokemon Name. And let's also add a paragraph here, so we can say Pokemon Name. Alright, so now we can also handle the error state by using the catch block. so we can go here and we can again use our curly boys colon catch and we can say error all right so now that we get the error we can display the error message so we can say error dot message all right so let's see if it works

 And awesome, we got Charizard. Alright, so if you don't care about errors, you can omit the catch block, and you can also omit the then block if you only care about the result. So let's just take the markup. We can delete this. We can paste our markup here, and the only thing we have to do is use then here. So we can say then, Pokemon. And everything works the same as before. Hey friends, I wanted to let you know that there's an experimental async feature that you can enable in Svelte. By the time you're watching this video, it might no longer be experimental, but currently if you enable this experimental flag, you can use await at the top level of your component inside state and inside your markup. So the only thing you have to do is enable the async feature in your Svelte config. And then you have to include this boundary at the root of your app. this is like react suspense if you're familiar with that and now we can use await directly in your component so in this example we're adding a and b as you can see we can use it directly in the markup and you can find more information in the documentation like indicating loading state so you can use this effect.pending rune but yeah there's a lot more information in the swell documentation all right sometimes you might want to recreate some elements when a piece of state changes in that case you can use the key block so let's look at an example let's create this value i'm going to set it to zero and then we can create a cute ghost i mean a spooky ghost we're going to learn more about transitions later but for right now we can just say in colon fade and we can just import fade from swelped slash transition all right so now let's create a a button so now we can create a spook on demand service by adding an on click event handler so let's just increment the value so now we want to play the phase transition each time value updates so we can use the key block for that so we can go here we can use the curly boys pound key so now we can pass any expression here like value and now we can close the key block so let's Let's use the curly boys slash key. And that's it. Now we can save it and now we have a spook on demand service. Alright, so now when we click on the button, it should recreate the ghost element and play the transition Spooky How spooky is that friends all right friends the last cool thing i want to show you is local constants basically local constants lets you define variables in your template so when would it be useful let's actually look at an example so let me just copy this example so this is the same example that we used in the loop section where we destructured id done and text but this approach kind of sucks because now we lost the original reference to the to do right and what if we want to use the to do as a key here now we can't anymore we have to pass id well we can actually fix this with local constants to create a local constant it has to be a child of any of the blocks like if each and so on and it can also be a child of a component so in this case we can just go here we can use the curly boys then we use the at sign and then we can say const So now we can define a variable that is scoped to this block. But in our example, we just want to destructure these values from to-do. So we can just take that, and we can say equals to-do. Now we can just say to-do is s to-do, and now we preserve the original reference to to-do. So now we can pass that as the unique ID. And we can also rename done to checked, and we're not using ID anywhere, so we can just remove it actually, and we can go here, and we can just say checked. And we already destructured text. As you can see, local constants are very useful. So let's look at another example that creates an SVG grid. As you can see, we can define the size and tiles in the script block. And now we can pass them to the SVG. So now we can combine what we learned before on how to create a grid. So in this example, we're creating a chessboard. And now we can use local constants to keep everything tidy and legible. and this also helps us avoid creating unnecessary components. And it's also a benefit to performance if we compute the value once, if we use it in multiple places. But in this case, we're just creating the tile, x and y coordinates, width height and the fill. So we just pass them here to rec and now we can look at the example. As you can see, we're creating this chessboard. Local constants are a very useful tool in your arsenal. Alright, let's talk about event listeners in Svelte. So far we used a button with an onClickEventListener. In Svelte events are just regular attributes so you can say on and the name of the event And then you can pass an inline function like this And we can say console click So if we open the developer tools and click on the button, we should see click. And what's really cool about events in Svelte is that they mirror JavaScript events. So what do I mean by that? Well, you might be familiar with something like this. So where we have element add event listener. And now we can pass the event listener. and we get access to the event so we can do whatever we want. But there's also an alternative syntax where we can say element on click. And we also get the event and we can do whatever we want. And of course we also get access to the event here. And instead of using an Inland function we can create a handleClick function. So let's take this and we can name this handleClick. So let's remove this. Yoink. Let's name this function handleClick. and we get the event implicitly so we don't have to pass it and then we can just put our console log here and now if we click on the button we should see click again and also because events are just regular attributes if they have the same name then we can use a shorthand so in this case we can rename handle click to on click and if I save and format the file it's going to use the shorthand and because events are just regular attributes we can also spread them. So let's take this console log here and let's create this object called events. So we can have on click and then let's copy it over and this is going to be on double click. And then we can just spread the events. So now when we click on the button we're going to get click, and if we double click the button, we're going to get double click. All right, let's do a more fun example where we track the mouse coordinates using the onMouseMove event. So we need to track the x and y mouse coordinates. So let's create mouse equals state, and then let's pass in an object here. So we can say x is equal to 0, and the y coordinate is also going to be 0. So let's create this container. I'm going to use this mouse class so this container is going to take the entire width and height and then you can say the mouse position is and we can use the coordinates so you can say mouse and mouseY Alright so let create the function to track the mouse coordinates So let's name this onMouseMove. Then we can accept the event. Now we just need to update the mouse position. So we can say mouseX equals E clientX and let's also update the Y coordinate. So mouseY equals clientY. and that's it now we just need to add the event handler so we can just go here and we can use the curly boys and let's just say on mouse move and we're going to get an accessibility warning but we can just ignore it by clicking on quick fix and then we can disable it all right so let's go to our example and now we can see that the mouse position is being tracked how cool is this and that's how simple that was all right so in the last example i want to show you that you can actually use forms to get the user submitted data instead of always using state so let me show you let's create a form it's not going to have any action because this is going to be purely client side when you're using sell by default you're building client-side applications so everything is handled on a single page using javascript so let's say for example create an input which is going to be email so to get the data from the form we have to give it an identifier such as a name So we can say email. And then let's create a submit button. So we can say type submit. So for example, this might be your newsletter. So we can say subscribe. Alright, so usually where you would use state to get the email, we can actually just create a function, and we can listen to the onSubmit event. So let's say function, onSubmit, we get the event as the argument. And now this is the most important part. We have to prevent the default behavior because the form is trying to post to the server. To avoid that, we can use event prevent default. So now we can control the form using JavaScript and avoid a page reload. Alright, to get the form data, we can say const data equals new form data, and we can pass the form. In this case, we can just use this to reference the form element, and then we can say const email equals data get, and this is where our unique name identifier comes in. so we can say email and that's it. So now we can console.log the email. Alright, so now we can go to the form and we can use onSubmit.

 Alright, so let's enter an email like test at test.com. And let's open the developer tools. And now we're going to see if we subscribe. It's going to output the email. As you can see, sometimes a form can be enough and you don't need any extra state. Alright, let's talk about data binding in Svelte. So here I have a special example for you. I'm going to copy and paste for sake of time. But it's really just a simple search. Here we have a list of JavaScript frameworks. Here, we're using a derive to filter the list based on the search. And this is how we update the search using this input. So we assign the value to search, and then we use onInput to update the value. And here we're just looping over the list. Nothing special. Alright, so for example, if we type in s, now we're going to get solid and swelped. And of course, in the example, I would also make this to lower case where you have item and search, so it's case insensitive. Alright, so in previous examples where we used events like onInput, there were probably some people yelling at the screen that already knows Svelte, what are you doing, this can be so much simpler. And yes, that is true, this is part of the plan. What we're doing here is called one-way data binding, because we're using the input to update some state in our application, but the state in the application doesn't reflect in the input. What's worse is that you do something like this all the time, so this is just boilerplate. Thankfully, Svelte supports two-way data binding using the bind directive. So let's see how we can use the bind directive to improve this experience. Alright, so let me show you how cool this is. So we can just delete all of this junk, and we just need to say bind colon value and what we want to bind it to. So we can say search. And that's it. Now we can save. Now if we go to our example, we can see that it works the same as before. And Svelte has many writable and readable bindings that you can use. Let me show you one of the more useful bindings, which is going to be bind colon this, to get a reference to a DOM element. So let's look at an example. Let's say that we have a canvas. And we can give it some styles. So let's say canvas width 200 pixels by 200 pixels. And then let's give it a white background. And now we have a simple canvas with a white background Alright so let say that we want to reference this canvas Maybe we can go inside of here and create an effect And then we can say const canvas document query selector. And let's select the canvas. And then we can get the context. So we can say const ctx equals canvas get context 2D. And if we log the context, so if we open the developer tools we can see that it works but the downside of this is that you're targeting any canvas in your app so you could have multiple canvases and etc so you actually don't know what you're selecting so instead of doing this we can remove this line and we can go here and we can say let canvas and this is going to be undefined until your component is added to the DOM. So now we can go to our canvas element and we can get a reference to it by saying bind colon this. And now we can bind it to canvas. As you can see now we get a reference to the canvas. And of course instead of using an effect here if you don't care about tracking any values you can use on mount. And you're going to get the same result. Alright so let me show you another cool feature when it comes to bindings. Let's say that you want to make a mocking Spongebob case converter. So in this example, I have a simple function which is called toSpongebobCase, which accepts some text, and then it converts it to the mocking SpongebobCase meme. And here is our state. All right, so how do we make this work? Well, we learned that we can bind the value, so we can say bind value, and then we can just maybe pass text, but we have to convert the case. So maybe we can pass a function here. So we can say to Spongebob case. And then we can pass text. And we immediately get an error. Because we can't bind to a function of course. Alright, so maybe you're thinking let's create a derived. So we can say mocking Spongebob case. And then let's say derived. So we can say to Spongebob case. And we can pass in the text. Alright, so let's go here. so maybe this is going to work well let's save it and we can go to our example so it seems that it works at first but we going to see if we type in anything else nothing is going to work And that is because we can bind to derives All right so if we can do this then maybe we need to go old school and just use the regular attributes. So we can go here, for example, and save value. So we can say to Spongebob case. Let's pass the text. And then let's use the event listener on input. So we get access to the event, and now we can say text equals e target value. Alright, so let's see if this works, and if we go to our example and start typing, awesome, you're going to see it works. Alright, but there's actually a better way to do this using function bindings. So what are function bindings? Well, instead of binding to the value, we can pass a get and set function. So we have complete control what happens when you read and write to a value. So here is how it looks like. Let's just delete all of this. We can say bind colon value. But now we can pass a get and set function. Or we can just write it inline. So let's define a getter. So we can say to spawn drop case. We can pass the text. And now we can set the value when we update it. So we can say value. And now we can reassign the text. So we can say text equals to Spongebob case. And we can pass the new value. And I'm also going to wrap this in curly boys because of formatting. Alright, so let's go to our example. And let's type test. And we can see it works. So now we can let everyone know that React is just JavaScript. Alright friends, let me show you some cool bindings that you can use. Among the many bindings, you have awesome media bindings for audio, video, and image elements. Let's look at the video player. So in this example, I have a simple video player. Right now, it doesn't do anything. So if we look here, here we have a reference to the clip, and then we're going to bind the current time, duration, and the pause date. In the markup, I just have a simple video element, some controls. Here we have the time, and the timeline is just a range input. So we're going to bind the value of the current time, the max value is going to be the duration, and here we have the step Alright so let go to the video element and let bind some values So we can bind the current time the duration and the pause date Alright so now we can go to the player. Let's see if playing the video works. Of course, we can also scrub through the video. Awesome. And if you want to learn about all of the values that you can bind, you can go to the Swell documentation. As you can see, there's a lot of them. Alright, I want to show you one last cool example. In this example, I have this content editable area, so we can edit the text. and let's say that we want to measure when its width and height changes. Usually you would use something like the ResizeObserver API. But Svelte provides read-only bindings for the client width and client height. So here we defined width and height, and now we just need to bind the value. So we can go to textarea, and we can say bind client width, and we can bind it to width, and we can also bind the client height. And that's it. Now we can go to the example and we can type something. As you can see, it's that easy. Alright friends, in this section we're going to learn everything about components. First we're going to create a basic to-do app and then we're going to split it into multiple components, so we can learn how we can pass data around and so on. Let's start by creating a form to add the to-do. Alright so let's add an input and a placeholder. So we can say add to-do and then we're going to bind the value to to-do. So let's use the onSubmit event and we can create a function that's called add to-do. Alright so let's add some state. So the first piece of state we're going to need is of course going to be letToDo. And then we can copy it over and create todos. And this is going to be an array by default. Alright, so let's create this addToDo function. And of course we get the event implicitly, so we want to prevent the default behavior.

 so we don't reload the page. And then we can just push the to-do to the to-dos array. So we can say to-dos push. So let's pass in an object. So first we're going to create an ID. So we can use crypto from window to get a random UUID. And then we're going to have text, which is going to be the to-do text. And then we can say completed is false by default. All right, so now let's loop over the to-dos. So let's create a list. Then we can use the curly boys. We can use the each block. So we can say each to-dos as to-do. We can pass the to-do as the unique key. Let's close the each block. And then here we can just create a list item. All right, so we can create a checkbox. So we can bind the checked value to to-do completed. So let's add another input, which is going to be our to-do. so we can bind the value to to-do text. And let's also add a button for removing the to-do. So we can say on click. We're going to create this function called remove to-do and we can just pass the to-do. All right, so now we can go here in the script block. Under add to-do, let's add this function. Remove to-do is going to accept the to-do and now we can reassign to-dos to equal to-dos filter. So we get the to-do and then we can say if the to-do ID doesn't equal to the to-do ID that we passed, then we're going to filter the items based on that. All right, and the last thing I want to do is add a container here for styles. So we can say to-dos and that should be it. All right, so let's see if we can add any to-dos here. So we can say learn Svelte. As you can see, it works as expected. Alright, but let's add a simple transition. We're going to learn more about transitions later in the course. But for right now, I'm just going to go to the list item. Then we can say transition colon. So we can type slide. So let's press enter to import slide from Svelte slash transition. As you can see, slide is imported from Svelte slash transition. Alright, so now if we go back to our example, let type in Learn Svelte now we going to see this beautiful transition And that how simple that is Alright so let fix one more thing So for example if we add a to like learnSwelt you're going to see the input doesn't clear. So let's clear the input by going to add to-do. And then we can just clear the to-do value. Alright, so now we can say learnSwelt. Profit. And as you can see, now the input is cleared. And let's also remove the to-do so we can see our animation working and removing the to-do works. So you can see it looks great. Alright, let's show the remaining to-dos. So we can say let remaining. So this is going to be a derived piece of state based on when to-dos change. So we can create this function, remaining to-dos. And we can create this below remove to-do. So we can say function, remaining to-dos. Alright, so we basically want to filter the to-dos and return the length of the array. So we can say return to-dos filter. So now we get access to the to-do. And then we can say if to-do is not completed. But of course we want to return the length. So below the list we can create a div. And let's create a paragraph tag. So we can say remaining. And then let's use an expression. So we can say if remaining is one. Then we can say item. otherwise it's going to be items. And then we just need to add left. Alright, so now let's add a to-do. Alright, so let's delete a to-do. As you can see, everything works as expected. Alright, but I also want to be able to filter the to-dos by all active and completed. And I also want to have an option to clear the completed to-dos. So back in the code, let's create this filters div and let's use the curly boys so we can create an each loop and now let's use an array directly so we can define our filters which are going to be all active and completed so we can say as filter let's close the each block alright so let's create a button so we can say the name of the filter and now we only have to update the filter so we can say on click So let's say setFilter and then we can just pass the filter. And then the last thing we have to do is add the button to clear the completed todos So let add a button here then we can say clearCompleted And then we're going to create another function named clearCompleted. Alright, so now let's go back to the script block. And this looks like a good place to add our functions. So let's say function setFilter is going to accept the new filter. So we can just say filter equals new filter. And of course, we need to add this piece of state. So let's say let filter state, and by default, it's going to be all. All right, so now we only have to clear the completed todos. So we can say function, clear completed. So let's say todos equals todos filter. now you get access to the to-do now we can filter the to-dos that aren't completed alright so let's add our to-do LearnSwelt Profit what you're going to see if we complete this and we try using our filters it won't really do anything and that is because in our code here we're looping over to-dos what we actually want to loop over are the filter to-dos so let's go to the top So here below filter, let's add another piece of state. Let's say filtered todos equals derived. So let's create a filter todos function. So let's keep everything organized. Alright, so let's create a filter todos function. Let's find a cozy spot. Here looks perfect. We can say function filter todos. Alright, so we just need to filter the list of the to-do items. So we can return to-dos filter. And now we can say if filter equals all, then we can return true. So let's copy this over two times. We can say active and completed. So here we can just say isn't completed. And then for completed, we can say completed. Alright so now we can replace todos with filtered todos So let go to our example and now let add a to Let's complete the first to-do, so now let's sort the to-dos by active. As you can see it works, so let's sort them by completed, and let's sort them by all. So now let's see if clear completed works. Awesome, everything works as expected. Alright friends, let's learn about components by taking the contents of this file and splitting it into multiple components. So let's open the sidebar, and inside the lib folder, let's create a new folder called todos, and we already learned that svelte components end with a .svelte extension. So for example, todos.svelte. But the casing doesn't matter, this can be lowercase or uppercase. The name of the component itself doesn't matter as long as it ends with a .svelte extension. Alright, so let's one-shot all of the components that we're going to need. So let's create a to-do. We're going to have a to-do list, a to-do item, and a to-do filter. Alright, so let's close the sidebar, and we can close all of these files. Alright, so let's start with the Add To Do component. So we can go here to our form, we can cut this content, and to use a component we start with the pointy boy, and then we can type component. And in this case the casing is important. The component name has to be capitalized or used the dot notation. For example, my component. But in this case we want to import the Add To Do component. So let's say Add To Do, as we start typing it, if we press enter, we're going to auto import it at the top. Alright, so how can we pass things to this component? Components like regular HTML elements also have attributes, but for components we call them properties, or props for short. So what we want to pass to addToDo is the addToDo function itself, and the to-do. Alright so let's go to the addToDo component. To accept props inside of a component we can just say letProps, and then we can use the props rune. And now we can paste our content. Now we can get add to-dos from props. And we can get to-do from props. Of course this is tedious, so we can destructure the

 them. So we can say add to do, and we can say to do. We can also specify the default value as a fallback. And if you have any other props, you can just gather them, and you can spread them on your element. So we can do something like this. And this is really useful if you're making something like a component library, you're making a button, so you can pass whatever you want. But in this case, we're not going to use it. So let me just remove it. And of course, let's remove props. Alright, so let's add a to-do. So we can say learn Svelte. But we're going to see nothing happens. And why that is? Well, basically, we're mutating this to-do from a child component. So we have to tell Svelte that to-do here is bindable and that it's okay for the child to mutate parent state. So you can use the bindable rune. So we can say to-do equals bindable. and if you want you can also pass a fallback here alright so now that we've done that we actually have to go back here and now we can bind the value of TODO and we can remove this alright so let's add a TODO as you can see it works beautifully what's also really cool is that you can bind the instance of this component using this and you can bind it to some variable like element and now inside add TODO if you have any function like example and you export this function now you can actually access it where you bound it. But in this case binding the property isn't even necessary because we can move state inside addToDo. So we can deleteToDo and let's just add a state here. Let's say letToDo go state and that's it. So now we can invoke addToDo. We can create a function onSubmit so let's remove add to do here and of course we need to prevent the default behavior so we can say e prevent default and now we can say add to do and we can pass our to do and let's clear the to do alright so we can save this let's go back here to our component we no longer need this now we need to update the add to do function to just accept a to do So this is going to be todo We can delete this line And this one Alright that should be it Alright so let add a to As you can see, it works the same as before. Let's also do a bit of cleanup, so we no longer need this piece of state. And I like to keep the imports separate. Alright, so next let's work on the to-do list. So let's go to our markup. Let's take this list. and let's go to to-do list. Alright, so let's add our markup, then let's create a script block, and now we can accept some props. Alright, so we're going to accept to-dos, and remove to-do. So in this case we can replace filter to-dos with a more generic to-dos, because we can pass anything, right? So let's just import slide, and that's it for this component. Alright, so we can go back to our main component, So now we can add to-do list here. Going to auto-import. So now we just need to pass the to-dos. But keep in mind these are going to be the filter to-dos. And we just need to pass remove to-do. Alright, so let's see if this works. Awesome. Alright, so let's take this markup. And this is going to be our filter to-do component. So let's go to filter to do, or to do filter. So let's add some state. Alright, so let's destructure these props. So we're going to pass remaining, set filter, and clear completed. Alright, so back in our component, we can say to do filter. And now we can pass the remaining to do's. the setFilter function, and clearCompleted. Alright, so let's go to our example. Let's add some to-dos. So let's see if our filtering works, and it seems it does. Beautiful. So let's do some cleanup, we can remove this slide, and I think that's all. Let's see. Yeah. Alright, the last component is going to be the to-do item, So we can go to to list and now we can create a to item So let yoink this markup And then let go to to item And we can paste it right here So let's get the props. So the props are going to be the to-do and remove to-do. Let's also add slide here. Save everything. And now back in this component, we can say to-do item. so we're going to import it at the top. So let's pass that to do. And remove to do. We can delete slide. And that's it. So now let's add some to do's. We can see that everything works as expected. Alright, so the last thing to do is to go to app.svelte. Now we're going to take everything from here. So let's go to to do's.svelte. and let's put our code here. And now we can update these imports. This is no longer lib todos. We can just delete this part. Alright, so now we can go back to app.svelte. Let's delete everything and now we can use the todos component. Alright, so let's do one last check. We can complete the todo. we can filter the to-dos and we can clear them awesome all right there is one last thing i want to show you so for example it's really troublesome how we're mutating state so deeply in this child component so if you go to to-do list now we're mutating from this child where we have to do item and this can get you into trouble if you're not aware of it in my opinion binding values is perfectly fine one or two levels deep max, but it can get out of hand if you have more nested components. In that case, instead of binding the values, we can just pass regular callbacks. So let's actually do that quick refactor, just to show you how it looks like. So back in to-dos, we're going to update add-to-do to work the same as before when we had an event. So now we have to say event prevent default. So let's go pure JavaScript and we're going to get the data from the form. So we can say const form data equals new form data. And we can pass it this which is going to be a reference to the form inside of add to do So here we can just say form data get to do And then we can clear the form inside of add to do so here we can just say form data get to do and then we can clear the form all right so because we not going to bind the values in the to do item component we actually have to create functions for toggling and updating the to do but it's nothing complicated so let's go here and let's create our functions so let's say function toggle to do we're going to accept the to do. First we need to get the index of the to do. So we can say to dos find index. So we get the to do item. And then we can say to do ID equals to do ID. Alright, so now we can update the completed state of the to do item. So we can say to dos, pass in the index, and we can change the completed value. Alright, so the updateToDo function is going to be similar. Alright, so let's create the updateToDo function. So let's say updateToDo. Alright, so we also get the to-do index, but in this case, instead of completed, we just want to update the value. So we can say text equals to do text. And that's it. So now we just need to update the props that we're passing. So add to do is going to be unchanged. But for the to do list, now besides passing to do's and remove to do, we're going to pass toggle to do and update to do. Now let's see, what is this complaining about? It's because we didn't pass the prop, that's fine. And to do filter is going to remain the same. Alright, so let's update AddToDo. And isn't this nice, friends? Deleting code sometimes feels better than writing code. So you can just delete all of this junk. Since we're not going to use Bind, now we just need to give this an identifier using name. We can name it ToDo. And of course, on submit, we're going to invoke AddToDo. And that's it for the AddToDo component. Alright, now we just need to update to do item. Inside to do list we're going to accept toggle to do and update to do. So let's pass those as props. Alright, now let's update

 to do item. So let's get toggle to do and update to do. All right, so this is going to be a bit more verbose because we're not binding the value. So we have to say that the checked value is equal to to do completed. And now we can use an event listener on change. So we can say toggle to do and then we can pass that to do. So we can do the same thing for the text. Value is going to be to do text and we can use on input and we can say update to do and we can pass that to do. Alright, so let me save and format. So let's try adding a to do. The only thing that's not working is clearing the input so let's investigate that. So we can go here to our component where we have add to do. Oh, my bad. Clear isn't a thing. This is actually dot reset. Alright, so let's add a to do. So let's see if we can complete a to do. If we can filter them. And let's see if we can clear the to do's. Awesome. As you can see, bindings are really useful, but in most cases you can just pass in regular events. There's nothing wrong with that, especially if you have deeply nested components. And later we're going to learn how we can communicate between components without using props or events. Alright friends, now that we know how components work, let's talk about component composition. Let's learn how we can compose components in CELT by using nesting and snippets to render children and how to communicate between components without using props or events by making a completely customizable accordion. So in HTML, we take it for granted that we can just nest elements. And we can also slot content like in this accordion item. So let's see how we can translate these concepts to Svelte. Alright, so let's open the sidebar and let's create a new folder called accordion. So let's one-shot the accordion components. So we can create accordion.svelte. And we're also going to have an accordion item. And let also create index so we can export our components So let close the sidebar Alright our goal is to be able to use the accordion items like this So we can say import accordion and accordion item. And for this we have to individually export the components. So we can say export default as accordion from and now we can say accordion.self. So let's do the same thing for the accordion item. And that's all that we have to do. Alright so now in app.svelte we can import the individual accordion components. So we can say import accordion and accordion item from lib accordion. In this case the index.js file is going to be automatically picked up. Alright, so let's use the accordion component. And inside of the accordion, we're going to have our accordion item. Alright, but how can we render these children? By default, any content between these component tags is going to automatically become part of a children snippet. And snippets are just regular functions that let you create reusable markup and let you delegate rendering to child components. So in this example, this is actually a snippet. So we can create a snippet by ourselves. If we define the snippet here, we can say children. Let's close the snippet. And the great thing about snippets is that it can be anywhere in your component. So we can have it here. And now we can pass it as a prop to this component. But if you define a snippet between these component tags, then it's going to become a prop implicitly. So we can remove this. And we don't even need to define a children snippet. because it's already done for us. Alright, so let's go to the accordion component and let's render the contents. So we can destructure children from props and now let's create an accordion element. So we can use an if block to check if the children exist and to render a snippet we use the render tag. So we can use curly voice at render. So you can say children, and we can invoke the function. And we can also provide a callback. So let say else And now we successfully render the children Alright instead of using this if block we can also use optional chaining So again, we can use the curly boys, at render, children, question mark, and then we can invoke the function. So this is a shorter way of doing it. As you can see, it works the same. Alright, so let's go back here, and I'm going to remove this, so let's use an accordion item instead, since now we can nest anything. So we can say accordion item. Alright, so let's pass some content here, and let's create a title prop. So we can say item A. Alright, so let's go to the accordion item, and we have to do the same thing. So we can destructure children, and we also have a title. So let's create an accordion item. We're going to have a button, which is going to have a name, Accordion Heading. So let's create a div inside of it. We're going to pass the title. And let's create an accordion trigger. So let's use an emoji. And then let's add an on-click listener to the button. we can name it toggle so let's go back here and let's create a piece of state called open by default it's going to be false and let's create this toggle function so we can say open is opposite of open so we're just going to flip the value all right so below the button we're going to render the children content so let's say if open let's create a div named accordion content and then we can render the children so let's use a curly boy at render children and i'm also going to add a dynamic open class to the trigger so you can say class open all right so we can go to our example let me bump the size up and we can see that it works beautifully. And that's basically it. We can add multiple accordion items. So let's create four of them. Let's say item B, C, and D. And now we can go to our example and we can see that they all work. That being said this has limited composability And what do I mean by that Well let say for example that your user now wants to change the icon So you going to add an icon prop and then they can pass an emoji or whatever but maybe they also want to change the icon position. So now you create another prop because you want to please the user. So you say icon position, okay. Alright, so you have all of these options, but that's not a way to live your life. Instead of doing this, you should use Inversion of Control. So you should let the user control how they want to render this content. Unless of course you want a stricter API like this. Alright, so let's remove this. And let's go into the accordion item component. Alright, so instead of passing children and title, we can pass a snippet. So let's pass an accordion item snippet. So now we can go to the markup, and we can just yoink it out of here. And here we can render the snippet. So we can use the curlyboys at render accordion item. And because snippets are just functions, we can pass open and toggle. And now we have complete control how we want to render the accordion item. So we can just remove this prop since we don't need it anymore. Let's remove the content. And now we can just pass a snippet. So we can say curlyboys hash snippet. So the snippet name was accordion item. And now we can destructure the open and toggle state from the accordion item. So let's close the snippet. And inside of the snippet, we're going to paste the code that we copied. So now we can remove this title here. And say item A. and of course we're not rendering any children so this is our content and that's it and as you can see now we have complete control how we want to render the accordion item of course you can have both in the accordion item you can conditionally render by default the prop the user passed or a custom snippet all right so let's look at our example it works the same as before but now we have complete freedom how we want to render this accordion item. So for example, maybe we want to move this icon here. We can just render it like that. Alright friends, let me show you something really cool, and that is how you can communicate

 win components without using props or events. So let's say for example that you want to control the open and close state of every accordion item. So for example, we can declare a piece of state here by saying open, and then let's say false. But here's the problem. Are we going to pass this piece of state to every accordion item? That seems really annoying. And if we for example bind this value, how are all of the children components going to get notified that this value changed? Well, for this, we can use the Context API. So let me just remove this. I'm going to keep Bind open. So let's go to the Accordion component. We're going to accept this open prop. But remember, we have to make this bindable. Alright, so now in the parent component, we can set the context. So we can import the setContext function from Svelte. And now we have to give the context a key. So we can say Accordion. And now we can pass in here whatever you want. including reactive state. But keep in mind, just passing open isn't going to work. And that is because open is just a regular value, as we learned before. So in this case, open is just going to evaluate to false, and that's it, it's never going to update. We need to use some mechanism to get the latest value of open. So you can use functions or classes, but in this example, I'm just going to use a property accessor. So I can just say get open, and then we can return open. So, now that we defined the context in the parent component, we can access it in any child component. And in this case, it's going to be accordionItem. So we can go to the top here. Alright, so let's get the accordionContext. So we can say const accordion equals, and now we can use the getContext function from Svelte, so we can import that, and now we can access the context by passing the key that we defined before, which is accordion. Alright, so now we can turn this open state into a derived, and we can listen when accordion.open changes, because it's reactive. Alright, so now let's go back, and now here we can create a button, let's say button outline, so let's use a curly boy and an expression inside, so we can say if the state is open, then we're going to say close, otherwise we're going to say open. So let add on ClickHandler and then we can just flip the value of open Alright, let me copy the accordion item multiple times. Alright, so now when I click open, all of the accordion items should be open. So now if I close them, they're all going to be closed. Most of the time you're going to want to pass props. But when you have a deeply nested component, or you're making something interesting like this accordion component, then the Context API is a perfect solution. Alright, so there's one more thing that I want to show you when it comes to component composition, and that is the module script block. It's easier to show you, so I'm going to create a new file, so let me press Ctrl-Shift-P, and then we can change the language mode, so we can change this file to be JavaScript. Alright, so essentially, Svelte components are just regular functions. so for example we have a function called component and then let's say inside of it we want to create a unique id so we can say crypto random uuid and that's great if you want a unique id for every component instance because when we create a new component we're going to get a new random id so let's say that we have four instances of the same component so we can say let a equals component So we have A, B, C, and D. And now every component is going to have a unique ID. But let's say that you want to share the same unique ID across component instances. Well, this file is actually called a module. So instead of creating a unique ID inside of a component, we can move it at the top of the module. So let's just move ID. and now it doesn't matter how many component instances you have because they're all going to reference the same unique id so that is what the module script block is for all right let's look at an example so let's open the sidebar and then let's collapse to dos and accordion and now we're going to create a new component inside the lip folder named counter.swelt. So let's collapse the sidebar. Alright, so normally we would create a script block and we would say count equals state 0 and we can create a button. Say count. On click Count plus plus But let say that we want to share this count state across component instances So instead of using a regular script block we can just use a module script block So we just say module, and that's it. And of course, you can have both of them in the same component. So you can have a regular script block and a module script block. But this isn't only useful for sharing data and state. you can also export utilities and whatever else you want, including snippets. So for example, let's add a function that can reset the count. And then we can say count equals 0. Alright, and let's say that you have some snippets. So here I have an icon snippet, and this is a really great use case for snippets. You can define your SVG icons inside of a component, and then you can export them. The only caveat to when exporting snippets is that they can't reference any state inside of a script block. so they have to be self-contained. And remember, snippets are just regular functions. And we can say export icon. So you can export as many snippets as you would like. Alright, so now inside app.svelte, we can create a script block, and we can say import counter, and let's import icon and reset from lib slash counter.svelte. Alright, so let's use the counter component, and let's create a reset button and let's also render the icon. So we can use curly boys at render. We can say icon. So let's render one at 50 by 50 pixels, 100 by 100 pixels and 200 by 200 pixels. Alright, so let me also add a container Alright, so now in the example, we can increment count. As you can see, now it's shared across the component instances. And we can also reset the count. And of course, we can also see our beautiful icon being rendered at different resolutions. As you can see, the module script law is very useful. You can use it for anything from controlling media playback across component instances to just exporting some utilities from the module you want, instead of creating a new new file. Alright friends in this section we going to learn how to create delightful user interactions with Svelte transitions and animations So let look at a basic transition Let add a message element with two spans inside of it and we can say hello world. Alright, so to add a transition, we can use the transition directive. So we can say transition colon, and we can use one of many built-in Svelte transitions. So let's say fade, and let's import fade from Svelte slash transition, and we can also pass some animation options. So we can see that we have multiple options such as delay, duration, and easing. And the options depend on the type of the transition you're using. So in this case, let's say duration, and this is going to be 600 milliseconds. Alright, so first I want to animate this hello text during these 600 milliseconds, and then I want to animate this world text. So we can do the same thing, we can say transition, fade. but instead of a duration let's use a delay and we can set it to 600 milliseconds. All right so transitions only run when the component is added to the DOM. So let's refresh the page. And as you can see the transition works beautifully. All right let's make this more interesting. So let's create a new piece of state called play. So we can say let play equals state let's say false. alright, so let's create an interval that's going to update the state of play every 2 seconds so let's say setInterval and then let's pass a callback so let's flip the value of play and then let's say 2 seconds alright, so let's add an if block we can use the curly boys found if and we can say play so let's close the if block and that's it you can also define custom intro and outro transitions so for example instead of transition we can use the indirective instead of fade let's import fly from swell slash transition so now we have new properties to play with so for example let's say x should be negative 10 let's leave the duration alone and now we can also specify an easing so it has a bunch of custom easing that you can pick from, but let's pick a fun one like elastic out. So we can also import that from svelte slash easing. And of course, let's specify an ultra transition so we can say out fade. All right, so let's do the same thing for

 second span set of transition let's use the indirective going to say fly and x is going to be 10. and we can also use the same easing and let's specify the outro transition all right so let's do a bit of formatting all right so let's go to our example and we can see that we have this fun transition There is one important thing that you should know about transitions, and that is local versus global transitions. Let's say that we're looping over a bunch of items that we also want to stagger. So let's create an element called stagger. Any side of it, I'm going to use the each block. So let's use a curly voice, found each. Alright, so let's create an array of 50 items. And let's also close the each block. Alright, let's look over the 50 items. So we can say I plus 1. So this will give us 50 items. And it works. Alright, let's add the transition. So let's use the indirective. And we can import phase from Svelte. To create a staggered effect, we can just use a delay. And we can multiply the index by the time. So we can say 100 milliseconds. But this isn't going to work. So if you go to our example, no matter how many times we refresh the page, nothing is going to happen. And that is because transitions are local by default. That means that transitions only play when the block they belong to is added or removed, and not the parent block like this each block, for example. To fix this, you can use the global modifier. So you can use this pipe, and you can say global. So now our example should work if we refresh the page. As you can see, now we have a beautiful staggered animation. In past versions of Svelte, transitions were global by default, so keep that in mind if you ever encounter older Svelte code. Alright, so we've seen that transitions play when the element gets added to the DOM, but if you're using a framework like SvelteKit, that's not the case, since the initial payload is server-side rendered. So let make a fade component where we can control if the transition should play So let open the sidebar any side of lib Let create a new file So let create a transitions folder And then let's create a new fade.svelte component inside of it. Alright, so let's start by creating a script block. And now we want to destructure the children, if the transition should play, and the transition options from props. and if you're using something like Soilkit and you just want to automatically play the transition when the element is added you can just use an effect so you can just say play true when the element is added but in this case we want to manually control if we can play the transition alright so let's use an if block we can use the curly voice so if play is true then we're going to play the transition so let's close the if block and inside of the if block we're going to create a div Alright, so we can use our transition. So let's import fate from Svelte slash transition. And then we can pass the transition options. So it should be options. So inside of the div, we can render the children. So we can use our curly boys at render. And then we can render the children. Now let's go back to app.svelte. Alright, so now inside app.svelte, we can use the fate component. So let's just import it. So we can say something like, boo. And let's use a spooky ghost. And as you can see, we have a warning because these props are required, but we can actually make them optional. So if we go here, let's say that we don't want to play this transition by default, and we can also use an empty object by default for the transition options. Alright, so now we no longer get a warning here. But of course, we can specify the transition options. So we can say duration should be 2 seconds. Alright, so we can go to our example, and we can see regardless how many times we refresh the page, the transition isn't going to play. But we can of course specify play. But this is redundant, we can just say play. And let's refresh the page, and you're going to see it still doesn't work. And you probably already know why. So if we go to the fade component, we learn that transitions are local by default, so we need to make this transition global. So let's use the pipe and say global. Alright, so now our transition should play when the outer block gets removed or added. And if we refresh the page now you going to see we get a spooky transition Alright friends not only are we able to use swells built transitions we can also specify our own custom transitions and a custom transition is just a simple function that returns an object with the transition options and a css or tick function all right so let's create a custom transition so we can start by creating a function named custom transition we get a reference to the node and we can also pass the transition options all right so let's destructure the options and we can set some default values so here we can say that duration should be two seconds there should be no delay and let's use a custom easing so we can say elastic out so we can import that from self and now we can return an object with the transition options all right so now let's return an object with the transition options so you can say duration delay and easing all right so this is the important part. We can either return a CSS function which is going to use CSS keyframes to generate this transition, or if you need to use JavaScript for your transition, you can return a tick function. So let's return a CSS function. We can say CSS, and we get the st argument, so this is going to be the progress of the transition that goes from 0 to 1, and then we can return some CSS. So let's use backticks. So we can say color, HSL. So let's use a template literal. So we want to animate the hue. So we can say 360 times T. And then we can say 100% for the saturation and 80% for the lightness. All right, so let's also add a transform. So we can say transform, scale. And let's also use a template literal. And then we can just say T. So we want to animate the scale from 0 to 1. Alright, so let me briefly explain what this T means. So for example, let's say that you have a transition where an item goes from 0 pixels to 100 pixels, over 2 seconds. So if T is a value that goes from 0 to 1, that means that if T is 0.5, for example, then the progress of this transition is going to be at 50 pixels. And it's really that simple. And besides t, we also have this u value, which is just the opposite. Alright, so let's use our custom transition. So let's go here, let's create a heading. Alright so we can use the custom transition like any other transition So we can use the indirective and we can say custom transition Alright so let save this and go to our example and we can see it works beautifully How cool is this, friends? Alright, friends, let me show you a custom transition that uses JavaScript. This is really useful when you want to use JavaScript to control a transition, such as a typewriter effect or this scrambling text effect. So I'm just going to copy and paste this custom transition here. So if I reload the page, we can see how it works. And it's a really cool effect. Alright, so let's talk through it. So here we have some Hackerman characters, and then we just have a simple function that gets a random character. So here is our custom transition named scramble text. As before, we get a reference to the node and the options. So we set some default values here, but now we're using JavaScript. So we get the final text from the node text content, and we get the amount of characters here. Alright, so now we only have to return an object with the transition options, but now instead of CSS, we're going to use this stick function to use JavaScript. So we're going to accumulate the result in this output variable, then we're going to loop over the characters in this for loop, so we're saying if t is higher than i divided by length, then we're going to rest the character at its final position, otherwise we're just going to get a random character. and then each time we're updating the node's text content. So we can just assign it to output. Alright, so now in the rest of the code, we can just use this like any regular transition. We're using a monospace font, so the letters have the same width, and then we can use our custom transition by using the interactive, and we can specify that it should be the scramble text effect. And that's it. Now we have this wonderful scrambling text effect. Alright friends, let me show you something that is going to blow your mind, and that is coordinating transitions between different elements. So if you're familiar with view transitions, basically Svelte has them built in. So here I have an example that I prepared for you. Here we have just a simple example where we're looping over these posts, and we can archive them and unarchive them, and the code is really nothing special. Here we have these random posts, and we have these two functions where we can archive and remove a post. And in the template, we just have two sections, the first one being post, so we're looping over the post, and we're filtering them based on the

 the ones that aren't archived. And then we have another section, which is the archive. So here we're doing the opposite. We're just filtering the post based on the ones that are archived. And that's pretty much it. As I said, there's nothing special going on here. All right, so what is the problem? So in this example, when we archive a post, and then if we unarchive it, we're going to see that the item just magically teleports. And in the real world, items don't behave like that. and this is really a worse user experience because it's not clear what happened. To fix this, we can use the crossfade transition. Alright, so the only thing that we have to do is import the crossfade function from svelte slash transition. The crossfade function creates two transitions named send and receive. So we can destructure those from CrossFate. And we can just pass an empty object for now. Alright, so the only thing that we have to do is go to a niche block here where we have article so we can use the indirective and use the receive transition which accepts a unique key so we can say key and we can set it to the post so Svelte knows what items to transition. Alright, so now we can use the Out directive, we can use the Send transition, and we also need to pass a key, and we can say Post. Alright, now we have to do the same thing for the Archive section. So we can just copy this code, let's go to the Archive, so again here we have this each block, and this article, we can just go here, we can copy and paste our code, so let's save everything, and now we can go to the example and we can see the magic happen. So let's archive a post and as you can see it's no longer going to teleport. How magical is this, friends? And we can also specify some crossfade options. As you can see we can pass a delay, duration, easing and a fallback transition. For example we can base the duration on the element distance. So let's use a duration function and we can get the distance, and now we can say math square root, and now we can multiply the distance by 200 And you can also provide a fallback transition if no match is found So we can say fallback and we get a reference to the node with the options So we can return a custom transition object. We can use the CSS function, we get access to T. We can use backticks. So let's say transform, scale, and then we can use template literals. we can just pass T, and we can also animate the opacity. And that's it. Alright, so now if we go to the example, we can see that the duration is based on the distance. How cool is that? Alright friends, let's talk about flip animations. Currently, there is a problem with our transition, so let me show you that. If we remove this fallback, let me set our duration to something more obvious like 2 seconds, So let's go to our example. So when I press archive on this post, you're going to see that we have this empty space here, so when the transition is done, the elements are going to snap back in. And this looks janky. So we can see it again. So let's archive the second post, it's empty, and then the item snap in. And we can see the same thing if we unarchive the post. Alright, so to fix this, we can use the flip function from Svelte. So back in our code, the only thing that you have to do is import flip from svelte slash animate. Alright, so now back in our template where we have the each blocks. So we can go here. We can use a new directive called animate which only works inside each blocks and then we can use flip. And of course you can also pass in some options here such as delay, duration, and easing. But in this case, we're going to ignore it. Alright, so now we have to do the same thing for the second container. So here we have article. We can say animate, flip. And that's it. Alright, so now if we go back to the example, we can archive a post, and we're going to see that the items are going to animate gracefully. How cool is that? Let's archive the second post. post We can also unarchive the post And of course this also works if you delete a post And that is the power of flip animations And flip animations don depend on crossfade transitions but as you can see, they work great together. Alright friends, just like with custom transitions, you can also make custom animations. Alright, so let's look at an example. So here I have a simplified version of the flip animation. As you can see, we get a reference to the node, we get the before and after state, and we also have some animation options. So in this case, we're calculating the delta for x and y, and then we're calculating the scale based on the width and height. And just like with custom transitions, we can return these animation options, including a CSS function. And then we can do some math, and we can apply a transform. And here we have a simple shuffle function, and we're creating 10 items, same as in the The gsev flip example, in fact we're using the same markup from that example, so here we're going to loop over a bunch of items. As you can see, we can shuffle the items, but I also want to animate them. So going back to our code, here inside of each block, we can use the animate directive, and we can just say flip. So now if we go back to the example, we can see that we can flip the items. Now that's magical. And we can even log the value of the before and after state. So we can say console.log. So let's say from to. So now if we open the developer tools, and let's shuffle the items, you're going to see we get the before and after state for every item. So now using the animate directive and the flip function, we can animate the difference in their position. Let's talk about tween values and springs. Imagine if you could take the CSS animation engine, but you can interpolate any number including objects and arrays. This is where Svelte's tween and spring classes come in. Alright, let's look at an example. So let's create a value named size, and instead of defining this with state, we can say new, and if we start typing tween, let's import tween from Svelte slash motion. And if you're wondering, because you're animating between two values, that is what tween means. Alright so we can pass the target value of 50 so this is going to animate this value from 0 to 50 And then we can pass some animation options So we have a couple of options We can pass the delay duration easing and even a custom interpolation function So if you want, you can interpolate between colors and anything else. I recommend checking out the D3 interpolate library, which gives you a bunch of interpolation functions out of the box. Alright, but in this case, we're going to specify a duration, 300 milliseconds, and I'm also going to use an easing. So let's say cubic in out. So we can import that from Svelte slash easing. And that's it. So now we can define two functions. The first function is going to be called onMouseDown. And tween has a couple of properties on it. So we can look at size dot. We can see we get current. So this is what we can use in the template to get the value. We can use a set method. So for example, we can say 200. And then we can override the animation options if we want. and this is also a promise so you can await this if you want and make this async but in this case we can just say size.target and we can say 150 and this is the quickest way to update the value alright so let's copy over this function so instead of mouse down this is going to be mouse up and we can use the default value alright so let's create an SVG with a circle so we can say the width and the height are going to be 400 and then we can specify the view box and you can think of a view box like a camera for the SVG so for example here we can say the x and y coordinates should be 0 0 and we can also specify what the camera sees so this is going to be 400 by 400 it. Alright, so let's create a circle. So let's pass the event handlers. So we can say on mouse down, and this is going to be on mouse up. Alright, so let's specify the circle coordinates. And for the radius, we can say size.current. And let's also add a fill color. We can say orange-red, and that's it. And we can even disable this accessibility warning, so we can go to quick fix, and we can just disable it. Alright, so let's go to the example. And now when I hold the mouse down on the circle, it's going to grow larger, but

 So when I release the mouse, it's going to go back to the original position. How cool is that? Alright, so besides the tween class, there is also a spring class. So you can use spring physics based on Hooke's law. So here where we define the tween, instead of tween, we can say spring. And we can also import spring from Svelte slash motion. So spring physics are based on Hooke's law and they don't have a duration. Instead, you can specify stiffness, damping, and precision. So, for example, we can go here, and instead of using these values, we can say that stiffness should be 0.0, damping 0.25, and precision should be 0.1. So, we don't need this easing, and let's remove the tween. Alright, so now let's go to the example. So when I hold the mouse button down, it's going to grow larger. And when I release the mouse, it's going to go back to the original position. As you can see, it feels a lot more natural and springy. All right, friends. In this section, we're going to learn how we can use third-party JavaScript libraries in Svelte. So if a specific Svelte package isn't available, you have the entire JavaScript ecosystem at your fingertips. Unfortunately, third-party JavaScript libraries usually require direct access to the DOM, and they don't understand Svelte's reactivity. So in this example, we're going to use the popular GCEP animation library in Svelte. Alright, so let's say that you've read the GCEP documentation, and you want to try out their example. So we can create this box element, and then we can just simply create an animation. Let's import GCEP, and then we can use this to method to create a twin animation, and then we can specify the target, which is going to be the box class, and then we can specify some animation options. So we can say rotation, 360 degrees, the x position should animate 200 pixels, and the duration should be 2 seconds. Alright, so let's go to our example, but you're going to see that nothing happens. Alright, so let's open the developer tools for any clues, so we can see the warning from GSAP, target.box not found. And this is because when this line of code runs, box doesn't exist in the DOM yet. So we can use the onMountLifecycle function So if we say onMount we import on mount from Svelte And let pass a callback function And we can place our animation inside of it. And let's also organize the imports. So let's go back to the example. And when I reload the page, the animation should play. Awesome. In this example, we're saying dotbox, which is just a query selector under the hood. but of course we can pass a reference to the element instead. So let's create a target variable, and then we can bind the value of this element using this, and then let's bind it to the target. Alright, so instead of saying dotbox, we can just pass the target. And we can also say const tween, so we can return a cleanup function. So we can go here, and we can say return, and you can say twin.kill. And of course, if we reload the page, everything works the same as before. And of course, instead of using onMount, you can use an effect. So we can remove the onMount import, and instead of onMount, we can just use an effect. And this works the same, but keep in mind that effects aren't lifecycle functions. an effect lifecycle depends on the value inside of them updating. So in this case, if you make target reactive and update it at any point, then this effect is going to rerun. There is no right or wrong way here. If you don't care about tracking values, then you can just use onMount. The more important thing is that you don't treat effects like lifecycle functions. So if you understand how effects work, then you're not going to run into problems. Alright, we got this GSEP example working, but now let's look at how we can bend it to our wheel and create a declarative component out of it. So let's take this code, and then let's open the sidebar, and inside of lib, I'm going to create a new component called tween.svelte. Alright, so in our new component, let's paste the code, then let's go to the top. I don't want target to be reactive, so I'm going to remove this. Alright, so for the props, we want to destructure, tween which is going to be a reference to this animation so we can control it and we're going to make this bindable and then we want the animation options i'm going to name this vars because that what g sub calls them so for example if we go here to two you can see g sap has targets and vars I don know why it names it vars but it is what it is And of course we want to accept the children because we want to be able to animate anything Alright, so now instead of defining tween here, we can just reassign it, and then we can remove this part, and we can use our animation options. And the last thing that we have to do is render the children. So we can use the curlyboys at render children And that's it. Alright, so now let's go back to app.svelte And let's use the tween component So we can import tween from lib.tween.svelte And now we can get a reference to the animation by binding tween to animation And we can create it here alright, so let's pass the animation options so we can say vars rotation, recalor in a 60 x should be 200 and duration should be 2 seconds alright, so we can animate anything that we want so let's create a button with a box class we can say lay and because we have a reference to this animation we can say onclick and we can say animation restart. And this is just a built-in GSEP method. Alright, so let's do a bit of cleanup. And inside of tween, we can also remove this box class. And that's it. So now when we go to the example, we can press play and the animation is going to play. So far, we learned that we can use onMount to get a reference to an element. This can be a bit tedious and boilerplate-y when you want a quick reference to an element. So what if instead of component-level lifecycle functions, you had element-level lifecycle functions? In that case, you would have attachments. Attachments are just regular functions that you can attach to regular elements that run when the element is added to DOM or when state inside of them updates. So let's look at the same GSEP example using attachments Alright, so I'm going to start with the box and then let's format this a bit So we can say curlyboys at and the attach keyword So now we get our reference to the node element but you can name this however you want So let name this box and then let create a function So let's import GSEP. And now we can say .2. So now we can pass the target and the animation options. So let's say rotation, 360, x is going to be 200, and the duration is going to be 2 seconds. Alright, so now we can look at our example. So now if I reload the page, the animation should work. As you can see, this is a lot more convenient. Alright, how do we create a Tween function that we can reuse across components similar to the Tween component that we created earlier? Alright, so the first thing that we have to do is create a Tween function which accepts the animation options and an optional ref callback. So we get a reference to the Tween. So inside of the function, we can say letTween, and because attachments are just regular functions, we can just return an attachment. So let's return an attachment, and of course, here we get our reference to the target element, and inside the function, we can reassign Tween to be gsep2 with the target and animation options. And if you need our reference to the animation, we can invoke the callback. And let's also return a cleanup. That's it. So now in the markup, instead of using an inline attachment, we can use the attachment that we made. So let's use the curly boys at attach, so let's use the twin attachment that we created. So let's pass the animation options. So we can say rotation, 360, x is going to be 200, and the duration is going to be 2 seconds. And we can use the optional callback to get a reference to the animation. So we can get a reference to the tween, and now we can assign it to animation. So let's create animation. Alright friends, this is the coolest part, so now instead of div, we can turn this into a button, and let's say play inside of it.

 Now we can say onclick animation.restart. Alright, so now if we go to the example, and if we press play, we can see that our animation works. How cool is this? Alright, let me show you another cool thing about Svelte, and that is special elements. So Svelte has special elements you can use at the top level of your component. Let's say that you want to listen to the window scroll position. so let's create a script block and then we can say let scroll y equals state and let's say 0 alright so now we need a handle scroll function so we can update scroll y to equal window scroll y alright so let's use on mount so we can add an event listener to the window we can say window add event listener let's listen to scroll and then we can invoke our handle scroll function. And let's return a cleanup function. So we can say window remove event listener. We want to remove the scroll event and we need to pass our handle scroll function. All right, so now let's create a div element named scroll and then we can say scroll y and we can say pixels. And that should be it. This is what it would usually take to listen to an event and update the value. So now if we go to the example and if we scroll, we're going to see that the scroll position is going to be updated. Thankfully, there's a better way to do this in Svelte. So instead of using onMount, where we also have to do the cleanup, we can use a special element instead. So let's remove onMount, and then at the top level of the component, we can use Svelte colon window. So we can say onScroll and we can use our handleScroll function. And Svelte also takes care of the cleanup. So now if we go to our example, it works the same as before. We can make this even simpler. Instead of using events, we can use bindings for properties like the scroll position. So in this case, we don't even need the handleScroll function. and we can just remove this. So the only thing that you have to do is bind the value So we can bind scroll y And now if we go to the example it works the same as before Believe it or not we can make this even simpler Svelte also exports reactive window values from reactivity slash window, so you don't even have to use a special element. So we can remove this, and now in the script block, we can import scroll y from svelte slash reactivity slash window. And now in the template, the only thing that we have to change is to say scroll y dot current. And that's it. Now our example should work the same as before. Awesome. Alright friends, let's talk about Svelte's reactive data structures and utilities. Alright, so here I have a simple Pokemon search example. So here we have a search query which is called name and then we're storing Pokemon in this map cache. So here inside of this getPokemon function we can just check if the Pokemon exists inside of the map. If that's the case, we can just return early. Otherwise we're going to fetch the details for the Pokmon, and then when we get the data we can just add the Pokmon. And of course we're using an effect to get the Pokmon. Inside the template we're just binding the value to the name, and then here we're looping over the Pokmon. Since it's a map, we can just structure the name and the details, and then here we're going to use the details element with a summary. And then we can just JSON stringify the details, and that's it. And we also have a button to clear the map. Alright, so trick question, is this going to work? As you can see, nothing is showing in the example. Alright, so how do we fix this? Well, maybe we can pass this map to state, I don't know, let's try it. Alright, at least the example is showing. But if we search for something like Pikachu, nothing works. And that is because, of course, this still isn't reactive. because there is no way for Cell to know that this method is going to be reactive. But thankfully, Svelte has reactive versions of some built-in JavaScript objects, like set, map, and so on. So let's go here where we define the map, and instead of using set or new map, we can say new Svelte map, and we can import this from Svelte slash reactivity. Alright so now if we go to the example Let search for Pikachu and you can see it reactive So we can see all the details for Pikachu Alright, let's search for Charizard, and you're going to see now we have Charizard details. And we can also clear the Pokemon. Awesome! You can find even more reactive built-ins in the Swell documentation. So here you have a media query class, for example, if that's something that you need. We have SvelteDates, so you have reactive dates. Here you have SvelteMap, which we just used. You have SvelteSet, which is really great. You have SvelteURL for working with URLs. Then there's also SvelteURL search params, and so on. You can read more in the Svelte documentation. So you can use any of these in your project. Alright friends, this is a more advanced topic, but I think it's useful to know whenever you're trying to make an external event-based system reactive in Svelte. And an external event is any event you can subscribe to and listen for changes. In this example, we're going to create a GSEP timeline and our goal is going to be to synchronize the timeline with an input. So let's start with a basic timeline, in this example I have a simple class called Timeline and here I have a reference to the GSEP timeline. When I create this timeline, I'm going to invoke this method, create timeline, so this is going to create the timeline when the component mounts. And this is just so we have a nicer API when we create this timeline, so we can just pass in an array of arrays for the animation keyframes. And then we add it to the GSAP timeline. And in the template, we just have two items, box1 and box2, and an input. So we can go to the example, and when I reload the page, you're going to see that we have a simple animation here. Our goal is going to be to synchronize this input with the GSEP timeline. Alright, so let's start with a naive approach. Here at the top where we define our class, below timeline, we can specify a new reactive variable called time, so this is just going to be state, and then inside of the constructor, we can use an effect to update it. So let's create an effect, provide a callback, so we need to reference the gseptimeline, so we can say this timeline, and we can invoke the seek method, so we can update the timeline playhead each time this time updates Now we just need to create the getter and setter so we can bind the value And we can say get time so we can return time And then let create a setter So we can say set time the new value that we're going to receive and then let's update time to the new value. so now in our template we can bind this value to the input so we can say bind value tl for timeline and then we can pick time all right so let's save and format the document so if we go to our example we can reload the page to see our animation and we can now control the timeline but you're going to see that it's still not synchronized so if i let go you're going to see nothing is going to happen all right so how do we synchronize the timeline and this is where using events comes in. So we can subscribe to GSEP's onUpdate event, and then we can update time, which is going to trigger the effect. So we can synchronize the input with the GSEP timeline. Alright, back in our code, let's go to the effect. So now we can go here. Let's reference the timeline. And then we can use GSEP's event callback API. So we can subscribe to onUpdate, and then we can pass a callback function. Alright, so each time the animation updates, we're going to update the time. So we can say this time, and now we need to reference the timeline, so we can say this timeline, and we need to get the latest time by using GSEP's time function. Now when this updates, it's going to trigger this effect, which is going to synchronize the timeline and return the latest value of time. Now in our example, we can change the input and you're going to see it's synchronized with the timeline. And that's awesome, but there's a simpler way. Alright, let me show you a simpler way how to make reactive events using the create subscriber function. So we can delete this effect and this code below it. And then we can say create subscriber, so let's import that from Svelte. As you can see, it's imported from Svelte slash reactivity. And we can pass a callback function to createSubscriber where we get this update function. This is going to let us create subscribers. So we can just say this timeline, and we can say eventCallback, we can subscribe to on

 update, but in this case, we can just pass the update function. And we can also return a cleanup function. So let's say return this timeline event callback on update and we can say null. Of course, this way of doing cleanups is specific to GSAP, but the method remains the same for any event that you can subscribe to. Alright, so now instead of having this extra variable time, we can just create a subscriber. We can just say subscribe, and then we can store the reference to the function that's returned from createSubscriber. So we can say this subscribe equals to createSubscriber. Now we can subscribe to the timeline updating. So we can go to our getter, and this makes things a lot simpler. The only thing that we have to do is say this.subscribe. So this makes the time value reactive when it read inside of an effect The best part is that you don need any extra state because now you can just return the value from the timeline So we can say timeline and of course we can update the timeline So we can go here, and we can say this.timeline, seek, and we can pass the new value. But of course, don't forget to invoke the subscribe method. So let's see if the example works. So if I reload the page, the animation should play, and as you can see, the input is synchronized with the timeline. As you can see, using Create Subscriber can make your code a lot simpler, and not only that, but you can control when you want to run this update method. The Create Subscriber API is great whenever you're trying to make an external event-based system reactive in Svelte. That can be anything from browser APIs to random JavaScript libraries. You can subscribe to and listen for changes. Alright friends, without a doubt, at some point you're going to run into legacy Svelte code. So Svelte 5 was a large shift from previous versions of Svelte that introduced a new system of reactivity with runes and snippets replacing slots among other things So if you ever need a quick overview you can find the Legacy API section in the Svelte documentation And there are even other things that aren't listed here, such as Svelte stores. In the past, stores were required to have reactive state outside Svelte components. The reason I didn't cover stores in this course is because I don't think that you no longer need them, because now you have universal reactivity with runes. But if you ever run into stores, then you can read this section in the Swell documentation. There is one more thing worth mentioning when it comes to legacy Swell. By default, Swell components are in legacy mode, unless you use runes in your component. And this is worth noting because you might run into unexpected behavior when you're using legacy components. So there's two ways that you can ensure that your component is in runes mode. the first method is just using runes. So you can say letCount equalState and now your component is automatically in runes mode. The other method is using this special element to specify some compiler options for Svelte So we can say Svelte colon options and we can say runes equals true You can also specify the Svelte compiler options for the entire project. And this is what I've done for this entire course so we don't run into any problems. So if we go into the Svelte config, you can see under the compiler options I enabled runes by default. And in the future versions of Svelte, this is going to be the default. Alright friends, in the last section, I want to talk about using Svelte with AI. To be completely honest, I'm not a big AI user, but I know that this is important to a lot of people. Newer AI models seem to be getting better at supporting the latest Svelte syntax, but it's still not perfect, and it's often going to hallucinate features that don't exist with overwhelming confidence. So, if you're using AI and want the latest Svelte syntax suggestions, Svelte has LLM-friendly documentation you can feed to an AI context window for more accurate suggestions. Alright friends, that's it. I hope that you enjoyed this Svelte course and I'm going to catch you in the next one. Peace!