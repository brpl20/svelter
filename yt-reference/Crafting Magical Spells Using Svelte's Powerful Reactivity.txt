 Hey friends, what's up? Today I want to show you something really magical and that is how we can use Svelte runes to create spells. So what is a spell? Well, basically a spell is just a reusable utility. For example, you might have a local storage spell. In the past you might have used Svelte stores, but in Svelte 5 we have runes, which is a new reactivity system. And the beauty of runes is that they work inside and outside Svelte components. So today I want to explore a couple of ways how we can use runes to create spells from functions to classes which should be really interesting all right but before we get started don't forget to like and subscribe and you can also support me by becoming a patron all right so here i have a simple count which i can increment so you can see there is nothing special but let's say for example that you want to persist the value of the count when you reload the page for that we can use local storage and it's really simple to do in svelte so we can use the effect room for side effects and if you don't know what side effects are well that's basically anything that's happening outside your components which can be a fetch call it can be talking to your database or manipulating the dom in this case we're using a browser api local storage which is a side effect right so we can come here and we can first get the data from local storage so let's check if it even exists so we can say item and then we can use the local storage api we can say get item and let's just name it count and then we can check if the item exists in this case we're going to reassign the count value to item but this is not enough because we actually have to parse the value from the local storage using jason and of course besides jason there is his brother jamel but jason is really awesome right so we can say jason parse and then we can just pass the item and that's going to be it and as you can see if we go here nothing is still going on because we actually have no value so we don't persist anything so that's our first effect and then we're going to create another effect so we want this one to rerun the first one is going to run just once on page load and this one we want to run each time the count value gets updated so we can say local storage in this case we want to set the item pass it the key count and then we can use json stringify and then we can just pass it a counter you don't have to pass any dependencies here svelte already knows that it has to rerun this because count changed so if i save this and go to the browser even if i refresh you're going to see now we have this key value in local storage named count so now we can increment this up to four i'm going to refresh the page and you're going to see is going to go from 1 to 4 because it's going to first render on the server and then in the browser right and if i go up to 10 now we're going to refresh the page it's going to use the initial value and then it's going to get the value from local storage and there's also another way you can do this so for example since we want this effect to run once if you're using swell kit you can just import browser so you can know if you're in the browser context so in this case i'm just going to take these two lines i'm going to remove this effect i'm going to say if browser and we we can import this from SvelteKit and then we can just copy and paste it over here and it's going to work the same as before since we only want this effect to rerun right so I'm going to save this and even if I go here and clear local storage I'm going to refresh the page it's going to create this key value count with zero let's go up to four let's refresh the page and we're going to see everything works the same as before all right that's cool but let me actually show you the beauty of SvelteRune so let's say that we want to create our usable function we can just copy and paste our existing state. We don't have to use another piece of reactivity system like stores and etc. We can just use what we have. So let's create a use local storage spell. I going to name it use local storage I going to pass in a key which is going to be a string and then the value is going to be any for now and we just need to copy and paste our existing state and of course we need to make this function more generalized so instead of passing count here this is just going to be a generic key which we passed and instead of count i'm going to rename this to something like storage and i'm going to create an object here and pass it the value as the initial value so we can just do this we can just say return storage and now we have to create this storage so we can go here and let's just say let count we can say use local storage let's pass it the key which is going to be count and let's pass it the initial value zero and here in a template we have to say count dot value and count dot value that's it and i forgot about another thing so we have to say here storage dot value and that's it so now i made another oopsie since i have storage dot value we have to say here storage dot value and that's basically it let me see everything looks great let's clear this refresh the page you're going to see everything looks great let's just go up to four refresh the page as you can see everything works great all right so now we can take this existing code and we can place it outside of this component and it's just going to work like magic. So where are we going to put our spell? Well, inside of this SvelteKit project, I'm going to go to source lib. And the only important thing is once you name this file, I'm going to name this index, but make sure your file ends with Svelte.ts or JS, whatever else you using, because this is an indicator to the Svelte compiler that we have goons inside. So I'm going to put our spell here. And inside of here, I'm just going to export this. And that's basically it. so now going back to page.svelte let's also import browser here that's it so now we can go back to page.svelte we can remove this and actually let's say use local storage so now this is going to be imported from lib and everything should work the same as before so now even if you refresh let's go up to 10 and boom how beautiful is this friends all right but let's say for example that you pass in something more complicated like obj so you can say use local storage object and then let's say we pass it a1 for example b2 and we want a nicer user experience using typescript so for example if you look at the type here it's object with value any and that kind of sucks and this is actually not really that hard to type so we can actually go here and then we can pass in a generic and generics aren't really anything that intimidating if you don't know what they are how you have arguments to functions basically generics are just type arguments so we can pass in t here but this can literally be named banana or whatever else you want so you can pass t and then we're also going to make this value t because we don't know ahead of time where this is going to be and the only thing we have to do is type state so this is also going to be a generic it's an object with a value and whatever we pass into the value is going to be of type t all right so now we can save this and again if you go here back to the page now when we hover over this type we're going to see we get value which is a and b number and now we get great auto completion in our editor awesome how beautiful is this friends all right so let's do the same example using classes so why would you use a class and not listen to those people who talk about performance like for most use cases it really doesn't matter it's personal preference if you want to use a function or a class but in some examples let's say for example that you're making a confetti library so you have a of particles and etc Of course a class is more performant because a function is more expensive so it really just depends on personal preference or what you doing if you really know these performance problems then reach for a class instead right don't just listen to people who have their dogmatic opinions and i'm just going to show you how simple this is so i'm going to say export class local storage and now we just need to define two fields so i'm going to say value and you can just use state like this and that's basically it and now we're also going to have a key which we're going to set to nothing and now we're going to create a constructor so we're going to pass in a key the same as before and we're also going to have a value which is going to be any all right so now we can set this value to value and let's set this key to equal this key and that's basically it this is how you initialize a class and we can even be more prudent when we have a class so we can make things like serialize and the serialize so it's really neat and tidy so let's create a serialize method and we're going to create the serialize method also all right so inside serialize we're going to accept a value which is going to be any for now and then we're just going to say return json stringify value that's basically it and the serialize is going to be the opposite so we're going to take in a value which should always be string and then we're going to return json.parse.value. That's basically it. So already we can see using a class we're more incentivized to split things out, make things a lot more cleaner, because of course that function looks pretty since it has a couple of lines, but your code of course isn't always going to look that simple, so classes are really awesome. And actually we can take most of the code that we have inside of this function, which is really neat, right? So we can go here, let's go inside the constructor we can paste this code this should be the same and now we just need to change a couple of things so inside of storage dot value this is going to be this value and instead of json parts we're going to say this the serializer because we're fancy like this so you can flex on your friends knowing all these fancy words and then here instead of passing key we're going to say this key and instead of json stringify we're going to say this serialize and we're going to say this dot value. Alright, so now we have this simple class we can save. As you can see, it looks almost the same, like there is barely any difference. Alright, so now we can go here to plus page.svelte and we're just going to swap this out. Let me just remove this. So let's just import local storage and then we can say new local storage. This is going to be count and let's save this. So now I'm going to clear local storage. Let's refresh the page and you should see everything works the only thing that's complaining here are types so let's actually fix this really quickly so this is how we type a class we can also pass in a generic here we're going to pass t here and we can also say st here because there's some weird bug with types right now and then of course instead of any here we're going to pass in t and even for these functions here we can be more strict so this is going to be t we can be explicit even about what we returned. So we can say, hey, this should always return a string, and this one should always return t, right? And actually, this looks pretty good to me. Cool. So we can save this, and now if we go back here, we're actually going to see this is a local storage number, and of course, you can pass in a type or whatever else you want, but TypeScript is going to infer most of it. So now, when you have count you have this great autocompletion If you refresh the page you going to see everything works the same as before How beautiful is this friends I also have a cool trick you can use if you don want your users to use classes so maybe you prefer to offer your code using classes which is perfectly fine but maybe you don want your users to use classes for whatever reason well you can just define a function give it any name local storage and then just pass it a key and then we can also say that the value is any for example right and just return new local storage pass it the key value and that's basically it now you just need to export this function and now your users don't even have to know that they're using a class. Okay, there is one last thing that I want to show you. So remember how we passed an object here. And why is that? Well, if we just passed in value here, there is no way that this would work because this is just JavaScript, right? You can't just return a value and for JavaScript to know that this should update. So you would have to return a function with a value and also an updater function to update the value inside the function. And Svelte really can change how JavaScript works. but Svelte does something else for you it has deeply nested reactivity if you pass in an array or an object and what this basically means is that Svelte uses a proxy under the hood to know when this value is updated otherwise if you just passed in a value you would have to return a function or define a getter and setter here so you would have to go here you would have to say get banana or value right and then you would also have to specify a setter for the banana and that's basically it and I also want to show you this example on the class since we're using it right now so here on the class this is the same principle so here we're using this dollar sign state rune and under the hood what svelte is doing is creating a getter and setter on the class for you so here we can actually turn this value into a private field and now we're going to get complaints because we changed it so let me change this value and this is completely optional we don't have to make this value private but now we can actually specify a get and set method ourselves so we can say get value and we can also say set value and we can also pass it a new value here we just have to return this found value that's it so now we have complete control over this instead of swell doing it and here we can just yoink this line since we don't need an effect anymore since we already know when we're updating this value right so now we can just go here we can say if browser and then let's just set the local storage inside of here but of course we also have to update the value so we can say pound value equals new value and we can also keep everything here so we check the local storage and i think we also have to set it once so for example when this gets initialized you can also do if like this let me just do it quickly so we can do this else we can do local storage set item right so if it exists or it doesn't we're going to set it all right cool so now again we're using the same class here and i'm going to clear the local storage and now we have complete control so now when i refresh this again we're going to set the local storage and now everything should work the same as before let me see what is happening here so we can go here back to our code and this is happening because we're setting the value after the fact but we should actually set it before so we get the newest freshest value so now when i clear local storage let me refresh the page, now I go up to 4, reverse the page, everything is great, I can go up to 10 and boom bam, thank you ma'am, easy peasy lemon squeezy like that friends. I hope you now understand the power of runes. If you like what you're seeing, don't forget to like and subscribe and you can also support me by becoming a patron. Thank you for watching and catch you in the next one. Peace!