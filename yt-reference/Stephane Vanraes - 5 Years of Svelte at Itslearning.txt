 Thank you. Hi, I'm glad to be part of Svelte Summit again, this time with a short presentation about how Svelte has changed in the past five years and how it has been used in its learning. I have to add a small disclaimer, however, that I do no longer work for its learning, but the company has been so nice as to give me permission to talk about them during this presentation. Science Learning is a platform that handles several aspects of education. There are systems to grade and follow students, give homework, provide lecture material, communication with parents, attendants, and many other features. It is used on many different levels of education, from primary school to universities and even adult education. The company was founded in 1999 and currently has over 30 developers. It is mainly active in Europe as customers worldwide. At peak moments, around 400,000 of the 7 million users are using the platform together. It goes to say that this is not just some hobby project, this is a real application used by millions of people. It is also from 1999, so it has a lot of old code. parts of the application are still written in isp.net and use jQuery to handle the front-end parts. These things cannot be simply rewritten in a modern framework because it has so much functionality that it would take years to redevelop the entire application. And the customer wants to see new features on a regular basis and maintenance, especially considering this is such a crucial part for lots of schools. Think of during the COVID, a pandemic and lots of people had to work had to have school from home It was a very important tool for them However in 2016 we started looking at ways to modernize the frontend We could have chosen established frameworks like React or Angular but out of nowhere came Svelte, and we loved it. One of the main reasons we chose Svelte was the promise of small bundles. For many of our end users that are on slow connections, computers, or mobile devices, that was an absolute must. I'll have a look at some of the differences we saw over the years using different versions of Celta. To do so, my former colleagues provided me with a source code of the Your Students page. This is a simple page listing your courses and students, with some functionality like searching, filtering, sorting. Because of its simplicity, it was rewritten in each version of Svelte to serve as an example for other teams. I will not be showing the entire code as it would take hours to dissect, but rather draw inspiration from it to highlight some of the differences. Let's start at basics. How does a component look like? Here is version 3. We import components, we export props, we use them in our markup. And if you have lots of props you want to pass to children, you can spread them in those children. If you go back to version 2, we had to do export default. List all the components used there and export the properties as a data function. You also see in the markup, there is no more the possibility to spread the props into a component. If you look at the actual code, you'll see that sometimes the children have like 10, 15 properties, and this makes for a long code. The spreading was a very good addition to Svelte. If we go even further back in time, we see the appearance of double Curtis. If you look at the markup, you will see that course.title there does not have double course. It should have, but it doesn't because I made a mistake here. We also use the extension HTML to import components. This was done for syntax highlighting reasons, as we did not have the tools back then that we have now Reactive variables are taken for granted nowadays and are very easy to work with colon name of the variable equals whatever you want this variable to equal But if we go back in time, we see that in version 2 and in version 1 for that matter, they were called computed variables. They had to be declared as computed variables in this exported object. Then you have the name of the variable as a property, and then a function, where the dependents are the arguments, and then yeah, you have the function result is your computed variable. Firing events in version 3 is easy, albeit a bit cumbersome maybe with the create event dispatcher thing. Here we see select course, dispatch, select, and we pass the course as an argument to be used in detail. Here is the same code, but for version 2. We see several things differently. All the methods are declared as a method of the component, and we use this.fire instead of a dispatcher. Another very important difference here is that when we look at the markup, we see on select and then a function call instead of a function reference like we have them now. Now, this is one of the biggest differences between version 2 and version 3, except of course for this whole export default thing. And a lot of, it costs a lot of bugs during the transition from 2 to 3. We still see now that beginners in Svelte often put their functions like this, thinking this will work, but we all know that this doesn't work. You have to put a handler in there. Using variables in the scripts is quite easy. Here is version 3. I'm not sure what I can tell about this, it's easy. Active equals not active and it's changed. In version one and version two, you have to use this.get and then the property you want to get and this.set with an object that you set the state of the component on. This code will only change the properties that are listed in the this So ID and visited in this case will still remain the same A favorite feature in Svelte are stores There are writable stores, derived stores, readable stores. The V3 version of your students uses stores extensively. I think there are about 10 different kinds of stores used. And they are easy to work with. However, in version 2, there was only one store type. It was called store. And we would often just make one global store for the entire site. Site that contains all the data used on this page. You would pass the store as a separate property to a component. And then it would be available for all descendants of that component. meant that you could have a store declared on the application level and then for instance in a subsection of the page you could have another store defined. We did not do that however in its learning. As a final thing let's have a look at lifecycle methods. Here we have the on mount. The on mount uses student list. Student list is a reference to a DOM element. It was declared as a variable, and then using bind this, we bound the DOM element to this variable. In version 2, we use ref colon to reference DOM element. And then we use this.refs in the code to get this reference, preferably with the correct variable because this code will for surely not work as we expected. Where it concerns the lifecycle methods is just onCreate, onDestroy, onUpdate, and so on. It's fairly straightforward. I have to note there is a bind directive in Svelte 2, but it's only used to keep input values in sync with properties of the component. That concludes a very quick overview of some of the differences of Svelte over the years. There are many more details, but it is clear that Svelte has evolved a lot in those five years. It has always been a pleasure to work with, and it will always stay a pleasure to work with.