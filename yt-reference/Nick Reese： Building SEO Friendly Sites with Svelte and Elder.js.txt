 How's it going? My name is Nick Reese and today we're going to be talking about building SEO friendly websites using Svelte and ElderJS. ElderJS is a new static site generator or server side rendering framework for Svelte. Before we get into the details of it, I think it's helpful to know a little bit about me and why I built ElderJS. Additionally, Philip on my team also wrote all the tests for it and helped quite a bit, but I was the main driving force for programming ElderJS kind of from scratch. And my goal was to encompass all of the real lessons I've learned across my career. So mainly I've been in the CEO role or the front end developer role initially. But over the past 14 years, I've mainly done SEO and performance marketing. What that means is performance marketing is generally where you get paid when you generate leads or sales. And initially I did it mainly for the money. But these days I'm mainly focused on basically making tools to help consumers make informed decisions. And what this generally looks like is finding a large government data set or many of them merging them together and building a tool that really helps consumers. The latest, most recent version of this is broadbandnow.com and businessinternet.com. What we did is we took several billion rows of government data and made it available to consumers as a zip search for finding the internet providers in their area. We listed about 3,000 providers and we only had deals with a handful of them, but it was enough to be sustainable. Sold that a little while back and I've been doing consulting since and I've migrated some other majorly complex WordPress sites to static site generators. And to be honest, they're a great concept, but the current solutions just aren't built for the type of sites that I build. I know that I only have a limited amount of time, but I have a pretty bad horror story with Gatsby. It led a small team of really great developers. But no matter what we did, Gatsby basically turned into a big ball of mud as you get to a site that has many thousands of pages. So if you have 20,000 pages plus or 50,000 pages, Gatsby becomes a problem if you're querying multiple data sources. Now, I'm going to do an overview of ElderJS and a little bit of the features. But at the end of this, we're going to be building a demo from scratch where we basically find a government data set. and we build out a 500 page site that's all data driven and we also implement an auto complete search functionality using Svelte All of this is in ElderJS So first why did we build ElderJS Beginning of this year in 2020 I had a friend approach me for building out a site that would help change the elder care space. The site's called elderguide.com, and I know that within five years it's going to have 100,000 pages, and I just knew that no static site generator was going to be able to handle that, and in my test, it really, the static site generators weren't going to support that. Basically, this ended up with a dream checklist. Having built several sites with static site generators, I knew what I was looking for, but I needed to find it. I didn't want any client-side JS if it wasn't needed. There's no reason to push JavaScript to the client if you're not going to be using it. I wanted to use Svelte for templating. I wanted clean data flow across multiple data sources. I have to tell you that GraphQL is great until it isn't. That was the main problem with Gatsby. I wanted no client-side routing. There was a lot of SEO headaches caused by client-side routing in Gatsby, and I wanted fast build times. Building even a moderate sized website with Gatsby or any of the other tools can take quite a while. I wanted preview functionality. I didn't want you to have to regenerate the whole site in order to preview it, and I wanted no SEO compromises. In my journey to build this elderguide.com, I tested six different static site generators and built basically a single template in each of them. And in the end, I decided on Zapper. But I hit some roadblocks surrounding development speed, especially when you have a lot of components, it needs to rebundle them all for both the server and the client. And that slows things down. Also had issues with build times and data flow issues. So I set out in the afternoon and said, you know what, I'm going to commit the whole afternoon to building a static site, an SSR flow and see if I can generate my own static site from it. And I got it in an afternoon, but little did I know that I would spend the next six months kind of exploring that rabbit hole. So today ElderJS has hit version 1.0. We consider it stable. And in general, here are the high level features. And I'm going to go into detail on only one of them and get into the demo. But we support partial hydration and there's zero JavaScript if the page doesn't need it. No module and module support is coming. That basically means that it should work in IE is what we're looking for. Scalable builds. An 18,000 page site runs on a four core VM in about eight minutes. 55 of that in my testing is all in waiting on the database So it could be much quicker depending on what you building The same site on a bare metal box builds in a minute and 22 seconds You get some detailed performance logs that look like this. Pretty sweet. Basically everything's built around performance. Hooks, I'll talk about that on the next slide. There's six official plugins for this. If you're familiar with the Gatsby image plugin, that kind of resizes your images and makes them responsive and serves the best needed for the browser that's visiting your site. We offer that. We also have a full Markdown plugin that you basically drop in your Markdown files in a folder and out can spit routes for you in ElderJS. Also, there's short code support built into the core. And I can do a whole talk on short codes, but it's a great way to manage your static content debt you have. Unfortunately, this talk, I just don't have enough time to do it because I want to get into the demo. So a few notes. First, ElderJS can do static site generation or server-side rendering. It does have a learning curve specifically around explicit routing. I've worked a little bit on trying to streamline that in the docs, but certain newcomers to it do find it a little bit more complex than the standard routing that you see elsewhere. All right, let's look at why we built hooks basically before broadband now I my company managed 30 plus SEO websites and we had multiple developers the biggest lesson I had across that was to have a predictable location for complexity but WordPress is great until it isn't and what we found is if we use WordPress hooks to manage all of the the customizations to the site and then use the same template on every site we could share a handful of developers across many different sites. And that really allowed us to bootstrap our company and not have to take on funding. And so what this generally looked like is we'd have a single hooks.php file on WordPress, and it would allow you to plug into any part of the WordPress cycle and make the customizations. This allowed one developer to switch from project to project, knowing where all the complexity would be. Also, we had some guidelines for developers to not have specific types of side effects. I wanted this also in ElderJS, and we're going to see this in the demo where I actually hit the roadblock where I'm mutating something that shouldn't be mutated and ElderJS stops you. Basically, I think about it as bowling with bumpers When you start bowling your first time bowling you might have bowled with bumpers and the idea is to help you be successful and not shoot yourself in the foot or really not have fun building something Also, we found that by using this hooks.php in WordPress, that the code was reusable across projects. And that was great. And so that was a big goal for ElderJS is to have reusability and also have plugins. so basically what elder js hooks allow you to do is tap into any part of the build process while keeping your site maintainable and you know that all of your complexity should live in your hooks.js because no project starts out as a as a ball of mud but it happens over time you kind of think okay i'm just going to do this little hacky fix here and then you forget about it and you come back later or someone else looks at your code and they don't understand what's happening if you have a single place for all that complexity it really helps streamline things so let's look at the hooks and then we'll get into the demo. Essentially hooks on the right hand side you'll see that there's a list of hooks and basically data flows through your application as a page is generated. Basically there's several hooks that run it at server start and then every time a page is requested in a server-side rendering context all these hooks fire in this order. And on the left you'll see the bootstrap definition this is from the docs and essentially each function that's registered on a hook is given a list of properties that they have access to, and then a list of which of those properties are mutable. And then there's also some documentation on what that hook is good for. And what this allows you to do is know that, okay, I'm going to get this data object. I can mutate this data object. Great. And you know that on all the other hooks, certain things are mutable and others aren't. And that allows you to basically have limits on who's doing what. So you don't have someone stopping the entire build or changing a core build variable like right before compiling the HTML and causing everything else to have issues. So we're going to be building a demo from scratch. I like using government data. If you want to try to find your own data set, go to data.gov. And I really spent a lot of time trying to find the right demo for this. I've worked with four different data sets and all of them, I ended up spending a lot of time writing code to massage the data to make it usable. Finally, I stumbled across a data set that required minimal massaging, but it's in GeoJSON. So we have to do a little bit of it in the video. What we're gonna be building is a S&P 500 company finder with an auto complete. And I'm about to show you what that's going to be.

 to look like. Here's what the data looks like. And if you want to download the data, you can in the video, because I pre-recorded it before this intro. I didn't want to open the full data set. So just take a mental model of this. We basically have a properties object that has all the details and that's what we're getting at in the demo. So without further ado, we'll jump into the demo. We'll let you see what we're building along with us building it. Thanks. What we're going to be building is we're taking a JSON file of the S&P 500 companies that we found on data.gov. We're building a search functionality that is hydrated on the client and then static routes for all the individual companies, which have all the data. What's happening under the covers here is ElderJS is generating all this static HTML, hydrating the client with the data that is needed, and then setting up an intersection observer and doing a few other things to hydrate this in a smart, intelligent way. So I've got a freshly cloned ElderJS minimal template here. We're going to build what you've just seen. I'm going to run npm start, which we'll go through and roll up all of our Svelte components and templates. And additionally, it'll kick off a server. During development mode, I recommend you basically run npm start and then in another window run npm run dev rollup. And what this will do is this will live reload or re-roll up your components every time you change them. It's going to keep reloading for a second. All right, we're good. So now we have the minimal template, which has a clock. It hydrates it and gives you a minimal simple route. So that's where we're at now. We're going to start with the homepage. All of your code lives in your source folder. You have a components folder where the clock lives. You have a layout and some routes. We're going to start with the home. It's the home route. What we're going to start doing is we're going to, we need to add in nodefetch. So let's do an npm install save nodefetch. We're going to go ahead and import that while that's running. running Now here the big thing that we going to be doing is we going to be taking this URL that we found from data and we going to be returning an object called companies here And what this will do is this will pass into our home dot svelte and at data dot companies we will have access to it so let go ahead and do that we got this URL we now need the the fetch code we go ahead and copy this over for sake of time so we have we have our fetch code here and we're going to be returning companies here so what's happening is where we're running a fetch and this is an async function running a fetch we're now getting our the results we're getting the because this is geojson we need to do a little bit of etl in order to be able to use it and we're going to pass in our companies so let's go into home.svelte console log this data.companies and we will see in here that all the data gets put out. Now what's happening in the background is there is an elder JS plugin that is running a reload every time we reload our server. So every time I save, you'll see it spit it back out and it'll reload the page for us. So that's the reason why we could see it immediately. So now that we've got the data in our home.svelte, let's go ahead and make it a little bit more interesting. Let's go ahead and output all the details for each company. We'll go ahead and remove this simple route. We'll open up a UL. We've got an each statement. Companies and then company. And because each of these Svelte files that are within the routes are actually a special type of, in ElderJS we call them Svelte templates. They're a little bit different than a Svelte component. designed only to be a server-side rendered so they get four different props here um that's the reason they're there even though we're not going to use them and there's no real uh downside to leaving them there so you can remember uh what the options are but let's go ahead and finish our our each statement uh we're going to go ahead and have an li in here and we know we want to output the the company and then name since this this file everything's capitalized uh it's it's going to going to be capitalized here. Let's go ahead and reload this and see what we've got. That moment when it doesn work right Oh it data All right so now we got all of our companies Now we need to set up a link to each of these And what we've decided for this demo is we're going to link on what's known as the FID. So essentially what our routes are going to look like is one, two, et cetera. So it was just a unique data point within the data. And each URL needs to be unique. You may want to do something different. We haven't quite set this up yet, so we will come back to linking all this up. Let's go ahead and remove this clock component. And let's work on building our autocomplete functionality. We do hydration something like this. Component name and then hydrate client. And here's where we pass in our props, right? So what's happening under the covers, we're actually generating the mount code for Svelte. And so this will create a new root Svelte component. Since we want to use an autocomplete component that needs to connect to, needs some of the Svelte directives such as bind, in order to bind to variables, we can't do that within a root component, so we need to wrap it. So we're going to create a new component here. We're going to call this company finder.svelte. We'll go ahead and get this over or open. We're going to need a dependency npm install. let's go ahead and save this and what is the name of it it's simple svelte autocomplete you made this package thank you so much it was great for this demo so go ahead and start with our script tag we've got I'm going to import simple svelte autocomplete okay so we've now got this and it's going to receive a prop called companies and we're going to use selected in order to know if we have something selected and here we're simply going to add in our autocomplete and so what's going to happen is we're going to bind to the selected item and we're gonna render all the companies looking at the name field so we now that we have this ready we need to import in the company finder let go ahead and import that in hit save don know I pretty ears not cleaning things up for me Let do company finder It complaining because it didn couldn find the module for that And so once again it's not finding a module. Company finder. Sometimes this happens you need to restart your rollup. And in a moment it should be done. At least this is realistic. Sometimes you end up not, sometimes things don't work as you'd expect. So here you go. Auto complete. So you've got your auto complete here. Now this code should work. Now let's go back here. Let's see if our auto complete is indeed working. There's no results. So it may not be getting the correct data. So let's see what is being written to the client. Nothing. That's the reason it's not working. So before we dive into getting this wired up, let's actually look at what's being mounted right now so you can get a conceptual understanding of what's happening. All this code here is used for the live reload during development. What's happening here is each component that we're mounting is given a unique ID. We pass in the props here and we're hydrating it. So many of the things that you can do with Svelte, such as Svelte directives, can't be used here, as I discussed, because this actual mount code doesn't support it. So what we want to do is we want to pass in just the data we need. This large JSON file that we're working with actually has a lot of data on it. I'm not actually going to open it because it's going to force me to download it, but it has a lot of data there, which we'll see in a moment. We only want to pass in the data that is actually needed. So we're going to actually map over these companies and only pass in their FID and the name so that we can basically build this. So I'm going to copy this code over for the sake of time. Because I'm error prone when it comes to writing things. So we've got data.companies. And companies. For some reason, Prettier is not formatting for me, which is a bummer. So now we have our autocomplete and what we'll be doing is when you click on this, we'll redirect you to their individual page. But in order to do that, we need to wire up these all of these into real routes.

 Before we move on, let's go ahead and set up the really simple redirect logic. And so I'll just copy and paste this over. What this will do is if when we select it, it'll redirect us to the FID. I know that there's other ways to do this, but very quickly for this demo, this was a quicker way that it could work since I couldn't get the autocomplete events to work immediately. So we can see now it's redirecting us to here. So let's go ahead and build these individual routes. All right. Let's change this simple route to company. Within company, we're going to need to change simple.svelte to company. And here's our route. So very simply what's happening is this is the first real route file that you're going to be seeing. The last route file used both defaults. And essentially this is the default for the permaling function. We can go ahead and take this out because we're going to be using that. But this is what a more complex route file looks like. And there's a full tutorial on how to use route files coming. So I'm not going to spend the time during this talk covering it. But we're going to go ahead and set up routes for all of them. And we're going to return in specific data here. So let's go ahead and set this up. Once again, we're going to need node fetch. And we're going to go ahead and import in the company data on all. All these functions besides permalink or async, I don't know why it's left off on the minimal template. I will resolve that after this tutorial. So, here we go. go we've got the same code that we had uh in our home route to go ahead and import the companies now all we're going to do now is pass in each of our what's called request objects and what these request objects represent is anytime in like a router like express let's say you have something that's uh you know a blog slash uh slug right whatever was whatever the slug was would be passed In this case, our URL is going to look something like this. So we need to define all of our slugs. And ElderJS in order to build quickly uses something known as explicit routing And what we have to do first is define all of our request objects and then we take those request objects and turn them into a permalink so this should give us all of our routes let's go ahead and reload and see if we get all of our all of our routes and let's go to one and see if the page at least loads here it may not have any data in it and we're seeing a module not found because company js is not found and it's because anytime you you add a new swell component a new file rollup is not watching it and you're going to need to add it again all right now that it's all compiled we should be good let's check and make sure see if one works it does so we've got a simple route here before we move on to setting up the actual uh data in in the the route the company view um we can see that what's what's happened is for all 500 s p 500 companies we now have a route here so we need to file in or funnel in what data is going we're going to need within that spell component so here we're going to once again copy in this this code and if this feels redundant i'll show you in a little bit how we We will simplify it. And from here, we're going to take and just do a quick find and return the company. So here's the code for finding. So we're taking, we're running the find function on the array. We're matching the FID to the request ID and this gets a request and we're going to return this company. So there we go. move to our company svelte and let's see what's logged out on here console log data dot company we should see in here data.company put out so these are all the fields of what our our company object looks like let's go ahead and make a really really simple uh page here i like to have the ability to navigate to the home page and i'm going to copy this over and i'll walk you through what this does first is the ability to navigate back to the homepage. This is the the name of the company is what we're going to do here. So it's going to be data dot name and data dot details. And this will loop through all of the entries and show us what we have for each company here So we go back to this We now got something that not working So let see where I made a mistake. Cannot convert undefined to an okay. So we got data.company.details. actually it's just gonna be data.company and so here we go here undefined the name is undefined so we need data.company and now all of our code is being piped in and we can now set up the routing for all these but these should work so you can go to steel dynamics and it will now output it to the page but the really fun thing that's going on is the actual hydration of this that's the really useful thing. But before we talk any more about that and see the code that it's actually putting in into the page, let's let's wire up these and see one of the helper functions. So let's go back to our homepage. And what we're going to be doing is adding using a helper function in order to link these. So if our permalink function within company changes, if this changes, let's say you wanted to make it the name, all of the links would change. This is a pretty common offering and ElderJS also offers this. Let me go ahead and show you how this works. So we've got a space href and we'll wrap this. And then we're going to use helpers.permalinks.company. And we're going to pass in the slug of it just like we did in the all function where we were defining our request objects. and there we go so now the the page all these links should work and we've built a very minimal site with client-side hydration let's go ahead and look at at the code that was generated what's happening here is we've written all the props that were passed in and defined in in this hydrate client to the dom or to the HTML and it's mounted here. We have some module, no module code that's running and it will go ahead and mount it all for you. So at a high level that how all this works and that what going on Let very quickly talk about hooks and you may have noticed in our code we duplicated quite a few different things So I going to go ahead and open up our two route files side by side and you'll see that this code is exactly the same across both of them. I'm working on a much bigger monitor. I'm not going to make my screen any bigger because you won't be able to see it but essentially this code is duplicated on all of them. So let's go ahead and open up our hooks file. You'll see that there's a single hook in here. We're going to define a hook so that we don't have to keep defining this data. Instead it will get passed in to us here and here. So this will come in on the home page and we'll also be able to get it within the company page. Basically what's happening is ElderJS runs hooks in a sequential order. So you know that the data function will be run at a specific time and the all function will be run at a specific time and those happen after the bootstrap hook is run so we're going to define a hook on bootstrap that defines what company data is or maybe we'll actually just say companies so we don't have to keep transforming the object so let's go ahead and grab this code and let's write that hook from scratch let's say hook we're going to use the bootstrap hook Name is add companies to data description. We require all this to be defined in order for us to better document what's going on. I know this is boring watching me type, but. add companies to the data object available in all all hooks and routes so we've now got an async function where we can do whatever we would like and we can we're going to get a data object that is empty here and we can define whatever we want on that so let's go ahead and set up a fetch we're going to need a node fetch. So let's go ahead and import it. And we've imported it. So now this code will run it exactly the same.

 return our data object we're gonna spread it out and then add in companies what's happening here is lrjs will run all these hooks in a specific order in each hook if you look at the hook interface in the documentation it has things that can be mutated and things they can't so it defines what props it will get and along with which props can be mutated and so this adds a way to predictably know what will be mutated on each hook and I really like to have all all of the cruft, so to speak, the hacky stuff that happens on a project in one file. And that's generally where your hooks.js file comes in is all the crufty stuff happens there. So now we can go to the company routes. And we'll see that if we do data.companies here, we can just remove this code. Because this all function is run immediately after the bootstrap hook, which this is run on. So additionally, data is run during the page generation cycle. And that's run about halfway through the page generation cycle. After the majority of the hooks have been run, it is run. So we'll have access to this same data object here. So now we have data.companies, and we can remove this code. We can do the same thing on the home route so we go ahead and get rid of this companies and just pass in companies We won even need to pass this We can actually remove this entire function. We can just return it empty nothing. You can remove the whole thing as well if you'd like. So everything should be working. Let's go ahead and see. We refresh the page and we've got an error. of course so things are undefined somewhere and data routes what is this not mutable on this hook so what I did here is instead of returning data I was spreading it across and we're trying to mutate it what we're seeing here is actually that the hooks is denying us to mutate companies well there's not actually a prop called companies but it's not in the list of things that are mutable so it's preventing us from polluting the global scope or having plugins do things that are unpredictable so instead what we actually need to do is we need to do data and we need to return a data object here in order to populate it so there we go So the site should work as intended and we now have a fully functional ElderJS site We missing one last step Let go ahead and run npm run build and you get to see it build we gonna rebundle everything it's bundling it babble filing it tercoring it runs through all of them and then it builds 501 pages in 1.72 seconds i think that's a pretty fast time and we're back to the presentation all right there you have it um i hope you enjoyed that demo uh quick note um that demo because i recorded a couple times i accidentally used the the npm beta version that It was local on my own computer, so that was the reason there's extra console logs and some funky errors. Also, what I was testing there is no module module support, and so it's coming. It's just not quite ready. It was in the actual code there, so you got to see it. A little bit on it closing. First, ElderJS is great for data-driven sites and blogs. If you have a whole bunch of markdown on your current blog, basically, if you clone the template, you can toss the markdown in a folder, and it'll generate a blog for you. Apps are possible. We do do server-side rendering, but unless you need more control and power and you really familiar with Express or Polka use Sapper There a lot more tutorials out there For instance if you wanted to implement authentication there tutorials on that where otherwise you kind of have to figure out how ElderJS does it which hook to tap into. It would be the middleware hook and how to kind of set it up. Unless you're a power user, I would suggest using Sapper for true apps where people are logging in. One thing I want to touch on is the reason we open source this is it's an SEO experiment. All of the docs are hosted on elderguide.com, and the goal is that if people write about ElderJS, they link to ElderGuide. So far, it doesn't seem that those links are serving us, but it's still early. It's an SEO experiment. Also, we're interested in hiring. We think that having â€“ because I'm an investor and I also work with other investors and we invest in SEO properties, I believe that by open sourcing our framework, not only is it great documentation for our team, but it also should make hiring easier. So if you're a great backend Node.js person that also has Svelte experience and you want to work with ElderJS, feel free to drop me a note because we're hiring. Last call to action is to try the template out. You can simply do a dget and go ahead and run the template. You'll see what it's like, you can explore it, and I hope you find ElderJS useful for your needs. With that, that's it. Thank you so much for your time and best of luck.