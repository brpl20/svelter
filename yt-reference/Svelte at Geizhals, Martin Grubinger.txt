 So, good evening and welcome to my talk titled Swelt at Geizhals, in which I will surprisingly talk about how we use Swelt at Geizhals. First, let me introduce myself. My name is Martin Krovinger. I'm a long-time visitor of Swelt Vienna Meetup. Thank you for organizing to of you and thank you for having me today so this is my first time here long time visitor first time speaker so be kind you know um i actually started using swell around three uh 2019 i guess when sweat 3 came out um at my job at that time i created highly interactive web applications with mostly PHP, handlebars, and jQuery, and later a bit of React. With that background, I discovered Svelte, and Svelte 3 felt just right, just the right amount of magic. I think most of you can somehow relate to that. In 2020, I joined GuideCell, so five years ago, as part of the frontend team, Some of my colleagues sit in the first row. Svelte, of course, was not used at GuideSales at that time. But, you know, things can change. And I'd like to share a bit of the reasoning behind the move to Svelte and what we've built so far. So you can find me on my personal website, gruwinger.com, with 3.0 or Mastaton, preferably. I even have a BlueSky account because I feel like the Swell community is more active on BlueSky than Mastodon, which is a pity. So I assume most of you know GuideSales here in this room, but just to make sure, I'd like to give a brief introduction first. Then we look at the most important pieces of the tech stack we use at GetSales and which tools we have been using before the switch to Svelte. And I like to show you a couple of apps that we built so far and explain the architecture and outline some of the drawbacks and limitations we encountered so far So, why Svelte and Svelte in action? Drawbacks and limitations. Let's start by talking about GuideSells first. GuideSells is a price and product comparison website. it. When you're looking to buy something online, it helps you to make an informed decision and find the best price. You can also manage wish lists of your favorite products or get pinged once a product drops below a certain price by email or push notification or whatever. You can view detailed specs about a certain product, see how the prices evolved over time, view ratings, external tests even compare our partner company Tarifati Katsos also lets you compare two or more products to help you find the best products for your need so you can compare all the specs of different products and lots of more functionality so Katsos is the number one price comparison website in Austria, but we're also very successful in Germany, but just not number one. I won't mention any names. We have more than 4 million monthly unique users with over 3.5 million manually edited products. I think that's one of the key features that we have at Geizels. Our products are not just straight from some website, there are actually people sitting there in the office closer to Patashten managing those products, making sure everything's correct. We have at the moment roughly 280 million up-to-date prices for all of these products. You can see that number on the start page of Gatsels as well. Gatsels has been in business for 25 years which is you know a very long time for a website and actually tomorrow something will go live I will show you today I have to move this somewhere we can see it So we changed the logo You seen it first here Okay, let's continue with the presentation, I guess. So the tech stack for the Katsas Plus website, I'd like to mention that this is for the public website only. We use different set of tools for internal tools that we also built. The backend is written in Perl with the Postgres databases. We use a templating system called Xlade. No offense if nobody ever heard of Xlade. it's pretty niche but you can maybe compare it with something like Blade and PHP or something most pages are completely server rendered by the Perl application and Excel templating but we render widgets, some call it islands these days on the clients on the front end we use less CSS preprocessor historical reasons but it still works. And plain old JavaScript. So we have some of these widgets or apps on the websites that we enhance the server rendered markup just using JavaScript. You can still do that. The front-end side of things is built with Vite since three weeks, maybe? It was Webpack before, and I think we worked on it for two years or something to migrate everything to eat, and now that's life, and the world is much better now. So, let's talk about Swell. Oh, no, actually, back up a little bit and show you more about the recent history before we moved to Swell. So if you're curious and you pay attention to the network tab while visiting your website, you might spot this gem. I don't know if you can read it in the back. It says something, correct, something. And under certain circumstances you can even spot this one which starts with Redux Saga Effects And if that does not make you shudder I don know what will This gamer, we use React and Redux a lot in turn to, so that's fine. But we can do better. Before switching to Svelte, we used Preact for interaction-heavy widgets on the website. And the TLDR is, it has better performance than React. It's much smaller when you ship it to clients. It has no virtual DOM, no virtual events and stuff like this, so it's a lot faster. Another plus is it has the same API as React, so it makes it easy to migrate. But on the negative side, it has the same API as React. and also the same limitations regarding global state styling animations you name it things that we love when this website works um preact actually is still in use for some parts of the website for the main navigation on desktop for example and the comparison page on desktop as well uh we're just not there yet so react is not the worst choice in the world so why do did we move on from react we had a problem we needed to overhaul a certain part of the website and the aim was to create a highly interactive page but it was also crucial that we rendered the markup on the server for you know better search engine optimization being usable without JavaScript at yeah make sure it works without javascript so how do we solve that we had one part of the site that already had solved the same problem and the way that previous developers went about it they built a version of this of this page first in pearl and xlade and then they did the same thing again in Preact. So we shipped the markup from the server that's generated by Exelate, and then we have to maintain and build the same thing again in a completely different language. And the site we were going to build was that complex that we thought that's in no way maintainable or a complex.

 economically efficient. Oh, wow. I missed that. So we started prototyping with server rendering correct code, but it pretty soon became clear that we need a meta framework anyways to handle a lot of data loading and that kind of stuff. And with my previous experience in Svelte and SvelteKit, we decided to try to build that prototype using SvelteKit. Svelte enters this age. Since that prototyping phase was quite successful, we then made a conscious decision to, first of all, build out this new part of the website using SvelteKit. And second, eventually replace all the pre-act apps that we did so far. and only do new projects with Svelte going forward. As I mentioned earlier, we're not quite there yet, but we're slowly ripping out the pre-act stuff and replacing them with Svelte. So why Svelte? For guide cells, performance is crucial, and Svelte matches that mindset perfectly. We use other third-party libraries for charting and that kind of stuff, and they're really easy to integrate in Svelte. Another point is that it's much easier to understand for non-fronted developers than reading a JSX or React app. In my opinion, it has superior templating to JSX. Actions can actually be used for plain JavaScript as well. So I mentioned earlier we have some of the apps that's just plain JavaScript, so we can reuse those actions in JavaScript. which is awesome. In general, Svelte does not get in the way. No more juggling with different state management libraries, for example. In scoped, CSS, accessibility warnings, animations, it's all baked in. It just makes so much more sense. So Sweat in action gets us or should I say in attachment I'm going to show you a couple of parts of the website that you sweat already, like the autocomplete, start page, a couple of widgets there, the auth, wish lists, price alerts, ratings, manufacturing filter. More and more. So I'm going to switch over to the browser for a second. So we're on the start page of the Geyser's website. Where's my mouse? Go. Focus. Yes. So, for example, this part up here, autocomplete box, if I look for iPhone, all of that is a Swell's component. Or Swell's app, rather, say. What are we looking at next? Also on the start page, we have things like this one here, like your browsing history. That's the client's rendered SwellTap as well. We have this part, which is a bit of a mix. On the start page, we show deals. Those are products that the price dropped significantly recently. And initially, on server templating, we render out this part. but then replace it on the client with a Svelte app that lets you select your favorite categories that you might want to watch on the start page. You can switch here and select a category here. It's probably really small in the back. If I'm into Kopfh√∂rer, I get a deals from this category on the start page. We'll talk about Radfieber later on. What else? If you want to log in, which I am already. See that one? So, if you log in, the whole authentication model with registering and resetting password and all that kind of stuff, that all as well as well If you add a certain product to a wish list for example here add to wish list it will load this dialogue model. And you can add this product to your wish list, and then move on to that wish list. And all of that is also planned, rendered, swelled these days. Same thing goes for a feature that we call price alarm. So if you're watching a certain product and want to get a notification once that price drops below a certain threshold, you can just enter a price limit, hit save, and it will send you an email once that price is reached. And you can also review your price alignment on this page. That's also client-rendered swipe. Let's see. I'm going to show you one more thing, maybe. I don't have too much time on that. if you go to Bewertungen, so ratings on a certain product page, you will get this ratings summary here and the list of all the ratings that's also swept. We have a couple of smaller dialogues and filters and that kind of stuff on the website. I'm not going to go too much into detail here. Okay. Okay. And that. Okay. So we are using Svelte 5, but mostly Svelte 4 syntax. We have not migrated everything with a few exceptions. As I said, it's mostly client rendered with a few exceptions that I'll go to later on. We rely on custom stores a lot for data fetching. I'm going to show one piece of code on the next slide. And we maintain a set of reusable components that we use throughout the site. Absolutely makes sense, like a select icon, dialogue, that kind of stuff. Those are all written by us so we don use an external library for that So we use custom stores a lot for co data storage and fetching data fetching because most of our apps on the website or widgets switch widgets, somehow communicate with an API in some way. And by co-locating the data storage and data fetching, it's very easy for us to reason about how the data flows through the app so usually what we do is we create a writable these days that would be a state room and then we return all the uh writeable methods but also we add our own methods so it's really easy to to interact with that in the component that actually uses the storage so So, sound effects here. New category page. I mentioned earlier the project that we prototyped, SwellKit first, was actually to rebuild what we call category page, which is where you can set all the filters in a certain category to find the products that match those filters. It was meant to incrementally be introduced for more and more categories, because we also had to redo the backend set of the things. So for individual categories, we wanted to migrate to a new UI. This is what it looks like. Some of you maybe know this view. That's what we call category page. and the new version looks like this but it has different phases and you can switch the views between a more simplistic layout because one of the aims was to attract new users and not scare them away with something like this but also at the same time we have to cater for the pro users that have been using GuideSales for 20 years or even more. So you can switch to different layout mode here. So components move around the layout quite a lot. So it makes sense to render that on the client. So as I said, it aims to make the UI

 easier for new users, but at the same time, equally as powerful for what we call pro users. It aims to provide more interactive UI than what we had before without page reloads. And also at the same time, we developed new data endpoints that would allow for much more granular control about which data we want to load. So with that in mind, we developed a server-side rendered SwelltKit app that's actually embedded into the main markup at request time. So what happens is a request comes in, a Perl code does all the sampling, renders out the header, the frame around the actual category page, and then it makes kind of like a sub-request to the SwelltKit node server, gets back the markup. He checks that into the already existing markup and then continues just rendering X-Late templates. So it's kind of a Frankenstein architecture. It uses around 80 components for this sub page. And as I said earlier, it was incrementally introduced and it's still not yet active for every category because the filters are not ready yet. And also, we're doing ongoing iterative improvements on the UI. So if you have an idea how to improve it, let me know. Fun fact, the development actually started way before SvelteKit 1.0, but post-separate world, luckily. And also, the category page launched, even though it was the reason we switched to Svelte, it launched long after we already had other Swells client-side rendered apps on the Kessler's website. So I'm going to show you what that looks like. Here we go. For example, so this is, it's up here. So this is what we call the simple layout or einfache filter And the main switch up here is you can switch to erweiterte filter which we also call pro mode where you get more filters you get more of the aesthetics and the old category page. So our regular pro users will feel more at home. You have some presets over here that you can choose and that are managed also by people in the editorial team. price range slider like this. In categories where you have loads of filters, it's really handy to just search for any filter value or one of these keys, like camel back, and you just get these filters back that apply to that filter, filter, filter. And you can customize that view quite a bit, show more collapse things, that kind of stuff. One feature that was previously very underrepresented on the old UI, in my opinion, is that you can actually add certain attributes to the table of products down here. So if you're really interested in the weight of a drink flusher in this case, you can click this little button here, and it will add another column down here and makes it easy to sort for Gewicht. Two grunts sounds optimistic, I guess. So if you find something like this, I can show you. There's feedback sent in here. I'm not going to do that now, but I should. Yeah. That's about it. Different kind of filters. As I said earlier, this range slider and colors that are enhanced depending on the type of filter. And let's see if that works. Hooray, it has yellow in it somewhere. Okay, so this is the Frankenstein architecture I talked about earlier. So the whole header, including breadcrumbs, the server rendered, and xlate and perl. And from here on it actually the Swellkidat And all the way at the bottom we continue with the server markup again Easy right Drawbacks of embedding a SwelltKit app in a monolith. So the SwelltKit server is not accessible from the public. We wanted to shield that off as best as possible. So it's only accessible from the Perl backends. So we could not really use the SwelltKit router. Also, it lives under a different route that we can handle in SwelltKit. So we had to roll our own client-side router. Then again, we have this client-side routing, but we also wanted to make sure that any filters you select in the view changes and all that is represented in the get parameters as part of the state. So if you hit refresh or bookmark that site, you'll end on the same page. So handling those query parameters is a bit cumbersome because you have to handle them once on the backend site in Perl. Then you have to send them on to the sweat kits, paste out server.js, manage them there, validate them, and then pass it on to the actual client's components. And the dev server also needed a bit of tinkering using Hook's server chairs to manipulate paths to serve it in the development environment. Still have a little bit of time, right? Just one sip. Then there's a different category of Svelte apps again. Another part of the website, it's called Ratgeber. You can think of it like guides. It's also rendered on the same SvelteKit node application, but works a little bit differently. It looks like this. Oh, shit, where can I switch here? Sorry about that. Oh, we can actually go here. I don't give up. So we have a dedicated editorial team that writes these guides. So if you looking to buy an external hard drive or an SSD you can consult this guide So it looks like a regular website that maybe you would manage on WordPress or something This has different components, like this box here, images. We have like pro and contra lists, not here. Yeah. And the FAQ section here, table of contents, that kind of stuff. And how we built that is again, a little bit different. So it's long form content about categories for individual products edited by, as I mentioned, our in-house editorial team, no AI, real humans. It is edited in self-hosted Strapi CMS. It's a node-based CMS and then it's statically pre-rendered on SwelltKits routes. So markdown from the Strapi CMS goes in, spits out HTML, we store it in Redis and request it on request time or read it on request time. And the rendering, statically pre-rendered rendering part is triggered by Strapi publish hooks. So Let me show you how that works. In the Strapi CMS, an editor hits the publish button once they're done with editing. Strapi calls a webhook that talks to a webhook service, also a Perl service. That webhook goes to the SvelteKit application. We're not there yet. The SwellKit service fetches data from the Strapi API, renders out the markdown, and returns HTML, which we then store in Redis. So the bridge between what's accessible from the public is Redis, actually. So the Perl application that runs on Apache actually only talks to Redis. It does not talk to Strapi CMS. It does not talk to the Node server. So all that is shielded away, super efficient lookup. So the pro is a very fast delivery. So Redis lookup just by the category and the language that the user is requesting it in. And the stop

 CMS as well as Git-Node server are not exposed to the public at all. Drawback, as with all the statically pre-generated sites, when any CSS or the components change, we have to re-render the whole suite of ratgevers to make sure that they are actually showing the correct markup. I've shown you that. this will be a quick one and also the last one we are at the moment developing a new self-service app for our merchants which are our clients they pay us so that's how we can work on the website and I'm allowed to give you a little sneak peek but unfortunately only screenshots there's not really not too much to say about it it's a standard pretty standard SweatKit application running on a node server actually multiple node servers it consumes two different APIs which is not true it actually consumes three different APIs because I forgot to OAuth API it's also served by the same Strapid CMS so we reuse that CMS that I talked about earlier with the Ratgever to populate some parts of the merchant service app. The merchants can edit all their company data, where they're located, their opening hours, that kind of stuff, view a lot of statistics, view their ratings on the website, respond to the ratings, view how many clicks they made through our website, get FAQ news and all that kind of stuff. Some of you have to be very brave now because we're using Bootstrap for CSS. No regrets. It's so simple. We had a different component framework first. It was not a lot of fun. It was not complete. It was buggy as hell. Then we decided to rip it all out. Just use Bootstrap. It's fun. For that application we leaning heavily into states via forms and get parameters which is really nice because it makes it pretty easy to build a system where you can save certain filters and views to your dashboard kind of because it all just get parameters And here's a little sneak peek of what that looks like. This is the dashboard. We have news and empty chart because I'm missing data here. You can edit or review the status of your shop, FAQ, review the sources of your price lists that we actually use to display the correct prices on the website, and loads of other views. one of them is ratings, so you get a nice view of your recent ratings on our website and you can also go into detail and view each individual rating and answer them. A quick conclusion, I can't really speak for my colleagues, you can talk to them later, maybe they have different opinions, but here's my conclusion. Overall, I think we're pretty happy with how that migration to Svelte turned out in terms of performance, which is most important, ergonomics for us and also for the user, and the pace of development of the Svelte library itself. Svelte 5, mixed feelings. It is a bit of a chore to update existing apps, even if the auto migration works pretty well in most cases. But as I showed you earlier, we have a few not standard situations, I would say. Early returns in an effect derives me nuts. We used to do that in stores. We early exit maybe if a condition does not apply. But with an effect, you can't do that. And I have not found a very nice solution to solve that. But still, rules make the code more explicit. I talked about magic earlier, which is nice. And I think I'm quoting Rich here that only a certain amount of magic is good. Also I think we are reaching much faster iterations with sweat than we did before and a lot less head and why is this not re why is this rendering so often, and all kinds of performance good foot guns. The lack of dev tools is a bit of a mm, but I found it only really relevant in larger apps. Most of the time, you can get away with debug and inspect and that kind of stuff. Colocating CSS is mostly a blessing, but it can make reuse some of the less mixins that we already have for the rest of the site a little bit difficult because of scoping issues and then maybe it's too global. So you have to be careful. That's about it. Thank you. Any questions? Yes. I asked a few questions. Did anyone on the back end team hear from Hanson? No. Also, why did you talk to them? Historical reasons. Yeah, but you might get rid of the Red X students. So I can only speak for the frontend team. This is what I'm in charge of. So we try to move a bit faster. Our backend devs, the love pearl. Yeah. And from me, yeah, it is. Perl was the language Gatsas was originally created in 25 years ago or even more, because it was not a company at that time. And they just never felt a real need to replace it as fast. To compare to what? To assemble a main deal? Maybe. Or I don't know. Not sure. I don't know. But one difficulty that we're facing is that it's getting harder each year to hire PERL devs. There not too many young PERL devs newcomers I newcomers So at some point maybe pearl devs will earn wages like cobalt devs or something So, thank you. Yeah. Yeah. Talking about rice wealth, and one reason was that it's easier for non-troncom developers to understand it. I work in a company, we only use .NET, .NET for back-to-back to the front. And we, for example, have this problem that a lot of the people are more back-end focused and don't want to touch the front as much as possible. We have problems to communicate to them. There are good frameworks which are easy to use. Does this thing only fit if you're a Prol developer, then it's easier to go with Svelte, or is it from other programming languages, or different programming languages as well? Very good question. I think since Svelte is like a superset of HTML, if you know HTML, which you should if you're a backend developer, it's easier to reason about Swell components than if we compare it to a JSX or React application, where it's JavaScript first. If you're not living in that world, I think sometimes it's difficult to see what is JavaScript, what is React, what is all that. And if you look at a simple Swell component, that's just markup, right? and you have some placeholder variables. So, yeah, I think it's much easier to reason about if you know HTML. Okay. Okay. There was another question, I think, or two more. So you have multiple different apps running at the same time, and how do you test those, or is it like bytes only and words? Both things can be true. Now, we have a test suite, end-to-end test suite for the Ryzean Cypress, which we're not particularly happy with. So, we are thinking about

 Maybe switching to PlayWrite because it lets us write tests a lot faster. But we're not there yet. But we do have end-to-end tests that cover most of us. I don't know. Maybe not most because there's so many, so many, so many features and different layers and viewports sizes. But we try to cover the most important things and cache them. So that's front-end testing or end-to-end testing. There's spurred tests as well, of course, but no real unit tests for all swipe components, if that's what you're asking. You wanted to ask a question? Yes, I did. So since you mentioned that for the home page, for example, that it renders the the self application and after the page was reversed and then called the API after that. I wonder if you... How do you handle this calling API? Do you generate web or ill-point API or do you have some kind of end-to-end type safety that you generate it, or do you use REST API or GraphQL? Good question We talking to REST APIs so different APIs for different use cases And the Swagger documentation, we have Swagger documentation, but in some parts they're not completely accurate because we have so many overloads sometimes on one endpoint. It can return different things depending on the parameters and that gets pretty tricky to correctly define in Swagger. But for the last application I showed you, the merchant service application, we were heavily using audit-generated types based on the Swagger open API specification. So I run that. It just generates those types, and I just set them in the JS doc in my data fetching, and that propagates all the way through. So in this WorldKit app, it's pretty easy. Even if you're not using TypeScript per se, you can still generate TypeScript. And I even sometimes add my own TypeScript types if I'm missing something. But I consume them in JS doc, not TypeScript. For on the public website, it's a little bit more difficult, as I said, because the Swagger or the OpenAPI specification is not that accurate, and then it doesn't happen that much. Does that answer the question You mentioned that of course it a big moment Do you have a setup monoratwalk Basically, I wonder how you deal with the breaking changes in your API. If you then deploy your backend first and then quickly frontend, or do they get coupled together? They are coupled together as one deployment, and only when the deployment finishes, we switch to the new version. So by that time, we know that the Apache web servers restarted already, in theory at least. So we just recently, as I mentioned, we did the migration to Vite, and it was not only the migration to Vite, but we completely ripped out a whole build pipeline and how those assets are served and how we load the correct chunks with the hashes. We use import map as a very central piece with that change. So, yeah, once it's built and the web servers are restarted, we then flip a switch that basically only then the new assets are loaded. So we know that we're ready. Yeah We have time for one more question There was one more A short one It is a short one So you mentioned that your Citrus site is doing some things for historical reasons and it's also a bit about what you call Frankenstein. If you had to set it up from the ground up, imagine the new day doesn't exist through building it from day one. How would you do it? You can just tell me how to do it. We do that right. Yeah, okay. That sounds like a short question. Yeah. I'm thinking of... So we had a similar situation when we decided to do the merchant service application that I showed last from scratch, which is a rare situation, and we went SwelltKit. But we talked to a Perl API, so that's still there. You could do it just in Swaggit and use the server routes a lot and we'll be fine, I guess. It sounds like you have this issue right now and you can talk about it. I'm never interested about this CMS, but I thought why not ask about the whole thing? So if anyone has more questions, Martin is going to be happy to... Yeah, I'll be around. Thank you. Thank you.