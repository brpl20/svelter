 Thank you, Brittany. Hey, everyone. I'm Dominic. Matthias also said a very few lovely words about me and my involvement in the open source community. I've been doing it for five years now. I checked earlier. It's been a great pleasure to be part of the SWAT community, and I'm so grateful for all of you being here and listening to my ramblings about, well, testing. I've been doing software development for more than 20 years. I've been very fortunate that in the first team I was a junior developer, and there was a senior that was very passionate about testing. I learned the ropes of how important testing is. today I'm trying to give every one of you either if you have never heard of testing before oh, let's do that right now who writes tests for the applications here? okay, so for the online people that's like 80% but next one, who likes writing tests? okay, that's still like 40% so half of you like writing tests that's great at the end of my talk I hope it's at least three-thirds, hopefully. Okay, so testing one, two, three, four is going to be a speed run about how to set up testing with Svelte and Beat. You can do unit and component and end-to-end testing. So it's a little bit of everything. I hope a little bit of something for every one of you. To start, there's this great combination of technologies that is made possible by using Vite and Svelte, that is ViteTest. It's been around almost as long as Vite. Like, Anthony Fu had this great idea, and people ran with it. It started in 2021. Since then, it has grown almost as much as Vite has. it's liked for its simplicity and it's zero config by default for JavaScript unit testing. I think you could do away with not installing the test in your project You could like npxv test and if you had a test file and it found it it would work So that how zero config it is But for SvelteKit, you have to do a little bit more because SvelteKit is not simple JavaScript, it's Svelte, right? So instead of forcing you to write all these configurations by hand that you had to do just a few months ago, There is the SV CLI made by Manuel, who is also here. So if you find him, give him all the applause you can, because the SV CLI makes scaffolding and SvelteKit projects that much easier. You just type SV add, and it gives you a list of options, and you can pick VTest, and it will configure it for you. You can also type SV add VTest, so all the add-ons for SV. They can be added by name on the CLI directly, so you don't have to use the UI anymore. You've also heard that there is vTestEcosystemCI earlier from Matthias. The SVCLI tests its add-ons, and the vTestEcosystemCI uses the SVVTest add-on tests to verify that changes in vTest don't break your setup. So that's the level of care we provide to making sure that your projects work when you initialize them. It's a lot of work and gritty scripting, but I think it's very worth it. I wanted to let you know that we care about you. I'm so glad you care about us as well. Please come and contribute. It will help a lot for everyone. But this is all you have to type to get started with testing. It creates the vtest config for you. The vtest config can be a separate file, but in its form, it's just the test key inside of the vt config. If you look closely, there's something awkward going on here. There's this workspace. And a workspace in vtest contains projects. It's originally a feature that's geared towards monorepos where you have multiple applications or packages you want to test with vTest. But it doesn't have to be that way. And SvelteKit has two parts, basically. SvelteKit is a server application and a client application And you want to be able to test both of them and what we do now after like figuring out how to do it is we configure two projects inside of vtest one for the server part and one for the client part so now you have these two test projects one named server and one named client and And the server config looks like this. It's just telling the tests, hey, I need a node environment. And then you have an include that includes all your spec or test files and an exclude. And this exclude excludes all the files that have a dot svelte in it, which means on the server side, you don't test your svelte components by default because you want to test the client rendering. That's what the user is using, right? So we do that for you automatically. So, when you start writing a unit test, it runs in the Node environment. And on the other hand, when you want to test a component, you need a client environment. And the client environment needs a DOM. And for that, you can tell vTest that you want the JS DOM environment. You need a little bit more to mount Svelte components inside a client environment. So, there's a lot of testing library, and this provides a little plug-in that we also add to your configuration. And then we also add a setup file, which is something that is executed before every test, which allows us to inject mocks into the environment. Because JSDome is not a real browser. Like, it's a fake browser in Node, and as such, it doesn't have all the APIs available that are there in the browser. especially the modern ones like mock media it doesn't have it no match media sorry like so we have to mock it because svelte 5 contains some reactivity helpers that rely on match media and if you were using these five features in your test components then vtest would break in js dom because match media isn't there and with this insight of your setup file, it just works. There's also an import for jest.dom vtest, which sounds a bit weird. Why are we importing something from jest Like jest is the old stuff But it helps set up like auto completion for matches that rely on just dom because vtest matches like are the same as jests so that you can just port your tests over from just easier but i hope all of you have done that like three years ago yeah you can also have multiple setup files so if you want to mock something else like if you have a canvas somewhere or something else that isn't available in jstom you can add mocks here and i just realized i didn't start my timer so please remind me when i run over um but running is a good thing to talk about because we already set up to run our unit tests you just go into the console and there's a test unit script in your package.json generated for you that starts vtest this what i'm showing here is a test application it's public on the top i'm going to post the link later you might also see more in the next talk but also more about that later um another thing you might notice here it says waiting for file changes who of you knows what watch mode is okay that's like 10 maybe maybe 20 okay so watch mode nb test is the best thing ever ever However, it's basically hot test reloading. So when you edit a test file, it is re-executed automatically. This might sound innocent, but it only re-executes the test you are editing, not your whole test suit. In older test frameworks, when you change something, you had to rerun all your tests, like filtering worked somewhat but you had to remember this arcane syntax and it always took minutes the feedback loop is just that much faster when vtest does it for you and like editing test files is only half the story of this vtest is like it has the knowledge of the module graph so it not only reruns tests when you edit the tests it reruns tests when you edit your source code when you you have button.svelte and you have a test for that button and you edit the button.

 and that watch mode is running, it tests that button again. And this is a really powerful combination. Some real-world talk, like when I'm fixing bugs in client projects, there's usually a bug tracker, you have an ID, and it describes what you have to do. And you take the reproduction, you start a branch, you fire up watch mode of the test, and then you go into the test case, you take the reproduction and add an expectation that makes the test fail based on that reproduction. Now your test is failing. It has been rerun automatically. Next thing you do is you open your component and start fixing. And once your fix is complete, the test will turn to green automatically. You haven't restarted watch mode once. And then you can commit and open your PR, and the reviewer will be so happy to see that you added a test case as well. And it just works. Like, the workflow is super easy to follow. There's more tools to it, like IDEs have vTest integration also in IntelliJ or VS Code. It even works with the native IDE UIs. So, so great, like I can't live without it anymore. Maybe I can get to show it to you later, but it depends on the time I have left at the end of the talk. last thing i want to mention if you look at the left hand side it says server and client so by default watch mode runs both projects at once but you can also do dash dash project client and only look at the client project so it's really nifty and i like it a lot So, in Svelte 5, we added Svelte modules, which is basically a JavaScript module where you can use runes when you name this module .svelte.js or .svelte.ts. What this means is that in this stupid example of a doubler class that doesn't make sense because you can just use derived directly, it is able to use the derived rune in a class, And then when you do new doubler somewhere, it'll just work, even if that is not reactive by default. So how do you test this The problem is doubler expects a state being passed in So you need to be able to create a state in your test how do you do that well you write rooms in your tests remember how i said earlier that files with dot swell dot js get compiled automatically for reactivity and making rooms happen well it's not the suffix really it's not dot svelte dot t as what's triggering it it's the dot 12 dot it's an infix so files that are named dot svelte dot test dot ts automatically inside of vtest get passed to v plug-in svelte we plug-in svelte compile svelte module and gives you reactive state inside your tests so you don't have to mock anything it just works and this is really powerful because five lines of code and you have tested your reactive state and it's just like using the tools you know. You don't have to learn a new concept. I have to thank someone from the Svelte community to making me aware of this infix notation really early in the Svelte five stages when we added this. I think it was Hugo, but I'm not quite sure. Whoever you are, thank you so much for making us alert and suggesting this great solution. just like that like it's full reactivity it's great so now you can test unit tests for regular javascript and slot modules but we are here to test components too right so for component testing we already saw the setup with the client project. I mentioned vTests, testing libraries, briefly. It's basically testing library as a set of tools to mount components and they have packages for all the different frameworks. So there's testing library react, testing library view, and testing library svelte. There's also a testing library shadow DOM. So maybe if you use light mode with Theo's stuff and testing library shadow dom you can also test his swap components with this you will have to try but in theory it should work back to svelte um testing a component works basically the same as testing a module you have to have one key thing though You have to render the component into the JS DOM provided DOM To do that, you just call render from testing libraries felt and you get back a set of options. You get get by row, get by whatever you want to select something, or you get the container itself. and inside the container you can just look at the text and have an expectation. So how does Testing Library Svelte do this? It just imports mount from Svelte and has a few housekeeping things around it. And that's it. Like you could do it on foot as well, but please don't. It's just like more work and repetitive. This is all it takes to test your Svelte component. Of course, this test is very, very simple, but you can expand on it. It also works, as with the module tests, with state or any other reactive rooms. Like if you have a component that takes a prop that has to be reactive, you can pass in something reactive you made. made or in this case you can also make the whole props thing you pass to render reactive and change it later that makes writing tests a little bit easier but you have to be aware that sometimes you have to call flush sync especially when you do this props trick because it takes a while to propagate and because you are not in a real browser it's like basically it's like tick or await act from before. And now this is something a bit more advanced. Anybody tests SSR output of components? Or has an idea why you would want to do that? Let's say you have like SEO.svelte that contains all your important meta tags, OG image or whatever. and you want to make sure that it renders what you want. So usually what you have to do is like fire up an end-to-end test and then take apart the head and make sure it's there. But this is like really slow. We talked about feedback cycle earlier If you want to change something in this component you might want to be able to do it faster and you can Remember earlier when I showed the selectors like the dot was used to put something into the client project for testing? Now, if you have greeter.svelte.test, it will test it in client mode. But if you name it something else, like greeter.ssr.test.ts, it will enter server, the server project. And in the server project, you cannot use render from testing library Svelte, but you can use render from Svelte server. You can just use the Svelte SSR renderer to render your component to basic HTML. Like it was shown in an earlier talk as well. So when you call render, you get back the body, you get back the head, and you get back the CSS. So you can just render it manually and then make expectations on that output. And this is super fast, like it takes milliseconds and you know immediately if you changed your SEO component to something that doesn't work anymore. Or if you have like a component that is responsible for rendering the first H1 in your page and you want to make sure this component always contains the H1 in SSR output. You can make that a test and you get failure immediately. It will never break in your application. I'm in the camp that says you can probably don't have too many tests if they are meaningful. You can write a lot of tests just to get coverage to 100%, but the core functionality of your application that would degrade your revenue because suddenly your shop isn't ranked anymore or something isn't found anymore is worth testing. And this is a good way to do it. The thing I've been mentioning a bit is that JS DOM is not a real browser. Wouldn't it be great if you could run your component tests inside of a real browser instead? I mean, there's Cypress and others that show that you can run tests inside of a browser. Like, the whole test engine runs inside the browser in Cypress. So, what if you did that with vTest? vTest is running on Node, and you can't do that, right? Except you can't, because there's vTest browser mode.

 And I forgot what I wanted to say on this slide earlier, I think. The missing APIs part I covered already, but you also can't look at what JSDOM does. There's no rendering output. So if something is strange, you don't have visual feedback to correct it. And JSDOM, of course, doesn't behave like a real browser all the time. So with a real browser, you get with VTest Browser Mode, you don't have all of that. So your tests are closer to what your user uses and are more reliable and give better feedback, of course. To install it, you just have to add three dependencies. There's also a vTest CLI that has a helper for this, but honestly, I don't know if it is targeting SvelteKit applications right now, so installing them manually works as well. Then you just have to edit your vtest config a little bit. You change the client project to no longer use environment.js DOM. You use environment browser. Then you add a browser object and tell vtest which browser to use. You need to have a browser provider so vtest doesn't have its own abstraction over it, of course. And there's Playwright and WebDriver.io. It's really recommended to use Playwright here because later on we also use it for end-to-end testing so you only have one dependency instead of two. Then you can ask Playwright to give you a Chromium instance, but you can also ask it to give you a WebKit instance or a Firefox instance. And you can have some in parallel as well. So all of the Playwright stuff you can configure here, like the vTest documentation is really extensive on this. Check it out. And with this, you have a real browser environment. You know what is no longer needed in the real browser environment? That mock media, that match media mock. Oh God, I make my own tongue twister. Okay. You also can add new matches because VTEST browser has Playwright under the hood, and with Playwright under the hood come Playwright matches. And it also now has its own browser matches that might differentiate a little bit more from Jest but are more useful And there one other thing Earlier we used Testing Library Svelte With browser mode, it is recommended you use VTest Browser Svelte, which is basically a light fork of Testing Library Svelte that has a few key differences. Testing Library Svelte cleans up the DOM state after each test. So immediately after each test, the whole DOM is flushed and reset to empty. This is not great if you run your tests in the browser, because you might want to look at what the test did at the end. If you flush it at the end, it no longer works that way. But if you flush it at the beginning, then you can look at the end result of each test. So this is what vTest Browser Cert is doing. and i hope in the future they will collaborate and have a common core so that we don't have like two packages living side by side but this is like most of the thing you have to change one important difference is that vtest browser does not export stream but i think you can can do without because you can either use the container or get by role or the other helpers to look at the components output. And with that, we have reached demo time, but I'll postpone demo time until the end because then I don't have to do my screenshot of change twice. So this is component testing. Are we finished? Do we skip end-to-end testing altogether? Or do we have another nice logo mashup? Yeah, thanks. So Playwright and Svelte is another great match. Just like earlier, you just use the SV CLI, as we add Playwright, well, you get a nice little Playwright config. There's not much in here because like end-to-end testing is by definition not really related to the framework you use it with. Like if it was, then it wasn't end-to-end. So I going to show some tricks that are relevant for SvelteKit applications but this is like not a lot about Svelte internals really but it still worth knowing so one thing you notice here is that there is a web server that has a command so when you run end-to-end tests locally you have to spin up a server and this automates this for you it uses the preview strip from beat by default and the other thing is that it puts a testier property which we named e2e by default because while unit tests and component tests are usually co-located with the file they are testing end-to-end tests are usually related to the roots and the paths of your application in slalkit you could technically co-locate them with the plus page files But some routes, like if you use the groups or if you use parameterized routes with rest params, not every route has representation in the file system, really. And then you end up, like, things getting mushy. so if you put it in a separate directory you can put the hierarchy of your tests and your paths there and it will be more discoverable and also separates it more nicely you know that end-to-end tests are in there so i recommend using a separate directory but if you want to co-locate them as well you can and that's it like you can start running end-to-end tests immediately They also run in parallel. You get all the nice output. Playwright config is very, very powerful. I like it most of all the end-to-end testing solutions I've used because it's so composable. You can customize it greatly. If you want to see crazy customizations, you can look at the SvelteKit repo because testing an app with end-to-end testing is one thing. testing a framework for its behavior with end-to-end testing is another thing. Like, we have to be a lot more tight on timings and stuff like that. So if you want to see crazy playwright conflicts, look in the SvelteKit repo. But this is what you need for apps, like just the web server and you can go. So this reads nice, but what is this API data JSON about? SvelteKit offers you a way to define API routes and Playwright has functionality to test APIs So what you usually know about Playwright is you get a page object and you can like interact with the page and then expect that something happened. But you don't get access to your API that way. But you can use the request object instead and just ask your API for some JSON and then look at that JSON and hey, hey, there's the data my application needs, or it won't render correctly. The great thing about this, this is much faster than actually rendering a page. So, again, feedback loop, you could put it in a separate filter test category to have API tests. It's nice. And it's also nice because you can also use it for your pages. I mentioned earlier about testing SSR output. testing ssr output of a single component is nice but if you really need to know all the gritty details of what your page looks like to google bot at first you can just ask get request with display right request and you get the ssr output there is another way you can do it with pages as well if you configure them to have javascript disabled and we do that in the svelte kit repo because page and the get by APIs are great to navigate around the HTML. But for basic testing, or if you want to do snapshot testing to the complete SSR output, this is the way, and it's a lot faster. I also skipped ahead a little bit, I think. I'm sorry about that. The example I did here was, for example, that it checks that there's no script block in your output of the About page, so you know it works without JavaScript. Of course, you can also do the regular page testing and interaction testing. I think this is very important because, like, testing your component is nice, but once you compose components, you never know. like your on click listener on the button works and you put it on a page and it still works but somewhere something else in the middle of these components swallows the event and suddenly it doesn't work anymore and you will never notice inside of a component test another nice trick about

 the web server config. You can have more than one web server, but why would you want that? Because it allows you to spin up local APIs. This means that if you have a back for front project and a front end project in your monorepo, you can spin up the back for front and then the front end and it works. Like zero effort really to have this locally, but locally is also nice on the the developers' machines. It doesn't work great in CIs because most CI agents are slow. But if you have a CI job that deploys to a preview environment, you can just point your tests at this preview environment by telling Playwright about the remote URL. This is nice also because you can control it from the environment. And if you do that, you can run tests locally and run them against your remote at the same time by just switching this environment variable. This is a great way, like even if you want to know if something failed or reproduce a failed CI run, you just check out the code at that commit and then point your local test runner to the remote of that preview deployment and you get the test run and you can repeat it and watch over it Getting feedback out of a CI is really hard sometimes but with that you can just repeat it and have it done I mean, Playwright is awesome here. They have this test tracer and everything, and I recommend you to check out the documentation and also grill me for everything you want to know. But running it locally is always the way I do it if I want to know. And if you work with clients that have Docker environments and Kubernetes and testing has to be like really formalized, you can also use a Playwright image from Microsoft that has the browsers already baked in. Like making an image manually that contains Chrome and all of Chrome's dependencies is not really a piece of cake. I don't recommend doing it. So taking this image And then adding your project to it, PNPM has another great feature called Fetch, which is geared towards Docker containers. It's basically installed with frozen log files on steroids because it skips the whole log file thing and just downloads everything that's in there in one go. And then you cache it in a separate layer of your Docker image and then you have a testable container you can reuse for that release all the time Yeah, that's the last thing I have on my things I wanted to sell you. But I have to thank a few people. Matthias first. I don't know if I would be as active in the open source community if it wasn't for him. He basically beer-hugged me and made me part of the VEED community as well. I'm very thankful for that. Vladimir from VTESTE, great guy as well. We all owe him a massive amount of time savings. Jeppe is coming up next, and he's going to blow you away because what I just told you is kindergarten. and his shit is the real deal. So whatever you do, don't go away. Like I'm taking that laptop and having a seat somewhere and enjoying the show. James Camieri, because you saw all those turning cubes behind me. The presentation framework is called Slide to the Left. And he made it he showed it on Last Start Summit and I liked it so much that I been doing my talks with that since And I think this is great Like our community produces so much great content Even this slide thing is made possible by Threault And Grisha is right here as well. So if you like 3D and Threault, check out Threault. Also, thank all of you. Like seriously. Making this shit and nobody using it would be so sad. and seeing you here and using it and being thankful and hopefully also considering contributing is so great of you so um i'm going to post these resources in the discord in the svelte summit later there's a link to this talk as well and to the test app repo i mentioned um i'm available for consulting so if you need help with salt or anything else related to the web get in touch. You can find me here. On Mastodon, I'm not that active, but you can find me on Svelte Discord as well. So thanks a lot for your time. I'm done.