 Hello, everyone. Welcome to another episode of Svelte Radio. I'm your host, Kevin. I run Svelte School. And today we have a very special episode. We have the creator of Svelte on Rich Harris. But before he gets to introduce himself, we'll kick it off with our other hosts. Hey, I'm Sean. I work at AWS on random stuff, including trying to get Svelte into AWS. and that is an ongoing mission. Hi, I'm Anthony and I'm the CTO of Bianc. I'm also a Svelte maintainer. And I'm a graphics editor at the New York Times, currently working on SvelteKit. Ooh. Cool. The new shiny thing. Before we get started, how's everything with the election and all of this stuff? How's the workload? For me, thankfully, it's settling down. And last week was quite a busy week for everyone, certainly in the graphics department at the times and probably in the organization as a whole. It's very difficult to avoid getting sucked into the madness. But you know what? It's fun. There's no better place to witness history than from a newsroom, even if it is a virtual newsroom scattered around people's homes. Something I didn't appreciate about your election coverage is that you're actually spinning up visualizations fairly quickly based on what counties or states are in focus at the time. Like there's some parts of this that you could not have prepared beforehand, right? Yeah. There's some slight of hand, you know, you prepare for a variety of different outcomes, but yeah, like as soon as the results start coming in, the politics editors and the graphics editors who are covering this are bashing their heads together and trying to figure out what is the story. And then that kind of filters down to the people making the charts and maps. And we all come together, we analyze the data and we try and figure out what just happened. There is some infrastructure that's already built out because you kind of know that people are going to want to know which parts of the country swang in what direction. But yes, a lot of it is kind of rapid response data visualization. So you've got Lego blocks for building visualizations that will tell you population this area voted this way or whatever. You've got that sort of stuff. Yeah, like you know that you're going to need a lot of demographic information about counters. We know that the results are going to be coming in per county or in New England it's per township because they like to do things differently And you just have all of the data that you might possibly need in a massive spreadsheet ahead of time And then you can all sort of plug it in to make something relevant. All right. So we're not here for the election. We're here for something that's more exciting. That certainly is a matter of perspective. For sure. So we're going to talk about SvelteKit today. So before we dive in to the questions, what is SvelteKit? So SvelteKit is one way it's a successor to Sapper. You could even think of it as Sapper 1.0, if you like. But in another larger sense, it's our kind of vision for the way that you should build Svelte apps in future. It's something that we've been kind of talking about in a peripheral sense for a long time. We've been talking about how we can evolve SAPA to take advantage of some of the recent trends in front end development particularly the rise of serverless and more recently the rise of unbundled workflows which we I'm sure we'll get into later but it all sort of came to a head recently you know the pace of development on SAPA had hit a bit of a lull at least until Ben McCann really picked up the baton and started churning through issues and people were getting a little bit frustrated i think with the progress i know anthony is one of those people because he uses snapper very heavily in his job at a certain point we're like what if we just started from scratch like the big rewrite as opposed to trying to get all of these ideas into what was honestly kind of a warty code base i sort of proposed this very hesitantly in the discord thinking everyone was going to yell at me and instead everyone's like oh yeah let's do that and so that was sort of the germ of the idea and then over the last i guess month or so the idea turned into a prototype and the prototype turned into a project with a name and i was i guess reckless enough to announce it it's felt summit as a thing that i was working on and then at that point it was like a de facto So this is what we're doing now. This is it. So now the whole team is full steam ahead. We've got some new contributors as well. People who haven't previously been on the SvelteCore team are helping us out. Andreas Ancrona is one of them. And Dominic who created Sveat are helping out on the repo And it awesome It looking good And I think that probably the alternate version of that story is that Rich claimed to be going on holiday He went on holiday He came back a week later and SvelteKit appeared, and then we spent ever since bike-shedding the name. I promise I didn't do it on holiday. That would have been very sad. I had a really nice break, and if I'd spent it in front of a laptop, I've been very unhappy with myself. It's just the way of these things, right? The first 80% of a project is, you can build it pretty rapidly, but then once you start to get into the details, that takes the remaining 400% of the time. And that's the situation that we're in at the moment. It's a modified Pareto principle. Obviously, I'm not so steeped in the history of Svelte as much as some other people here, but I feel like this is something that happens every now and then in Richland, this idea that a big rewrite would update just a lot of the core assumptions and change the design to something that is much more enjoyable. Is there like lessons that you learned from, you know, having done things like these, for example, going from Racktiv to Svelte and then from pre-Svelte 3 to Svelte 3? I thought that these are pretty major bumps, right? Yeah. I mean, I guess the main lesson that I've learned is probably that it is a good idea because software, it grows organically, right? And there are layers at the bottom that very often don't make a lot of sense anymore because things change, especially in the front-end world. Things are changing all the time very rapidly. And we started sick of dealing with a legacy code base, but because there's actually a new foundation that you want to build on top of, then it is worthwhile. But at the same time, I have also learned every time I've embarked on any kind of big rewrite that it is going to be so much more work than you anticipate. Because the old thing that you're replacing, it did a lot of stuff. And the new thing needs to do all the same stuff. Just better. Yeah. Also, I guess we're sort of building it in parallel with Sapa. It's not like we've just abandoned Sapa completely. Sapa is now, I guess, in a kind of maintenance mode. It's not really officially announced yet. We're adding to it as we go. and the issue of course there is any new stuff or fix as we put into sapper have to be then ported across to svelte kit so it's actually keeping track of that as well actually it's actually quite difficult so it almost inhibits us it makes us try not to do too much on sapper even though we need to keep it going yeah and that plus you know psychological factors I think uh really driving us to get this work done as fast as we possibly can in spite of all of our schedules we really want to get this done sooner rather than later speaking of getting this done sooner rather than later yep you sure did are we talking hours hours hours months days when can we try it for real the one thing that i've said about timing publicly other than i'm not going to say anything publicly about timing is i think we're looking at weeks rather than months i would be disappointed if we didn't have a public beta or beta we've had a long conversation about how to pronounce that word sometime this year which gives us just under two months for the public and then you know a 1.0 version is gonna be a little bit longer it kind of depends on what people find when they first try it out if there's all sorts of bugs and use cases that we haven't considered then you know it might push things out a little bit but you know hopefully early 21 we're gonna have a stable 1.0 That's exciting. I think also that the reason that committing to an ETA isn't really possible or really even giving that rougher guideline. Svelte has no full-time maintainers. It has people who have real jobs in the real world who do this in their spare time. The advantage to that, of course, is that you know that everything that's going into Svelte and Sapper and SvelteKit and everything is people's passion. and it's stuff that people want to do, not stuff that they feel is a chore or that they're paid to do against their will, anything like that. It's really a product of passion. And I think that gives it an advantage over something that's maybe run to a sort of an expectation or a schedule or a more official, officiized, I mean, you can call it company, I suppose. Also, no ivory towers here. Everything we build is driven by very real world practical needs. Now that we know what SvelteKit is, and when we can expect it. Should we get into some questions? I think the first one that most people that are coming from SAP are wondering about is, what about migration? How easy or hard will this be? Yeah, so one way to think of it is, imagine that we did put out a SAP 1.0, and with SAP,

 all along that there's likely to be some API changes between like where are we now Sapper 0.28 and Sapper 1.0 and every time we've released a new version of Sapper we've had a migration guide that sort of walks you through the process it's actually not going to be any different from that there are some changes that we have to make because we're embracing serverless as this first class idea but like the bones of a project are going to be relatively unchanged and so we've been migrating some of the existing sample SATA projects like our Hack and News clone and our real world clone it's not that much work because your file structure continues to represent the structure of the application we have the same file name convention for dynamic routes and all that sort of thing things that have changed let's go through the list previously you had had a custom server.js because the expectation was that you were going to be running a node server or you were going to be statically exporting the entire app we can't make that assumption anymore because there isn't going to be a server in the traditional sense there's going to be a set of serverless functions so right now there is no function that will run for every single request other than the function that generates the session context which like you know includes your user information and stuff like that. And so you can't use things like express middleware and stuff like that, which you might have been using before. As things stand, like all of this is subject to change if it proves that there are a lot of things that people just simply cannot do without having a custom server. But right now we're trying to lean as far as we can in the direction of being like fully serverless. On the same note, your endpoints. So we used to call these server routes, which is a bit of a clunky name. We're now taking to calling endpoints, which is to say that if you have a file like source slash root slash foo.js that will respond to requests to the slash foo endpoint inside that your handlers no longer take the request and response object that you get when you're dealing with nodes http module because if you're on an aws lander environment or something like that then you don't see those things you are given an object that represents the method and the headers and the body and everything like that associated with a request And your job is to return an object that contains a status code some headers and the body And so we basically adapting to that surface which means that you will need to write all of your endpoint handlers We might change the preload signature. We think that we can probably improve that a little bit. A lot of people don't like the fact that you have a this inside your preload functions, and so we might fix that. But everything else, it's just a few little cosmetic bits, bits and bobs here and there. If you have a very complex build config, like if you've changed the webpack config or the role of config in your project, then you'll need to find some way to represent those changes in the new snowpack config. But that's about the extent of it, I think. Something I've been a little bit vague on is, so we're splitting things up from a single server to multiple serverless functions. Do we have fine green control over which of these are statically rendered or which of these are dynamically rendered? I don't know if that's the term. we do so there's this concept of pre-rendering that can apply to all of the different adapters we'll explain what adapters are at some point in this episode i'm sure and essentially what that means is that as the functions are being built we can pre-render a subset of the application as static files and they will just get dumped on your cdn wherever and then when a request comes in for one of those static pages, it will just retrieve the pre-rendered HTML, which is great because there's no work to do. Having said that, I don't know if you've been following what Remix are doing at the moment. They have a conviction that static site generation is a waste of time and that actually we should be dynamically pre-rendering everything but using cache headers in such a way that it is as if you had statically pre-rendered everything. It gives you the benefit of the dynamic rendering, but without the downside of pre-rendering, which is that if you have a very large site, it might take several minutes to pre-render all of your pages. So you can sort of amortize that cost over the life of the app. That's a long-winded way of saying, yes, we do have pre-rendering, but also we're kind of thinking about whether that is the right direction and there's more exploration warranted around that topic. I think it's a very interesting direction. Yeah. I had a question about like the, so in other frameworks, like Next.js, you have this get static props thing, for example. And I guess this touches a bit on that. So prefetching data at build time Yeah Well Next has get static props and get server props If you have a statically pre page then you call one function If you have a dynamically rendered page then you call a different function. We're not doing that. We just have one consistent way of pre-learning data, whether it's a pre-rendered or a not pre-rendered route. And the way that we differentiate between pre-renderable pages and non-pre-renderable pages is you just export a Boolean. Export const pre-render equals true. if that exists on a given page then the adapter can know that it can pre-render these pages and you don't need to seed it with the pages that are pre-renderable because it can just look at the root manifest that it generates and identify the statically rendered pages for you i think it is the same idea but i think the implementation is a little bit simpler as far as you know authoring an app is concerned. I think this idea, especially, you know, just thinking about the caching stuff, if you go down that path, it would mean that you basically have very predictable build times because you don't, essentially don't have to build your pre-rendered page. It would just get pre-rendered on request. That'd be an interesting solution. It would change it from like O of N to like maybe O of one. But then I think it's also one of those things that's very contentious because It's just not a norm to set cache headers in a lot of JavaScript frameworks. It's definitely a bet on Ryan and Michael's side of things. And it's something that... So having worked at Netlify myself, Netlify does take the fairly strong view that people don't never... They either never set cache headers right, or they try to do it right. And then at the first sign of problems, they turn it off, and then they leave it off. Because that's the way you solve problems with cache and validation. You just stop caching. It's an upcoming struggle, I feel like, that we're really going to see play out because of all these frameworks exploring this space. It is. My guiding light around caching is a blog post that Jake Archibald wrote a while back in which he basically says there's two reliable ways to set cache headers. One is the content is immutable. It has some unique identifier in the file name, like a hash of the contents. And then you can treat that as immutable. Once the browser has it, it can hang onto it indefinitely because nothing's ever going to change. And that's guaranteed. The alternative is you're going to need to check everything with the server. And the server can respond with a 304 which means nothing has changed since the last time you had this file So you can use the version in your cache but you still need to check everything with the server And anytime you start to get into well maybe you can hang on to this file for a little bit then don't check for like the next 10 minutes or something. Inevitably, you start getting a mismatch between, you know, you've got some resources cached and some other resources that relate to that resource are uncached and it gets out of sync. And this complexity is magnified when you have a server-rendered page, which is cached for a certain amount of time. And then if you navigate to that page client side and the framework is just getting the data for that page instead of the page itself, then that JSON file or whatever it is will have a separate cache lifetime. And so the server-rendered page and the client-rendered version of that page will be out of sync. And even Remix doesn't have a solution to this problem. It's a really tricky thing. But I think what Remix are doing is pretty smart. after talking to Ryan and Michael a little bit about this, it turns out that what they're doing is they're actually controlling the deployment as well as the generation of the files that get deployed. So they're equivalent of our adapters. They are also responsible for invalidating caches on the various platforms, which is how they're able to have this level of granular control. Whether it's worth thinking about adapters in SvelteKit in the same way that they should be responsible for deployment as well as just for building is something that we probably need to think about. I think also if you're generating a load of content up front and then static generating content and then you're deploying that content and then someone changes what that content is based on and then you have to rebuild the whole thing, you're going to have that build delay whilst all that content is rebuilt anyway unless you're going to have a way to build them one by one, which will be very quick. So if you're rebuilding all that content every time someone makes a change, then that's basically the equivalent of having a long cache on some stuff and having stale content rendered to the browser. So I don't think either is a silver bullet. It's definitely an issue that needs a lot of thinking about. Yeah. It's one of two hard problems in computer science. All right. So TypeScript support, of course. Yeah. We're going to have full TypeScript support when we launch for whatever your definition of full TypeScript support is. We'll have the ability to set up a TypeScript project when you do npm and it's felt it already in fact asks you do you want this to be a TypeScript project and if you hit yes then it will add TypeScript to your package.json, it will convert

 the example component to have lang equals TS, give you a TS config, all of that stuff. And it just kind of works. There's other little nuances about how we incorporate SvelteCheck into this setup. But the short answer is yes, TypeScript will be supported. We're not making the mistake this time. I think you've also touched on another point there that SvelteKit has a CLI and it has a config file. And those are two things that originally we considered to be not a good thing. And now they've become part of what we're building. So it might be interesting to talk about why. Maybe back up a bit as to why DGIT in the old case. Yeah. So for a long time, we kind of rejected CLIs in favor of just clone our template repo. And that's your project. to make that easier we have this tool called dgit which essentially clones a repo without all the history and has some like nice stuff around discovering the repos that you've already cloned in the past so that you don't need to type it out each time and it will do offline caching and stuff but it's basically just cloning a repo and then deleting the dot git folder and that's nice because you're really you're showing your work there's no there's no magic there's no like if you do a create react app thing then at some point you're going to stray from the happy path and you're going to need to eject from your create react app setup and at that point you're on your own and what was formerly this relatively self-contained thing just kind of splooges all over your file system and it's just a it's just a very confusing experience and so we felt quite strongly that it's better to just give someone some files and say this is how they interact with each other if you want to make changes go nuts and that way also people can they can make their own base repos like if you spin up a lot of projects then you might have some opinions about how to set that up about how to do tests and all this and the other and so you can make your own repo which is based on hours and then you've got a project template that you can clone just as easily as as cloning our own uh but we are introducing a cli and i think that is largely motivated by the typescript thing if I honest because we got a situation now where once you clone the Svelte template you have to sort of run a command that sets up TypeScript And if you look at the script that does it, it's like brittle. It's very clever and it works, but it's also kind of messy. and if we're going to start adding stuff like that if we're going to have questions about how you want to set up your project then i sort of think that we need to be in control of how that project is initialized a little bit sooner and it's also just people know what npm init does people are familiar with that so the fact that you'll be able to do npm init svelte without installing a single thing that will give you a Svelte project and you can get started really quickly. I think that's neat, but you'll still have the ability to de-git from a repo that you maintain if you have specific requirements. I think it gives us the best of both worlds. It gives you a really nice onboarding, but we're still not going down this whole messy eject or don't eject route that some frameworks seem to like. So this config file, so that's where you would define your adapter, your preprocessors, all of this stuff? Yes. Yeah. So that's another thing that we resisted for a while, having a Svelte config file, because config files have a way of getting a little bit unwieldy. And so we sort of said, maybe let's pump the brakes on this and not have a config file just yet. But then what happened, of course, was people in the community thought, we want to have a Svelte config file for our tools. And so people created incompatible Svelte config files. So, you know, you have one in the Snowpack starter project. You have one in the Parcel plugin and they're fundamentally incompatible. incompatible. So we sort of had to come along and say, we're laying down the law. This is what a Svelte config file is going to look like. And now that we're having this like official way, like this is how you build Svelte apps. We have Svelte kit and this is the officially supported way to build Svelte apps. It's less of a problem to have a Svelte config file because the project structure is already just kind of more predictable and more understandable if that makes sense. Speaking a bit about adapters, can you tell us anything about which ones are going to be coming at launch Like which ones are you excited about having in Also what adapters do Cause I myself don really know Yeah That a good question You've got two choices. You can do SAP a build, which will create a node server that serves your app. And then you have to find a platform that can run a node server. And that's harder now than it used to be. Like for example, before the cell was a cell when it was still now, now V1, you can just run a node server. And that was great. really easy way to run a Sapper app. Now V2 comes along and you can't do that anymore because they've gone fully serverless. So that's like an indication of the sort of direction in which things are going. Sapper build was designed for the world that formerly existed. Sapper export, on the other hand, would build your server. It would then start your server and then it would crawl your server and bake out what it found. There was no in-between between Sapper build and Sapper export. Now we want to be able to say some pages are pre-renderable, some pages are not pre-rendered. And so that means doing things in a slightly different way. At the same time, we want to be able to generate cloud functions that run on Netlify or Vesel or Begin or any of these other platforms. Cloudflare. Cloudflare workers. Yeah, that's another big one. It's difficult for the framework itself to be able to satisfy the competing demands of these various platforms. So one of the big changes in SvelteKit relative to SAP is this concept of adapters. The way that it works is when you build your site, it happens in three phases. The first phase is we run it through Snowpack, which is what powers SvelteKit. And that will generate what we call the unoptimized build. And that's just like a one-to-one transformation of the files in your project. It'll do it twice, once for the server-side rendered version of your app, once for the client-side rendered version of your app. We then move on to phase two, where we optimize that output. We run both of those applications through Rollup. That allows us to do things like bundling things into coarse-grained chunks, which is better for loading performance. We can extract CSS from your application and write that out as static.css files. And we can generate a manifest that allows the cloud functions to know which code they need to load in order to render the page that's being requested. and so after that we've got something that is pretty agnostic and doesn't actually do anything yet so we apply the adapter to it as a final step which takes the optimized build and massages it into the form required for the various different platforms be that a node server or a purely statically exported site as with sapper or one of the cloud function providers that we're going to support you asked what we're going to support at launch we don't have like a list yet but you know definitely the cell definitely begin definitely netlify definitely cloudflow workers i think and i'd be happy to have pigeon to help support for aws definitely aws yeah it's worth noting yeah that a lot of people have come forward and say that they'd like to build an adapter for their platform of choice and i think that's that's a great thing that's a really fantastic thing the list that we have right now it started off with rich building a netlify one i built the for sell and begin ones based on what richard did with net the fly because well for sell easy because i'm already hosted on it and i want it to work on there and i want to see how much work it would be because i helped build the original for sell builder as well and the begin because i mean there's my pick right i have it as my pick begin.com is my pick right i really like what they're doing with architect i really like the fact they have data built in i really like that kind of stuff And so I just want to see how quick can I get this new thing running on this platform and how different is it to Netlify, for example. And actually, it's not that different at all. And that's quite a nice thing about adapters. They're all turning out to be roughly along the same lines, which is really interesting. Those lines are AWS. Everyone is using AWS underneath, it looks like. So it's pretty straightforward, really. yeah so in addition to these official adapters that we're talking about there's going to be a well-documented api for people to build their own adapters so any platforms that we don't support people will be able to support them themselves and actually there is a conversation happening about how much stuff we want to do ourselves and how much we want to farm out to other people and let let them maintain it but the api is very much not locked down yet so yeah hence why we haven't just invited everyone to build them. There's an open question of whether every meta framework, like Remix is doing something, you know, Next.js is doing something, whether every meta framework should have adapters or should every meta framework target a single format? And I may have brought this up with you, Rich, I don't remember, but Glenn Maddern proposed Fab, the front-end something application bundle, which are basically containers for front-ends. And it's a fancy way of just saying, let's just standardize what we export to so that all

 All the providers know what to ship, agnostic of framework, and all the frameworks know what to build to. Doesn't that make sense? It makes total sense. And I've chatted with Glenn about this. I should have added that to the list, actually. We definitely want to have a Fab adapter for SvelteKit. I'm actually surprised that more people aren't using Fab. It's such an obviously smart idea. Because he targeted Cloudflare. He's like, only Cloudflare. And then there was a story for like two years. that's another easy way for us to support multiple platforms is go by yeah i think on the flip side of that coin though of course and i think perhaps a fantastic idea i think the flip side of that unfortunately is that you can make something that adapts to everything but abstraction has a cost and i think that at some point you encounter a bit where well this won't work now because this radically new different thing that's super optimized won't fit into this pattern so you can understand why there's there's always kind of a it's not a silver bullet nothing's off a bullet space yeah we don't want to outsource our adapters to fab but because we do want to be able to optimize specifically for different platforms but it's a great net to catch the things that we can't support ourselves i want to move on to developer experience so this kind of seems like a with one of the important things with svelte kit things like snowpack and the adapters, I guess, are also part of that. What are some pain points that you'd like to explore in the future when it comes to bringing the developer experience even further along? Not particularly anything to do with SvelteKit, more like just general thoughts. Wow, that is a big question. I think SvelteKit represents a big upgrade in developer experience from Sapper just because the Snowpack developer experience is so good. For people who haven't tried it yet, it's worth just trying out one of their sample projects so that you can get a sense of how the thing works. It doesn't have any of the delays that are involved in traditional bundlers at development time. And it also has some really nice features, like it has error overlays. As soon as there's an error in one of your files, you'll instantly get feedback in the browser. You don't need to have your terminal visible at the same time as you're developing. It just gives you way better feedback. The hot module reloading is really robust in my experience. It's just great. But I think it does open doors to potentially some future improvements that we haven really begun to explore yet One of those is the idea of having something like a storybook type experience built into the framework I not personally a user of storybook Have you tried Svench? I haven't tried Svench yet, no, but it's on my list of things I want to play with. Aesthetically, I just can't get on board with the way that stories are written in storybook. And also like it takes a little time for a storybook to get started. But now that we have this unbundled workflow, you no longer need to point your bundler at all of the components that you want to have in your storybook because everything is just dealt with at runtime. So I think we could have a built-in storybook type experience that would be really slick and really fast. But then, you know, once you start thinking along those lines, you start asking yourself, why not just bring this stuff directly into your editor? And so I'm also kind of idly wondering about what an integration between, say, VS Code and SvelteKit could look like. Can we start to move more in the direction of WYSIWYG component editing? That would be pretty cool. I have wondered, because I also faced that frustration with Storybook. We used it at Netlify and a bunch of other open source projects that I contribute to. And yeah, it is way too slow and there needs to be a change. But the workflow of having independent components apart from your app so you can develop in peace, but also document and kind of have a live design system, it does make a lot of sense. And we all have a source slash components folder anyway. Like let's actually make use of that in some way. I think you're going to build that as a layer on top, but some people use Vim and all that. So it's nice to have a standalone browser version and the browser version, you can just kind of bring into VS Code pretty nicely as a VS Code extension. And then the other thing to take note of is that people often build their storybooks as an externally available site so that people can reference their design systems just for designers and whatever. Yeah. And actually, this is a point worth touching on. At the moment, we have this fairly neglected component template. If you want to build a Svelte component for distribution or a component library for distribution, you don't get as much hand-holding as if you want to build an app with Svelte. And we can change that with SvelteKit. I think that using SvelteKit for building component libraries or even just single components is going to be a first experience because we can have this storybook thing in the future But even without that, you can build your demo site using the components in your source slash components folder, and you can put that somewhere. But you could also have – we haven't built this yet, and we haven't really talked about it even among the core team – But you could have a CLI command that packages that up as a component library for distribution as well. And I think that could be very powerful. That could cause a renaissance in component libraries in Svelte Land. You can do things like pre-process all of the components in your components folders to strip out the SAS and the TypeScript and whatever so that it's easily importable everywhere. But while keeping the component source otherwise intact and you know we can generate export maps and like all of these other things that are a pain to set up yourself we can just do it for you speaking of things that are a pain to set up testing so sapper had a cypress included right at some point i'm not sure if it still does yeah it's been removed actually so what's the idea with testing when it comes to spell kit have you guys thought about anything around that we have an issue open for it i i don't know every time we start talking about testing we're like yeah we recognize the importance of testing but honestly what kind of tests make sense to have in a front-end project it's far from clear like what stuff you are supposed to be testing we don't want to have some sort of official recommendations that end up with people writing meaningless tests and a lot of front-end tests are kind of meaningless they're just duplicating the functionality of the framework's own test suite which is not a good use of anyone's time so yeah i don't know anthony i think you have to pick the problems you want to solve and i think for us to determine what a good testing strategy is is not a problem that we really want to solve or we're even set to solve so i think a lot of the maintainers especially have different views on what testing is i'm not even sure now that my view on testing has changed in the last three years it's gone from ice cream cones to mountains and you name it it all over the place it very difficult to say what a good testing strategy is It very app dependent It very much about where you are going I like to build very dumb, thin front ends and very smart back ends. And therefore, I can actually replace the front end or have a native app or anything else like that anytime and not lose the crux of the application. and i think that it does almost make a lot of acceptance testing extremely costly because you're writing tests or something that's effectively throw away it's almost a waste of time to throw the front end away or make some drastic changes to the workflow i think it's one of those things that it's easy to pull out and say look to somebody his name slipped my mind the guy who writes testing framework or testing library can see that yeah so it's better to defer to someone like him and say look go and have a look at what the recommendations are from people who sort of make this their core goal rather than just try and educate as part of building something that's just not really related to this at all that said like in a situation like yours maybe it makes sense to make it easier for you to do testing of your endpoints you know separately from testing your components because if that's where all the heavy lifting is being done but let's not also forget like my applications when i say the front end i'm talking about everything that's happened serves. So my testing in logic is in my happy application. It's in my API. I don't really have that many server routes. It's a tough one. My API is covered in tests. My front end is definitely lackluster in terms of testing. It's got a few unit tests and not much else. Yeah. And there is a cost to having a default because most testing setups, they'll need something like puppeteer or playwright. And these are big dependencies. So if you're starting up a new project, then you've got to spend several minutes installing all that junk before you can start developing it's like if you're going to use that then fine but if maybe you're not going to use that then do we want to impose those opinions on people i don't know and you've got browse support and it could be flaky you know we find the svelte tests are actually quite flaky on various different browsers on macs and things like that and on windows machines you've got to worry about that you've got to go about infrastructure for running the tests all this kind of stuff is stuff that we really can't define for somebody, I suppose. I guess the Svelte team doesn't have to decide for people, but something that we can do is send people to relevant pieces of information wherever we can find it. Mainly because I've seen people reject Svelte out of hand because they're like, oh, look at them. And they'd be like pointed that specific line.

 any FAQ that kind of just does this like, well, testing. Yeah. It's honest. It's just like people like to be given the full package and sometimes it just takes a little bit of better communication sometimes. So we can work on that. I love testing and it should be absolutely forefront everyone's mind all the time. And I absolutely endorse it, but yeah, it's just not something that can be answered quickly or even well, really, in this context. So I agree, FAQs and documentation would be a good place to start. So in Sapper and SvelteKit, we have the router. Is that changing anything? No, it basically behaves exactly as the Sapper router does. We're not changing anything there, which is one of the reasons that it's going to be fairly straightforward to migrate your application. People do keep asking us, is this going to be a standalone package that we can use outside SvelteKit? the initial answer is no the medium term answer is maybe there is some complexity around it like you need to have a good way to so it needs to work server side and client side right and at the moment because felt server side rendering is synchronous it makes it a little difficult to work with you know a manifest that includes dynamic imports and stuff like that so there's just a lot of complexity and nuance that we need to work through before we can offer something that can be decoupled from the rest of the SvelteKit CLI? I think when I build projects a lot, I tend to build a monolith first. And the boundaries between the different components are always sort of logical boundaries in my head and in the code. And they're not necessarily physical boundaries or different projects or modules. And I think probably the same goes for what we're doing here is that there's definitely a notion in our heads that we want to have the router as a separate component. It isn't right now. it is as rich said very difficult to do but every bit of work we do towards the routing we are consciously thinking is this isolatable can this be you know separated at some point one other big topic is the internationalization support and it comes up a lot right what are we looking at on that front that is not a problem that we're going to solve for 1.0 that's still going to be a problem that developers have to solve themselves unfortunately it's a big and complex and you know fascinating topic and when we first started talking about it in the context of SAPR we generated a huge discussion about the best way to do stuff I maintain my belief that a project structure like Svelte Kits gives you the opportunity to do some stuff with internationalization that is ordinarily quite difficult But we are just not focusing on that for the 1.0 release because if we do, it'll be a 2022 thing at the earliest. It also has to be something that someone wants to work on, right? there has to be interest there right i think that there is interest it's just it's a too many cooks spoil the broth type situation we've got to have a very clear direction that we agree that we want to go in we can't just sort of open it to the floor and say who wants to who wants to help work on this because we'll end up with absolute chaos and there's a lot of overlapping problems involved like the routing side of it also how do you express localized text inside your components How do you generate that localized text in the first place? Like what format do you use? Do you support multiple different formats of localization? There's just so many questions that we need to have good answers to. And we need to decide how opinionated we're going to be in our answers to those questions. I have an ending question if no one else has any other topics that you want to raise. What's on everyone's wishlist for Svelte in 2021? Oh, wow. I mean, that it exists. I think that will be achieved. So setting your bar high there. You know, management expectations, I guess. I definitely think it will continue to exist. We've talked about how we would love for the Svelte community to be more diverse. We are very typical of an early adopter focused open source project in which, you know, our user base is unfortunately slightly homogenous. And if we can find a way to reach people who aren't currently using Svelte that don't look like us, then that would be a wonderful thing. And I think it would be to the benefit of the project health overall. Yeah, I was going to raise that. Damn it. I got to think something else. I think it's kind of tangential. I'd like to see more accessibility features in Svelte. Things like maybe high contrast warnings. So this is the kind of thing I hadn thought of this at all until you said it just now but this is exactly the kind of thing that having a central officially supported project structure like SvelteKit kind of allows you maybe to do a little bit more reliably because you can say in a very predictable way like this is how you build the application so that you can serve it and inspect it using Playwright or whatever you can't do that if the project structure is completely arbitrary but if we can say that the majority of our users are going to be using SvelteKit then that is exactly the sort of thing that we can start thinking about adding to the developer experience I'll plug Kev's favorite topic here is Svelte Actions I started actually prototyping a little you know project just just to see just to achieve consensus on what people think would be nicest official Svelte Actions things we all use a lot, like on click outside, we all have some version of that anytime we write a modal. And then I already forget what else. Long press would be interesting for mobile web. Yeah, stuff like that is stuff I'm accumulating. And so there is an RFC. I took a stab at prototyping it and maybe we'll see it merge next year. I actually thought about an action for focusing on an input. That'd be pretty sweet. Focus on loading the page pretty much. Anyway. Right. Isn't that the antithesis of accessibility? I think it's like that's the opposite of, because I know that the problem, if you focus on an attribute, then it's unexpected for users who aren't using keyboard or something like that. I can't remember the exact rules. I think you want to avoid autofocus when a page first loads, because people who use keyboards to navigate will expect the focus to be in a different place. I think it is okay to use autofocus in content that is created dynamically. Like if you create a new dialogue, then it's useful to focus the input in that dialogue immediately but the accessibility rule sort of does a this blanket you can't do that when you add autofocus to an input which is i don't know i often find myself adding the ignore declaration is there an html why would they put in html if we're not supposed to use it left hand right hand this is what would be nice with more accessibility warnings it would help me stop myself from doing stupid stuff like this. I mean, I would also say like inside of this felt code base, I think there's a lot of to do is left on the accessibility stuff. Right? Yeah. I mean, the biggest one is like when you do have, well, the biggest one for me is when you do encounter an accessibility warning, like if you add autofocus you will get a warning but it not at all clear how to disable it Like you sort of have to know about the like what the warning codes are which we don expose anywhere and it not very well done we need to fix that all right all right to do this let's go on to pics if you have any i can start i got myself a robot vacuum machine a couple of days ago oh we can see it over your shoulder yes yes exactly best purchase i've done in years love it do you go barefoot in your home or are you yeah yeah i do no wonder or well i have socks on but i think it's a american thing to like always wear shoes in the house or at least like non-asian thing i don't know yeah but it's not a thing either yeah like the rumba just cleans up things that you would already have on your floor anyway i don't know what i'm saying doesn't that rob you of the joy of vacuuming though the joy of vacuuming What? Sorry? What joy? Vacuuming is by far my favorite chore. Wow. Because you get such a sense of accomplishment. I have one of the battery-powered Dysons, which takes a lot of the hassle out. You don't need to bend over and unplug it and then put it into the new socket in the room that you're doing now. You just walk around with this battery-powered Dyson and you collect all of the dust off the floor and then you look at it inside this transparent cylindrical container it and you feel a real sense of accomplishment okay i think if i had a room i wouldn't get that that pleasure once a week my wife shows me that right so we've got we've got the dyson two we've got two of them one for upstairs one for downstairs and what she does every time she uses it she comes and shows me all the dirt that's in it like some sort of like a ward i don't understand it but now i kind of get it it's not just her it's people do this and are entertained by the amount of dirt in the back i do however i will say that i hate vacuuming i really i don't enjoy any chore really but especially vacuuming i do a room bar as well and one of the good things well i have a room bar and the fun thing is taking apart after it's done a few cleans and pulling all the hairs out of it and cutting all the bits off it that's satisfying that's absolutely great fun i can sit there for like an hour taking it piece by piece apart and pulling all the bits of stuff and hair it's great fun great fun so you have that joy to look forward to kev oh no i got a new phone recently and i'm quite enjoying it my old phone i had the pixel 2xl and it served me pretty well but the screen was like smashed up and it was just dying and everything so i asked people on twitter what phone i should get between

 some Samsung Galaxy, whatever the newest one is, or the Pixel 5 or the OnePlus 8T. And the Pixel 5 was the overwhelming favorite. So I bought the OnePlus 8T and I've been very happy with it. You made the right choice. Yeah, I did make the right choice. Yeah, Anthony was one of the people who steered me towards. I think maybe you actually sent me a YouTube review of the OnePlus 8T in comparison with the Pixel. And it's just a much better phone. well somebody did and it convinced me it's really high powered and it costs the same as the pixel 5 and it has this sort of nice turquoise shiny case on the back just very well put together device so if anyone needs a new phone then check out the oneplus range that's cool i'm not being paid to say that actually so i moved i have used i used ios i use apple iphones for 13 years since launch and I switched to Android in February and I went through the same rabbit hole and I landed on OnePlus as well. It was the 6T because I'm cheap. I think my conclusion between Pixel and OnePlus is that like Pixel just randomly like prioritizes camera over everything else no matter what it has to have the best pictures but i don take many that that many pictures so that's what made me choose the one plus which is you know let's let's have better specs for everything else and a decent good enough camera like that i think that's the way yeah i actually bought a decent camera recently like one of the new the mirrorless ones that it's like the ds the old dslr's but a little bit smaller and so now when i go somewhere i want to take photos I will take that with me. The image that it produces is just so much better than what you get out of a phone camera that I'm not taking as many pictures of my phone anymore. So it was the same thing for me. It's just not a priority. Like I think that phone cameras have sort of slightly cheapened the art of photography and I refuse to participate in this nonsense. I will say that I went the other way. I had an iPhone 1 originally. I then switched to OnePlus and I bought OnePlus 1 and it was stupidly cheap. because it was when they first launched, they were just basically free almost. And it lasted me six years and I couldn't actually make it break in order to get a new phone. And it was amazing It just slowed down a bit and they stop making the OS for it And I switched to iPhone and the only thing that good about this is the health thing with the watch It really good but I miss the Android And the only reason I'd go back is to go back to a OnePlus. The browser on this is terrible. Safari is just a joke. It's useless. So I'm very much of the opinion now that I might look at Android again. It's a trade-off. My summary is iOS is the better operating system, but then Android has the better browser. So pick your poison. Yeah, yeah. This is probably true. They're both pretty locked down, right? I guess you can sideload on Android. Android, you can kind of choose what you install. And I think OnePlus are very good for actually having custom iOS and stuff. Their phones will take quite a lot of stuff without a lot of modification. They're very generic kind of hardware. Well, at least they were when I had one. I've been using a new calendar app, SavvyCal, S-A-V-V-Y-C-A-L. It's by a friend, Derek Reimer. He's sort of trying to make his way in terms of indie hacking his own business. I kind of bought it as a way to support him, but then it actually turned out really good. So it's exactly like Calendly, except that it's indie and it looks different. I always get compliments on it whenever I drop a link to people And I think that a lot of people don do that So they do they always do the back and forth emailing like i free at these three times can you make any one of these and it just better if you just give them a choice i been enjoying it and he got some like nice pretty nice team features coming up which is which is exciting for my team this is this looks good actually this looks perfect for what i need nice nice pick i think my pick has to be begin.com i mean i said it before right i'm really enjoying it i really like open js architect and i really like the fact they got built-in data i've started building a small project on it just to see you know how that actually works and it's it's pretty great it's pretty great experience so yeah that's my pick i mean uh brian's a friend we should try to have him on to chat absolutely yeah i like products like that where like you know the people who build it at least a little bit yeah so you can yell at them it gives you a level of confidence that someone to yell at but also but also you kind of have a sense of their product philosophy and whether it's something that you align with yeah it's more relatable right yeah thanks for coming on rich always fun to hear your thoughts thank you everyone for listening and we'll talk to you in a couple of weeks again bye bye bye