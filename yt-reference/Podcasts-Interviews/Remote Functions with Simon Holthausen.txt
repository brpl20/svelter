 Hello, everyone. Welcome to another episode of Svelte Radio. I'm here today with Simon from the cell team. Hello. Hey, welcome for having me. Thank you for having me. Not welcome. Great intro. Stumbling upon my words right away. When it's digital, am I visiting you or are you visiting me? You know? I'd say I visit you. Okay. I was trying to save you here with a welcome. Yeah. It's beyond repair. Yeah. All right. All right. So before we start, Anthony and Brittany were supposed to be here, but we ran into a couple of scheduling issues. And I decided I'm just going to do this on my own because it's easier. And we want to get this out there because it's really interesting and fun. The stuff that we're going to talk about today. Remote functions, async, svelte. I guess that's what you would call it. Yes. Kind of two parts. Yeah. So maybe start off with what are remote functions in SvelteKit? So remote functions are a new way to interacting with data in your SvelteKit applications. Today, you have load functions and form actions to do that. So load functions you have in your plus page TS or plus page.server TS file, export a load function and you do things in there. You can also have layout load functions, and that's how you can get your data. And if you want to interact with that data, not just read it, but also manipulate it, the first class way to do that is forum actions, which live in pluspage.server.ts files. and basically it's a nice way of writing regular forum posts just like yeah basic web forum posts and this has served us very well so far but over the years a few things have become apparent that it just doesn scale as much as we like like both scale up but also scale down. I know one thing I've always gotten a bit irritated about is that when you have one page you have a bunch of different kinds of data that you want to bring into the page on first load, but then you might want to refresh just part of the data. At the moment, with load functions, you have to rerun the whole thing, right? And then you would fetch everything from... Correct. That's one of the drawbacks that you can only get as granular with loading or reloading as a load function. So I don't know if you want to only reload a certain thing, then maybe you, I don't know, need to introduce a layout that is UI-wise empty just to split it apart. And that's like really clunky. So, yeah, you're forced to... You can use groups, right? You could use groups. Nested groups. Yes. Yeah, so there are ways around it with enough painkillers besides you. but yeah it's not good it also another problem with loading data like that is that the co-location is not great so you're loading your data in all these load functions and then maybe you're using part of that data only very deep inside your page like I don't know five components deep and then you have either the choice to do prop drilling or go with the page store, which basically is a collection of all the data on that page, but that is no longer really type safe. So yeah, that's another problem here. And also keeping those things in sync isn't as nice because maybe you want to refactor something or delete that data, but then you have to always think about the other end where you also need to change or delete your code. And speaking of TypeScript, the same is true for forum actions. So they work really nicely the way you author them but it not exactly type safe because the way you do it is you write basically the action path for the form You write yourself and then you have to be sure that it's in sync with whatever you have in your plus page.server.ts file. And we have also heard people saying like, hey, I have this in my plus page.server.ts file, but maybe I want to use this on several pages. And so how can I do this? And so there are multiple, basically, problems to that too. And so also, what if you don't want to use form actions? So, I mean, we, of course, advocate for progressive enhancement, which means everything ideally should also work without JavaScript. But maybe you're doing some internal business app or the thing you're interacting with requires JavaScript. And then why would you want to use forms in that case? And SvelteKit basically offers you nothing in that regard. So you're completely on your own just using regular fetch. I've had to use I mean I would use so I always use super forms to do forms in Svelkit before and that kind of works in the SPA way as well but it's still like it's a bit weird you're kind of what's it called faking forms in a way because you're using super forms and it kind of looks like you're using form actions but you're not really because it's all SPA networks but it would be better if it was easier, better DX. Right. And so we were thinking, okay, how can we basically keep the niceness about data loading and make it more granular, more type safe, give a better first class integration with when you don't want to use forms, and so on. And this is how remote functions came to be. And it all started back in May when we had our offsite, basically. So prior to the Svelte Summit many of the maintainers came together and we did a brainstorming And previously we already had written up some discussions but yeah the bulk of the design happened in those two to three days prior to the conference like it's it's amazing what you can do when when you get people in a room yeah and and talk to each other live so i mean i'm a proponent of remote uh first i was gonna say the exact same thing yeah right like remote first is nice but it's hard things like this it's hard to beat in person right especially when you consider that many of us are not working on this full time and to have these voices in the same room still and not having to wait on them like i don't know four days until they give a response. That is so valuable. And so, yeah, we got out with remote functions. And that is basically, I would say, our take on RPC. So it looks like you write regular functions and call regular functions. And on the server, that is what you are doing. But on the client, you are actually doing a fetch call to the server. and the server knows how to basically deal with this special call, call the actual function, and then come back to the client where it can unpack the serialized response. And more specifically, you write your remote functions in .remote.ts or .remote.js files. So for example, I don't know, if you have a blog post and then maybe you do like a blog.remote.ts file. And in there you can then have a so-called query function, query remote function. So you import all these functions from dollar app slash server. And for get posts, you would do a query. And in there you would query your database and return the list of posts. when you are creating a new blog posts, you would use the form function, which, yeah, you give a schema, standard schema like Zot or ValleyBot, and then that parses the form, gives you back an object from that, and then you

 You can interact with that and, I don't know, do a few checks like, are you authenticated? Are you authorized to do a blog post to create a new entry and so on? And then call the database. And you can even right then and there do something like a single flight mutation where you're saying, okay, I want to refresh get posts. so as part of the response you're also already getting the new data and you could maybe also have a toggle like in there so as a reader you could press the like button and maybe that is for some reason not a form under the hood but it's a so-called command so that's the third one you have and the command works very similar to the form you also have a schema if you have arguments in In case of toggle-like, you probably don't have arguments and so on. And so basically you have all these different functions, which all are called remote functions, and you have them inside this .remote.ts file. And then in your plus page, Svelte, or any other Svelte file or regular file, you just can interact with them like regular functions, which return promises. So things that come out of this is like we get full type safety, right? Yes. Without any magical kind of things. Because before you had to do some magic under the hood, right, for the load functions? Or am I misremembering? Yes. So, right. So one of the, that's another thing that gets better here. So for load functions, to make them type safe, we had to do a bit of TypeScript voodoo. Like if you do let records data equals dollar props, like there's zero types, type safety. So you don't write the types yourself. It's done in the background for you by the language service. You could also write it explicitly by importing page props from a relative file called dollar types which doesn exist And at this position it actually exists somewhere in the generated files which is another TypeScript trick which you can employ to make that work And that, it works, and it's nice, it's clever, but wouldn't it be better if we didn't have to do this? Because it's something we have to maintain, it may break down in some places, and so on. And if we can just rely on regular TypeScript, so to speak, that would be even better. And yeah, with remote functions, from a TypeScript perspective, it's just that, it's just TypeScript functions. And so that's why TypeScript will have a much easier time with this and why type safety will be increased with this with less effort. because it's not just that your load functions will have type safety. Also, your forms now will have type safety and your commands will also have type safety. It's not actually functions though and that's because like on the client, you're actually doing a fetch call to the backend and that's why we encourage people to use a schema whenever they require arguments for the commands or queries or forms. Because in theory, everyone could call this endpoint with rubbish and could try to break it. They're not hidden or anything. Right. It's auto generated and it has funky names, so it's not exactly predictable or anything. But it's still public after all. And so you have to be careful there. And that's why we encourage you to do a scheme. So speaking of schemas then, it's a bit interesting that we ended up, because I have some vague memory of the Svelte core maintainers not wanting to deal with validation in any sense because it's like an extra thing to have to do. But I think since then there's this, what's it called standard schema that's come out from all of these validation libraries. So these remote functions they have support for passing in well support for you have to pass in something if you taking a parameter right You have to pass in the schema You could also do a quote as a string unchecked. That way you can bypass it. Like if you know what you're doing or you're using some very custom built validation library that is not standard schema compliant, then you can you can bypass it, but the name unchecked should already clue you in that this goes unchecked. Like the types say this is a string, but it's not necessarily a string. And so that's where the encouragement to use it comes in, but we don't force you to do it. So what does it look like? Let's say I have a blog and I want to fetch one blog post. So I do const getPost equals query. And then what do I do to get the post? Yeah, if you're using ValleyBot, for example, then you would do v.string as the first argument, which is the first argument is the schema or the string unchecked. And you do v.string. and then the second argument is the function that is then called. And in that case, it's, I don't know, probably the ID. And ID would already be type checked in that sense. So you don't have to do like colon string yourself anymore. That's inferred from the schema. So in a sense, most of the time you're actually not typing anything more compared to not using a schema. which is kind of nice. Yeah, and then in there you would, I don't know, query your database, fetch the blog post from wherever and return it in a way that SvelteKit can then serialize it, you serialize it, and so on. So as long as you use something that is devalue compliant, then it works. So like everything about JSON is okay, dates are okay, map is okay. And you can even so SvelteKit has this transport hook where you can basically define custom classes and how they should be serialized deserialized You could even use that in there I was going to ask about the types of data that you can send back and forth I assume you can't do functions. Correct. You could do functions. You can do functions? No, you couldn't. Okay. I mean, maybe you could have a special class that represents a function or in some way, and then you have knowledge, domain knowledge about how this should be deserialized and serialized. But not like a generic function. Yeah, but no generic functions. So I've tried the query functions a bit, and I find that having to use a schema for my queries also kind of encourages using schemas in the rest of the application as well. which is kind of nice. So that's another side effect, I guess, of remote functions, if you will, for me at least. Yeah, I think so too, that in general will encourage better practices and ultimately make your app more resilient. Yeah. Okay, so remote functions do rely on this other feature that was built for Svelte called, I don't know if you call it async Svelte or async. Yeah, async. Top level await. Async Svelte, okay, yeah. But maybe we can talk a bit about that. It was introduced, was it introduced at Svelte Summit or a bit before and then Rich did a talk about? I don't remember. Yeah, it was introduced at Svelte Summit. That's correct. And remote functions also got like an outlook there. and yeah so async svelte for those who who don't know yet basically for the longest time people have asked hey i i want to use the await keyword in my components preferably at the top level but maybe also somewhere else and so far that didn't work the only way you could do that is either by using the await block the like curly braces hash await and that's a bit like clumsy because it only works for one um promise at the time so you have multiple then you got to repeat

 this again and again and again. And each of them are basically in their own life cycle of showing a loading screen and then showing the data. And if you have, I don't know, 10 of these on your page and it's like 10 loading spinners and it's like it makes for a horrible experience. So you want to coordinate that somehow, ideally. The other way you could work around it is by flattening the async into something synchronous by having like a resource-like object where you have loading and current and error properties on an object and then you could use that. But that also like it could be clumsy sometimes and could make it so that the coordination problem is still there. Like ideally you want to somehow have maybe define, okay, this is my boundary basically And that's where I want the one loading screen to appear. And then once that's done, I want to show that loading screen until all async functions are resolved. And then go from showing that to showing the end result and not have 10 spinners. I only have one spinner, so to speak. And that's what AsyncSvelte basically gives you. It gives you the ability to use await inside the template and at the top level. You can also use it inside derived, so basically like asynchronous derivations that also works. and you can wrap these in a boundary and give that boundary a pending snippet which then shows up on first render for as long as anything inside the boundary is still loading. And that doesn't have to be in the same component. It could be 10 components deep. So it's a runtime concept. like the runtime knows where the nearest boundary is and what async work is still out um pending and yeah and that that way you you can coordinate it so you mentioned uh you resources I heard this word kind of in some places Is that something special? No, I think it's just like a term that is more or less common in the async. When talking about async, you're talking about resources, or at least we in the team are calling it resources. And in fact, with remote functions, especially with queries and so on, they give you nice ergonomics. And people have rightfully asked us, hey, this requires a server because the remote function lives on the server, so you have to have a server runtime. What about the SPA case? What if I want to use something like a query there too? And we are actually in the process of designing and implementing a resource-like API right now, which will bring the query-like capabilities to Svelte itself. And the client implementation of remote function queries will then likely use that under the hood. So you would kind of migrate the current remote functions to use that when the resource API is done. Right. It's all connected. Yeah. Yeah. That's kind of nice to hear that the SPA use case is getting some love because it's been a bit neglected, I feel like, in SvelteKit, at least. Yeah. Like you've always used Svelte, right? That is true. Like I... It felt a bit neglected and I appreciate that feedback and I get where it comes from. And I think with Async Svelte itself already, the SPA case already is easier, much easier to do because if you wanted to have proper data loading, a proper data loading story, you basically had to use SvelteKit. But now with async where you can just slap in a weight in front of a fetch for example coordinating asynchronous work in SPA only applications even applications that don't use SvelteKit, they just use Svelte. That's now much easier and much more doable compared to before. Yeah. We haven't had enough documentation on this topic though yet, so that's another part I think where the feeling comes from that many of our documentation is SSR and progressive enhancement centric and I think we can do better here with having more for SPA use cases without like abandoning the progressive enhancement yeah because that's an important part like the progressive enhancement and the kind of building for people that aren't necessarily using JavaScript in their browser. Right, or don't get it fast enough. Yeah, yeah, yeah. For any reason that they don't have JavaScript working on the website or on the page at the moment. Okay, cool. So that was ASIC Svelte. There's talk from Svelte Summit that we can link. We talked a bit about queries. anything else about queries that we should talk about? I know there's a query.batch where you can kind of fetch many things and then... Yeah, so now that we have this remote functions primitive, it's very fun to think about all the additional things we can bring to it on top. So query.batch is one example. just to quickly explain what query batch does. It's solving the so-called N plus one problem. So imagine you have a list of cities and for each city, you want to get the weather data for that city. And I mean, you could have like an endpoint which says, okay, let's get me the weather for all these cities. and you could write it yourself. But I don't know, maybe the list changes and then you basically you re the data for all the ones you already have and not just the I don know five that are new or something So instead ideally what you want is to call on the client, just get weather as a query for each of the cities. But that means that you would, in the worst case, do, I don't know, let's say it's a list of 20 and then you do 20 query requests and therefore do query 10, 20 backend requests and maybe each with, I don't know. In the case of whether it's probably easy, but I don't know, maybe this is behind some authentication. And then for each thing, you're doing the authentication dance, doing some database request. The database request maybe itself is already pretty complex and therefore texting on the database and so on. And you're doing that 20 times. And instead, what you could do is basically do what the alternative is to do it, to do manually to bulk request 20 at one. But from the client, it looks like you're doing like 20 requests and query batch then batches them into one request. so on the client you're calling this with one city each and on the back end you receive an array of cities so you only do one request only do one response and on the client it can then spread it out again to the to the right requests and that's what query batch does so in my example of the getting a blog post this would be get the list of blog posts for the front page. Basically, you would use Query to Batch there, I assume. If you want to have the details of all the blog posts, then yes, you could do that. I guess for the front page, I would probably still do one get posts, which has a different structure. It's only containing a short summary and a title or something. um but yeah like it's it's not it's not common but when you run into this it's kind of it's kind of annoying and now with remote functions with this nice primitive we have the ability to also

 provide more quality of life functions that way. And if you don't use it, it's basically, it's tree shakable. So if you don't use that, then you're also not paying for this. That's the best scenario. Getting a lot of functionality. Yeah, and that's going to be other, so, right. There's going to be others, like we have to think about what we want to do with caching. This is an ongoing design question. And ideally, it's more than just set headers because setting headers and getting that right, that's like really, it's almost rocket science. Like setting the correct cache headers in the correct ways, that's not easy. And like many cloud providers have now more elaborate ways of doing caching and ideally we can on a provider basis integrate with that. But having an API that basically makes this write ISR for example. So that's one thing we're talking about. We're talking about query.stream which basically allows you to stream data, live data from the backend to the frontend. There's people who want this both ways in both directions. So something around WebSockets, we have to think about that, see how that goes. So yeah, there's lots of possibilities and it's all going to revolve around the same primitives and the same ideas and APIs. And so I feel like it's going to become a really nice set of APIs, which will give you like a good way for many of your use cases without like restricting you or something and also without forcing you to use it all at once. Like you can explore over time and grow with it. Yes, I've tried it out for a bit, like in preparation of this interview and I experimented with like moving. I only had time to try out the query one but just like converting a load function into a query remote function super easy I really enjoyed it Like it it very nice And you also get that like one thing I ran into, cause I stupidly didn't read the documentation that well was the, like, how do I get access to locals? And then I discovered, what do you call it? Like get request event for yes which is pretty nice and it's what i discovered as well i i didn't realize this at first but you can you don't have to like you can use get request event in a function that you're using inside of a remote function right um so i at first i thought i i would i would chain chain like i would call a remote function inside of another remote function but then I realized why would I do that when I can just call a regular function for some reason I didn't realize that I could do that yeah that's definitely another beauty of this it's all functions and it looks like functions but it actually is just functions without any gotchas so you could use other queries from within queries you could use regular functions from within queries. So yeah, you can compose and nest this as you like, which is really nice. And at the same time, because it's so like, because the boundary is the file, you don't run into any weird hiccups where, I don't know, you accidentally close over a variable and then somehow end up having a security leak. That's one of the reasons why we went with file boundaries compared to use server, for example. Ah, right, like in React, I guess. I have no idea how use server and stuff works in React. All right, so the experience is nice. I really enjoyed it. I haven't tried the form stuff yet, but I am sure I'll have a great time. But there also like I heard that you not quite done with how the form stuff works yet Like you evaluating maybe changing it a bit Is that right Or am I misremembering maybe Yeah, so there's a couple of ongoing tweaks right now. So we started out with form functions retrieving the regular form data and then you have to like pull out the data yourself from there. We since then have switched it to requiring a schema as the first argument and then doing conversion logic there so that you get a regular pojo from form data, which is already much nicer. And the way you interact with the form on the client when, for example, you have, I don't know, you return a list of issues via the schema and then you can show that in the client. You can show the current value on the client. And the way this works is still a bit rough and we're in the works of tweaking this to give a much nicer API. So it's probably going to be something like this that you have a field property on your form. And from there on, you just use regular dot notation to go wherever you want to go in your model. And it's type safe because through the schema, it knows which things are available at which level. So in other words, you don't have to have flat forms. like your object can be nested. You don't have to have it only one level deep. Yeah, and through the stop mutation, and then you can get a much easier time connecting that to your input so that things are in sync with the value and so on. And yeah, it's a bit hard to explain just over voice. Yeah, for sure. Yeah, just stay tuned. It's going to be out soon. and it will make forms even easier to work with. Yeah. So some questions there. With regards to forms like handling forms from end to end is like a huge undertaking right if yes if you like if you look at super forms it's super complicated because there are so many edge cases and so much functionality that people want um that is how how far do you think the you guys will go with with like implement because validation is the first step right because then you have to handle error messages. How do you display the error? Like, where do you get the error messages from? Where do you... How do you handle, like, if the form has been touched, et cetera, et cetera? Like, there's like a rabbit hole of stuff that you can end up implementing. Yeah, I mean, we started out without having a way to get issues because we didn't have schema yet. Now that we have a schema, through the schema you can tell when a field fails, you can basically return a message along with it that is then sent back to the client. You can also now have so-called pre-flight, which is basically validation on the client as you type. So yeah, we have added more stuff because the community said like, oh, yeah, this is nice, but do you know what would be even nicer if you also had this? Yeah, I mean, just opening the Superforms documentation is basic. Like that's how you end up with Superforms or like all the freshness. Because you kind of need that. The goal will explicitly not be to rebuild Superforms into SvelteKit. So there will still be room for Superform to exist. But the goal basically is to solve the 80% use case and leave the rest of the 20%, which are the ones where you get increasingly diminishing returns with even more edge cases and so on. And to leave those out in favor of a consistent, concise API that is easy to use, to understand. But at the same time, leave enough room for people to build something on top of it. So you could imagine a world in which maybe at some point superfluous.

 forms is built as an extension on top of remote form functions. That makes sense. I mean, the complexity would just like skyrocket if you would add all of the functionality and features that you would need from, if you wanted to build a one-to-one kind of thing, a proper full-featured form library, if that makes sense. That's correct. But that sounds like a good, like, building for 80% of the use cases sounds good. Anything else about forms that we should talk about? Nothing springs to mind right now. Just that, like, you can still redirect from there. You can still throw an arrow in there. So basically all the existing ways in which you used forms so far, they still continue to exist. Okay, cool. So let's say not having used the form remote function yet. What if I, after posting some data to, let's say it's a to-do list and I want to post a new to-do, and then I want to refresh the data that I have from my query that I use to fetch the to-dos, right? So let's say I have a query remote function that's called get to-dos, and then I have a create to-do form remote function. What would be like an easy way to refresh the data? Because in the old SvelteKit way, you would just form, you would submit the form and then the log function would rerun. So how does it work now? So by default, it will refresh everything on the page to mirror the just like before to mirror the non-progressive enhancement page case, in which case you would basically get a full page reload, which basically means you reload everything. So does it, how does it, sorry, no, I was going to say like, how does it, does it just know like exactly what remote or query remote functions that are on the page? That's correct. So, so there's a, basically there's a hidden client cache that knows about all queries that are on the page. That also means that if you are using I don know get user as a query in three different places you not actually doing three different fetches You sharing the same instance under the hood So it all shared cached client under the hood which is another nice thing because you don't have to worry about like, I don't know, hoisting your data loading up, for example. Oh, I need get user, the user data. I need that in my layout as well now. So today you wouldn't hoist your get user fetcher. up into the layout function. And with remote functions, you just do like a wait get user right then and there. And that's it. And you don't, yeah, as I said, you're not doing an extra request that way. It's just, it's deduplicated. It knows about that. So if I have a query function that's called get post, and then I want to show two posts, as long as I assume, Like if I supply two different query parameters, it would run it, the query twice? Yes, so the cache key is basically the ID of the remote function plus the stringified payload. Okay, cool. And that way we know about all the existing query functions on the page. And that means when a remote form function runs, it knows which things to refresh. And by default, it will refresh everything. But you can also opt into more granular refreshes by doing a so-called single flight mutation, which means you are not only returning data or doing the form post, you're also telling the client, hey, and these are the things that I wanted to have refreshed. And this is the new data from those queries. So basically, in your form function, if you do like, I don't know, create post, you would then at the end of your inside your form function, you would do something like get posts dot refresh. and then getPost is the query remote function that exists so you invoke the query function call dot refresh on it and that way the remote function knows okay the user is interested in getting the new data now of this thing So I going to request the get posts now and I'm going to wait on its result and once it's there, I'm going to put it into basically a hidden field on the return, on the response and then the client knows, ah, okay, there's this hidden field and these are the hash keys I need to update and it's going to do that. And that way you get both a more granular refresh because you're no longer refreshing anything, everything, but only this one. And at the same time, you get a single flight mutation, which means you're faster because you're doing the mutation plus the refresh at the same time, instead of having to do one round trip to the server to get the response, like, okay, the form has succeeded to post there, and then do another round trip to the server to say, okay, and now give me the refreshed data. You're doing it in one single flight invitation. Yeah. I mean, that's because then you reduce, like, what's it called? I forget what it's called, like when you have to go multiple times. Multiple round trips. Yeah, the round trips, right? Yeah. So this brings up another interesting question that I have. Like, are you batching all of the queries into one request or are they done one at a time? This is actually an open question still, if we do that or not. It really depends. And that's also, I guess this is a, please give us feedback which way you'd like us to go or rather give us feedback on how many requests you're having on your page like do you have a few requests at once or do you have like i don't know 30 requests going on in your network tab at the same time you're starting to get a bit worried we have it still open as a design question because what we going to do is either have a way to specifically batch things across queries or have a way to say explicitly I don want to have this be automatically batched because for some reason this query needs to be isolated because maybe I want to set headers on this or something. And for the same reason why we haven't done this automatic batching yet, for the same reason you cannot use set headers yet on queries, for the same reason, because we don't know, okay, do we disallow it only on like the dedicated batching query or do we disallow it by default? And then you're using something like query.isolated and then you can do set headers on there because you know this is only ever going to be this one. And yeah, so it's still an open question. There's a few considerations here. So obviously less requests is better. At the same time, if we batch requests, then we have to do post requests because like we, or rather we cannot cache things between. Right, right. So yeah, it's still an open question, but we will solve it one way or the other at some point. Okay, yeah, cool. So then there's also like two more. I think you briefly mentioned command, which is kind of like the, I don't want to use the web platform. I want to use just fetch. Right. I want to use, I require my people, my users to have JavaScript enabled. Right. And then you can use commands. And yeah, commands are basically where previously you were on your own had to do regular fetches, now you can use commands, which is integrated into the rest similar to forms. So by default, commands will request nothing. So it's like inverse compared to forms because commands don't exist in the non-progressive enhanced case and commands by its nature are probably much more granular. And so by default, they refresh nothing. And so basically you opt into what do you want to have refreshed by employing the same mechanism with the refresh.

 didn't mention yet. You can also initiate this kind of single flight mutation from the client. So you can, you can tell the command or the form, Hey, please also refresh the following. And then basically we're passing in the remote function key from the client to the backend. And it then knows which thing to call and how to return. And when you do it from the client, you can even do optimistic updates. So you can on the client say, okay, while this request is pending, I want to, I don't know, maybe you click the toggle button and then you're saying like, I'm sure this will work in 99.9% of the time. so I can just already do an optimistic update and, I don't know, show that it's in thumbs up state already. And that you can use, yeah. The specific APIs don't matter really, but you have the capability to do an optimistic update there which exists as long as the mutation is pending. Yeah, no, that makes sense. So it's basically, it's like form. basically command. It's form, but without using forms in a sense. It's probably simplified a lot, but then there's also the last one, the pre-render one, which this one is pretty cool. I feel like you can pre-render parts of your site. Well, parts of your page, I guess, which you couldn't really... Parts of your data, yes. Yeah, that's definitely something which is really, really cool that before you basically had to do all or nothing, you could pre-render your whole page. But what if your page is like 50-50 dynamic and the other 50% is static? What do you do then? You could do it today by having like pre-rendered plus server TS endpoints and using this in your load function. So there is a way today, but it's not obvious. It's clumsy. So yeah with pre you basically saying invoke this function at build time And then it just like a blob that lying around on your file system deployed somewhere. And then whenever a request is done, you just serve that file. Yeah, so an example, and I think that the same example is done in the documentation, is like if you have a blog site, you could pre-render the actual posts, but then you could have the comments being fetched dynamically, for example. Correct. That would be one example, I guess. Yeah. And the insight here generally is that the thing that makes your site slow is probably not going to be Svelte's server-side rendering. Right. It's going to be the data that's taking so long to load. And if you can pre-render as much as possible, as granular as possible beforehand, and then this will speed up your sites. Yeah. Very, very, very nice addition. All right. I think, have I missed any of the remote functions? Are there secret remote functions? There might be coming. Secret remote functions. Like if you do a cheat code, do we get another one? No hidden remote functions. No April Fool's remote functions planned either. But yeah, I mean, I talked about caching. So this is, we are not sure if this will be like another variant, like query.cache or something, where it's going to be part of the regular query. We'll see. So this may be another one. But yeah, no immediate plans there for more. so how would we use remote functions today we just enable it in the Svelte config right with experimental right so first you would for remote functions you would go in your Svelte config.js and then inside the kit namespace you would do experimental and then objects and then remote functions colon true and to actually make proper use of them, you would want to use that together with async svelte. So that means you also have to at the top level do another experimental colon and then object async colon true We put that in into notes as well It wouldn really make sense to use remote functions without the async function. Can you actually do that? I mean, you could. You could call them inside your load function. You could call them inside a hash, like a wait block. You could also... So the nice thing about queries is they don't just return a promise. They also return an object with current and loading and error on them. So if you want to, you can use the flattened version of this, the non-blocking version, so to speak. And you could use that. So yes, theoretically, it's possible to use remote functions without async spelled, but we will probably at some point basically require you to opt into that flag anyway because of how we will connect this with Svelte's resource API and so on. That makes sense. Yeah, and I mean, again, realistically, you're going to use this with await. Yeah. I mean, if you're going experimental, you might as well go experimental. Right, if you're going experimental, why not go all in? Exactly. All right. Now, I think that's, Unless you have something else that you want to highlight. I think that was a pretty good overview. Yeah. And, oh, we should definitely mention that you've made, I think you did mention it a bit, but like the remote functions videos that you've done for the South Society website are really good. So if you want to just have like a nice overview and you also do one where you talk about auth, like how to protect queries, because this might be something that we should talk about where in previously, like the load function, we kind of use the hooks to protect routes and protect stuff when it comes to auth. I mean, you could do it in the load function as well, I guess, But my experience was that you would just add an auth hook, and then you would do protection in there. But now, since the functions themselves are, you mentioned they were public, right? Anyone can call them so you have to protect them somehow Yes So you it I mean the handle hook still runs before remote functions Right That will not go away So you could still do it in the handle hook. But the difference is that remote functions are not tied to a page or a route. So that's the big difference to layout and page loaders because they are always tied to routes. And so you could in your handle hook be like, okay, everything under the path slash authenticated or something should be guarded. And that you can't really do with remote functions. and the way I would solve it is to have a, basically, I would say it's like a private query function, a shared query function, basically, which does all the authentication checks for you. And then you just call that inside your query function before proceeding to do the rest. and that's again that's the niceness of having this be just functions because you can just use regular function composition to get this. You could even create higher order functions from queries to I don't know call not query but authenticated query or something which does this for you. There's a few options you have. Is this the beginning of Svelte turning into React? No. I mean, the thing in React is all about functions, right? And function composition. I mean, function composition is nice. It is, yeah. React hooks, not so much. Throwing some shade there. All right. Yeah, thank you for coming on, Simon. Thank you for having me. Do you have any picks? I don't think I prepared you for this sorry my pick is probably my my new microphone so after the first YouTube video I did like before then like every now and then I thought oh maybe I need a proper microphone and I just not just like the built-in crappy one in my headset and then there was one YouTube comment like please get a better audio or an

 next time or something. And I was like, yeah, you're right. Like I should, I should finally do this. If I, if I, if I do more videos, then I probably should gear up a bit. And so, yeah, I got a, um, what is called Elgato wave free? I think it is. Um, yeah, I'm, I'm, I really like it so far. So, yeah. And, and I'm sure all your colleagues as well are, are like super hyped about the audio being even better in meetings and stuff. Yeah. All right. They can finally understand me. Yeah. Okay, so my pick is... I haven't prepared myself for this. So I think my pick is my new Thunderbolt dock. It has all sorts of fun functionalities. I think it's like 20 ports or something, just one cable connected to my computer, and then I have two monitors and all sorts of stuff, Ethernet. It's a very nice experience just having one cable to connect your laptop. Yeah, the docking stations are really nice. Yeah, my Surface docking station is, yeah, I would need a few more USB ports to be fully happy. this one I got had extra USB-C ports which was very nice so I think it has like 8 USB-Cs wow yeah it's a lot and then 2 monitors crazy crazy dock yeah I think that's it thanks everyone for listening again thank you Simon for joining me and we will talk to you next week bye bye