 Ready? All right. All right, everyone. Welcome to another episode of Svelte Radio. We're back. It's actually the first in-person interview ever. So with that said, I'd like to welcome Penguin, Svelte maintainer. Would you like to say some words? I am Penguin on the Internet. I am a maintainer of Svelte, a maintainer of Radio, and I am here in person with Kevin. Yeah, very nice. We're in Budapest. We're at JSConf, and it's great. But we are very excited to have a very nice guest here today. It's PatakDev on Twitter, but that's not your real name, is it? No, I'm Matias Capeleto. And yeah, really, really nice to be here and the first ever in person. Yeah, I'm a maintainer of Vite, and I work at Staglitz, where I get to do full-time open source. I have been doing this for like two years and a little bit more now. I'm really excited to talk with you, too. Yeah, very excited to have you on. So you're pretty well known now in the JavaScript ecosystem, especially with Vite pretty much blowing up and becoming like the de facto thing in the JavaScript ecosystem, right? So maybe you can tell us a bit about your background. Where did you start off as a developer? Yeah, I see my cat is known. It's not me that's the one that is known. Yeah. Sora is the one that everybody knows. I can confirm you are not a cat. Yeah, so I started a long, long time ago. I studied electronic engineer, and my first open source stuff was doing C++, like in boost libraries kind of thing. very different to the kind of collaboration we have between all the frameworks and everything now. It was very solo thing. And yeah, there was a lot of water under the bridge. But in the past, I think it's like three years already, since Bit2, I started to get into the game of doing open source again. And Bit was just at the point where there was a lot to do and I got involved there in the early community And once Evan created the big team because he needed to refocus on Vue I was one of the first that were doing things there. So I started being a team member and trying to build up the team and helping with the community. And yeah, that's kind of like how... The origin story. The origin, kind of like how I got to also know all of you, because the origins of Vite is kind of very tied to the Svelte project also. Right, yeah. And before we go into that, maybe we can tell people what Vite is. That's a good question. So at the beginning, Evan Yu has a very hard time describing what is Vite. And his way to describe it is like, go test it. Go to bit.new in your browser, you know, and the stack bits will open up and you just see HMR working, for example, and you feel the difference. But bit is a build tool. Normally, for you that do Svelte, normally you know that the browser doesn't run Svelte. Right. There's a compiler. Yeah, you need a tool in the middle that will compile all your Svelte files. I generate a nice bundle that you can put in the browser. And yeah, it's kind of like setting an API for framework outdoors. Like I see our users are mainly frameworks like Svelkit. Right. So like it's setting like a good API and choosing what are the best tools at any time to be able to do this process of generating like a good production app and give you the best experience during development that we can withhold more reload. So VIT in particular chose RollApp during build. That is another tie into... To Svelte, to Rich. Yeah, to Rich that started the RollApp project and then later on Lucas maintaining it now. And yeah, we chose RollApp even if it is JavaScript and not like Rust or native speed, but that was the best most mature project at the time and it was extremely flexible and during that time We have like a compatibility like plug container that let us you write your plugin in the same API during dev and build And we use ESBuild where like a speed really matters. It's a bundler writing in Go. Like it can transpile away TypeScript, for example, very fast. So like, yeah, we use the tools and provide kind of the best experience we can. Yeah. So you mentioned like your users are the frameworks themselves. So it feels like to me as I'm not an expert on Vite, I'm not an expert on like the internals of Svelte, but it feels or any other framework for that matter. I just use the frameworks. But it feels like every modern framework is kind of using Vite. It's really been growing fast, and everyone seems to be excited about it. So the origin stories of Veep. Evan, you made it, and then you said you joined. You found it kind of early. Was that during the version 1, or was it pre-version 1? Yeah. So the origin is, this was 2020, April 20, Evan uploaded the first repo. Wait, it's not older than 2020 or 2021? Yes, it started in 2020. Oh, wow. It's a little bit more than four years ago. Wow. I thought it was older. It feels like it's been around forever. No, no. It was really fast, the adoption, right? So during the initial year, that was like bit one, Svelte was already kind of working on the replacement of Zapper. So you were working on SvelteKit at that point, and you choose Snowpack to do that. You can tell maybe a little bit about that time. Yeah, so it was kind of an interesting time when all of these kind of new bundle tools were starting to offer kind of like this improved development experience. But obviously, like you say, it was in its infancy. It's kind of hard to think now, but SvelteKit has actually been in development for several years now. It was a long time before there was any kind of release after announcing it. But that time for bundlers was a period of, there was a lot of change, there was a lot of experimentation There was obviously we think now of Veep is really the only survivor But even at the time there was talk of Snowpack in the beginning but even I think Parcel had a version that kind of and there was talk of, will that become the standard? So there was a whole conversation around this. We initially chose Snowpack because I think Snowpack was kind of framework agnostic before Vite. But then when all of the roadmap, I guess, for Vite 2 came out, then it was like, well, we very much kind of took a very intentional position of we are bundler agnostic, and then whichever one wins or whichever one the community gets behind, whichever one the ecosystem kind of chooses, we will kind of move to that one, which was why initially we didn't expose the bundler API as part of our API. Obviously, that's changed now, now that SvelteKit is basically just a plugin for Vite. But at one point, we wanted the flexibility to shift internally because things were changing so dramatically. But I think it was that decision to make Vite not a Vue-specific tool, which is how it started, and then make it completely framework agnostic in version 2, which has unlocked all of these use cases, both in terms of SvelteKit, obviously, but even, you know, I started using it at work for, I think it was Preact at first and stuff, and for my own kind of, our own custom architecture, that wasn't really possible in V1. So it was really that kind of watershed moment with kind of V2, and I guess the assembly of the team as well. It kind of felt like a, it wasn't, you know, Evan's baby anymore. It kind of felt like a legitimate kind of cross framework platform with a genuine kind of desire to be cross platform i guess at the time it's worth mentioning like wmr which was also around the same time similar ideas around performance although obviously a dramatically different kind of take but that was another thing that we kind of thought of at the time it's like could you know is wmr kind of you know going to be useful is so it was you know just it's actually kind of first time I've really looked back properly on that time, but it was like a lot of stuff was happening in there, and there was a lot of churn when it came to bundlers. But now, you know, obviously gradually the whole ecosystem has moved, you know, to Vite. And, you know, we've obviously had a very kind of close collaboration with the Vite team, although it's kind of worth mentioning that, you know, the Vite team and the Sveltec.

 team are, you know, in some cases the same people. So to call it a collaboration, you're kind of collaborating with ourselves, right? Yeah, yeah. Like, it's very interesting that, like, around 30%, I think, of the B team are, as well, team members, like Jorn Blueby, Dominic G, for example. I don't know how to pronounce. Yeah, Grigor. Yeah, Grigor Flitzer. Nobody knows. they know. So, yeah, it was interesting. One of the, about that part, one of the first things that happened when Evan created the team is that we said, okay, then we need representation from each framework. So we invited some of the more active ones to be part of the team. Then Jorn came a little bit afterwards, for example, but like it was just there was a lot of alignment and Vite grow after Vite 2 also because it was pushed by the needs of all these frameworks like and Svelkit was like you were all working a lot on it and had like a lot of needs and yeah like you what is very interesting is that having this kind of users is like you have like the best kind of I don't know, like, they are maintainers. They create a beautiful issue, and then, like, you say, like, oh, how I will solve this? And you see, like, boop, and there is a PR to solve it. And I say, like, okay, and you merge it. And it's, like, I think this is why it was growing so fast. In the bit one period that you mentioned, I think it's worth mentioning that all these projects, Snowpack, WMR. First I think that we could be talking about Snowpack, like it would be fine. It's just that between all of us we needed to choose one. That was the idea. But I also felt during that initial time that it could be any of them. And I think that Evan did something very nice there in between bit one and bit two because it not only like with the the thing that he learned from doing bit one and the experience that he had before with Vue CLI that was based on Webpack but also he looked into what WMR was doing right and what Snowpack was doing right And he took some of the best parts also and bring it in the design in the roadmap of V2 So I think that all that projects live in V2, let's say, because the universal rollout plugin API, this idea that you write a plugin and it works in dev and build, this came from WMR. It was Jason Miller, the one that had the idea and they implemented it. And that is a very important piece of the puzzle. And then the SSR primitives that we have, that came from Svelkit. When Svelkit was working with Snowpack, I don't know if it was Rich or someone else in the team, they developed this idea of the unbundled dev server doing SSR. And this was implemented as SSL module in VIT and really allowed other frameworks later on. Like first, allow Svelkit to move very easily because it was the same idea. Now we implement it, like not maintaining it by you, but like implement it in core. So for you, it was, yeah, nice. I don't have to maintain that anymore. And for the others, like it really, there was an explosion of exploration in meta frameworks that really helped with that. I'm curious, actually. I was chatting yesterday to someone about how the initial phase of an open source framework often defines the narrative of that framework. So, for example, to take an example of Svelte, Svelte was very much from the beginning trying to solve a very specific need that Rich had. And if you take something like Solid, Solid was very much attacking things from that performance angle. And it's often the case that the kind of narrative that appears around a tool, it's very difficult to shift that narrative later. However, Veet did shift the narrative because Veet started as Evan's amazing next generation development tooling for Vue. So the fact that Evan and the rest of the team were able to shift that narrative to being more open and more cross is pretty impressive And do you think that was just because of how intentional that process was going from version 1 to version 2 Yeah, that's interesting. I always thought that Evan wanted, from the beginning, for Bit to be a tool that was more cross-platform. Like the React plugin, for example. I think that predates Bit 2. Not maybe the React plugin, but React support. Yeah. Because at that point, I don't think you could compete with other tools like Snowpack or if you will not have that. I think the main problem was that without the universal rollout plugin API, without the right architecture that V2 had, it was really hard to make a tool really framework agnostic. So I think it was, let's say, possible, but there was a lot of hacks in core maybe saying if you do this, something else. So I think the idea was there. It was just that V2 was really the one that executed completely. I see. Yeah, so that was V1 to V2. What's the current version of V? like bit 5 like and yeah how many hours do we have can you give us we're not progressing faster now yeah like what is interesting there from the period of bit 2 that really changed it like bit 1 from bit 2 bit 1 never existed really because it was in RC and Evan decided okay no we are not going to release it right and then bit 2 appeared and bit 2 is the first release that was like 2021 one in around February. And from then on, once the team was formed and we started to have more users, Svelkit switched it from Snowpack to Vite. Then later on, I think that particular moment was really important, like kind of like the tipping point for others to really say, OK, the ecosystem is choosing Vite. And then Astro ended up switching also from Snowpack to V. They were the creators of Snowpack so that was an incredible moment because they took it very well And I think they made the right decision seeing how much Astro has grown in the past too And it was very important for the whole ecosystem because they brought all that knowledge that they had from Snowpack and we're starting to get a lot of PRs from everyone in the team there. And then later on they went to hire Jorn. Oh, right. that to work also like as a bit maintainer because they need so like it it really worked out well and yeah like during all that first year we we were mainly polishing and making it stable and like yeah makes sense saying no to a lot of like requests for new apis and saying to people like look go make a plugin for that and so that we can keep core like slowly and try to support all these power users, like meta frameworks that were appearing. So we released it. B3, I think it was around, I think October or something. And from then on, like the test appear, for example, in December that year. We had very, that was a very big pain point with Jest because the ESM story was not working. They didn't have a sync transformers. So it was really hard to tell people, yeah, like, go with Bit. It's awesome, but you want to test your app, you're... Yeah. It doesn't work. That tiny part that you usually want to do, that doesn't work. Yeah. It's kind of, like, a need. So at one, there was an interesting, like, Bit meeting that, like, it was like, okay, maybe we need to do it. And I said, like, hey, like, I put it, I think I wrote a message, like, in the chat, like, Vitez, just that, like I put the name Vitez. And Anthony said like, oh, who wrote Vitez? And he went to NPM and it was free. Now I have taken Vitez. Perfect. He took it and then like that night or a few nights afterwards, like there was Vitez. And that was also a really interesting example of like all this community and like of framework collaborating in Vite, flock it to the new Discord that we created for Vitez and also there were, again, people from the Svelte community and others that make sure that Vitesse worked it well, even before we open sourced it, I think.

 that worked well in all the frameworks. And then after three months, there were some other maintainers, awesome people that took over. Like even shout out to Vladimir Sheremeth for all the work that he's doing there and Ari Hiroshi also later. And it went up and it worked everywhere. Right. And that was really interesting. And yeah, it kind of kept evolving with a lot of new plugins. the Rolaply plugin API again shout out to Rich for creating such a beautiful API and Lucas for maintaining and extending that because it really allow it for very wide collaboration like there is starting to be projects like BitPluginPWA and then if you want a PWA you just put that plugin in your pipeline and then that's it and of course there is a lot of work involved into that plugin but for the user it feels like magic. That's interesting. Other than front-end frameworks, are there other that you would consider users of Vite that you wouldn't expect? Someone like me, who's mainly just a front-end developer, I would just expect front-end frameworks to use Vite, but are there other parts of the ecosystem that use it? So, mainly I think the collaboration is with frameworks because that is the most active part around us also. So, it feels that we are building it together. But there is a lot of people using VIT without a framework. If you just are doing an SPA and need something simple, maybe you don't need a whole full stack framework like SSR. and you see the stats and there is a lot of usage of like, I don't know, like a lot more BitPlaying React usage compared to like the frameworks that are doing like Remix or these other frameworks using Bit. So they are final users also. Yeah. And there is also tools. So BitTest is using Bit to test. Makes sense. Yeah. But yeah, so that is, and it's very interesting because now like the engine of VTEST that is with Node is moving inside of VT and then like it going to simplify VTEST So it also upstreaming things Later on we can talk a little bit about BitEnvironment API but that is the basis of BitEnvironment API is BitNode And also other tools like Storybook, for example, or tools like Playwright, they created component testing, for example. Like every time that you need to process something that is framework related, for example, like VIT is very useful because you have the plugin pipeline there for you. So like for a storybook is awesome that a lot of framework has chosen this standard. Like let's say like this, I don't want to call it a standard, but like this plugin API, because now they have to only support that. yeah I excuse me it's kind of interesting the kind of gradual adoption of kind of Vite or that Vite plug-in pipeline like you say because at work we use a variety of different tools but we basically kind of use Vite for kind of all of them you know we have front end and we're not using a framework but we're using Svelte which obviously Vite is a natural choice partly just for the dev experience but as well you know the nice APIs, but then we also use PlayWrite. And then, sure, if you're doing full end-to-end testing, you just build your application, it's fine. But if you want those tests that you can't perform in a mocked browser environment in Node, you need a real browser, then we can use the PlayWrite component testing, and we can just use our existing Vite config and all the existing custom plugins that we have. And then, if we need to bundle a library, which we also need to do, we can just use Vite again, because we can reuse a lot of our existing... We don't need Vite particularly in that context. because we could just use rollup. But we're using Vite for everything else. We may as well just kind of carry on using Vite. And even if you just need to compile a simple script from TypeScript to regular JavaScript, because TypeScript's not going to run in Node, why install another dependency so that you can do that on the command line when you could just, you know, a quick config for Vite, or even no config for Vite potentially, if it's kind of vanilla enough, because it's a batteries-included tool. And I actually had a conversation with someone a few days ago about, in many ways, the lasting legacy. And we'll talk more about, obviously, the environment API, which is going to be a huge, huge thing. But I think one of the most important things that Vita's done is kind of popularized ESM like chosen ESM as its kind of target the primitive that it wants to work with in all kinds of scenarios and the roll-up plugin API. Because even if there's a new tool in a few years or something, having this buy-in for such a... It is such a simple, kind of flexible, relatively intuitive API that it's complex enough to give you what you need, but it's simple enough that you're not frightened of writing a one-off plugin. And so I think those two things are the kind of the lasting legacies so far. Obviously, you know, I was talking about this, about Vitas, if it's like died or something. But it's... It just started, we said. Just 10 minutes ago. Yeah, but it's, you know, even like that as a legacy moving forward, it's like it's a great thing to have popularized. We've got a great ecosystem now of these roll-up compatible plugins in a lot of cases. And obviously the popularization of ESM. And I think that's like a, aside from the specifics, you know, there's all the specifics, that is one of the great things. Yeah, and I was thinking actually like around like a year or two ago that like I wouldn't mind if there would be a better tool that beat. Even someone else will maintain it. Like that would be no work to do anymore. But like that's what is important is what you said. that I hope that now we have said, okay, this plain API, this is it. Like the web, you know? It's kind of like we settle down into this is a good API for sharing around the framework game. So in the next tool, if they are going to use the same API, it will be very easy to migrate to that one. So maybe it is more performant or they have other kind of trade-offs that are interesting. nowadays I think that I saw that that could happen because every tool goes up and down, and maybe it could happen in three years or something. Now that we maybe can talk about rolldown a little bit, it looks now that there is a possibility for VIT to ride that wave and then has another wave after rolldown. Just to give more context, so VIT has, as we said before, always use it roll up during build. You could think that bit is just an opinionated configuration for roll up during build And during that we were using a compatible rollup thing and then using ES build to make things very fast But ES build is not flexible, like rollup. Right. So Evan now started a new project, and there is a team working on this, that's called Rolldown. and the idea is that it's going to be a reimplementation of RollApp that is going to be RollApp API compatible but write it in native, in Rust. And the scope is bigger than just RollApp because we want to also be able to replace ES build with it. Because having these two different tools to transpile was always a little bit difficult. For example, one of the contributions Yarn did is like in our, we pre-bundle dependencies. And when we pre-bundle dependencies, you don't want to, like I've seen like Svelte components are not normally pre-bundled, like when you deploy a library, for example. So you need to be able to, we do that with ESBuild, like the pre-bundling. And to teach ESBuild how to deal with the Svelte components, like we need extensions, and things that just to configure ESBuild. So when you use BitPlugin as well, it actually checks these kind of ESBuild plugins also to make the whole thing work. And it's always having two different things that has two different set of bugs, maybe a different way to configure some things. So the idea of having only one tool there that will be used for everything, It really feels like we can simplify and remove a lot of pain points, make even build and dev closer. This was one of the main things that the tractors, let's say, against this kind of new tools were saying, I don't want you to change so much the way that dev works. And the problem is that we need that. We already do it because we don't minify. But people accept that, but they still wanted to feel that they were bundling more like Webpack. And Bit is really different. It's bundled less during that. But I think it proved to be a very good trade-off. If done right, and if we have

 have enough people like fixing all the bugs to make sure that dev and build is the same. That is like our, one of our main priorities in the project is making sure that dev and build is the same. But yeah, if you have that, then this is quite a nice trade-off to have because now you can have like a very snappy dev environment. Yeah. So Roldown obviously isn't done yet, right? No, yes, but it's already able to bundle things. Oh, nice. It's alive. It's alive. It's open source. You can go to, like, they need help also. It's a huge undertaking. So you can go download, you need to learn Rust. So that is also a trade-off there. But at that expense, you get a very, very fast tool. Yeah, I was going to say, other than making it so that it's the same on dev and production, it's also making it faster at the same time. So it's like an extra nice feature of better performance. Yeah, exactly. And more during build, because during dev we were already fast using ES build. So there are possibilities to speed up even more, like longer term, because it, like, roll down maybe can get a little bit bigger in scope. Maybe, like, this compatibility layer that we have in dev mode to, like, offer, like, a roll-up compatible API, it could be implemented by roll down directly. Right. So, like, maybe roll down will be used, we already will be using it for, like, certain things, like what we use ESBuild now, like stripping the types, for example. But it could be that we do more things. And then we have this import analysis plugin, for example, that does transformations of your code to modify the imports because the browser doesn't understand what you write normally against the file system. We need to modify the URL to something that the browser can request back to the server. And these transformations right now are done in JavaScript. And maybe for these core plugins, if we have the plugin runner in Rust, it makes sense for at least some of them to also live in Rust. And then we can speed up the Dev Server too When you say we speed up build I curious do you have an idea of how much faster it would be or is it very much just it will probably be faster? I don't want to just say marketing. I don't really know, but it's kind of the difference between ES build and just roll up. It is significant. I don't know, it's like an order of magnitude or something, but at this point I think they are at the level of ES build. That is quite huge. This is why it did work in the first place, because we had that speed. And we had a lot of people asking. Actually, I thought at one point that we would go in the other direction, that at one point we would do bundling in build with ES build, because this was the other option. If ESBuild gets a little bit more flexible or people get comfortable writing Go plugins or something, maybe we can offer that mode for certain big apps. But it looks like it's going to be the other way around. And about the roadmap, how it looks right now is that once Roldown is able to do this pre-bundling, then we can replace ESBuild with it, with Roldown. keeping rollup during build still is just like replacing that part and then later on at one point it could replace rollup and then at one point we could have this other integration in dev. This like we need to see how it's going to be integrated like there's a lot of applications using rollup right now so like I I think it will be kind of always it's not that it's replace it and you cannot use Rollup anymore. I think it will be like kind of, okay, you can use Rolldown, and then you can opt in to Rollup maybe because it's compatible, I think. Yeah. All right. So let's also talk a bit about this new environment stuff that's been â€“ because that's a new thing that's coming, or is it already out? Like what's the deal here? What is it even? Let's start there. It's coming. So the story of that is when NAX3 was integrating with Vite, now they have Vite by default So they went into another completely road different than Svelkit Svelkit has this like VIT as a plugin thing that we can discuss also And like the next team created Nitro. That is their way to do adapters. Like they go to any platform and service. And Nitro, like this abstraction for servers, didn't work well with SSRL module. They needed to create something using more lower-level tools in Vite. This thing is called Vite Node. This was how to connect the two. That is why Anthony Fu was able to build Vite Test so quickly. It's because he worked it on Vite Node before. And that is the engine of Vite Test. So he grabbed it, bit node, put it even in the monorepo, because in the bit test, monorepo is where bit node has been living. And yeah, it's a way to run using the bit pipeline, what you say, like a node process. And what was very interesting about this way that NACs is structressing is that they got HMR, like in SSR, like real HMR, and proper source maps. Because in the way they were running, it was working a lot better. So actually there is an issue, an old issue from Rich Harris asking VIT to have proper HMR API during SSR. And proper source map also. And so we wanted, we discussed it with Vladimir, like he was maintaining, he rerouted VIT node. And we discussed it with him. He joined the VIT team also. And he worked it for a long time to port BitNode as a feature in BitCore. Apart from HMR and apart from better source map during SSR, the other big feature that this has is that it creates kind of like, you know, like the browser will be a client for the BitServer. So it will ask for the request and ask for the different modules and do proper HMR. The way we do SSR-law module is just some caching layer that we have, but it's not real HMR. And Bitnode had this idea of having a little client in the server client thing that like a module runner that will be the one running the modules that is separated from the server and this module runner will end up like acting like the browser like i'd ask for the module and then the module is processed inside of the bit server and then the bit server answer back with the module and then that will generate other like asking more modules and get the whole module tree. And what's interesting about that separation is that then you don't need to do SSR in the same node process. You could have that and put it in a worker thread or put it inside Miniflir. That is the way to emulate WorkRD locally. Like if you want to run in Clofar, for example. Or I don't know, or Barcel or Netlify could have their own environments in the same way. so that was like very interesting for people like Cloudfire so they got involved and we released that like that's called Runtime API 5.1 Hydrogen from Shopify is using that in production I think right now it was like double experimental label it has and we said don't use it we are going to change it like we are releasing this for feedback only but like it really shows that this is something that they really need and the problem was that we developed this feature a little bit like out of the main API because it was a little bit easier and because it's very scary to change this API now that there is so many people using it but we ended up seeing that that will not work so at the end environment API is basically like okay let's go like full with it like what what it will look if we actually integrate these new capabilities but directly as a like integrated API into it then the idea is that you will not longer have only like the client and SSR environment but you could create any number of environments your application have now meta frameworks are getting more complex maybe you have three environments Maybe you have the client, maybe you have a node server, and maybe you have some edge server that serves in the middle. And that was not possible to model during that before. But now maybe you could. You could say, OK, my meta framework is not going to have two. It's going to have three different environments, and each of them.

 have their own model graph because they will have like separate bundles that they are doing for it and this is environment yeah like we we are going to provide these capabilities there is going to be an extension of the hooks ipi of the plugin so instead of just having a simple ssr boolean because before it was only two so it is true or false that that was all and now instead of that there is going to be like a these.environment in the context and have all the information you need for the environment in there yeah and so i guess an example of this for you know especially for the svelte community would be you know you mentioned cloudflare and you know recently a lot of work has gone into the cloudflare adapter for svelte kit and you know the challenges around you know we had we had a whole conversation we've been having a whole conversation for a long time about what about dev? Because dev has always just been Node with SvelteKit. It was never anything else. And you would deploy to Cloudflare or your workers or whatever. But how do you kind of make use of the various APIs? If you're not using any of those built-in APIs, the platform APIs, you can kind of get away with it. But if you do want to use the key value store or, well, I mean, there's a whole number of Cloudflare APIs now, and then you just couldn't do it. So then recently there was a whole effort, and we are now using kind of like MiniFlare, this kind of WorkerD kind of environment, and there's all kinds of mocks for various things. But the problem is there as well, from Cloudflare's point of view, is they then need to do that for every single framework, every single tool that has some kind of Cloudflare adapter type thing, whereas these environments can be reused. So you can package up an environment and then publish it to NPM and then when Remix or Nuxt or SvelteKit need to use this environment, they can import it, they can implement it in some way. But the point is it will be there for dev. So you don't need to add additional API on the framework side like we did in SvelteKit to get this kind of really cohesive and again going back to what you were saying before you know a symmetrical dev build environment again so it's going to be amazing for those kinds of use cases as well yeah yeah and again this is what you asking about if this is done or not It not But there is a bit 6 branch that we started long ago working on this because it is really different from the work that we have been doing with bit 3, bit 4, bit 5. We took a lot of pride during that time on not changing the API and giving frameworks a very stable base. So mostly maturing and improving performance. So shout out to Dominic Schieder, like with creating BitEcosystem CI that later on like Sbelt also adopted and like other people also adopted. And this tool like really allowed us to know if we are going to break someone or not before we release. And we were like our majors in Bit have been always very painless. This was our main objective. And this one in particular, it's a little bit scary because of that. So what we decided that we will do is that we need to go, because we are going to change things, we need to go slow with this. We really need to avoid any kind of moment like Python 2 to 3. These kind of things. The ecosystem is too large for that. so we are going to release bit 6 as a known trying not to have any breaking change and we don't even go into promote this API a lot in the sense of like plugin authors maybe shouldn't start using it right away because for example like if you want to use it you can use this dot environment in your hooks but this dot environment will not be there in bit 5 so if you start using it then you have to do a major for your own plugin and maybe you need to support both versions for a while. So, yeah, the idea will be that we launch trying to keep the same thing that we did before, but these are under the hood. These new APIs are there. Under the hood, they are like, instead of one mixed graph between client and SSR modules, there's going to be a separate graph for each environment. But all the APIs the old APIs still work. Like there is like some proxy layer that we'll find and maybe generate on the flight and know that looks like before but inside the data is different Yeah And maybe after six months like as usual like frameworks and users will adopt the new major very quickly if we do the job right. And then at one point we say like, okay, almost everyone is in bit six. Then now we do a big push to let's update all the plugins. Yeah. Frameworks kind of start using this because almost everybody is in there. Maybe you need to add an experimental underscore like three times this time. Yeah, I think we are still going to release it and experiment. We had a lot of feedback already, to be honest. I heard Rich in your last V-log saying that he also is excited about playing with it for adapters, for the same thing. He mentioned something that is interesting also is that in the V-team, we always said that VIT was browser only. So all the use cases the user had about, I want to use VIT for Electron, I want to use VIT for Tori, or these other uses, they hacked it their way and they did it, but this was not something that the project explicitly said. This is a use case that we are supporting and encouraging. And right now with environment, it looks like this is again the big team is a lot of people so still there will be discussion in the same way that we've developed but I think that there is an opportunity now that we have the environment abstraction to let people say okay my client environment is not the browser now my client environment is Tori so Tori will provide a Tori environment and that will set configure everything so the client is that and during dev and during build they will do what they need to do they have the hooks now to get into and properly offer a good experience I think it sounds kind of similar to something that's I'm sure it's not similar very similar but it kind of sounds like something that's happening in the Elixir ecosystem there's a project called LiveView Native that lets you basically write SwiftUI and and whatever the Android version is. I don't remember. Kotlin? Yeah, I think. Like, as a template, so you can compile Elixir to SwiftUI and Kotlin Well I guess you writing SwiftUI so it doing something Well it basically enabling the ability to reach more platforms. In the Elixir case, it would be the native iOS and Android. And I guess... So now maybe down the road, could we see native targets in the sense of iOS and Android for Vite as well? There are people working on like reg native integrated with Vite, for example. And yeah, this could also be an interesting use case of that. I think it will require a kind of shift in our mind as a team that say like, yeah, we want to support these more use cases. Right. That is very interesting because it's a trade-off. I think that Vite was able to grow in the way it grew because it had a very clear scope. And we were saying, okay, Vite is this tool. It's not, like we say many times to people, that's a valid use case, but you can keep using other tools because Vite is not for that. And that was important. But I think the team now is mature enough and there's also a lot more users and frameworks obviously want to push the limits a little bit more. And I think not only the bit team, but the bit team, contributors, the community, all the frameworks working together, I think we are at a point where we could start sharing a little bit more. And this idea, for example, of, okay, now we have three adapters of traction. So, like, as well, GitHub has one, Astro has another one, Nitro is another one that other frameworks, like an analog use and SolidStar is using also the NIFO one. And so we have these three different, and this is why Cloudflare is pushing to, oh, it would be nice if they are sharing this. So we also only need to care maintaining one. Instead of the three. So I think it makes sense that we keep talking. We keep doing the same thing that we have been doing, like trying to keep saying what from everything that we are doing is common. and that's then like trying to put it on in a plugin if possible, obviously, but if not, maybe we need to extend core a little bit more. Okay, so that's the...

 latest in in v um let's let's talk uh community and vietconf oh nice so when is when is vietconf happening uh vietconf this year is going to be october 3 uh everybody is invited i i actually like it was very nice to meet you in person because i i say this but i want to say it also in in the recording because when we started doing the the first vietconf this a little bit of history there like once Eric Simon the CEO of Stagrid like hired me like one of the first discussion we had was like what do you think about doing a bit conference and I said like what? And more or less because actually like Dominic I think was one of the people that already mentioned before like hey it would be nice to do a meetup or something like that and there were like there was some movement in the community but like we definitely didn't have the resources of like or like the idea that once yeah i one of the things that i did when i started working full time is that okay i have to have more time and then like there was like the marketing side of stability that could help also this kind of thing so we did bitconf and that that was a very interesting moment the first bitconf because a lot it really showcased it how wide the ecosystem them have become. I think it put it at the spotlight. We talk it with every team. And so Rich Harris did a belt, a kit talk, and then Ryan Carniancho was there doing the solid talk. Evan, of course, was doing a talk about... He did a talk about VIT, but then Daniel Roy was with Naxx, and Anthony Fu, and so many other maintainers, awesome maintainers in the ecosystem like all together. I think it was like 40 talks or something. Yeah, it was a big... Like a 24-hour marathon. It was long, but it was good. A lot of content. I didn't sleep, but because we wanted to do this thing about like reaching out all the world, let's say. No matter where you get up, then you can see the 12-hour of content because it's 12-hour repeated. And when we were organizing all the things, like we were discussing how we do it and like Esval Sumit was one of the the things that we had there very high in our mind Oh thank you Because we really enjoyed the vibe and the way for example we use Discord to do the conference because we've seen that it's very good at all that activity remains in the community later on. There's new people coming because of the conference and then they stay. And we really like that. and we did that because Aswell Summit was using you were having discussions while you were watching the talks also and it was so lively Aswell Discord in general I think it was also not only for the conference but it was also a very heavy influence when we did the beat Discord because your Discord has always been extremely lively and there is a lot of very helpful discussions and I don't know the vibe feels like right to me so yeah thank you for I'm happy you copied a bunch of stuff if you took inspiration or whatever that's great it's interesting you mentioned the issue of wanting to have it be available for everyone around the world it's something I've experimented with so I'm in Stockholm right so I'm in Europe and that's one time zone but then there are a bunch of folks in the US and then there are a lot of people in Asia. So how do you make it work? You could do what you guys did and just do 24 hours, of course. It's not sustainable. You can do it one day. No two-day conference for sure. I've experimented with when in the afternoon do I hit the most people in the world to see it And then also you want to be able to have the speakers be there when their talk is going on. And that's another problem because you have speakers from all around the world. So you need to kind of time it so it has to be in a certain order. Lots of fun problems to solve there. Well, it helped me there that we have these 12 hours and it's repeated twice. So speakers can be... Yeah, they can come from one of them. Which one is the one that is best for them. But yeah, it's a very interesting conference. I really advise that people get into the Discord when the conference is there because the speakers and not only the speakers like the it is the beat Discord during that day is a place where a lot of different communities get together. So like, during the Svelte talk, you will have like, the Svelte discord for a moment came to visit the beat discord, you know, and then like the, during the Astro talk, like the whole Astro discord is there talking and then like, it's, I think it's really like It's fun. Interesting. And I love that it highlights this collaboration and this spirit. And you have, like, in, like, I don't know, like, you're in four hours, maybe, like, the tracks about the frameworks. And you see every framework, one after the other. Yeah. And you see that people are, like, let's say, like, you don't feel, like, that competing. Like, you know, like, ah, my framework is best or whatever. Yeah, yeah. and it's a lot more about like oh that's that's cool like they are doing a cool thing we should we should also do that we should also do that yeah and and it's not only that it's because you don't only say like oh we should also do that and then start to like copy the thing it's more like oh that's a good idea let's improve on it in some way or exactly like yeah would you like to do a plugin for that so like we can share it and this is like also a place for not only for people users in general, but also even for maintainers to connect. Yeah. Alright. I think we're getting close to the end here. Is there anything that we've not talked about that we should talk about? I think we've covered most of it. I want to do another shout out just to everyone involved, like all the team members of the contributors, the people that help in the community, the people that do triaging. Yeah. Like, really, open source is a game of so, so many people. So, like, just a shout-out to everyone that is helping in any way. Yeah. Absolutely. All right. So, let's move into the picks section. I can start. So, I've recently been watching a TV show called Sugar on Apple TV+. It's a private investigator that is trying to track down someone in Hollywood. The main character is Colin Farrell, I think he's called. I should know who Colin Farrell is I think But yeah But yeah it a very good show Apple TV in general Apple TV Plus in general has a lot of high TV shows that people are often sleeping on Because most people don't have Apple TV Plus, I think. Most people just have Netflix or one of the other ones. Disney, probably, et cetera. But, yeah, that's my pick. I'm going to pick a kind of more of a trend that I've seen recently I've seen a lot of people talking about kind of like local first applications and privacy first applications obviously with the big kind of AI booms and stuff privacy has become a very kind of like hot topic but there has been kind of a trend now of having kind of applications that maybe they're local first and then they can maybe sync with a network so you're using some kind of embedded databases in fact there's a whole movements, there's whole conferences dedicated to these ideas and it's a really healthy trend, this idea that we can have these really wonderful local experiences that we can use, you know, essentially it's almost like progressive enhancement at a macro level, you know, it's like we start local and we kind of enhance things with maybe some API calls, maybe some data synchronization so that you switch to another device, you're getting the same experience so I'm kind of really excited by this idea and I'm hoping that we can start, you know, maybe, you know, we're talking about all these different environments now, maybe we're talking about all these different levels of integrations, maybe local is, in various contexts, is a thing that we can start developing applications for. Yeah. Interesting. Really nice. Really nice pick. Yeah, I would choose one also to give a shout-out again to SvelteKit. Not SvelteKit, but Svelte in general. but it's about a tutorial that you so Rich Harris and I think Penguin you were involved at the beginning and other people so you created this awesome tutorial for SvelteKit following the same thing that you had for the normal Svelte and I was telling Penguin that when the first time I learned about Svelte was using that tutorial and I think it had a very big influence in people picking up as well. Because it made it feel so easy to do. So you use WebContainer API to be able to run as well as in the browser and do the same.

 And then because you did it, you show that that is awesome. And then Angular has Angular.dev using a tutorial. Oh, really? Nice. And then Anthony Fu streaming himself doing the full tutorial for Nux. Oh, right. Actually opening even the Svel one and seeing how you're doing things. Oh, nice. Yeah, it's a really nice stream. and later on now like Stagwick have been working also in a thing called TutorialKit, so if you go TutorialKit.dev or PMPM create tutorial that will also give you that and it's also like shout out to all of you because it's kind of the same, the idea is that you will get this app but you don't have to make it write the content don't write the hard part multiple times for every framework. Yeah, so I think that is interesting. And it's another one of the trends we were talking about, like these things that starts in a community and it spreads because it a good idea Yeah that a great pick I love tutorials in general like i think it was what made me like actually try svelte because every time i i so when i found svelte in 2019 i i remember the website and i remember like trying it on on the tutorial like but i i found it on hacker news and on hacker news you see all these frameworks showing up and but you hardly ever actually try them. You just open the landing page, and you're like, oh, this looks interesting. I'll try it later. But if you have an interactive tutorial, it's very easy to just go in and just try one thing, and then you're like, oh, this feels very good. I'll actually have to try it properly. But yeah, all right. I think that's it. Patek, thank you for joining us, or joining me, and Penguin, or Pete. Thank you for... Maybe I doxed you now, sorry. thank you for joining us thank you thanks a lot lady it was a great discussion whenever you want I will definitely invite you back on with that said thank you to all the listeners and you will hear us next week again