 Thank you. Hi everyone, I'm Kyohei, a software engineer and I usually develop a library called KOMU which allows you to introduce video chats into your web application without any hassles. Meanwhile, I also run the coding boot camp in Tokyo. Feel free to contact on Twitter if interested. Today, I'll give a talk about how well Subet supports web components and what it looks like to have it running in production. Before explaining why we adapted spouts and web components, I need to share the context we did so. We were developing a library called Commu. It provides WebRTC-based video chats. It was started as an ordinary class library and wraps around really well the complexity WebRTC introduces. introduces. But besides, video chats also inevitably have to interact with users visually, so users need to sort out the mess of the DOM and events. To avoid it, we wanted to provide the UI helper which users can just load, place it, and configure some, then done. We are SWIRT heavily for UI development in contract works and internal tools, but to use it in this way, meaning for library development, SWIRT's relatively smaller share would be problematic since projects using React or Vue would not be able to use the half of our library. Luckily, SWIRT supports web components, so we decided to provide these UI parts of the library using web components. For those unfamiliar to web components, I'll put a brief summary. It is a web standard which allows JS to define a kind of elements, simply put, tag, you know. I guess you haven't seen the tags called clipboard copy in HTML ever. They are built with web components. This provides a functionality to copy something into your clipboard and which you don't have to care how it works since it's done inside. You can try this on GitHub's repository. Yes, actually GitHub is known as heavy users of the web components. Web components are called technically custom elements. Custom elements can provide functionalities roughly corresponding into components in spurtz. Let's take a look how it can be in place of spurtz components. Attributes, you know, as you know in HTML, they can be used as props. Actually, when we build the spurtz components into custom elements, props with it will be translated to attributes. When it comes to think about props, there's another important property, reactivity. Unlike source code in spells, we cannot put dynamic variable in raw hdml document. There's just a literal string, which doesn't change, called attribute value. If you need to change it, you need to do it with JS, but once you can set it through the After DOM API, I mean, substituting the value, subvert reactivity which is built into the custom elements takes care of and it keeps in sync all over the inside the elements. As events, also the interesting parts of the subvert components. A subvert component can emit events which would be listened by hundreds passed through corresponding props, namely like on, colon, click. DOM also have event mechanism, which of course, Svirt1 comes from. Custom elements can emit DOM events, and it works almost the same manner to events emitate from Svirt components. And lastly, Svirt components have bidirectional data binding, which there's no counterpart in custom elements. So how do you know when some state in custom elements has been changed? We can use custom DOM events for that. Similar to that you can listen an event in a DOM element, namely onClick, you can listen non-standard events emitted by the custom element. You element. You can update a variable on the page when a props is logically bound to the variable has been changed inside the custom elements. Of course, you can do anything other than updating the variable. It is actually more than that by far, but it would be safer to consider it to it is similar to the bi data binding It built You can mark your component to compile into those custom elements with just adding a special type like this setting your module bundle up which is just a one if you using roll Custom elements are, under the food, invocations of custom element registry APIs. Your bundle will also use to write a tag technically again in a custom element. And it seems to you it's like spouts mount your components in place of the tab. They can be working fine even if side by side with React components as long as correctly loaded, or even if in project with no frontend library. So let's take a look how it's working in production. I'd like to show you our Commune library as an example of web components SDK, and provide a demo like a hands-on to create simple custom elements with Svirt. You can try it as a hands-on. In a way, we'll hit the pitfall in the current state of Svirt's web component supports with walk-runs for every one of them, which is the actually highlight of this session. I'll show you a little bit how easy it is to build a video chat with CommuLibrary with its web components SDK. This is really this is it. Before digging into a little into it, let's see how it looks like. I mean I'll pull. Okay let's try calling. Click start calling. This is written in start calling or join meeting in Japanese and click this button. and waiting hello how are you how are you yeah pretty fine and I'm in the summit bye yeah happy it's working fine and okay turning back to the slide OK, what you have seen is a video chat built with the KOMU, KOMU's web components SDK. It's just loading a bundle like this and a put tag you must not be used to in a normal HTML. You can see two parameters passed as attributes. The former is the API key, a completely static string. And while the latter differs sometimes because different users may want to use different rooms. In our example, we are ok if everyone on the page joins the same room. But in the more realistic use case, users will want to meet a specific group of other people. You can implement this by setting elements room name dynamically like this. If you put an input field for users to type some keyword and retrieve and pass it into the element, it allows users to meet each other, only those who know the keyword. What is interesting in this way is you can use these components as a switch component as well with or within other Svelte components. So you can develop effectively as in Svelte while providing an interoperable custom elements for library users. And yeah, let's try building small custom elements. As usual, we can start by fetching the boilerplate and converting it to typescript. To enable Svirt's web component support, add a line to rollup config.js to plugins, Svirt, compiler options, custom elements to true. Note that this enables all over the codebase, there's no granular control like module-wise, and all the components must have this special tag. This will be the tag name for the custom elements. So we'll try implement three major functionalities of Svirt's components like blops, reactivity and data binding. Ok, let's get started by adding a special tag to our app Svirt. It has a simple greeting already, but we want something more happier to make it say happy birthday. And that's it. This produces a bundle that defines set custom elements. But to see how it's working, we need to do a little more work. Open the main TS which mounts app component to the entire body of the page. Let's remove it since we don't rely on it anymore. This file will contain just an import statement, an index.html in public directory, put our custom elements with attributes like this. You can use whatever you like as this name value. And start with npm run dev and open a local host on port 5000. It will show the name passed through the prop It working Another important trait of this virtual component is reactivity Of course a HTML document is static so I cannot change the attribute value literally. But you know, sure, I can do it using JS. So in index HTML, put a button here, and when clicked, first get your custom elements and and change attributes, it will change reactively. Event-driven feature in web components called lifecycle callbacks is leveraged under the field. Svelte automatically translates props into the lines of JS exploiting lifecycle callbacks. But we don't have to care of it not so much. It's elegantly supported by Svelte. But the final one we want to try is not so elegant because there's no direct counterpart of data binding in DOM world. So we need to find other way around to achieve the same objective. Most intuitive and DOM-friendly strategy will be to use custom events. Library users who are familiar with DOM programming won't be surprised by the library says like, Hey users, to get this value on timely manner, you need to listen to these events. doesn't surprise you, that sounds very usual. In a Spert component, emitting custom events is relatively easy. You can just use createEventDispatcher from Spert Package. If you emit nameChanged events like this, you can listen it with passing a handler to onColumnNameChangedProps. Ideally, you want this to emit DOM custom elements as well, which can be listened with addEventListener or like that. But it doesn't. To do it, you need to use insert method called DispatchEvent inside the component class and pass it to your custom instance. Combined, you'd like to have a helper function like this to make components to emit custom events correctly whenever it is for which ever you use as a reach ever as a subbed component as a custom custom elements and let's listen listen this events we can use as event listener as as usual. One point to note is you have to use whenDefined method to wait until the custom elements being available. Otherwise, getElements by tag name returns undefined, which prevents us to call an event listener on it. OK, changing this way. Let's see how it works. I have written, I have the complete code for this demo and just have npm run it and open the browser. Actually I have already opened this. And initially it has a, it's saying happy birthday to the one I set through the attribute value. And when clicked bottom inside the custom elements, it changed the value and it occurs the event then it's show by this we can show that this alert to show the another person's name and happy birthday is to Sido Masamune it's very good yeah you get celebrated here okay that's cool let's go back to the slide okay it looks easy on hindsight but I had to struggle with this and found the workarounds. Actually, there's more rough edges in Svelte's web component supports, but I could get through this because of the warm and active community of Svelte. I'm a relatively read-only member of the community, but in the future, I'd like to contribute at least some, and hope things like this session help someone. And later this session, I'll look through these pitfalls and work around for them and how community helps. But for now, I'd like to congratulate us because we have those three major functionalities in our custom elements. Let's forget the implementation we hustled and look at it from a library user's perspective. It looks very similar to ordinary HTML tags and elementary JavaScript. That's the point, when you build a library that involves UI parts, it would be nice if you give it a consternin to have it as a custom element. So then, let's walk through some of the pitfalls I've encountered in a way we build Kami. Firstly, in HTML, most of the attributes are named in kebab case, words in a lower alphabet combined with hyphens. In contrast, these props are described as a declaration of JS variables whose name cannot include hyphens inside. A naive workaround for this would be use this helper to access the props like this in previous situations But this works only in the case you use the custom elements in HTML directory It is okay for the end users of the library and end users of the custom elements since they would use it in that way, but it is problematic for developers of the components. If you mount it as a svelte component, all props should be undefined at the moment the component has been initialized unintentionally. Another workaround which allows you to do this is to have a wrapper class to intercept behavior of the svelte. Secondly and similarly, you cannot use an uppercase letter in the name of attributes if the component is mounted as a custom element. Actually, it doesn't fail at compile time, but the value will end up being undefined. For instance, if you specify like this, this data-attr with uppercase A, the value will end up being undefined. In this case, it will be converted to a lowercase version like your name, no, dataattr. It seems to be browser that converts names to comply the naming convention explained above rather than problem of Svelte's web component support. Since camera case is the default standard way of naming in JavaScript, naming a prop like your name with uppercase n as a usual result undefined. In this case, changing prop name to contain just a lowercase letter fix and make it work. Interestingly, the attributes name on Colossus doesn't matter how many uppercase letters it contains. So these three Every variation of attribute name would work at all. But of course very confusing. Don't do it. So far, we have worked through how web components development and spout looks like. Let's have a little recap. Finally, firstly, we learned the web components gives us a way to provide encapsulated components to vanilla JS. If you are building a library and want to provide a bunch of visual items on a web page, then you can leverage web components. Of course, the most smooth way to do this would be by providing a component in one of the front-end libraries, namely React or Vue. But of course, not every project adopts one of them. And if you provide Vue components, no one from React projects cannot adopt. Once you compile components into custom elements, even Vinyl.js project can adopt them easily without sacrificing development velocity a lot, since you can work on Swift codebase as well. Secondly, I've shared how we can build custom elements with functional parity to Swift components, say props, reactivity, and data binding. Surely, it's not completely equal from the perspective of the library users because DOM works on fundamentally different paradigm on Svets, but can reduce complexity enough for some extent. It can provide a good abstraction layer to UI library has to have with it. What I picked up to show you lastly was some pitfalls and best practices for you when you develop custom elements with Svelte. It's not complete support indeed, but there's a warm and great community that helps you a lot. In some cases, I had to read through the piece of code from Svelte compiler and write. It may sound annoying to you, but they are not so massive but concise and insightful. It should be a great experience for you to improve your understanding on recent JS ecosystem and toolchains. Share your insights should you find this interesting and try yourself. Shameless liplab, I've just released a commu, a library. You can build a video chat into your web app without hassle. We provide it as a TypeScript SDK and Web Components SDK as well. As mentioned throughout this session, we developed the Web Components part with Svelte. If you are interested in it, we are open to share the code. Let's share insights with development in Svelte. And Kamu has just been available on various no-code platforms like Bubble or Webflow. If you find it interesting or know someone who'd like it, feel free to refer me to them. And thank you for watching this session at this very end. Follow me on Twitter, GitHub or Dev2. I'm at TNZK in... My username is at TNZK in all of them. In a dev too, you can find the code in this slide and more pitfalls. Happy hacking in Svart! Bye!